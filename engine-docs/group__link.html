<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Knots and Links</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Knots and Links</div>  </div>
</div><!--header-->
<div class="contents">

<p>Knots and links in the 3-sphere.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ExampleLink.html">regina::ExampleLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers routines for constructing ready-made examples of knots and links.  <a href="classregina_1_1ExampleLink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent.html">regina::Laurent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial with coefficients of type <em>T</em>.  <a href="classregina_1_1Laurent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>.  <a href="classregina_1_1Laurent2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>dim</em>-dimensional triangulation, built by gluing together <em>dim</em>-dimensional simplices along their (<em>dim</em>-1)-dimensional facets.  <a href="classregina_1_1Triangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StrandRef.html">regina::StrandRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to one of the two strands of a link that pass each other at a crossing.  <a href="classregina_1_1StrandRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Crossing.html">regina::Crossing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single crossing in a link diagram.  <a href="classregina_1_1Crossing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html">regina::Link</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a directed knot or link in the 3-sphere.  <a href="classregina_1_1Link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CrossingIterator.html">regina::CrossingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all crossings of a link.  <a href="classregina_1_1CrossingIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ArcIterator.html">regina::ArcIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all directed arcs of a knot or link.  <a href="classregina_1_1ArcIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1CrossingIterator_01_4.html">std::iterator_traits&lt; regina::CrossingIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1ArcIterator_01_4.html">std::iterator_traits&lt; regina::ArcIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">regina::ModelLinkGraphArc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an outgoing edge from a node of a model graph for a knot or link.  <a href="classregina_1_1ModelLinkGraphArc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">regina::ModelLinkGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single node in a model graph for a knot or link.  <a href="classregina_1_1ModelLinkGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html">regina::ModelLinkGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an undirected 4-valent planar graph with a specific planar embedding.  <a href="classregina_1_1ModelLinkGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraphCells.html">regina::ModelLinkGraphCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the cellular decomposition of the sphere that is induced by a given planar 4-valent graph.  <a href="classregina_1_1ModelLinkGraphCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html">regina::Tangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-tangle in the 3-ball.  <a href="classregina_1_1Tangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLLinkReader.html">regina::XMLLinkReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single knot or link.  <a href="classregina_1_1XMLLinkReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLLinkCrossingsReader.html">regina::XMLLinkCrossingsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that reads the XML element containing basic information about the crossings of a knot or link.  <a href="classregina_1_1XMLLinkCrossingsReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLLinkConnectionsReader.html">regina::XMLLinkConnectionsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that reads the XML element containing information on connections between crossings of a knot or link.  <a href="classregina_1_1XMLLinkConnectionsReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLLinkComponentsReader.html">regina::XMLLinkComponentsReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that reads the XML element containing information about the individual components of a link.  <a href="classregina_1_1XMLLinkComponentsReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1e5be55d0f0331a075915fde55cf0568"><td class="memItemLeft" align="right" valign="top"><a id="ga1e5be55d0f0331a075915fde55cf0568"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CrossingIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga1e5be55d0f0331a075915fde55cf0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84d76b541309792e018e43ee9d63d44"><td class="memItemLeft" align="right" valign="top"><a id="gac84d76b541309792e018e43ee9d63d44"></a>
typedef <a class="el" href="classregina_1_1Crossing.html">regina::Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CrossingIterator &gt;::value_type</b></td></tr>
<tr class="separator:gac84d76b541309792e018e43ee9d63d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga322c98207f06f6a1b33075ebf04b2f16"><td class="memItemLeft" align="right" valign="top"><a id="ga322c98207f06f6a1b33075ebf04b2f16"></a>
typedef <a class="el" href="classregina_1_1Crossing.html">regina::Crossing</a> *const  *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CrossingIterator &gt;::pointer</b></td></tr>
<tr class="separator:ga322c98207f06f6a1b33075ebf04b2f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0a4f07c4a8fa8dfe0337745806a766"><td class="memItemLeft" align="right" valign="top"><a id="ga3f0a4f07c4a8fa8dfe0337745806a766"></a>
typedef <a class="el" href="classregina_1_1Crossing.html">regina::Crossing</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CrossingIterator &gt;::reference</b></td></tr>
<tr class="separator:ga3f0a4f07c4a8fa8dfe0337745806a766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8983f3ff406767d444ccec3323012147"><td class="memItemLeft" align="right" valign="top"><a id="ga8983f3ff406767d444ccec3323012147"></a>
typedef std::input_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CrossingIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga8983f3ff406767d444ccec3323012147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16bf38c836d993ff0fe93898df64d5f"><td class="memItemLeft" align="right" valign="top"><a id="gad16bf38c836d993ff0fe93898df64d5f"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ArcIterator &gt;::difference_type</b></td></tr>
<tr class="separator:gad16bf38c836d993ff0fe93898df64d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb7fccac562c88e8fabcd424b874322"><td class="memItemLeft" align="right" valign="top"><a id="ga3eb7fccac562c88e8fabcd424b874322"></a>
typedef <a class="el" href="classregina_1_1StrandRef.html">regina::StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ArcIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga3eb7fccac562c88e8fabcd424b874322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5da4d028ccc08c6f00a069e0d780edb"><td class="memItemLeft" align="right" valign="top"><a id="gac5da4d028ccc08c6f00a069e0d780edb"></a>
typedef <a class="el" href="classregina_1_1StrandRef.html">regina::StrandRef</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ArcIterator &gt;::pointer</b></td></tr>
<tr class="separator:gac5da4d028ccc08c6f00a069e0d780edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad909afd4ce29ed651ef2e8688f717d28"><td class="memItemLeft" align="right" valign="top"><a id="gad909afd4ce29ed651ef2e8688f717d28"></a>
typedef <a class="el" href="classregina_1_1StrandRef.html">regina::StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ArcIterator &gt;::reference</b></td></tr>
<tr class="separator:gad909afd4ce29ed651ef2e8688f717d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96556d9c6d421f0d0be5449c25d265f0"><td class="memItemLeft" align="right" valign="top"><a id="ga96556d9c6d421f0d0be5449c25d265f0"></a>
typedef std::input_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ArcIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga96556d9c6d421f0d0be5449c25d265f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8395d3783317af74eb30822e96e96c0f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8395d3783317af74eb30822e96e96c0f">regina::ModelLinkGraph::Use</a>) (<a class="el" href="classregina_1_1Link.html">Link</a> *, void *)</td></tr>
<tr class="memdesc:ga8395d3783317af74eb30822e96e96c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a knot or link.  <a href="group__link.html#ga8395d3783317af74eb30822e96e96c0f">More...</a><br /></td></tr>
<tr class="separator:ga8395d3783317af74eb30822e96e96c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaa7f28a9c71fb2f3db92141046be967a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">regina::Framing</a> { <a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">regina::FRAMING_SEIFERT</a> = 1
, <a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa2b478480a97632583fa3885399d523d6">regina::FRAMING_BLACKBOARD</a> = 2
 }</td></tr>
<tr class="memdesc:gaaa7f28a9c71fb2f3db92141046be967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates one of the standard framings of a knot or link.  <a href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">More...</a><br /></td></tr>
<tr class="separator:gaaa7f28a9c71fb2f3db92141046be967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6eb25d5d808233928b2756621f3b47b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6eb25d5d808233928b2756621f3b47b6">regina::ExampleLink::unknot</a> ()</td></tr>
<tr class="memdesc:ga6eb25d5d808233928b2756621f3b47b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a zero-crossing diagram of the unknot.  <a href="group__link.html#ga6eb25d5d808233928b2756621f3b47b6">More...</a><br /></td></tr>
<tr class="separator:ga6eb25d5d808233928b2756621f3b47b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3fd877d1650803abb8a00127a43f921"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa3fd877d1650803abb8a00127a43f921">regina::ExampleLink::monster</a> ()</td></tr>
<tr class="memdesc:gaa3fd877d1650803abb8a00127a43f921"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the monster unknot, a 10-crossing diagram of the unknot that is difficult to untangle.  <a href="group__link.html#gaa3fd877d1650803abb8a00127a43f921">More...</a><br /></td></tr>
<tr class="separator:gaa3fd877d1650803abb8a00127a43f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f1ec5a0b7dc12df56ed35cf6db2b1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga41f1ec5a0b7dc12df56ed35cf6db2b1a">regina::ExampleLink::gordian</a> ()</td></tr>
<tr class="memdesc:ga41f1ec5a0b7dc12df56ed35cf6db2b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> Haken's Gordian unknot, a 141-crossing diagram of the unknot that is difficult to untangle.  <a href="group__link.html#ga41f1ec5a0b7dc12df56ed35cf6db2b1a">More...</a><br /></td></tr>
<tr class="separator:ga41f1ec5a0b7dc12df56ed35cf6db2b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3ec2cdad02e186e7d2d89f563aaeca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaeb3ec2cdad02e186e7d2d89f563aaeca">regina::ExampleLink::trefoilLeft</a> ()</td></tr>
<tr class="memdesc:gaeb3ec2cdad02e186e7d2d89f563aaeca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the left-hand trefoil.  <a href="group__link.html#gaeb3ec2cdad02e186e7d2d89f563aaeca">More...</a><br /></td></tr>
<tr class="separator:gaeb3ec2cdad02e186e7d2d89f563aaeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e853bc606868629122e542e48ec6430"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7e853bc606868629122e542e48ec6430">regina::ExampleLink::trefoilRight</a> ()</td></tr>
<tr class="memdesc:ga7e853bc606868629122e542e48ec6430"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the right-hand trefoil.  <a href="group__link.html#ga7e853bc606868629122e542e48ec6430">More...</a><br /></td></tr>
<tr class="separator:ga7e853bc606868629122e542e48ec6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505f8c04024d001dcfc0bfa56d37dc2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga505f8c04024d001dcfc0bfa56d37dc2e">regina::ExampleLink::trefoil</a> ()</td></tr>
<tr class="memdesc:ga505f8c04024d001dcfc0bfa56d37dc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the right-hand trefoil.  <a href="group__link.html#ga505f8c04024d001dcfc0bfa56d37dc2e">More...</a><br /></td></tr>
<tr class="separator:ga505f8c04024d001dcfc0bfa56d37dc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b2f1c9aeb8ab01472b71e1c8d089be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf3b2f1c9aeb8ab01472b71e1c8d089be">regina::ExampleLink::figureEight</a> ()</td></tr>
<tr class="memdesc:gaf3b2f1c9aeb8ab01472b71e1c8d089be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-crossing diagram of the figure eight knot.  <a href="group__link.html#gaf3b2f1c9aeb8ab01472b71e1c8d089be">More...</a><br /></td></tr>
<tr class="separator:gaf3b2f1c9aeb8ab01472b71e1c8d089be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90aa8d21c77cac76343313154f74e22b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga90aa8d21c77cac76343313154f74e22b">regina::ExampleLink::hopf</a> ()</td></tr>
<tr class="memdesc:ga90aa8d21c77cac76343313154f74e22b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-crossing diagram of the Hopf link.  <a href="group__link.html#ga90aa8d21c77cac76343313154f74e22b">More...</a><br /></td></tr>
<tr class="separator:ga90aa8d21c77cac76343313154f74e22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66bec3dc74f7d1fc1ef2ce9cde5508ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga66bec3dc74f7d1fc1ef2ce9cde5508ae">regina::ExampleLink::whitehead</a> ()</td></tr>
<tr class="memdesc:ga66bec3dc74f7d1fc1ef2ce9cde5508ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a five-crossing diagram of the Whitehead link.  <a href="group__link.html#ga66bec3dc74f7d1fc1ef2ce9cde5508ae">More...</a><br /></td></tr>
<tr class="separator:ga66bec3dc74f7d1fc1ef2ce9cde5508ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bc9bfa99080688eccf0158348a4ad1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga02bc9bfa99080688eccf0158348a4ad1">regina::ExampleLink::borromean</a> ()</td></tr>
<tr class="memdesc:ga02bc9bfa99080688eccf0158348a4ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a six-crossing diagram of the Borromean rings.  <a href="group__link.html#ga02bc9bfa99080688eccf0158348a4ad1">More...</a><br /></td></tr>
<tr class="separator:ga02bc9bfa99080688eccf0158348a4ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e8c2042f255636ca66d4dc491a8e6f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga60e8c2042f255636ca66d4dc491a8e6f">regina::ExampleLink::conway</a> ()</td></tr>
<tr class="memdesc:ga60e8c2042f255636ca66d4dc491a8e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 11-crossing Conway knot.  <a href="group__link.html#ga60e8c2042f255636ca66d4dc491a8e6f">More...</a><br /></td></tr>
<tr class="separator:ga60e8c2042f255636ca66d4dc491a8e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b61afa22793bb6a289a4d4d192b6357"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7b61afa22793bb6a289a4d4d192b6357">regina::ExampleLink::kinoshitaTerasaka</a> ()</td></tr>
<tr class="memdesc:ga7b61afa22793bb6a289a4d4d192b6357"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 11-crossing Kinoshita-Terasaka knot.  <a href="group__link.html#ga7b61afa22793bb6a289a4d4d192b6357">More...</a><br /></td></tr>
<tr class="separator:ga7b61afa22793bb6a289a4d4d192b6357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f37e1919de78b6d37143a4e5b634c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga96f37e1919de78b6d37143a4e5b634c4">regina::ExampleLink::torus</a> (int p, int q)</td></tr>
<tr class="memdesc:ga96f37e1919de78b6d37143a4e5b634c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the (<em>p</em>,<em>q</em>) torus link.  <a href="group__link.html#ga96f37e1919de78b6d37143a4e5b634c4">More...</a><br /></td></tr>
<tr class="separator:ga96f37e1919de78b6d37143a4e5b634c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d02023afe905c817dd1df95a563b74e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9d02023afe905c817dd1df95a563b74e">regina::ExampleLink::gst</a> ()</td></tr>
<tr class="memdesc:ga9d02023afe905c817dd1df95a563b74e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 48-crossing potential counterexample to the slice-ribbon conjecture, as described by Gompf, Scharlemann and Thompson.  <a href="group__link.html#ga9d02023afe905c817dd1df95a563b74e">More...</a><br /></td></tr>
<tr class="separator:ga9d02023afe905c817dd1df95a563b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b246253bcd288646085f9930003399"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac1b246253bcd288646085f9930003399">regina::StrandRef::StrandRef</a> ()</td></tr>
<tr class="memdesc:gac1b246253bcd288646085f9930003399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this to a null reference.  <a href="group__link.html#gac1b246253bcd288646085f9930003399">More...</a><br /></td></tr>
<tr class="separator:gac1b246253bcd288646085f9930003399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8c0893752bbeacf59c06937b8d31dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6d8c0893752bbeacf59c06937b8d31dd">regina::StrandRef::StrandRef</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad">crossing</a>, int <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f">strand</a>)</td></tr>
<tr class="memdesc:ga6d8c0893752bbeacf59c06937b8d31dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this to the given strand of the given crossing.  <a href="group__link.html#ga6d8c0893752bbeacf59c06937b8d31dd">More...</a><br /></td></tr>
<tr class="separator:ga6d8c0893752bbeacf59c06937b8d31dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8608c1da51c291b35e6f5c4a5a8ceae7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8608c1da51c291b35e6f5c4a5a8ceae7">regina::StrandRef::StrandRef</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;)=default</td></tr>
<tr class="memdesc:ga8608c1da51c291b35e6f5c4a5a8ceae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__link.html#ga8608c1da51c291b35e6f5c4a5a8ceae7">More...</a><br /></td></tr>
<tr class="separator:ga8608c1da51c291b35e6f5c4a5a8ceae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5e3028eaf7ee815e082000d17154ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad">regina::StrandRef::crossing</a> () const</td></tr>
<tr class="memdesc:gabe5e3028eaf7ee815e082000d17154ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The crossing that this reference points to.  <a href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad">More...</a><br /></td></tr>
<tr class="separator:gabe5e3028eaf7ee815e082000d17154ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167bb9ba6ba78767f7753ff7f3317e3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f">regina::StrandRef::strand</a> () const</td></tr>
<tr class="memdesc:ga167bb9ba6ba78767f7753ff7f3317e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this reference points to the upper or lower strand of the relevant crossing.  <a href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f">More...</a><br /></td></tr>
<tr class="separator:ga167bb9ba6ba78767f7753ff7f3317e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd61713b60a4536a94461656e93298b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadd61713b60a4536a94461656e93298b2">regina::StrandRef::id</a> () const</td></tr>
<tr class="memdesc:gadd61713b60a4536a94461656e93298b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer that uniquely identifies this strand within the link.  <a href="group__link.html#gadd61713b60a4536a94461656e93298b2">More...</a><br /></td></tr>
<tr class="separator:gadd61713b60a4536a94461656e93298b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd818191c3f9c02682058565617d936"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafdd818191c3f9c02682058565617d936">regina::StrandRef::operator==</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gafdd818191c3f9c02682058565617d936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given reference are identical.  <a href="group__link.html#gafdd818191c3f9c02682058565617d936">More...</a><br /></td></tr>
<tr class="separator:gafdd818191c3f9c02682058565617d936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf636decd24394b8cc3c9b349ae8d2d1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf636decd24394b8cc3c9b349ae8d2d1d">regina::StrandRef::operator!=</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gaf636decd24394b8cc3c9b349ae8d2d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given reference are not identical.  <a href="group__link.html#gaf636decd24394b8cc3c9b349ae8d2d1d">More...</a><br /></td></tr>
<tr class="separator:gaf636decd24394b8cc3c9b349ae8d2d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00aaff7af2cd3c63d3a20116964b016e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga00aaff7af2cd3c63d3a20116964b016e">regina::StrandRef::operator=</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;)=default</td></tr>
<tr class="memdesc:ga00aaff7af2cd3c63d3a20116964b016e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment operator.  <a href="group__link.html#ga00aaff7af2cd3c63d3a20116964b016e">More...</a><br /></td></tr>
<tr class="separator:ga00aaff7af2cd3c63d3a20116964b016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9f21431143267c5f4d7142f604559f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaca9f21431143267c5f4d7142f604559f">regina::StrandRef::operator++</a> ()</td></tr>
<tr class="memdesc:gaca9f21431143267c5f4d7142f604559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this reference forward along the direction of the link until it reaches the next crossing.  <a href="group__link.html#gaca9f21431143267c5f4d7142f604559f">More...</a><br /></td></tr>
<tr class="separator:gaca9f21431143267c5f4d7142f604559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a82768f76ba5970aaec59c4e62d37f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6a82768f76ba5970aaec59c4e62d37f4">regina::StrandRef::operator++</a> (int)</td></tr>
<tr class="memdesc:ga6a82768f76ba5970aaec59c4e62d37f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this reference forward along the direction of the link until it reaches the next crossing.  <a href="group__link.html#ga6a82768f76ba5970aaec59c4e62d37f4">More...</a><br /></td></tr>
<tr class="separator:ga6a82768f76ba5970aaec59c4e62d37f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb370668021e61df5e583dad6d05d9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabb370668021e61df5e583dad6d05d9b4">regina::StrandRef::operator--</a> ()</td></tr>
<tr class="memdesc:gabb370668021e61df5e583dad6d05d9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this reference backward against the direction of the link until it reaches the previous crossing.  <a href="group__link.html#gabb370668021e61df5e583dad6d05d9b4">More...</a><br /></td></tr>
<tr class="separator:gabb370668021e61df5e583dad6d05d9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fd3eb1f35d2466c578acc8b6a2d6ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6fd3eb1f35d2466c578acc8b6a2d6ab5">regina::StrandRef::operator--</a> (int)</td></tr>
<tr class="memdesc:ga6fd3eb1f35d2466c578acc8b6a2d6ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this reference backward against the direction of the link until it reaches the previous crossing.  <a href="group__link.html#ga6fd3eb1f35d2466c578acc8b6a2d6ab5">More...</a><br /></td></tr>
<tr class="separator:ga6fd3eb1f35d2466c578acc8b6a2d6ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3ce62d47997b0e320735c7e32fd54a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0f3ce62d47997b0e320735c7e32fd54a">regina::StrandRef::next</a> () const</td></tr>
<tr class="memdesc:ga0f3ce62d47997b0e320735c7e32fd54a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that comes immediately after this when walking forward along the direction of the link.  <a href="group__link.html#ga0f3ce62d47997b0e320735c7e32fd54a">More...</a><br /></td></tr>
<tr class="separator:ga0f3ce62d47997b0e320735c7e32fd54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09918c5b00d7cdfa08d0bb3edf2d1d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga09918c5b00d7cdfa08d0bb3edf2d1d0a">regina::StrandRef::prev</a> () const</td></tr>
<tr class="memdesc:ga09918c5b00d7cdfa08d0bb3edf2d1d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that comes immediately before this when walking backward against the direction of the link.  <a href="group__link.html#ga09918c5b00d7cdfa08d0bb3edf2d1d0a">More...</a><br /></td></tr>
<tr class="separator:ga09918c5b00d7cdfa08d0bb3edf2d1d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80ba478d0d57d52d71f9fe25b3ce86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa80ba478d0d57d52d71f9fe25b3ce86a">regina::StrandRef::jump</a> ()</td></tr>
<tr class="memdesc:gaa80ba478d0d57d52d71f9fe25b3ce86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jumps to the other strand at the same crossing.  <a href="group__link.html#gaa80ba478d0d57d52d71f9fe25b3ce86a">More...</a><br /></td></tr>
<tr class="separator:gaa80ba478d0d57d52d71f9fe25b3ce86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ef609692c6491885504dad1d09459d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga50ef609692c6491885504dad1d09459d">regina::StrandRef::operator bool</a> () const</td></tr>
<tr class="memdesc:ga50ef609692c6491885504dad1d09459d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this is a non-null reference.  <a href="group__link.html#ga50ef609692c6491885504dad1d09459d">More...</a><br /></td></tr>
<tr class="separator:ga50ef609692c6491885504dad1d09459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf19ebfb95d12c438417a04f15511f20"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabf19ebfb95d12c438417a04f15511f20">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;s)</td></tr>
<tr class="memdesc:gabf19ebfb95d12c438417a04f15511f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a depiction of the given strand reference to the given output stream.  <a href="group__link.html#gabf19ebfb95d12c438417a04f15511f20">More...</a><br /></td></tr>
<tr class="separator:gabf19ebfb95d12c438417a04f15511f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8447c727708dce6bf6bd536da00a379c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8447c727708dce6bf6bd536da00a379c">regina::Crossing::index</a> () const</td></tr>
<tr class="memdesc:ga8447c727708dce6bf6bd536da00a379c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this crossing within the overall link.  <a href="group__link.html#ga8447c727708dce6bf6bd536da00a379c">More...</a><br /></td></tr>
<tr class="separator:ga8447c727708dce6bf6bd536da00a379c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06b875567dda4c15e075ecc4e62d724"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab06b875567dda4c15e075ecc4e62d724">regina::Crossing::sign</a> () const</td></tr>
<tr class="memdesc:gab06b875567dda4c15e075ecc4e62d724"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of this crossing.  <a href="group__link.html#gab06b875567dda4c15e075ecc4e62d724">More...</a><br /></td></tr>
<tr class="separator:gab06b875567dda4c15e075ecc4e62d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b28abed9edb209f54747b5e926530b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8b28abed9edb209f54747b5e926530b8">regina::Crossing::upper</a> ()</td></tr>
<tr class="memdesc:ga8b28abed9edb209f54747b5e926530b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running over this crossing.  <a href="group__link.html#ga8b28abed9edb209f54747b5e926530b8">More...</a><br /></td></tr>
<tr class="separator:ga8b28abed9edb209f54747b5e926530b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2b9f54049a9d814d6a6abe87de3edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaaf2b9f54049a9d814d6a6abe87de3edc">regina::Crossing::lower</a> ()</td></tr>
<tr class="memdesc:gaaf2b9f54049a9d814d6a6abe87de3edc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running under this crossing.  <a href="group__link.html#gaaf2b9f54049a9d814d6a6abe87de3edc">More...</a><br /></td></tr>
<tr class="separator:gaaf2b9f54049a9d814d6a6abe87de3edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd364d5dc16aaa052accbc0131585b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3dd364d5dc16aaa052accbc0131585b4">regina::Crossing::over</a> ()</td></tr>
<tr class="memdesc:ga3dd364d5dc16aaa052accbc0131585b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running over this crossing.  <a href="group__link.html#ga3dd364d5dc16aaa052accbc0131585b4">More...</a><br /></td></tr>
<tr class="separator:ga3dd364d5dc16aaa052accbc0131585b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed3d9d76a5e1554c595c79f5d5bce61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5ed3d9d76a5e1554c595c79f5d5bce61">regina::Crossing::under</a> ()</td></tr>
<tr class="memdesc:ga5ed3d9d76a5e1554c595c79f5d5bce61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running under this crossing.  <a href="group__link.html#ga5ed3d9d76a5e1554c595c79f5d5bce61">More...</a><br /></td></tr>
<tr class="separator:ga5ed3d9d76a5e1554c595c79f5d5bce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa943c46328c17f931283d95c01b55a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3fa943c46328c17f931283d95c01b55a">regina::Crossing::strand</a> (int which)</td></tr>
<tr class="memdesc:ga3fa943c46328c17f931283d95c01b55a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two strands of the link that pass each other at this crossing.  <a href="group__link.html#ga3fa943c46328c17f931283d95c01b55a">More...</a><br /></td></tr>
<tr class="separator:ga3fa943c46328c17f931283d95c01b55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17087fab18a03a777c04d2d6eba29b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf17087fab18a03a777c04d2d6eba29b8">regina::Crossing::next</a> (int <a class="el" href="group__link.html#ga3fa943c46328c17f931283d95c01b55a">strand</a>) const</td></tr>
<tr class="memdesc:gaf17087fab18a03a777c04d2d6eba29b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that immediately follows this when walking forward in the direction of the link along one of the two strands that pass at this crossing.  <a href="group__link.html#gaf17087fab18a03a777c04d2d6eba29b8">More...</a><br /></td></tr>
<tr class="separator:gaf17087fab18a03a777c04d2d6eba29b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9f537596ed523115aad084089553836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab9f537596ed523115aad084089553836">regina::Crossing::prev</a> (int <a class="el" href="group__link.html#ga3fa943c46328c17f931283d95c01b55a">strand</a>) const</td></tr>
<tr class="memdesc:gab9f537596ed523115aad084089553836"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that immediately precedes this when walking backward against the direction of the link along one of the two strands that pass at this crossing.  <a href="group__link.html#gab9f537596ed523115aad084089553836">More...</a><br /></td></tr>
<tr class="separator:gab9f537596ed523115aad084089553836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c68b505c86d79080a75532d920580d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3c68b505c86d79080a75532d920580d8">regina::Crossing::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga3c68b505c86d79080a75532d920580d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__link.html#ga3c68b505c86d79080a75532d920580d8">More...</a><br /></td></tr>
<tr class="separator:ga3c68b505c86d79080a75532d920580d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083ba1db333340322c8645943960b27b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga083ba1db333340322c8645943960b27b">regina::Crossing::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga083ba1db333340322c8645943960b27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__link.html#ga083ba1db333340322c8645943960b27b">More...</a><br /></td></tr>
<tr class="separator:ga083ba1db333340322c8645943960b27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d1b0c2fe43f14af761e350dfafd6dc"><td class="memItemLeft" align="right" valign="top"><a id="gad7d1b0c2fe43f14af761e350dfafd6dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::Crossing</b> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> &amp;)=delete</td></tr>
<tr class="separator:gad7d1b0c2fe43f14af761e350dfafd6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb69dd2f0ae1f02447947f8828f1f0d8"><td class="memItemLeft" align="right" valign="top"><a id="gafb69dd2f0ae1f02447947f8828f1f0d8"></a>
<a class="el" href="classregina_1_1Crossing.html">Crossing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::operator=</b> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> &amp;)=delete</td></tr>
<tr class="separator:gafb69dd2f0ae1f02447947f8828f1f0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b74ac162fbb0142f35b992b922d24e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga2b74ac162fbb0142f35b992b922d24e2">regina::CrossingIterator::CrossingIterator</a> ()</td></tr>
<tr class="memdesc:ga2b74ac162fbb0142f35b992b922d24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a singular iterator.  <a href="group__link.html#ga2b74ac162fbb0142f35b992b922d24e2">More...</a><br /></td></tr>
<tr class="separator:ga2b74ac162fbb0142f35b992b922d24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5091d6e2cdacfbddb80999db666ea836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5091d6e2cdacfbddb80999db666ea836">regina::CrossingIterator::CrossingIterator</a> (const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga5091d6e2cdacfbddb80999db666ea836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__link.html#ga5091d6e2cdacfbddb80999db666ea836">More...</a><br /></td></tr>
<tr class="separator:ga5091d6e2cdacfbddb80999db666ea836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdc1488025337c77393e1d92ba27430"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadcdc1488025337c77393e1d92ba27430">regina::CrossingIterator::CrossingIterator</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link, size_t index=0)</td></tr>
<tr class="memdesc:gadcdc1488025337c77393e1d92ba27430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given crossing of the given link.  <a href="group__link.html#gadcdc1488025337c77393e1d92ba27430">More...</a><br /></td></tr>
<tr class="separator:gadcdc1488025337c77393e1d92ba27430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3df1c038e0e74c0650bf2ee8567b42d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf3df1c038e0e74c0650bf2ee8567b42d">regina::CrossingIterator::operator++</a> ()</td></tr>
<tr class="memdesc:gaf3df1c038e0e74c0650bf2ee8567b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__link.html#gaf3df1c038e0e74c0650bf2ee8567b42d">More...</a><br /></td></tr>
<tr class="separator:gaf3df1c038e0e74c0650bf2ee8567b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696cc505076ba63d8c0c30a78e2f6d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga696cc505076ba63d8c0c30a78e2f6d21">regina::CrossingIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga696cc505076ba63d8c0c30a78e2f6d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__link.html#ga696cc505076ba63d8c0c30a78e2f6d21">More...</a><br /></td></tr>
<tr class="separator:ga696cc505076ba63d8c0c30a78e2f6d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb7aa49c38e92fca330eab98a741a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4bb7aa49c38e92fca330eab98a741a78">regina::CrossingIterator::operator*</a> () const</td></tr>
<tr class="memdesc:ga4bb7aa49c38e92fca330eab98a741a78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing to which this iterator points.  <a href="group__link.html#ga4bb7aa49c38e92fca330eab98a741a78">More...</a><br /></td></tr>
<tr class="separator:ga4bb7aa49c38e92fca330eab98a741a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec89329bc8a4d0788109cc9c6ef4b02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaec89329bc8a4d0788109cc9c6ef4b02d">regina::CrossingIterator::operator=</a> (const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaec89329bc8a4d0788109cc9c6ef4b02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment operator.  <a href="group__link.html#gaec89329bc8a4d0788109cc9c6ef4b02d">More...</a><br /></td></tr>
<tr class="separator:gaec89329bc8a4d0788109cc9c6ef4b02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6c163ac97344e96b5f4fd6b4b592bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5d6c163ac97344e96b5f4fd6b4b592bc">regina::CrossingIterator::operator==</a> (const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga5d6c163ac97344e96b5f4fd6b4b592bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="group__link.html#ga5d6c163ac97344e96b5f4fd6b4b592bc">More...</a><br /></td></tr>
<tr class="separator:ga5d6c163ac97344e96b5f4fd6b4b592bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20fa2514d5d12886c3e8208977e71b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab20fa2514d5d12886c3e8208977e71b2">regina::CrossingIterator::operator!=</a> (const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gab20fa2514d5d12886c3e8208977e71b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="group__link.html#gab20fa2514d5d12886c3e8208977e71b2">More...</a><br /></td></tr>
<tr class="separator:gab20fa2514d5d12886c3e8208977e71b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94ee19ea10ed9f63d07bbdc5b142f37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf94ee19ea10ed9f63d07bbdc5b142f37">regina::ArcIterator::ArcIterator</a> ()</td></tr>
<tr class="memdesc:gaf94ee19ea10ed9f63d07bbdc5b142f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a singular iterator.  <a href="group__link.html#gaf94ee19ea10ed9f63d07bbdc5b142f37">More...</a><br /></td></tr>
<tr class="separator:gaf94ee19ea10ed9f63d07bbdc5b142f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb3a876813a8b76ba1ec2e41ba0a44f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaedb3a876813a8b76ba1ec2e41ba0a44f">regina::ArcIterator::ArcIterator</a> (const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaedb3a876813a8b76ba1ec2e41ba0a44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__link.html#gaedb3a876813a8b76ba1ec2e41ba0a44f">More...</a><br /></td></tr>
<tr class="separator:gaedb3a876813a8b76ba1ec2e41ba0a44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc176bc09bcad39131c5ad885c777176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadc176bc09bcad39131c5ad885c777176">regina::ArcIterator::ArcIterator</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link, size_t crossing=0, bool upper=false)</td></tr>
<tr class="memdesc:gadc176bc09bcad39131c5ad885c777176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the arc exiting the given strand of the given crossing of the given link.  <a href="group__link.html#gadc176bc09bcad39131c5ad885c777176">More...</a><br /></td></tr>
<tr class="separator:gadc176bc09bcad39131c5ad885c777176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265281688e0ff3631b6fafde3e5e46ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga265281688e0ff3631b6fafde3e5e46ec">regina::ArcIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga265281688e0ff3631b6fafde3e5e46ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__link.html#ga265281688e0ff3631b6fafde3e5e46ec">More...</a><br /></td></tr>
<tr class="separator:ga265281688e0ff3631b6fafde3e5e46ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1624b6b018063fb2ee8c88f188c97da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga1624b6b018063fb2ee8c88f188c97da1">regina::ArcIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga1624b6b018063fb2ee8c88f188c97da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__link.html#ga1624b6b018063fb2ee8c88f188c97da1">More...</a><br /></td></tr>
<tr class="separator:ga1624b6b018063fb2ee8c88f188c97da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc6b9ba22ea5720a8614f1517606ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaadc6b9ba22ea5720a8614f1517606ad8">regina::ArcIterator::operator*</a> () const</td></tr>
<tr class="memdesc:gaadc6b9ba22ea5720a8614f1517606ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the directed arc to which this iterator points.  <a href="group__link.html#gaadc6b9ba22ea5720a8614f1517606ad8">More...</a><br /></td></tr>
<tr class="separator:gaadc6b9ba22ea5720a8614f1517606ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8dff9a165080ec57f9e52222907cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5b8dff9a165080ec57f9e52222907cdc">regina::ArcIterator::operator=</a> (const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga5b8dff9a165080ec57f9e52222907cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment operator.  <a href="group__link.html#ga5b8dff9a165080ec57f9e52222907cdc">More...</a><br /></td></tr>
<tr class="separator:ga5b8dff9a165080ec57f9e52222907cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ce7402d8274dd999715d30568d080b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga96ce7402d8274dd999715d30568d080b">regina::ArcIterator::operator==</a> (const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga96ce7402d8274dd999715d30568d080b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="group__link.html#ga96ce7402d8274dd999715d30568d080b">More...</a><br /></td></tr>
<tr class="separator:ga96ce7402d8274dd999715d30568d080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd054a653caeec40936205c8efabd13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafbd054a653caeec40936205c8efabd13">regina::ArcIterator::operator!=</a> (const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gafbd054a653caeec40936205c8efabd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="group__link.html#gafbd054a653caeec40936205c8efabd13">More...</a><br /></td></tr>
<tr class="separator:gafbd054a653caeec40936205c8efabd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3b1a19d19db7d06137445bb45a620c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gade3b1a19d19db7d06137445bb45a620c">regina::ModelLinkGraphArc::ModelLinkGraphArc</a> ()</td></tr>
<tr class="memdesc:gade3b1a19d19db7d06137445bb45a620c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this to a null arc.  <a href="group__link.html#gade3b1a19d19db7d06137445bb45a620c">More...</a><br /></td></tr>
<tr class="separator:gade3b1a19d19db7d06137445bb45a620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad784951ef84c86486a0eba995f22e1f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad784951ef84c86486a0eba995f22e1f4">regina::ModelLinkGraphArc::ModelLinkGraphArc</a> (<a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *<a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1">node</a>, int <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8">arc</a>)</td></tr>
<tr class="memdesc:gad784951ef84c86486a0eba995f22e1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this to the given arc exiting the given node of a model graph.  <a href="group__link.html#gad784951ef84c86486a0eba995f22e1f4">More...</a><br /></td></tr>
<tr class="separator:gad784951ef84c86486a0eba995f22e1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008baf2f96fc05cc1f124c97c3190cc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga008baf2f96fc05cc1f124c97c3190cc1">regina::ModelLinkGraphArc::ModelLinkGraphArc</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;)=default</td></tr>
<tr class="memdesc:ga008baf2f96fc05cc1f124c97c3190cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__link.html#ga008baf2f96fc05cc1f124c97c3190cc1">More...</a><br /></td></tr>
<tr class="separator:ga008baf2f96fc05cc1f124c97c3190cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0646e70ea3216d097bbbb1c99d6b54c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1">regina::ModelLinkGraphArc::node</a> () const</td></tr>
<tr class="memdesc:ga0646e70ea3216d097bbbb1c99d6b54c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node of the model graph from which this arc exits.  <a href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1">More...</a><br /></td></tr>
<tr class="separator:ga0646e70ea3216d097bbbb1c99d6b54c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d86898f011332b930717e67d4039ae8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8">regina::ModelLinkGraphArc::arc</a> () const</td></tr>
<tr class="memdesc:ga6d86898f011332b930717e67d4039ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.  <a href="group__link.html#ga6d86898f011332b930717e67d4039ae8">More...</a><br /></td></tr>
<tr class="separator:ga6d86898f011332b930717e67d4039ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb27406e070d9116d3e5b21921d26391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafb27406e070d9116d3e5b21921d26391">regina::ModelLinkGraphArc::operator==</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gafb27406e070d9116d3e5b21921d26391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given arc reference are identical.  <a href="group__link.html#gafb27406e070d9116d3e5b21921d26391">More...</a><br /></td></tr>
<tr class="separator:gafb27406e070d9116d3e5b21921d26391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe39709055f575f5859ce63a51c0b665"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabe39709055f575f5859ce63a51c0b665">regina::ModelLinkGraphArc::operator!=</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gabe39709055f575f5859ce63a51c0b665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given arc reference are not identical.  <a href="group__link.html#gabe39709055f575f5859ce63a51c0b665">More...</a><br /></td></tr>
<tr class="separator:gabe39709055f575f5859ce63a51c0b665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2b187c2d08eb862024e53f351566f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaad2b187c2d08eb862024e53f351566f8">regina::ModelLinkGraphArc::operator=</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;)=default</td></tr>
<tr class="memdesc:gaad2b187c2d08eb862024e53f351566f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment operator.  <a href="group__link.html#gaad2b187c2d08eb862024e53f351566f8">More...</a><br /></td></tr>
<tr class="separator:gaad2b187c2d08eb862024e53f351566f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397d518a7eb8ecf0e6d9f5b82c3e7439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga397d518a7eb8ecf0e6d9f5b82c3e7439">regina::ModelLinkGraphArc::opposite</a> () const</td></tr>
<tr class="memdesc:ga397d518a7eb8ecf0e6d9f5b82c3e7439"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the arc that exits the same node as this, but from the opposite side.  <a href="group__link.html#ga397d518a7eb8ecf0e6d9f5b82c3e7439">More...</a><br /></td></tr>
<tr class="separator:ga397d518a7eb8ecf0e6d9f5b82c3e7439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e9710e3cb111fc0e4826f41d024db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab9e9710e3cb111fc0e4826f41d024db5">regina::ModelLinkGraphArc::traverse</a> () const</td></tr>
<tr class="memdesc:gab9e9710e3cb111fc0e4826f41d024db5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the same edge of the model graph, but seen from the other endpoint.  <a href="group__link.html#gab9e9710e3cb111fc0e4826f41d024db5">More...</a><br /></td></tr>
<tr class="separator:gab9e9710e3cb111fc0e4826f41d024db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa071855b5a2d42aa2d18cc0aefbbd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga1aa071855b5a2d42aa2d18cc0aefbbd9">regina::ModelLinkGraphArc::next</a> () const</td></tr>
<tr class="memdesc:ga1aa071855b5a2d42aa2d18cc0aefbbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next arc after this when walking through the graph as though it were a link, in a direction away from the current node.  <a href="group__link.html#ga1aa071855b5a2d42aa2d18cc0aefbbd9">More...</a><br /></td></tr>
<tr class="separator:ga1aa071855b5a2d42aa2d18cc0aefbbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12029ae31f68fc95cc0f8cffe861de93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga12029ae31f68fc95cc0f8cffe861de93">regina::ModelLinkGraphArc::prev</a> () const</td></tr>
<tr class="memdesc:ga12029ae31f68fc95cc0f8cffe861de93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the previous arc before this when walking through the graph as though it were a link, in a direction away from the* current node.  <a href="group__link.html#ga12029ae31f68fc95cc0f8cffe861de93">More...</a><br /></td></tr>
<tr class="separator:ga12029ae31f68fc95cc0f8cffe861de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6da1ee39acdb0f069a502aec5e8f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gacd6da1ee39acdb0f069a502aec5e8f0f">regina::ModelLinkGraphArc::operator++</a> ()</td></tr>
<tr class="memdesc:gacd6da1ee39acdb0f069a502aec5e8f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes to the next outgoing link arc from the same node.  <a href="group__link.html#gacd6da1ee39acdb0f069a502aec5e8f0f">More...</a><br /></td></tr>
<tr class="separator:gacd6da1ee39acdb0f069a502aec5e8f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8380bee08f0311c799062af1435ed0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae8380bee08f0311c799062af1435ed0b">regina::ModelLinkGraphArc::operator++</a> (int)</td></tr>
<tr class="memdesc:gae8380bee08f0311c799062af1435ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes to the next outgoing link arc from the same node.  <a href="group__link.html#gae8380bee08f0311c799062af1435ed0b">More...</a><br /></td></tr>
<tr class="separator:gae8380bee08f0311c799062af1435ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9719945553f519a11026175141c0eb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9719945553f519a11026175141c0eb20">regina::ModelLinkGraphArc::operator--</a> ()</td></tr>
<tr class="memdesc:ga9719945553f519a11026175141c0eb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes to the previous outgoing link arc from the same node.  <a href="group__link.html#ga9719945553f519a11026175141c0eb20">More...</a><br /></td></tr>
<tr class="separator:ga9719945553f519a11026175141c0eb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585c6903d3d5ff419fc52ff60bc50d14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga585c6903d3d5ff419fc52ff60bc50d14">regina::ModelLinkGraphArc::operator--</a> (int)</td></tr>
<tr class="memdesc:ga585c6903d3d5ff419fc52ff60bc50d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes to the previous outgoing link arc from the same node.  <a href="group__link.html#ga585c6903d3d5ff419fc52ff60bc50d14">More...</a><br /></td></tr>
<tr class="separator:ga585c6903d3d5ff419fc52ff60bc50d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a986c8e02432f9f02a446bd5b7d7aa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8a986c8e02432f9f02a446bd5b7d7aa6">regina::ModelLinkGraphArc::operator bool</a> () const</td></tr>
<tr class="memdesc:ga8a986c8e02432f9f02a446bd5b7d7aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this is a non-null arc.  <a href="group__link.html#ga8a986c8e02432f9f02a446bd5b7d7aa6">More...</a><br /></td></tr>
<tr class="separator:ga8a986c8e02432f9f02a446bd5b7d7aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16afe99ca314816df9ad6790018b3d3c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga16afe99ca314816df9ad6790018b3d3c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;a)</td></tr>
<tr class="memdesc:ga16afe99ca314816df9ad6790018b3d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a depiction of the given arc reference to the given output stream.  <a href="group__link.html#ga16afe99ca314816df9ad6790018b3d3c">More...</a><br /></td></tr>
<tr class="separator:ga16afe99ca314816df9ad6790018b3d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0f916b26fe60795d1b78c59c3dfa96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gacd0f916b26fe60795d1b78c59c3dfa96">regina::ModelLinkGraphNode::index</a> () const</td></tr>
<tr class="memdesc:gacd0f916b26fe60795d1b78c59c3dfa96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this node within the overall graph.  <a href="group__link.html#gacd0f916b26fe60795d1b78c59c3dfa96">More...</a><br /></td></tr>
<tr class="separator:gacd0f916b26fe60795d1b78c59c3dfa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa163e8cc7ee1408f4e0ff6fa05b7e0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa163e8cc7ee1408f4e0ff6fa05b7e0e8">regina::ModelLinkGraphNode::arc</a> (int which)</td></tr>
<tr class="memdesc:gaa163e8cc7ee1408f4e0ff6fa05b7e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the four arcs of the graph that exit this node.  <a href="group__link.html#gaa163e8cc7ee1408f4e0ff6fa05b7e0e8">More...</a><br /></td></tr>
<tr class="separator:gaa163e8cc7ee1408f4e0ff6fa05b7e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e6d0ff69021f7f55372c76b2bdd169"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga03e6d0ff69021f7f55372c76b2bdd169">regina::ModelLinkGraphNode::adj</a> (int which) const</td></tr>
<tr class="memdesc:ga03e6d0ff69021f7f55372c76b2bdd169"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the arc at the other end of the given graph edge that exits this node.  <a href="group__link.html#ga03e6d0ff69021f7f55372c76b2bdd169">More...</a><br /></td></tr>
<tr class="separator:ga03e6d0ff69021f7f55372c76b2bdd169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5a0123fd3b826b561da8f88c5cb74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3b5a0123fd3b826b561da8f88c5cb74a">regina::ModelLinkGraphNode::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga3b5a0123fd3b826b561da8f88c5cb74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this node to the given output stream.  <a href="group__link.html#ga3b5a0123fd3b826b561da8f88c5cb74a">More...</a><br /></td></tr>
<tr class="separator:ga3b5a0123fd3b826b561da8f88c5cb74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975bbe195b67d788056adf21946d8025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga975bbe195b67d788056adf21946d8025">regina::ModelLinkGraphNode::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga975bbe195b67d788056adf21946d8025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this node to the given output stream.  <a href="group__link.html#ga975bbe195b67d788056adf21946d8025">More...</a><br /></td></tr>
<tr class="separator:ga975bbe195b67d788056adf21946d8025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60bf9d224d020d517c4ead5b4d77bc45"><td class="memItemLeft" align="right" valign="top"><a id="ga60bf9d224d020d517c4ead5b4d77bc45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphNode::ModelLinkGraphNode</b> (const <a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> &amp;)=delete</td></tr>
<tr class="separator:ga60bf9d224d020d517c4ead5b4d77bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3e5435582f148a60220fbcf0c4e601"><td class="memItemLeft" align="right" valign="top"><a id="gaba3e5435582f148a60220fbcf0c4e601"></a>
<a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphNode::operator=</b> (const <a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> &amp;)=delete</td></tr>
<tr class="separator:gaba3e5435582f148a60220fbcf0c4e601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabe9bd8331a5d5de03e0ce35c0ee669a0">regina::ModelLinkGraph::ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:gabe9bd8331a5d5de03e0ce35c0ee669a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty graph.  <a href="group__link.html#gabe9bd8331a5d5de03e0ce35c0ee669a0">More...</a><br /></td></tr>
<tr class="separator:gabe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8824307f9623abdf194742ad462890"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9a8824307f9623abdf194742ad462890">regina::ModelLinkGraph::ModelLinkGraph</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;copy)</td></tr>
<tr class="memdesc:ga9a8824307f9623abdf194742ad462890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given graph.  <a href="group__link.html#ga9a8824307f9623abdf194742ad462890">More...</a><br /></td></tr>
<tr class="separator:ga9a8824307f9623abdf194742ad462890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac9a6e5615cb448d21f99332ba6ffcbe1">regina::ModelLinkGraph::~ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:gac9a6e5615cb448d21f99332ba6ffcbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this graph.  <a href="group__link.html#gac9a6e5615cb448d21f99332ba6ffcbe1">More...</a><br /></td></tr>
<tr class="separator:gac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae830ab12408759e526ae15d16e0be5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8ae830ab12408759e526ae15d16e0be5">regina::ModelLinkGraph::size</a> () const</td></tr>
<tr class="memdesc:ga8ae830ab12408759e526ae15d16e0be5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of nodes in this graph.  <a href="group__link.html#ga8ae830ab12408759e526ae15d16e0be5">More...</a><br /></td></tr>
<tr class="separator:ga8ae830ab12408759e526ae15d16e0be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32048d7c0d574234df71c03cf8afcb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga32048d7c0d574234df71c03cf8afcb33">regina::ModelLinkGraph::node</a> (size_t index) const</td></tr>
<tr class="memdesc:ga32048d7c0d574234df71c03cf8afcb33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the node at the given index within this graph.  <a href="group__link.html#ga32048d7c0d574234df71c03cf8afcb33">More...</a><br /></td></tr>
<tr class="separator:ga32048d7c0d574234df71c03cf8afcb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a13d94cb957cd445bb446c8f56dd90d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9a13d94cb957cd445bb446c8f56dd90d">regina::ModelLinkGraph::swapContents</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other)</td></tr>
<tr class="memdesc:ga9a13d94cb957cd445bb446c8f56dd90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given graph.  <a href="group__link.html#ga9a13d94cb957cd445bb446c8f56dd90d">More...</a><br /></td></tr>
<tr class="separator:ga9a13d94cb957cd445bb446c8f56dd90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89a103eeda5359e83684d10b5f3444d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad89a103eeda5359e83684d10b5f3444d">regina::ModelLinkGraph::reflect</a> ()</td></tr>
<tr class="memdesc:gad89a103eeda5359e83684d10b5f3444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this graph into its reflection.  <a href="group__link.html#gad89a103eeda5359e83684d10b5f3444d">More...</a><br /></td></tr>
<tr class="separator:gad89a103eeda5359e83684d10b5f3444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4b314d226abfebfe9ba4ed26bfaf6b23">regina::ModelLinkGraph::cells</a> () const</td></tr>
<tr class="memdesc:ga4b314d226abfebfe9ba4ed26bfaf6b23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the cellular decomposition of the sphere that is induced by this graph.  <a href="group__link.html#ga4b314d226abfebfe9ba4ed26bfaf6b23">More...</a><br /></td></tr>
<tr class="separator:ga4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf992e58cf4215079603fb3d4d5c6bd62"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf992e58cf4215079603fb3d4d5c6bd62">regina::ModelLinkGraph::findFlype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:gaf992e58cf4215079603fb3d4d5c6bd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Flype is between arc&ndash; and arc, i.e., over the region defined by cell(arc).  <a href="group__link.html#gaf992e58cf4215079603fb3d4d5c6bd62">More...</a><br /></td></tr>
<tr class="separator:gaf992e58cf4215079603fb3d4d5c6bd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910f24b1a0045104f092fedb2f16dcd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga910f24b1a0045104f092fedb2f16dcd6">regina::ModelLinkGraph::flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;left, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;right) const</td></tr>
<tr class="memdesc:ga910f24b1a0045104f092fedb2f16dcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document.  <a href="group__link.html#ga910f24b1a0045104f092fedb2f16dcd6">More...</a><br /></td></tr>
<tr class="separator:ga910f24b1a0045104f092fedb2f16dcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56039020f86dbf85efbdb9b96075280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac56039020f86dbf85efbdb9b96075280">regina::ModelLinkGraph::flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:gac56039020f86dbf85efbdb9b96075280"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document.  <a href="group__link.html#gac56039020f86dbf85efbdb9b96075280">More...</a><br /></td></tr>
<tr class="separator:gac56039020f86dbf85efbdb9b96075280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69f103fedadb0c410b518fb76b3092a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab69f103fedadb0c410b518fb76b3092a">regina::ModelLinkGraph::generateMinimalLinks</a> (<a class="el" href="group__link.html#ga8395d3783317af74eb30822e96e96c0f">Use</a> use, void *useArgs=0) const</td></tr>
<tr class="memdesc:gab69f103fedadb0c410b518fb76b3092a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document.  <a href="group__link.html#gab69f103fedadb0c410b518fb76b3092a">More...</a><br /></td></tr>
<tr class="separator:gab69f103fedadb0c410b518fb76b3092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b794563bcc89728bf2dab6f6952a5c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5">regina::ModelLinkGraph::plantri</a> () const</td></tr>
<tr class="memdesc:ga3b794563bcc89728bf2dab6f6952a5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this graph in the ASCII text format used by <em>plantri</em>.  <a href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5">More...</a><br /></td></tr>
<tr class="separator:ga3b794563bcc89728bf2dab6f6952a5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab574d5b77af06b93deaf6de05d67b671"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab574d5b77af06b93deaf6de05d67b671">regina::ModelLinkGraph::canonicalPlantri</a> (bool useReflection=true, bool tight=false) const</td></tr>
<tr class="memdesc:gab574d5b77af06b93deaf6de05d67b671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text representation of this graph in the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression.  <a href="group__link.html#gab574d5b77af06b93deaf6de05d67b671">More...</a><br /></td></tr>
<tr class="separator:gab574d5b77af06b93deaf6de05d67b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4b88c8eb92b6c9abe6f557c3221486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaab4b88c8eb92b6c9abe6f557c3221486">regina::ModelLinkGraph::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaab4b88c8eb92b6c9abe6f557c3221486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this graph to the given output stream.  <a href="group__link.html#gaab4b88c8eb92b6c9abe6f557c3221486">More...</a><br /></td></tr>
<tr class="separator:gaab4b88c8eb92b6c9abe6f557c3221486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89355292f9354c4d8bfc7d5468ee26f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga89355292f9354c4d8bfc7d5468ee26f5">regina::ModelLinkGraph::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga89355292f9354c4d8bfc7d5468ee26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this graph to the given output stream.  <a href="group__link.html#ga89355292f9354c4d8bfc7d5468ee26f5">More...</a><br /></td></tr>
<tr class="separator:ga89355292f9354c4d8bfc7d5468ee26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7937582581020a947d0e728e950a8f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7d7937582581020a947d0e728e950a8f">regina::ModelLinkGraph::fromPlantri</a> (const std::string &amp;<a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5">plantri</a>)</td></tr>
<tr class="memdesc:ga7d7937582581020a947d0e728e950a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a graph from a line of <em>plantri</em> output.  <a href="group__link.html#ga7d7937582581020a947d0e728e950a8f">More...</a><br /></td></tr>
<tr class="separator:ga7d7937582581020a947d0e728e950a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05186004d59d73105241d86a848013c3"><td class="memItemLeft" align="right" valign="top"><a id="ga05186004d59d73105241d86a848013c3"></a>
<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraph::operator=</b> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;)=delete</td></tr>
<tr class="separator:ga05186004d59d73105241d86a848013c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f4806ed0e22f0f4461479e1f80b28c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9f4806ed0e22f0f4461479e1f80b28c2">regina::ModelLinkGraphCells::~ModelLinkGraphCells</a> ()</td></tr>
<tr class="memdesc:ga9f4806ed0e22f0f4461479e1f80b28c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this cellular decomposition.  <a href="group__link.html#ga9f4806ed0e22f0f4461479e1f80b28c2">More...</a><br /></td></tr>
<tr class="separator:ga9f4806ed0e22f0f4461479e1f80b28c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae15c42db3ab8321a751201bfeaef19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19">regina::ModelLinkGraphCells::isValid</a> () const</td></tr>
<tr class="memdesc:ga0ae15c42db3ab8321a751201bfeaef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is already known to be connected.  <a href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19">More...</a><br /></td></tr>
<tr class="separator:ga0ae15c42db3ab8321a751201bfeaef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0d54a49192f9ee3a54c486e0bd42ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad">regina::ModelLinkGraphCells::countCells</a> () const</td></tr>
<tr class="memdesc:ga4c0d54a49192f9ee3a54c486e0bd42ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of 2-cells in this cellular decomposition.  <a href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad">More...</a><br /></td></tr>
<tr class="separator:ga4c0d54a49192f9ee3a54c486e0bd42ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a2312e1d7864ab49cc946915d5ebe3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3">regina::ModelLinkGraphCells::arc</a> (size_t <a class="el" href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">cell</a>, size_t which) const</td></tr>
<tr class="memdesc:ga82a2312e1d7864ab49cc946915d5ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given arc along the boundary of the given 2-cell.  <a href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3">More...</a><br /></td></tr>
<tr class="separator:ga82a2312e1d7864ab49cc946915d5ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4043ef70f0d094c3ff49d8422e581529"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4043ef70f0d094c3ff49d8422e581529">regina::ModelLinkGraphCells::size</a> (size_t <a class="el" href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">cell</a>) const</td></tr>
<tr class="memdesc:ga4043ef70f0d094c3ff49d8422e581529"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs aloung the boundary of the given 2-cell.  <a href="group__link.html#ga4043ef70f0d094c3ff49d8422e581529">More...</a><br /></td></tr>
<tr class="separator:ga4043ef70f0d094c3ff49d8422e581529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3787c8a65c5c1ad581eef64111c4cee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab3787c8a65c5c1ad581eef64111c4cee">regina::ModelLinkGraphCells::begin</a> (size_t <a class="el" href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">cell</a>) const</td></tr>
<tr class="memdesc:gab3787c8a65c5c1ad581eef64111c4cee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the beginning of an iterator range for walking around the boundary of the given 2-cell.  <a href="group__link.html#gab3787c8a65c5c1ad581eef64111c4cee">More...</a><br /></td></tr>
<tr class="separator:gab3787c8a65c5c1ad581eef64111c4cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f82d487196daed2ecec41f69477b4b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4f82d487196daed2ecec41f69477b4b0">regina::ModelLinkGraphCells::end</a> (size_t <a class="el" href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">cell</a>) const</td></tr>
<tr class="memdesc:ga4f82d487196daed2ecec41f69477b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the end of an iterator range for walking around the boundary of the given 2-cell.  <a href="group__link.html#ga4f82d487196daed2ecec41f69477b4b0">More...</a><br /></td></tr>
<tr class="separator:ga4f82d487196daed2ecec41f69477b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8303a75b3d50bd5d568d9d12c86ab3df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">regina::ModelLinkGraphCells::cell</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;<a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3">arc</a>) const</td></tr>
<tr class="memdesc:ga8303a75b3d50bd5d568d9d12c86ab3df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 2-cell that lies to the left of the given arc.  <a href="group__link.html#ga8303a75b3d50bd5d568d9d12c86ab3df">More...</a><br /></td></tr>
<tr class="separator:ga8303a75b3d50bd5d568d9d12c86ab3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb166a8ee596ad4178d706e6fadb4283"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafb166a8ee596ad4178d706e6fadb4283">regina::ModelLinkGraphCells::cellPos</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;<a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3">arc</a>) const</td></tr>
<tr class="memdesc:gafb166a8ee596ad4178d706e6fadb4283"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> where the given arc appears along the boundary of the 2-cell to its left.  <a href="group__link.html#gafb166a8ee596ad4178d706e6fadb4283">More...</a><br /></td></tr>
<tr class="separator:gafb166a8ee596ad4178d706e6fadb4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a19ea743c6ed6d3908043a0ef9dc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga93a19ea743c6ed6d3908043a0ef9dc2e">regina::ModelLinkGraphCells::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga93a19ea743c6ed6d3908043a0ef9dc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__link.html#ga93a19ea743c6ed6d3908043a0ef9dc2e">More...</a><br /></td></tr>
<tr class="separator:ga93a19ea743c6ed6d3908043a0ef9dc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17ec70fa784c46ac7103fbe705b9a62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae17ec70fa784c46ac7103fbe705b9a62">regina::ModelLinkGraphCells::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gae17ec70fa784c46ac7103fbe705b9a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__link.html#gae17ec70fa784c46ac7103fbe705b9a62">More...</a><br /></td></tr>
<tr class="separator:gae17ec70fa784c46ac7103fbe705b9a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4997787f170de1dc19e85ba6db6b17c4"><td class="memItemLeft" align="right" valign="top"><a id="ga4997787f170de1dc19e85ba6db6b17c4"></a>
<a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphCells::operator=</b> (const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp;)=delete</td></tr>
<tr class="separator:ga4997787f170de1dc19e85ba6db6b17c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24c90c6bbf8bf637565fed530eb96f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae24c90c6bbf8bf637565fed530eb96f2">regina::XMLLinkReader::XMLLinkReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:gae24c90c6bbf8bf637565fed530eb96f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot/link reader.  <a href="group__link.html#gae24c90c6bbf8bf637565fed530eb96f2">More...</a><br /></td></tr>
<tr class="separator:gae24c90c6bbf8bf637565fed530eb96f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49ae8900301d590eb89ffed050abac9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf49ae8900301d590eb89ffed050abac9">regina::XMLLinkReader::packet</a> () override</td></tr>
<tr class="memdesc:gaf49ae8900301d590eb89ffed050abac9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__link.html#gaf49ae8900301d590eb89ffed050abac9">More...</a><br /></td></tr>
<tr class="separator:gaf49ae8900301d590eb89ffed050abac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcee2a779b45b242dca26dff055a569"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7fcee2a779b45b242dca26dff055a569">regina::XMLLinkReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga7fcee2a779b45b242dca26dff055a569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__link.html#ga7fcee2a779b45b242dca26dff055a569">More...</a><br /></td></tr>
<tr class="separator:ga7fcee2a779b45b242dca26dff055a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eceeda8be99a7fbb24789da450b24ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9eceeda8be99a7fbb24789da450b24ba">regina::XMLLinkReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga9eceeda8be99a7fbb24789da450b24ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__link.html#ga9eceeda8be99a7fbb24789da450b24ba">More...</a><br /></td></tr>
<tr class="separator:ga9eceeda8be99a7fbb24789da450b24ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f438ca8890283c5a3b830d79798491a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8f438ca8890283c5a3b830d79798491a">regina::XMLLinkCrossingsReader::XMLLinkCrossingsReader</a> (<a class="el" href="classregina_1_1Link.html">Link</a> *link)</td></tr>
<tr class="memdesc:ga8f438ca8890283c5a3b830d79798491a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new crossings reader.  <a href="group__link.html#ga8f438ca8890283c5a3b830d79798491a">More...</a><br /></td></tr>
<tr class="separator:ga8f438ca8890283c5a3b830d79798491a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c3fff79af8436854a3ffec13398f51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad3c3fff79af8436854a3ffec13398f51">regina::XMLLinkCrossingsReader::startElement</a> (const std::string &amp;, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *) override</td></tr>
<tr class="memdesc:gad3c3fff79af8436854a3ffec13398f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__link.html#gad3c3fff79af8436854a3ffec13398f51">More...</a><br /></td></tr>
<tr class="separator:gad3c3fff79af8436854a3ffec13398f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafc83aa265e5959176acd2883b6d547"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadafc83aa265e5959176acd2883b6d547">regina::XMLLinkCrossingsReader::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:gadafc83aa265e5959176acd2883b6d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__link.html#gadafc83aa265e5959176acd2883b6d547">More...</a><br /></td></tr>
<tr class="separator:gadafc83aa265e5959176acd2883b6d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea18d468f2ce15e590d049f3ba781eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0ea18d468f2ce15e590d049f3ba781eb">regina::XMLLinkCrossingsReader::broken</a> () const</td></tr>
<tr class="memdesc:ga0ea18d468f2ce15e590d049f3ba781eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the XML element has been found to contain invalid data.  <a href="group__link.html#ga0ea18d468f2ce15e590d049f3ba781eb">More...</a><br /></td></tr>
<tr class="separator:ga0ea18d468f2ce15e590d049f3ba781eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd8b63fbd08aeb21c39ad013f45fe9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadcd8b63fbd08aeb21c39ad013f45fe9b">regina::XMLLinkConnectionsReader::XMLLinkConnectionsReader</a> (<a class="el" href="classregina_1_1Link.html">Link</a> *link)</td></tr>
<tr class="memdesc:gadcd8b63fbd08aeb21c39ad013f45fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new connections reader.  <a href="group__link.html#gadcd8b63fbd08aeb21c39ad013f45fe9b">More...</a><br /></td></tr>
<tr class="separator:gadcd8b63fbd08aeb21c39ad013f45fe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ef883dde5628b57a152221f190861e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga72ef883dde5628b57a152221f190861e">regina::XMLLinkConnectionsReader::initialChars</a> (const std::string &amp;chars)</td></tr>
<tr class="memdesc:ga72ef883dde5628b57a152221f190861e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__link.html#ga72ef883dde5628b57a152221f190861e">More...</a><br /></td></tr>
<tr class="separator:ga72ef883dde5628b57a152221f190861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af92b9b8db289f8cfb7242ff6b0dabb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8af92b9b8db289f8cfb7242ff6b0dabb">regina::XMLLinkConnectionsReader::broken</a> () const</td></tr>
<tr class="memdesc:ga8af92b9b8db289f8cfb7242ff6b0dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the XML element has been found to contain invalid data.  <a href="group__link.html#ga8af92b9b8db289f8cfb7242ff6b0dabb">More...</a><br /></td></tr>
<tr class="separator:ga8af92b9b8db289f8cfb7242ff6b0dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30157129e97cea92b3dd4f860c8d113e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga30157129e97cea92b3dd4f860c8d113e">regina::XMLLinkComponentsReader::XMLLinkComponentsReader</a> (<a class="el" href="classregina_1_1Link.html">Link</a> *link)</td></tr>
<tr class="memdesc:ga30157129e97cea92b3dd4f860c8d113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new components reader.  <a href="group__link.html#ga30157129e97cea92b3dd4f860c8d113e">More...</a><br /></td></tr>
<tr class="separator:ga30157129e97cea92b3dd4f860c8d113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009e243aef258b3a6e8b37abd4274c8f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga009e243aef258b3a6e8b37abd4274c8f">regina::XMLLinkComponentsReader::startElement</a> (const std::string &amp;, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *)</td></tr>
<tr class="memdesc:ga009e243aef258b3a6e8b37abd4274c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__link.html#ga009e243aef258b3a6e8b37abd4274c8f">More...</a><br /></td></tr>
<tr class="separator:ga009e243aef258b3a6e8b37abd4274c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48568fbbfc05a92588119ad31434fc51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga48568fbbfc05a92588119ad31434fc51">regina::XMLLinkComponentsReader::initialChars</a> (const std::string &amp;chars)</td></tr>
<tr class="memdesc:ga48568fbbfc05a92588119ad31434fc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__link.html#ga48568fbbfc05a92588119ad31434fc51">More...</a><br /></td></tr>
<tr class="separator:ga48568fbbfc05a92588119ad31434fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86291976a435ec8528337b14bd8d346e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga86291976a435ec8528337b14bd8d346e">regina::XMLLinkComponentsReader::broken</a> () const</td></tr>
<tr class="memdesc:ga86291976a435ec8528337b14bd8d346e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the XML element has been found to contain invalid data.  <a href="group__link.html#ga86291976a435ec8528337b14bd8d346e">More...</a><br /></td></tr>
<tr class="separator:ga86291976a435ec8528337b14bd8d346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7063f2022a096350cb8e25cd937a94cc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7063f2022a096350cb8e25cd937a94cc">regina::Link::jonesVar</a></td></tr>
<tr class="memdesc:ga7063f2022a096350cb8e25cd937a94cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Jones polynomial, as returned by <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>.  <a href="group__link.html#ga7063f2022a096350cb8e25cd937a94cc">More...</a><br /></td></tr>
<tr class="separator:ga7063f2022a096350cb8e25cd937a94cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b2ca40f892a2375f27159cf11314ac"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf6b2ca40f892a2375f27159cf11314ac">regina::Link::homflyAZVarX</a></td></tr>
<tr class="memdesc:gaf6b2ca40f892a2375f27159cf11314ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="group__link.html#gaf6b2ca40f892a2375f27159cf11314ac">More...</a><br /></td></tr>
<tr class="separator:gaf6b2ca40f892a2375f27159cf11314ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3c7bb6dae63c7e28696f33f79ac6db"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0a3c7bb6dae63c7e28696f33f79ac6db">regina::Link::homflyAZVarY</a></td></tr>
<tr class="memdesc:ga0a3c7bb6dae63c7e28696f33f79ac6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="group__link.html#ga0a3c7bb6dae63c7e28696f33f79ac6db">More...</a><br /></td></tr>
<tr class="separator:ga0a3c7bb6dae63c7e28696f33f79ac6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4891884482d63762104e45c064375c"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabf4891884482d63762104e45c064375c">regina::Link::homflyLMVarX</a></td></tr>
<tr class="memdesc:gabf4891884482d63762104e45c064375c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="group__link.html#gabf4891884482d63762104e45c064375c">More...</a><br /></td></tr>
<tr class="separator:gabf4891884482d63762104e45c064375c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gace9dcc4b15180a96d0d2c8d0cbb157ab">regina::Link::homflyLMVarY</a></td></tr>
<tr class="memdesc:gace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="group__link.html#gace9dcc4b15180a96d0d2c8d0cbb157ab">More...</a><br /></td></tr>
<tr class="separator:gace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65375567e9a939248cef8a464e1ea0c7"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga65375567e9a939248cef8a464e1ea0c7">regina::Link::homflyVarX</a></td></tr>
<tr class="memdesc:ga65375567e9a939248cef8a464e1ea0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="group__link.html#ga65375567e9a939248cef8a464e1ea0c7">More...</a><br /></td></tr>
<tr class="separator:ga65375567e9a939248cef8a464e1ea0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b39da1b23893a682ff22b388041fdc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga79b39da1b23893a682ff22b388041fdc">regina::Link::homflyVarY</a></td></tr>
<tr class="memdesc:ga79b39da1b23893a682ff22b388041fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="group__link.html#ga79b39da1b23893a682ff22b388041fdc">More...</a><br /></td></tr>
<tr class="separator:ga79b39da1b23893a682ff22b388041fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memItemLeft" align="right" valign="top"><a id="ga1e9ca4d39ca75620494c1f03ae5b00e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StrandRef::Link</b></td></tr>
<tr class="separator:ga1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StrandRef::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="ga5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StrandRef::Tangle</b></td></tr>
<tr class="separator:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memItemLeft" align="right" valign="top"><a id="ga1e9ca4d39ca75620494c1f03ae5b00e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::Link</b></td></tr>
<tr class="separator:ga1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="ga5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::Tangle</b></td></tr>
<tr class="separator:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac427ed4036a7fdf0f108da0bbf1ca863"><td class="memItemLeft" align="right" valign="top"><a id="gac427ed4036a7fdf0f108da0bbf1ca863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::XMLLinkCrossingsReader</b></td></tr>
<tr class="separator:gac427ed4036a7fdf0f108da0bbf1ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52b37d823b9c630b33377f146c1520e"><td class="memItemLeft" align="right" valign="top"><a id="gaa52b37d823b9c630b33377f146c1520e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Crossing::XMLLinkConnectionsReader</b></td></tr>
<tr class="separator:gaa52b37d823b9c630b33377f146c1520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphArc::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphNode::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::ModelLinkGraphCells::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Links</h2></td></tr>
<tr class="memitem:ga152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="ga152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Link::ModelLinkGraph</b></td></tr>
<tr class="separator:ga152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="ga5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Link::Tangle</b></td></tr>
<tr class="separator:ga5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac427ed4036a7fdf0f108da0bbf1ca863"><td class="memItemLeft" align="right" valign="top"><a id="gac427ed4036a7fdf0f108da0bbf1ca863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Link::XMLLinkCrossingsReader</b></td></tr>
<tr class="separator:gac427ed4036a7fdf0f108da0bbf1ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab3f892e9d18731f9bee8f2a197e904"><td class="memItemLeft" align="right" valign="top"><a id="gacab3f892e9d18731f9bee8f2a197e904"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Link::XMLLinkComponentsReader</b></td></tr>
<tr class="separator:gacab3f892e9d18731f9bee8f2a197e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11d6d31315c7b000cb653901a0a711c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa11d6d31315c7b000cb653901a0a711c">regina::Link::insertTorusLink</a> (int p, int q, bool positive=true)</td></tr>
<tr class="memdesc:gaa11d6d31315c7b000cb653901a0a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new (<em>p</em>, <em>q</em>) torus link into this link.  <a href="group__link.html#gaa11d6d31315c7b000cb653901a0a711c">More...</a><br /></td></tr>
<tr class="separator:gaa11d6d31315c7b000cb653901a0a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080cbca4af7eadcab1aea5aec456d2ba"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga080cbca4af7eadcab1aea5aec456d2ba"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#ga080cbca4af7eadcab1aea5aec456d2ba">regina::Link::fromData</a> (std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... components)</td></tr>
<tr class="memdesc:ga080cbca4af7eadcab1aea5aec456d2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from hard-coded information about its crossings and components.  <a href="group__link.html#ga080cbca4af7eadcab1aea5aec456d2ba">More...</a><br /></td></tr>
<tr class="separator:ga080cbca4af7eadcab1aea5aec456d2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa67a9f8642ba7682baeade317ded53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga2fa67a9f8642ba7682baeade317ded53">regina::Link::fromKnotSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ga2fa67a9f8642ba7682baeade317ded53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a knot diagram from its signature.  <a href="group__link.html#ga2fa67a9f8642ba7682baeade317ded53">More...</a><br /></td></tr>
<tr class="separator:ga2fa67a9f8642ba7682baeade317ded53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24bafb845a51157cecfdbdd66f6f30c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad24bafb845a51157cecfdbdd66f6f30c">regina::Link::fromGauss</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:gad24bafb845a51157cecfdbdd66f6f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code.  <a href="group__link.html#gad24bafb845a51157cecfdbdd66f6f30c">More...</a><br /></td></tr>
<tr class="separator:gad24bafb845a51157cecfdbdd66f6f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552933848162ccc80e1ee0b4399f9866"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga552933848162ccc80e1ee0b4399f9866"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#ga552933848162ccc80e1ee0b4399f9866">regina::Link::fromGauss</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:ga552933848162ccc80e1ee0b4399f9866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code.  <a href="group__link.html#ga552933848162ccc80e1ee0b4399f9866">More...</a><br /></td></tr>
<tr class="separator:ga552933848162ccc80e1ee0b4399f9866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f23add46272acfdedb83be5fd5f7d3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c">regina::Link::fromOrientedGauss</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ga7f23add46272acfdedb83be5fd5f7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code.  <a href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c">More...</a><br /></td></tr>
<tr class="separator:ga7f23add46272acfdedb83be5fd5f7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9ccfdf468272086377417cf8a3df27"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga2d9ccfdf468272086377417cf8a3df27"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#ga2d9ccfdf468272086377417cf8a3df27">regina::Link::fromOrientedGauss</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:ga2d9ccfdf468272086377417cf8a3df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code.  <a href="group__link.html#ga2d9ccfdf468272086377417cf8a3df27">More...</a><br /></td></tr>
<tr class="separator:ga2d9ccfdf468272086377417cf8a3df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac206f9e3697de7472ee9ec151c106df0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac206f9e3697de7472ee9ec151c106df0">regina::Link::fromJenkins</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:gac206f9e3697de7472ee9ec151c106df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a link from the text representation described by Bob Jenkins.  <a href="group__link.html#gac206f9e3697de7472ee9ec151c106df0">More...</a><br /></td></tr>
<tr class="separator:gac206f9e3697de7472ee9ec151c106df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02aeec8648b7d97f889a3cb231ae226"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae02aeec8648b7d97f889a3cb231ae226">regina::Link::fromJenkins</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:gae02aeec8648b7d97f889a3cb231ae226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a link from the text representation described by Bob Jenkins.  <a href="group__link.html#gae02aeec8648b7d97f889a3cb231ae226">More...</a><br /></td></tr>
<tr class="separator:gae02aeec8648b7d97f889a3cb231ae226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d838c4975af256e7c8b40842d370dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga34d838c4975af256e7c8b40842d370dc">regina::Link::fromDT</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ga34d838c4975af256e7c8b40842d370dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.  <a href="group__link.html#ga34d838c4975af256e7c8b40842d370dc">More...</a><br /></td></tr>
<tr class="separator:ga34d838c4975af256e7c8b40842d370dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8e6024307a59835117f2910eac5a99"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga7b8e6024307a59835117f2910eac5a99"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#ga7b8e6024307a59835117f2910eac5a99">regina::Link::fromDT</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:ga7b8e6024307a59835117f2910eac5a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an integer sequence using the numerical variant of Dowker-Thistlethwaite notation.  <a href="group__link.html#ga7b8e6024307a59835117f2910eac5a99">More...</a><br /></td></tr>
<tr class="separator:ga7b8e6024307a59835117f2910eac5a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4c3e3e4fa822eebebef10246a5469f"><td class="memItemLeft" align="right" valign="top"><a id="ga6c4c3e3e4fa822eebebef10246a5469f"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Link::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga6c4c3e3e4fa822eebebef10246a5469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36d8a4b0c964cafb2cbac86b0d5e272"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa36d8a4b0c964cafb2cbac86b0d5e272">regina::Link::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gaa36d8a4b0c964cafb2cbac86b0d5e272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__link.html#gaa36d8a4b0c964cafb2cbac86b0d5e272">More...</a><br /></td></tr>
<tr class="separator:gaa36d8a4b0c964cafb2cbac86b0d5e272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df95452d2c6fdd8ec754c5adbaf9505"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4df95452d2c6fdd8ec754c5adbaf9505">regina::Link::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4df95452d2c6fdd8ec754c5adbaf9505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__link.html#ga4df95452d2c6fdd8ec754c5adbaf9505">More...</a><br /></td></tr>
<tr class="separator:ga4df95452d2c6fdd8ec754c5adbaf9505"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:gaff4dc84be20b66314534c2dcc7466324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaff4dc84be20b66314534c2dcc7466324">regina::Link::Link</a> ()</td></tr>
<tr class="memdesc:gaff4dc84be20b66314534c2dcc7466324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty link.  <a href="group__link.html#gaff4dc84be20b66314534c2dcc7466324">More...</a><br /></td></tr>
<tr class="separator:gaff4dc84be20b66314534c2dcc7466324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b717f99561f93f6b09118cdf770803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa6b717f99561f93f6b09118cdf770803">regina::Link::Link</a> (size_t unknots)</td></tr>
<tr class="memdesc:gaa6b717f99561f93f6b09118cdf770803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the unlink with the given number of components.  <a href="group__link.html#gaa6b717f99561f93f6b09118cdf770803">More...</a><br /></td></tr>
<tr class="separator:gaa6b717f99561f93f6b09118cdf770803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359918be5fb86081d1122cc2f2260a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga359918be5fb86081d1122cc2f2260a5f">regina::Link::Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy)</td></tr>
<tr class="memdesc:ga359918be5fb86081d1122cc2f2260a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link.  <a href="group__link.html#ga359918be5fb86081d1122cc2f2260a5f">More...</a><br /></td></tr>
<tr class="separator:ga359918be5fb86081d1122cc2f2260a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef22c9d7355dc008bfc0282c1f99e4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaaef22c9d7355dc008bfc0282c1f99e4b">regina::Link::Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:gaaef22c9d7355dc008bfc0282c1f99e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also.  <a href="group__link.html#gaaef22c9d7355dc008bfc0282c1f99e4b">More...</a><br /></td></tr>
<tr class="separator:gaaef22c9d7355dc008bfc0282c1f99e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b233fb32a24925705b616b5dc23b219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9b233fb32a24925705b616b5dc23b219">regina::Link::Link</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:ga9b233fb32a24925705b616b5dc23b219"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a link.  <a href="group__link.html#ga9b233fb32a24925705b616b5dc23b219">More...</a><br /></td></tr>
<tr class="separator:ga9b233fb32a24925705b616b5dc23b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca93be82c5a263db9e3dc28a928fb4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaca93be82c5a263db9e3dc28a928fb4ba">regina::Link::~Link</a> ()</td></tr>
<tr class="memdesc:gaca93be82c5a263db9e3dc28a928fb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this link.  <a href="group__link.html#gaca93be82c5a263db9e3dc28a928fb4ba">More...</a><br /></td></tr>
<tr class="separator:gaca93be82c5a263db9e3dc28a928fb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Crossings and Components</h2></td></tr>
<tr class="memitem:gad12a7e69700971494486e299bbc39c57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad12a7e69700971494486e299bbc39c57">regina::Link::isEmpty</a> () const</td></tr>
<tr class="memdesc:gad12a7e69700971494486e299bbc39c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link is empty.  <a href="group__link.html#gad12a7e69700971494486e299bbc39c57">More...</a><br /></td></tr>
<tr class="separator:gad12a7e69700971494486e299bbc39c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6f34794cc62574fcfca388f3f66d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga32c6f34794cc62574fcfca388f3f66d9">regina::Link::size</a> () const</td></tr>
<tr class="memdesc:ga32c6f34794cc62574fcfca388f3f66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this link.  <a href="group__link.html#ga32c6f34794cc62574fcfca388f3f66d9">More...</a><br /></td></tr>
<tr class="separator:ga32c6f34794cc62574fcfca388f3f66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab4fb9a0932d786dfca9eef2f6e45ec60">regina::Link::countComponents</a> () const</td></tr>
<tr class="memdesc:gab4fb9a0932d786dfca9eef2f6e45ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of components in this link.  <a href="group__link.html#gab4fb9a0932d786dfca9eef2f6e45ec60">More...</a><br /></td></tr>
<tr class="separator:gab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b47712bc419c15659a634ae6ea97b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga2b47712bc419c15659a634ae6ea97b91">regina::Link::crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:ga2b47712bc419c15659a634ae6ea97b91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this link.  <a href="group__link.html#ga2b47712bc419c15659a634ae6ea97b91">More...</a><br /></td></tr>
<tr class="separator:ga2b47712bc419c15659a634ae6ea97b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3425a2a6994fbc87baf890e9b429ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3425a2a6994fbc87baf890e9b429ef6f">regina::Link::component</a> (size_t index) const</td></tr>
<tr class="memdesc:ga3425a2a6994fbc87baf890e9b429ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a strand in the given component of this link.  <a href="group__link.html#ga3425a2a6994fbc87baf890e9b429ef6f">More...</a><br /></td></tr>
<tr class="separator:ga3425a2a6994fbc87baf890e9b429ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411f710b2b7a73d1999cf0ea44cc7a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga411f710b2b7a73d1999cf0ea44cc7a4a">regina::Link::strand</a> (int id) const</td></tr>
<tr class="memdesc:ga411f710b2b7a73d1999cf0ea44cc7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the strand in the link with the given integer ID.  <a href="group__link.html#ga411f710b2b7a73d1999cf0ea44cc7a4a">More...</a><br /></td></tr>
<tr class="separator:ga411f710b2b7a73d1999cf0ea44cc7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d5e4637efe2ed81e2c9588aaa76591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa4d5e4637efe2ed81e2c9588aaa76591">regina::Link::translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:gaa4d5e4637efe2ed81e2c9588aaa76591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference for some other link into the corresponding strand reference for this link.  <a href="group__link.html#gaa4d5e4637efe2ed81e2c9588aaa76591">More...</a><br /></td></tr>
<tr class="separator:gaa4d5e4637efe2ed81e2c9588aaa76591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc783777826fcf17af86d21a343118d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabc783777826fcf17af86d21a343118d5">regina::Link::connected</a> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *a, const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *b) const</td></tr>
<tr class="memdesc:gabc783777826fcf17af86d21a343118d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram.  <a href="group__link.html#gabc783777826fcf17af86d21a343118d5">More...</a><br /></td></tr>
<tr class="separator:gabc783777826fcf17af86d21a343118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Editing</h2></td></tr>
<tr class="memitem:ga15ae448f3fa16932d01d4c5a165e408c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga15ae448f3fa16932d01d4c5a165e408c">regina::Link::swapContents</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:ga15ae448f3fa16932d01d4c5a165e408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given link.  <a href="group__link.html#ga15ae448f3fa16932d01d4c5a165e408c">More...</a><br /></td></tr>
<tr class="separator:ga15ae448f3fa16932d01d4c5a165e408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d386bea941e436ae6548aa8663a005b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0d386bea941e436ae6548aa8663a005b">regina::Link::change</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:ga0d386bea941e436ae6548aa8663a005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of the given crossing.  <a href="group__link.html#ga0d386bea941e436ae6548aa8663a005b">More...</a><br /></td></tr>
<tr class="separator:ga0d386bea941e436ae6548aa8663a005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0546dc7f2bde7b63c31f3e057a8c04db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0546dc7f2bde7b63c31f3e057a8c04db">regina::Link::changeAll</a> ()</td></tr>
<tr class="memdesc:ga0546dc7f2bde7b63c31f3e057a8c04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the diagram.  <a href="group__link.html#ga0546dc7f2bde7b63c31f3e057a8c04db">More...</a><br /></td></tr>
<tr class="separator:ga0546dc7f2bde7b63c31f3e057a8c04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da54fa7f3352392989e34629c314a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6da54fa7f3352392989e34629c314a91">regina::Link::resolve</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:ga6da54fa7f3352392989e34629c314a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the given crossing.  <a href="group__link.html#ga6da54fa7f3352392989e34629c314a91">More...</a><br /></td></tr>
<tr class="separator:ga6da54fa7f3352392989e34629c314a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8b4396c9fcb99dbb3bb4ba7176b859c4">regina::Link::reflect</a> ()</td></tr>
<tr class="memdesc:ga8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this link into its reflection.  <a href="group__link.html#ga8b4396c9fcb99dbb3bb4ba7176b859c4">More...</a><br /></td></tr>
<tr class="separator:ga8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078b8f0dd10461df6f5b535fb3991bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga078b8f0dd10461df6f5b535fb3991bce">regina::Link::rotate</a> ()</td></tr>
<tr class="memdesc:ga078b8f0dd10461df6f5b535fb3991bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this link diagram, converting it into a different diagram of the same link.  <a href="group__link.html#ga078b8f0dd10461df6f5b535fb3991bce">More...</a><br /></td></tr>
<tr class="separator:ga078b8f0dd10461df6f5b535fb3991bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9326a4e30a7cfb373020c4c6084775fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9326a4e30a7cfb373020c4c6084775fc">regina::Link::reverse</a> ()</td></tr>
<tr class="memdesc:ga9326a4e30a7cfb373020c4c6084775fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of every component of this link.  <a href="group__link.html#ga9326a4e30a7cfb373020c4c6084775fc">More...</a><br /></td></tr>
<tr class="separator:ga9326a4e30a7cfb373020c4c6084775fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a70af4f63bbd4f7dea13a04a3b984a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga23a70af4f63bbd4f7dea13a04a3b984a">regina::Link::r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#ga2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga23a70af4f63bbd4f7dea13a04a3b984a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to remove a crossing.  <a href="group__link.html#ga23a70af4f63bbd4f7dea13a04a3b984a">More...</a><br /></td></tr>
<tr class="separator:ga23a70af4f63bbd4f7dea13a04a3b984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9535918349c0ada298fcabeac5638ec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9535918349c0ada298fcabeac5638ec8">regina::Link::r1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga9535918349c0ada298fcabeac5638ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to add a new crossing.  <a href="group__link.html#ga9535918349c0ada298fcabeac5638ec8">More...</a><br /></td></tr>
<tr class="separator:ga9535918349c0ada298fcabeac5638ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf3e0d6eaa504eba071e3950a939028"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafaf3e0d6eaa504eba071e3950a939028">regina::Link::r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gafaf3e0d6eaa504eba071e3950a939028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="group__link.html#gafaf3e0d6eaa504eba071e3950a939028">More...</a><br /></td></tr>
<tr class="separator:gafaf3e0d6eaa504eba071e3950a939028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050794f44093f3ec4740eb6b2653d40e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga050794f44093f3ec4740eb6b2653d40e">regina::Link::r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#ga2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga050794f44093f3ec4740eb6b2653d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="group__link.html#ga050794f44093f3ec4740eb6b2653d40e">More...</a><br /></td></tr>
<tr class="separator:ga050794f44093f3ec4740eb6b2653d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga92d15fe6c6ad9a04ae0e05c9fea67cea">regina::Link::r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to add two new crossings.  <a href="group__link.html#ga92d15fe6c6ad9a04ae0e05c9fea67cea">More...</a><br /></td></tr>
<tr class="separator:ga92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29467a23ac123cbab680b1e406e34bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad29467a23ac123cbab680b1e406e34bc">regina::Link::r3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gad29467a23ac123cbab680b1e406e34bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="group__link.html#gad29467a23ac123cbab680b1e406e34bc">More...</a><br /></td></tr>
<tr class="separator:gad29467a23ac123cbab680b1e406e34bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ba90169324b005d88587e4597ad129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae0ba90169324b005d88587e4597ad129">regina::Link::r3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#ga2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gae0ba90169324b005d88587e4597ad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="group__link.html#gae0ba90169324b005d88587e4597ad129">More...</a><br /></td></tr>
<tr class="separator:gae0ba90169324b005d88587e4597ad129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6293eb60b5477b5cac84363c43286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gacb6293eb60b5477b5cac84363c43286a">regina::Link::hasReducingPass</a> () const</td></tr>
<tr class="memdesc:gacb6293eb60b5477b5cac84363c43286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this knot has a pass move that will reduce the number of crossings.  <a href="group__link.html#gacb6293eb60b5477b5cac84363c43286a">More...</a><br /></td></tr>
<tr class="separator:gacb6293eb60b5477b5cac84363c43286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc961ba707da75f2b71d3585c994cc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9">regina::Link::intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:ga5fc961ba707da75f2b71d3585c994cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the link diagram using fast and greedy heuristics.  <a href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9">More...</a><br /></td></tr>
<tr class="separator:ga5fc961ba707da75f2b71d3585c994cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3adf6c87c3dc80de018d659e686b48ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3adf6c87c3dc80de018d659e686b48ef">regina::Link::simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:ga3adf6c87c3dc80de018d659e686b48ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings.  <a href="group__link.html#ga3adf6c87c3dc80de018d659e686b48ef">More...</a><br /></td></tr>
<tr class="separator:ga3adf6c87c3dc80de018d659e686b48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7701e3dd1fdbe8d8106363d118ec887d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d">regina::Link::simplifyExhaustive</a> (int height=1, unsigned nThreads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:ga7701e3dd1fdbe8d8106363d118ec887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph.  <a href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d">More...</a><br /></td></tr>
<tr class="separator:ga7701e3dd1fdbe8d8106363d118ec887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeadc3ba80f5f033f8b306a718b06566c"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:gaeadc3ba80f5f033f8b306a718b06566c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#gaeadc3ba80f5f033f8b306a718b06566c">regina::Link::rewrite</a> (int height, unsigned nThreads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:gaeadc3ba80f5f033f8b306a718b06566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings.  <a href="group__link.html#gaeadc3ba80f5f033f8b306a718b06566c">More...</a><br /></td></tr>
<tr class="separator:gaeadc3ba80f5f033f8b306a718b06566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28355f40d08c312c5f2e6cceb68bc1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga28355f40d08c312c5f2e6cceb68bc1b4">regina::Link::composeWith</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:ga28355f40d08c312c5f2e6cceb68bc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the composition of this with the given link.  <a href="group__link.html#ga28355f40d08c312c5f2e6cceb68bc1b4">More...</a><br /></td></tr>
<tr class="separator:ga28355f40d08c312c5f2e6cceb68bc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Invariants and Related Properties</h2></td></tr>
<tr class="memitem:ga821a3c1d060bdc5f3807ee1a64064775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga821a3c1d060bdc5f3807ee1a64064775">regina::Link::isAlternating</a> () const</td></tr>
<tr class="memdesc:ga821a3c1d060bdc5f3807ee1a64064775"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this knot diagram is alternating.  <a href="group__link.html#ga821a3c1d060bdc5f3807ee1a64064775">More...</a><br /></td></tr>
<tr class="separator:ga821a3c1d060bdc5f3807ee1a64064775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdacd0939c10de129dcf4c9a72f209c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8cdacd0939c10de129dcf4c9a72f209c">regina::Link::linking</a> () const</td></tr>
<tr class="memdesc:ga8cdacd0939c10de129dcf4c9a72f209c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the linking number of this link.  <a href="group__link.html#ga8cdacd0939c10de129dcf4c9a72f209c">More...</a><br /></td></tr>
<tr class="separator:ga8cdacd0939c10de129dcf4c9a72f209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6e5a318a8fdab39ebea49912074d19"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaed6e5a318a8fdab39ebea49912074d19">regina::Link::writhe</a> () const</td></tr>
<tr class="memdesc:gaed6e5a318a8fdab39ebea49912074d19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the writhe of this link diagram.  <a href="group__link.html#gaed6e5a318a8fdab39ebea49912074d19">More...</a><br /></td></tr>
<tr class="separator:gaed6e5a318a8fdab39ebea49912074d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b02a5c5a55f174df916132eb1b74d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga2b02a5c5a55f174df916132eb1b74d54">regina::Link::complement</a> (bool simplify=true) const</td></tr>
<tr class="memdesc:ga2b02a5c5a55f174df916132eb1b74d54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an ideal triangulation of the complement of this link in the 3-sphere.  <a href="group__link.html#ga2b02a5c5a55f174df916132eb1b74d54">More...</a><br /></td></tr>
<tr class="separator:ga2b02a5c5a55f174df916132eb1b74d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9da32820ca345fb6056f0cc149c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga2d9da32820ca345fb6056f0cc149c872">regina::Link::parallel</a> (int k, <a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a> framing=<a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a>) const</td></tr>
<tr class="memdesc:ga2d9da32820ca345fb6056f0cc149c872"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <em>k</em> cables of this link, all parallel to each other using the given framing.  <a href="group__link.html#ga2d9da32820ca345fb6056f0cc149c872">More...</a><br /></td></tr>
<tr class="separator:ga2d9da32820ca345fb6056f0cc149c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd286c4c3d5512b2d9de53e57a57055a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a">regina::Link::bracket</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:gafd286c4c3d5512b2d9de53e57a57055a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Kauffman bracket polynomial of this link diagram.  <a href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a">More...</a><br /></td></tr>
<tr class="separator:gafd286c4c3d5512b2d9de53e57a57055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a432a4f3024e537920770c0eb60d2e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6a432a4f3024e537920770c0eb60d2e2">regina::Link::knowsBracket</a> () const</td></tr>
<tr class="memdesc:ga6a432a4f3024e537920770c0eb60d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details.  <a href="group__link.html#ga6a432a4f3024e537920770c0eb60d2e2">More...</a><br /></td></tr>
<tr class="separator:ga6a432a4f3024e537920770c0eb60d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74edbfadfccb443efa6a6f1852ab9b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5">regina::Link::jones</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:gad74edbfadfccb443efa6a6f1852ab9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Jones polynomial of this link, but with all exponents doubled.  <a href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5">More...</a><br /></td></tr>
<tr class="separator:gad74edbfadfccb443efa6a6f1852ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a2acb5efa330841a89e91d28e5d64a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga13a2acb5efa330841a89e91d28e5d64a">regina::Link::knowsJones</a> () const</td></tr>
<tr class="memdesc:ga13a2acb5efa330841a89e91d28e5d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Jones polynomial of this link diagram already known? See <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details.  <a href="group__link.html#ga13a2acb5efa330841a89e91d28e5d64a">More...</a><br /></td></tr>
<tr class="separator:ga13a2acb5efa330841a89e91d28e5d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173ba85ab3f36b64631816894ff4809f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f">regina::Link::homflyAZ</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ga173ba85ab3f36b64631816894ff4809f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="group__link.html#ga173ba85ab3f36b64631816894ff4809f">More...</a><br /></td></tr>
<tr class="separator:ga173ba85ab3f36b64631816894ff4809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8165708806e390b41b33655bdbb40af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5">regina::Link::homflyLM</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ga8165708806e390b41b33655bdbb40af5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>.  <a href="group__link.html#ga8165708806e390b41b33655bdbb40af5">More...</a><br /></td></tr>
<tr class="separator:ga8165708806e390b41b33655bdbb40af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3cdae63725a633c32868737d44cb7c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7">regina::Link::homfly</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:gaa3cdae63725a633c32868737d44cb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7">More...</a><br /></td></tr>
<tr class="separator:gaa3cdae63725a633c32868737d44cb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae7100ef279d1f9a4ed7a739e76d5c5d4">regina::Link::knowsHomfly</a> () const</td></tr>
<tr class="memdesc:gae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details.  <a href="group__link.html#gae7100ef279d1f9a4ed7a739e76d5c5d4">More...</a><br /></td></tr>
<tr class="separator:gae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9867163e5b6defa9aa85d9bd8d9963"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadf9867163e5b6defa9aa85d9bd8d9963">regina::Link::niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:gadf9867163e5b6defa9aa85d9bd8d9963"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.  <a href="group__link.html#gadf9867163e5b6defa9aa85d9bd8d9963">More...</a><br /></td></tr>
<tr class="separator:gadf9867163e5b6defa9aa85d9bd8d9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b845088fe7d44ab3da72b9fa9abddc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7b845088fe7d44ab3da72b9fa9abddc0">regina::Link::useTreeDecomposition</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;td)</td></tr>
<tr class="memdesc:ga7b845088fe7d44ab3da72b9fa9abddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link.  <a href="group__link.html#ga7b845088fe7d44ab3da72b9fa9abddc0">More...</a><br /></td></tr>
<tr class="separator:ga7b845088fe7d44ab3da72b9fa9abddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Administration</h2></td></tr>
<tr class="memitem:ga645147f6f603066ea0eb85a8d0978578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga645147f6f603066ea0eb85a8d0978578">regina::Link::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga645147f6f603066ea0eb85a8d0978578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__link.html#ga645147f6f603066ea0eb85a8d0978578">More...</a><br /></td></tr>
<tr class="separator:ga645147f6f603066ea0eb85a8d0978578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58309b754fc2392ea83ee63c77a961b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga58309b754fc2392ea83ee63c77a961b8">regina::Link::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga58309b754fc2392ea83ee63c77a961b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__link.html#ga58309b754fc2392ea83ee63c77a961b8">More...</a><br /></td></tr>
<tr class="separator:ga58309b754fc2392ea83ee63c77a961b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34359ae0aeda30012164cd24256dd29d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga34359ae0aeda30012164cd24256dd29d">regina::Link::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga34359ae0aeda30012164cd24256dd29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__link.html#ga34359ae0aeda30012164cd24256dd29d">More...</a><br /></td></tr>
<tr class="separator:ga34359ae0aeda30012164cd24256dd29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exporting Links</h2></td></tr>
<tr class="memitem:ga805821d3da773fdd9a69f75916dbd90e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga805821d3da773fdd9a69f75916dbd90e">regina::Link::brief</a> () const</td></tr>
<tr class="memdesc:ga805821d3da773fdd9a69f75916dbd90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this link in Regina's own brief format.  <a href="group__link.html#ga805821d3da773fdd9a69f75916dbd90e">More...</a><br /></td></tr>
<tr class="separator:ga805821d3da773fdd9a69f75916dbd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05b65401950517d86be107268233b09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac05b65401950517d86be107268233b09">regina::Link::gauss</a> () const</td></tr>
<tr class="memdesc:gac05b65401950517d86be107268233b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a classical Gauss code for this knot.  <a href="group__link.html#gac05b65401950517d86be107268233b09">More...</a><br /></td></tr>
<tr class="separator:gac05b65401950517d86be107268233b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8c0d2be78044e3fc4108e092d086a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga5d8c0d2be78044e3fc4108e092d086a5">regina::Link::gauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga5d8c0d2be78044e3fc4108e092d086a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a classical Gauss code for this knot to the given output stream.  <a href="group__link.html#ga5d8c0d2be78044e3fc4108e092d086a5">More...</a><br /></td></tr>
<tr class="separator:ga5d8c0d2be78044e3fc4108e092d086a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d81af83901af217da0bee17b6bf120"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120">regina::Link::orientedGauss</a> () const</td></tr>
<tr class="memdesc:gab8d81af83901af217da0bee17b6bf120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an oriented Gauss code for this knot.  <a href="group__link.html#gab8d81af83901af217da0bee17b6bf120">More...</a><br /></td></tr>
<tr class="separator:gab8d81af83901af217da0bee17b6bf120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21eaa9351a071dc7ddcf8e4d1101d584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga21eaa9351a071dc7ddcf8e4d1101d584">regina::Link::orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga21eaa9351a071dc7ddcf8e4d1101d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this knot to the given output stream.  <a href="group__link.html#ga21eaa9351a071dc7ddcf8e4d1101d584">More...</a><br /></td></tr>
<tr class="separator:ga21eaa9351a071dc7ddcf8e4d1101d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga194f84f5ad2fb28ab1a0da34aa69d8a8">regina::Link::jenkins</a> () const</td></tr>
<tr class="memdesc:ga194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link as a string using the text representation described by Bob Jenkins.  <a href="group__link.html#ga194f84f5ad2fb28ab1a0da34aa69d8a8">More...</a><br /></td></tr>
<tr class="separator:ga194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6509ca2eaf2920bf4dc7e69eb5f5f499">regina::Link::jenkins</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link to the given output stream using the text representation described by Bob Jenkins.  <a href="group__link.html#ga6509ca2eaf2920bf4dc7e69eb5f5f499">More...</a><br /></td></tr>
<tr class="separator:ga6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga7394cd7aa9cb8d14cb4d7d39f9d96478">regina::Link::dt</a> (bool alpha=false) const</td></tr>
<tr class="memdesc:ga7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this knot using Dowker-Thistlethwaite notation.  <a href="group__link.html#ga7394cd7aa9cb8d14cb4d7d39f9d96478">More...</a><br /></td></tr>
<tr class="separator:ga7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e48b3891b1ec16cff1190f781e3ebd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6e48b3891b1ec16cff1190f781e3ebd0">regina::Link::dt</a> (std::ostream &amp;out, bool alpha=false) const</td></tr>
<tr class="memdesc:ga6e48b3891b1ec16cff1190f781e3ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this knot to the given output stream using Dowker-Thistlethwaite notation.  <a href="group__link.html#ga6e48b3891b1ec16cff1190f781e3ebd0">More...</a><br /></td></tr>
<tr class="separator:ga6e48b3891b1ec16cff1190f781e3ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92">regina::Link::writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the underlying planar 4-valent multigraph using the PACE text format.  <a href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92">More...</a><br /></td></tr>
<tr class="separator:ga8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b21aaa8020908478576e1f9325d4f91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga6b21aaa8020908478576e1f9325d4f91">regina::Link::pace</a> () const</td></tr>
<tr class="memdesc:ga6b21aaa8020908478576e1f9325d4f91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of the underlying planar 4-valent multigraph, using the PACE text format.  <a href="group__link.html#ga6b21aaa8020908478576e1f9325d4f91">More...</a><br /></td></tr>
<tr class="separator:ga6b21aaa8020908478576e1f9325d4f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718258433d47de780e6905585a00bd29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga718258433d47de780e6905585a00bd29">regina::Link::dumpConstruction</a> () const</td></tr>
<tr class="memdesc:ga718258433d47de780e6905585a00bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used to reconstruct this link.  <a href="group__link.html#ga718258433d47de780e6905585a00bd29">More...</a><br /></td></tr>
<tr class="separator:ga718258433d47de780e6905585a00bd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e305e2721276730a7783e84bc0bc04"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga96e305e2721276730a7783e84bc0bc04">regina::Link::knotSig</a> (bool useReflection=true, bool useReversal=true) const</td></tr>
<tr class="memdesc:ga96e305e2721276730a7783e84bc0bc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <em>signature</em> for this knot diagram.  <a href="group__link.html#ga96e305e2721276730a7783e84bc0bc04">More...</a><br /></td></tr>
<tr class="separator:ga96e305e2721276730a7783e84bc0bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:ga683a15a679a274e4cd2c905ef381d287"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga683a15a679a274e4cd2c905ef381d287">regina::Tangle::Tangle</a> ()</td></tr>
<tr class="memdesc:ga683a15a679a274e4cd2c905ef381d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the zero tangle.  <a href="group__link.html#ga683a15a679a274e4cd2c905ef381d287">More...</a><br /></td></tr>
<tr class="separator:ga683a15a679a274e4cd2c905ef381d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gae23fbb1a389e483e32f99c9eb1e3a3e9">regina::Tangle::Tangle</a> (int twists)</td></tr>
<tr class="memdesc:gae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tangle from the given number of twists.  <a href="group__link.html#gae23fbb1a389e483e32f99c9eb1e3a3e9">More...</a><br /></td></tr>
<tr class="separator:gae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a5f998255d48ee62fdd3c53b04c162"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga08a5f998255d48ee62fdd3c53b04c162">regina::Tangle::Tangle</a> (int num, int den)</td></tr>
<tr class="memdesc:ga08a5f998255d48ee62fdd3c53b04c162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rational tangle with the given parameters.  <a href="group__link.html#ga08a5f998255d48ee62fdd3c53b04c162">More...</a><br /></td></tr>
<tr class="separator:ga08a5f998255d48ee62fdd3c53b04c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe69c31e2d787bf47ccd21513d9f302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gadbe69c31e2d787bf47ccd21513d9f302">regina::Tangle::Tangle</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;knot)</td></tr>
<tr class="memdesc:gadbe69c31e2d787bf47ccd21513d9f302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tangle from two parallel copies of the given knot.  <a href="group__link.html#gadbe69c31e2d787bf47ccd21513d9f302">More...</a><br /></td></tr>
<tr class="separator:gadbe69c31e2d787bf47ccd21513d9f302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d96f9728fe44d1b8d0802d789e538c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga9d96f9728fe44d1b8d0802d789e538c9">regina::Tangle::Tangle</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;copy)</td></tr>
<tr class="memdesc:ga9d96f9728fe44d1b8d0802d789e538c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given tangle.  <a href="group__link.html#ga9d96f9728fe44d1b8d0802d789e538c9">More...</a><br /></td></tr>
<tr class="separator:ga9d96f9728fe44d1b8d0802d789e538c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda30f07f41d668822fb525b8253b8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabda30f07f41d668822fb525b8253b8d0">regina::Tangle::~Tangle</a> ()</td></tr>
<tr class="memdesc:gabda30f07f41d668822fb525b8253b8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tangle.  <a href="group__link.html#gabda30f07f41d668822fb525b8253b8d0">More...</a><br /></td></tr>
<tr class="separator:gabda30f07f41d668822fb525b8253b8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Crossings and Strings</h2></td></tr>
<tr class="memitem:gab88015bcdf131873362ba1da8e26507c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gab88015bcdf131873362ba1da8e26507c">regina::Tangle::type</a> () const</td></tr>
<tr class="memdesc:gab88015bcdf131873362ba1da8e26507c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the type of this tangle.  <a href="group__link.html#gab88015bcdf131873362ba1da8e26507c">More...</a><br /></td></tr>
<tr class="separator:gab88015bcdf131873362ba1da8e26507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e255ebc40070d5c43f14fb3848f2827"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga3e255ebc40070d5c43f14fb3848f2827">regina::Tangle::size</a> () const</td></tr>
<tr class="memdesc:ga3e255ebc40070d5c43f14fb3848f2827"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this tangle.  <a href="group__link.html#ga3e255ebc40070d5c43f14fb3848f2827">More...</a><br /></td></tr>
<tr class="separator:ga3e255ebc40070d5c43f14fb3848f2827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c92cf6b883589c87ef9ce24d36e318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf1c92cf6b883589c87ef9ce24d36e318">regina::Tangle::crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:gaf1c92cf6b883589c87ef9ce24d36e318"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this tangle.  <a href="group__link.html#gaf1c92cf6b883589c87ef9ce24d36e318">More...</a><br /></td></tr>
<tr class="separator:gaf1c92cf6b883589c87ef9ce24d36e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b27ae3e97e8ffb165914d67e235296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac0b27ae3e97e8ffb165914d67e235296">regina::Tangle::begin</a> (int string) const</td></tr>
<tr class="memdesc:gac0b27ae3e97e8ffb165914d67e235296"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing closest to the beginning of the given string.  <a href="group__link.html#gac0b27ae3e97e8ffb165914d67e235296">More...</a><br /></td></tr>
<tr class="separator:gac0b27ae3e97e8ffb165914d67e235296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85986cfd37035eaaa0f49a1bd4abb459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga85986cfd37035eaaa0f49a1bd4abb459">regina::Tangle::end</a> (int string) const</td></tr>
<tr class="memdesc:ga85986cfd37035eaaa0f49a1bd4abb459"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing closest to the end of the given string.  <a href="group__link.html#ga85986cfd37035eaaa0f49a1bd4abb459">More...</a><br /></td></tr>
<tr class="separator:ga85986cfd37035eaaa0f49a1bd4abb459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013419d2ffd00eb93d85b4aaae713209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga013419d2ffd00eb93d85b4aaae713209">regina::Tangle::translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:ga013419d2ffd00eb93d85b4aaae713209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference for some other tangle into the corresponding strand reference for this tangle.  <a href="group__link.html#ga013419d2ffd00eb93d85b4aaae713209">More...</a><br /></td></tr>
<tr class="separator:ga013419d2ffd00eb93d85b4aaae713209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Editing</h2></td></tr>
<tr class="memitem:gac361e059c41aa061a0b0130b02cc2ccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gac361e059c41aa061a0b0130b02cc2ccb">regina::Tangle::swapContents</a> (<a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other)</td></tr>
<tr class="memdesc:gac361e059c41aa061a0b0130b02cc2ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given tangle.  <a href="group__link.html#gac361e059c41aa061a0b0130b02cc2ccb">More...</a><br /></td></tr>
<tr class="separator:gac361e059c41aa061a0b0130b02cc2ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf4a4fa65f6b91f929833f55fb2c06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga1bf4a4fa65f6b91f929833f55fb2c06f">regina::Tangle::twist</a> (int sign=1)</td></tr>
<tr class="memdesc:ga1bf4a4fa65f6b91f929833f55fb2c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a twist to the right-hand end of this tangle.  <a href="group__link.html#ga1bf4a4fa65f6b91f929833f55fb2c06f">More...</a><br /></td></tr>
<tr class="separator:ga1bf4a4fa65f6b91f929833f55fb2c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfe8878a670f2cea6734f336cb9d563f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gabfe8878a670f2cea6734f336cb9d563f">regina::Tangle::turn</a> (int direction=1)</td></tr>
<tr class="memdesc:gabfe8878a670f2cea6734f336cb9d563f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this tangle by 90 degrees.  <a href="group__link.html#gabfe8878a670f2cea6734f336cb9d563f">More...</a><br /></td></tr>
<tr class="separator:gabfe8878a670f2cea6734f336cb9d563f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efe758c243da18417406ed5bff41ee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga0efe758c243da18417406ed5bff41ee8">regina::Tangle::changeAll</a> ()</td></tr>
<tr class="memdesc:ga0efe758c243da18417406ed5bff41ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the tangle.  <a href="group__link.html#ga0efe758c243da18417406ed5bff41ee8">More...</a><br /></td></tr>
<tr class="separator:ga0efe758c243da18417406ed5bff41ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75456efb18f88399f5e800fb52c3d70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga75456efb18f88399f5e800fb52c3d70d">regina::Tangle::r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#gaf1c92cf6b883589c87ef9ce24d36e318">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga75456efb18f88399f5e800fb52c3d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to remove a crossing.  <a href="group__link.html#ga75456efb18f88399f5e800fb52c3d70d">More...</a><br /></td></tr>
<tr class="separator:ga75456efb18f88399f5e800fb52c3d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80f087595912ee502a37bf2c7980c33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf80f087595912ee502a37bf2c7980c33">regina::Tangle::r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaf80f087595912ee502a37bf2c7980c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="group__link.html#gaf80f087595912ee502a37bf2c7980c33">More...</a><br /></td></tr>
<tr class="separator:gaf80f087595912ee502a37bf2c7980c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa71c2b2601ab277179d44e8f62176d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaaa71c2b2601ab277179d44e8f62176d8">regina::Tangle::r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="group__link.html#gaf1c92cf6b883589c87ef9ce24d36e318">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaaa71c2b2601ab277179d44e8f62176d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="group__link.html#gaaa71c2b2601ab277179d44e8f62176d8">More...</a><br /></td></tr>
<tr class="separator:gaaa71c2b2601ab277179d44e8f62176d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82854b84b334083c2dd8ccd5e23ee41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaa82854b84b334083c2dd8ccd5e23ee41">regina::Tangle::simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:gaa82854b84b334083c2dd8ccd5e23ee41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the tangle monotonically to some local minimum number of crossings.  <a href="group__link.html#gaa82854b84b334083c2dd8ccd5e23ee41">More...</a><br /></td></tr>
<tr class="separator:gaa82854b84b334083c2dd8ccd5e23ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Algebra on Tangles</h2></td></tr>
<tr class="memitem:ga13c803002ef7a372a10340c644bc3f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga13c803002ef7a372a10340c644bc3f96">regina::Tangle::add</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other)</td></tr>
<tr class="memdesc:ga13c803002ef7a372a10340c644bc3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given tangle to the right-hand side of this tangle.  <a href="group__link.html#ga13c803002ef7a372a10340c644bc3f96">More...</a><br /></td></tr>
<tr class="separator:ga13c803002ef7a372a10340c644bc3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d50a1e2852266c95d1e87618af48b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gaf8d50a1e2852266c95d1e87618af48b5">regina::Tangle::negate</a> ()</td></tr>
<tr class="memdesc:gaf8d50a1e2852266c95d1e87618af48b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects this tangle through the diagonal axis running from the top-left to bottom-right corners of the diagram.  <a href="group__link.html#gaf8d50a1e2852266c95d1e87618af48b5">More...</a><br /></td></tr>
<tr class="separator:gaf8d50a1e2852266c95d1e87618af48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f70fc6613c99a6647d1a229ec36804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga64f70fc6613c99a6647d1a229ec36804">regina::Tangle::box</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;topLeft, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;topRight, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;bottomLeft, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;bottomRight)</td></tr>
<tr class="memdesc:ga64f70fc6613c99a6647d1a229ec36804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encloses this tangle with the four given tangles in a box configuration.  <a href="group__link.html#ga64f70fc6613c99a6647d1a229ec36804">More...</a><br /></td></tr>
<tr class="separator:ga64f70fc6613c99a6647d1a229ec36804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494c34d7a968a65694c9a9c6b09c8357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga494c34d7a968a65694c9a9c6b09c8357">regina::Tangle::numClosure</a> () const</td></tr>
<tr class="memdesc:ga494c34d7a968a65694c9a9c6b09c8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the numerator closure of this tangle.  <a href="group__link.html#ga494c34d7a968a65694c9a9c6b09c8357">More...</a><br /></td></tr>
<tr class="separator:ga494c34d7a968a65694c9a9c6b09c8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002a4457f62aa27863893eb3e7988a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga002a4457f62aa27863893eb3e7988a73">regina::Tangle::denClosure</a> () const</td></tr>
<tr class="memdesc:ga002a4457f62aa27863893eb3e7988a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the denominator closure of this tangle.  <a href="group__link.html#ga002a4457f62aa27863893eb3e7988a73">More...</a><br /></td></tr>
<tr class="separator:ga002a4457f62aa27863893eb3e7988a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Output</h2></td></tr>
<tr class="memitem:gafc9da0489723b099bd15bf729a401933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafc9da0489723b099bd15bf729a401933">regina::Tangle::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gafc9da0489723b099bd15bf729a401933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this tangle to the given output stream.  <a href="group__link.html#gafc9da0489723b099bd15bf729a401933">More...</a><br /></td></tr>
<tr class="separator:gafc9da0489723b099bd15bf729a401933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafb3ede468c74cd0a7280f8a5d0fcc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gafafb3ede468c74cd0a7280f8a5d0fcc2">regina::Tangle::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gafafb3ede468c74cd0a7280f8a5d0fcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this tangle to the given output stream.  <a href="group__link.html#gafafb3ede468c74cd0a7280f8a5d0fcc2">More...</a><br /></td></tr>
<tr class="separator:gafafb3ede468c74cd0a7280f8a5d0fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exporting Tangles</h2></td></tr>
<tr class="memitem:ga4901f74db4ad01ee8987de6b2e87191e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga4901f74db4ad01ee8987de6b2e87191e">regina::Tangle::orientedGauss</a> () const</td></tr>
<tr class="memdesc:ga4901f74db4ad01ee8987de6b2e87191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an oriented Gauss code for this tangle.  <a href="group__link.html#ga4901f74db4ad01ee8987de6b2e87191e">More...</a><br /></td></tr>
<tr class="separator:ga4901f74db4ad01ee8987de6b2e87191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ad9e44a76bac84d1e314a2f60a6fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#ga57ad9e44a76bac84d1e314a2f60a6fe8">regina::Tangle::orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga57ad9e44a76bac84d1e314a2f60a6fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this tangle to the given output stream.  <a href="group__link.html#ga57ad9e44a76bac84d1e314a2f60a6fe8">More...</a><br /></td></tr>
<tr class="separator:ga57ad9e44a76bac84d1e314a2f60a6fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Tangles</h2></td></tr>
<tr class="memitem:gad9fb20a28b2e91fb8c5a72de9f2e0e19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19">regina::Tangle::fromOrientedGauss</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:gad9fb20a28b2e91fb8c5a72de9f2e0e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tangle from an oriented Gauss code.  <a href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19">More...</a><br /></td></tr>
<tr class="separator:gad9fb20a28b2e91fb8c5a72de9f2e0e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f4811a5e2ff79985524443c1d4a00c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga12f4811a5e2ff79985524443c1d4a00c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__link.html#ga12f4811a5e2ff79985524443c1d4a00c">regina::Tangle::fromOrientedGauss</a> (Iterator <a class="el" href="group__link.html#gac0b27ae3e97e8ffb165914d67e235296">begin</a>, Iterator <a class="el" href="group__link.html#ga85986cfd37035eaaa0f49a1bd4abb459">end</a>)</td></tr>
<tr class="memdesc:ga12f4811a5e2ff79985524443c1d4a00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tangle from an oriented Gauss code.  <a href="group__link.html#ga12f4811a5e2ff79985524443c1d4a00c">More...</a><br /></td></tr>
<tr class="separator:ga12f4811a5e2ff79985524443c1d4a00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7044a8efc72b68373c889bdcf16dac47"><td class="memItemLeft" align="right" valign="top"><a id="ga7044a8efc72b68373c889bdcf16dac47"></a>
<a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Tangle::operator=</b> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;)=delete</td></tr>
<tr class="separator:ga7044a8efc72b68373c889bdcf16dac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Knots and links in the 3-sphere. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8395d3783317af74eb30822e96e96c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8395d3783317af74eb30822e96e96c0f">&#9670;&nbsp;</a></span>Use</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* regina::ModelLinkGraph::Use) (<a class="el" href="classregina_1_1Link.html">Link</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a knot or link. </p>
<p>Such routines are used to process links that are found when running <a class="el" href="group__link.html#gab69f103fedadb0c410b518fb76b3092a" title="TODO: Document.">generateMinimalLinks()</a>.</p>
<p>The first parameter passed should be a link, which <em>must</em> be deallocated by this routine. The second parameter may contain arbitrary data as passed to <a class="el" href="group__link.html#gab69f103fedadb0c410b518fb76b3092a" title="TODO: Document.">generateMinimalLinks()</a>.</p>
<p>Note that the first parameter might be <code>null</code> to signal that link generation has finished.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaaa7f28a9c71fb2f3db92141046be967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa7f28a9c71fb2f3db92141046be967a">&#9670;&nbsp;</a></span>Framing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">regina::Framing</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates one of the standard framings of a knot or link. </p>
<p>Here a <em>framing</em> refers to a choice of normal vector field along the knot or link. Equivalently, a framing refers to a choice of longitude on the torus bounding each component of the link. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f"></a>FRAMING_SEIFERT&#160;</td><td class="fielddoc"><p>Indicates the <em>Seifert framing</em>, which is defined algebraically and is independent of the knot/link projection. </p>
<p>For each component of the link, draw a Seifert surface (i.e., an orientable surface embedded in the 3-sphere that is bounded by the corresponding knot). The Seifert framing is the vector field that points into the corresponding surface.</p>
<p>Equivalently, for each component of the link, the Seifert framing chooses the unique longitude for the corresponding knot that is trivial in the homology of the knot complement. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa7f28a9c71fb2f3db92141046be967aa2b478480a97632583fa3885399d523d6"></a>FRAMING_BLACKBOARD&#160;</td><td class="fielddoc"><p>Indicates the <em>blackboard framing</em>, which is specific to the knot/link projection. </p>
<p>For the blackboard framing, the normal vector field stays within the projection plane. Equivalently, the blackboard framing chooses longitudes whose projections do not intersect the original link diagram. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga13c803002ef7a372a10340c644bc3f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c803002ef7a372a10340c644bc3f96">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given tangle to the right-hand side of this tangle. </p>
<p>In Conway's notation, if this tangle is <em>t</em>, then this routine converts this into (<em>t</em> + <em>other</em>).</p>
<p>Specifically: this routine will attach the two right-hand endpoints of this tangle to the two left-hand endpoints of a copy of <em>other</em>.</p>
<p>This tangle will be changed directly. The tangle <em>other</em> (passed as the argumet) will be left unchanged.</p>
<p>It is allowed to pass this tangle as <em>other</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>It is not the case that both this and <em>other</em> are vertical tangles (which would cause the addition to create a closed link component).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tangle to add to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03e6d0ff69021f7f55372c76b2bdd169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03e6d0ff69021f7f55372c76b2bdd169">&#9670;&nbsp;</a></span>adj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp; regina::ModelLinkGraphNode::adj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the arc at the other end of the given graph edge that exits this node. </p>
<p>Let <em>e</em> be the undirected edge of the underlying model graph that corresponds to the given outgoing arc from this node. Recall that there are two <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects corresponding to <em>e</em>, one for each of its endpoints. One of these will be <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>this</code>, <em>which</em>); this routine returns the <em>other</em> object, which is the <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> describing the other endpoint of <em>e</em>.</p>
<p>Note that for a node <em>n</em>, calling <code>n.adj(i)</code> is equivalent to calling <code>n.arc(i).traverse()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>an integer in the range 0 to 3 inclusive, indicating which of the four arcs exiting this node we should examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the other end of the same undirected edge of the underlying model graph. </dd></dl>

</div>
</div>
<a id="ga6d86898f011332b930717e67d4039ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d86898f011332b930717e67d4039ae8">&#9670;&nbsp;</a></span>arc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::ModelLinkGraphArc::arc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph. </p>
<p>For each node of a model graph, the four arcs exiting that node are numbered 0,1,2,3 in a clockwise order.</p>
<dl class="section return"><dt>Returns</dt><dd>an integer between 0 and 3 inclusive indicating one of the four arcs exiting <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a>. </dd></dl>

</div>
</div>
<a id="gaa163e8cc7ee1408f4e0ff6fa05b7e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa163e8cc7ee1408f4e0ff6fa05b7e0e8">&#9670;&nbsp;</a></span>arc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphNode::arc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the four arcs of the graph that exit this node. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>this</code>, <em>which</em>).</p>
<p>The four arcs exiting this node are numbered 0,1,2,3 in a clockwise order around the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>an integer in the range 0 to 3 inclusive, indicating which of the four arcs exiting this node we should return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding arc exiting this node. </dd></dl>

</div>
</div>
<a id="ga82a2312e1d7864ab49cc946915d5ebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82a2312e1d7864ab49cc946915d5ebe3">&#9670;&nbsp;</a></span>arc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp; regina::ModelLinkGraphCells::arc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given arc along the boundary of the given 2-cell. </p>
<p>For each cell, the arcs along the boundary are given in order as you walk anticlockwise around the cell (so the cell is on the left of each arc as you walk around the cell boundary).</p>
<p>Each arc is described in the form of an <em>outgoing</em> arc from some node of the underlying graph (so if the return <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> is <em>a</em> then this describes an outgoing arc from a.node()). It follows that, if the underlying graph has <em>n</em> nodes, then each of the 4<em>n</em> possible <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> values appears exactly once as <code>arc(cell, which)</code> for some integers <em>cell</em> and <em>which</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>indicates which cell to query; this must be between 0 and <a class="el" href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad" title="Returns the number of 2-cells in this cellular decomposition.">countCells()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which arc along the boundary of the corresponding cell to return; this must be between 0 and <code>size(cell)-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested arc on the boundary of the given 2-cell. </dd></dl>

</div>
</div>
<a id="gaf94ee19ea10ed9f63d07bbdc5b142f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94ee19ea10ed9f63d07bbdc5b142f37">&#9670;&nbsp;</a></span>ArcIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ArcIterator::ArcIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a singular iterator. </p>

</div>
</div>
<a id="gaedb3a876813a8b76ba1ec2e41ba0a44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb3a876813a8b76ba1ec2e41ba0a44f">&#9670;&nbsp;</a></span>ArcIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ArcIterator::ArcIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="gadc176bc09bcad39131c5ad885c777176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc176bc09bcad39131c5ad885c777176">&#9670;&nbsp;</a></span>ArcIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ArcIterator::ArcIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>crossing</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upper</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the arc exiting the given strand of the given crossing of the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the underlying knot/link. </td></tr>
    <tr><td class="paramname">crossing</td><td>the index of the given crossing. This must be between 0 and link.size()-1 for a deferencable iterator, or must be exactly link.size() for a past-the-end iterator. </td></tr>
    <tr><td class="paramname">upper</td><td><code>true</code> or <code>false</code> according to whether the iterator should point to the arc exiting the given crossing from the upper or lower strand respectively. For a past-the-end iterator, this should always be <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0b27ae3e97e8ffb165914d67e235296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b27ae3e97e8ffb165914d67e235296">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing closest to the beginning of the given string. </p>
<p>Recall from the class notes that string 0 is always attached to the top-left endpoint. Recall also that strings are oriented from left-to-right for a horizontal or diagonal tangle, and from top-to-bottom for a vertical tangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>indicates which of the two strings in this tangle to query; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing closest to the beginning of the given string, or a null reference if the given string contains no crossings. </dd></dl>

</div>
</div>
<a id="gab3787c8a65c5c1ad581eef64111c4cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3787c8a65c5c1ad581eef64111c4cee">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> * regina::ModelLinkGraphCells::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the beginning of an iterator range for walking around the boundary of the given 2-cell. </p>
<p>Suppose that the <em>i</em>th cell is a <em>k</em>-gon. Then the iterator range described by <code>begin(i)</code> and <code>end(i)</code> will iterate through the <em>k</em> arcs along the boundary of the <em>i</em>th cell in the same order as described by <a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3" title="Returns the given arc along the boundary of the given 2-cell.">arc()</a>; that is, walking anticlockwise around the cell boundary with the cell to the left of each arc.</p>
<p>Dereferencing the <em>j</em>th iterator in this range gives the same result as calling <code>arc(cell, j)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3" title="Returns the given arc along the boundary of the given 2-cell.">arc()</a> and <a class="el" href="group__link.html#ga4043ef70f0d094c3ff49d8422e581529" title="Returns the number of arcs aloung the boundary of the given 2-cell.">size()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning of an iterator range for the boundary of the given cell. </dd></dl>

</div>
</div>
<a id="ga02bc9bfa99080688eccf0158348a4ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bc9bfa99080688eccf0158348a4ad1">&#9670;&nbsp;</a></span>borromean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::borromean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a six-crossing diagram of the Borromean rings. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga64f70fc6613c99a6647d1a229ec36804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f70fc6613c99a6647d1a229ec36804">&#9670;&nbsp;</a></span>box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>topLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>topRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>bottomLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>bottomRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encloses this tangle with the four given tangles in a box configuration. </p>
<p>The five tangles will be connected as shown, with this tangle in the centre: </p><pre class="fragment"> \     /
  O---O
 / \ / \
 |  O  |
 \ / \ /
  O---O
 /     \
</pre><p>The top-left corner of the argument <em>topLeft</em> will become the top-left corner of the resulting tangle, and so on for the other three corners.</p>
<p>This tangle will be changed directly. The other four other tangles (passed as arguments) will be left unchanged.</p>
<p>You may use the same tangle for multiple arguments, and you may even use this tangle for one or more arguments.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Every string in all five tangles (the four arguments and this) has at least one crossing. </dd>
<dd>
None of the five tangles (the four arguments and this) have types that would result in a closed link component after this operation is performed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topLeft</td><td>the tangle to connect to the top-left corner of this. </td></tr>
    <tr><td class="paramname">topRight</td><td>the tangle to connect to the top-right corner of this. </td></tr>
    <tr><td class="paramname">bottomLeft</td><td>the tangle to connect to the bottom-left corner of this. </td></tr>
    <tr><td class="paramname">bottomRight</td><td>the tangle to connect to the bottom-right corner of this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd286c4c3d5512b2d9de53e57a57055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd286c4c3d5512b2d9de53e57a57055a">&#9670;&nbsp;</a></span>bracket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::bracket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Kauffman bracket polynomial of this link diagram. </p>
<p>Note that the bracket polynomial is not an invariant - it is preserved under Reidemeister moves II and III, but not I.</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> should be called again; this will be instantaneous if the bracket polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the requested invariant has already been computed, then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently less than the number of bits in a long, which on a typical machine is 64). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bracket polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="ga805821d3da773fdd9a69f75916dbd90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805821d3da773fdd9a69f75916dbd90e">&#9670;&nbsp;</a></span>brief()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::brief </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this link in Regina's own brief format. </p>
<p>This format is concise, but contains enough information to reconstruct the link.</p>
<p>This format cannot (yet) be used to read links back into Regina, and so it is not good for external storage, or for passing links between different programs (or even different instances of Regina). It was originally designed for use with the test suite, where it was used to ensure that links with being created and/or manipulated correctly.</p>
<p>The output will contains the following elements, separated by single spaces:</p>
<ul>
<li>a sequence of signs (<code>+</code> or <code>-</code>), concatenated together, giving the signs of the crossings in order from crossing 0 to crossing <a class="el" href="group__link.html#ga32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1;</li>
<li>a description of each component of the link, in order from component 0 to component <a class="el" href="group__link.html#gab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1. Each component will be written in the form <code>( a b c ... )</code>, indicating the crossings that are encountered as we follow the component in the forward direction from its starting strand. Each element <em>a</em>, <em>b</em>, <em>c</em> and so on will be written in the format used by the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> class: either <code>^n</code> when passing over crossing <em>n</em>, or <code>_n</code> when passing under crossing <em>n</em>.</li>
</ul>
<p>For example, the Whitehead link as returned by <a class="el" href="group__link.html#ga66bec3dc74f7d1fc1ef2ce9cde5508ae" title="Returns a five-crossing diagram of the Whitehead link.">ExampleLink.whitehead()</a> will give the following brief output:</p>
<pre class="fragment">--++- ( ^0 _1 ^4 _3 ^2 _4 ) ( _0 ^1 _2 ^3 )
</pre><p>As a special case, if the link contains no crossings, then the format will not begin with a space; instead it will simply be a sequence of the form <code>( ) ( ) ... ( )</code>.</p>
<p>The string will not end in a newline.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link in Regina's brief format. </dd></dl>

</div>
</div>
<a id="ga0ea18d468f2ce15e590d049f3ba781eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea18d468f2ce15e590d049f3ba781eb">&#9670;&nbsp;</a></span>broken() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::XMLLinkCrossingsReader::broken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the XML element has been found to contain invalid data. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if invalid data has been found. </dd></dl>

</div>
</div>
<a id="ga8af92b9b8db289f8cfb7242ff6b0dabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af92b9b8db289f8cfb7242ff6b0dabb">&#9670;&nbsp;</a></span>broken() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::XMLLinkConnectionsReader::broken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the XML element has been found to contain invalid data. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if invalid data has been found. </dd></dl>

</div>
</div>
<a id="ga86291976a435ec8528337b14bd8d346e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86291976a435ec8528337b14bd8d346e">&#9670;&nbsp;</a></span>broken() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::XMLLinkComponentsReader::broken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the XML element has been found to contain invalid data. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if invalid data has been found. </dd></dl>

</div>
</div>
<a id="gab574d5b77af06b93deaf6de05d67b671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab574d5b77af06b93deaf6de05d67b671">&#9670;&nbsp;</a></span>canonicalPlantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::canonicalPlantri </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReflection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text representation of this graph in the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression. </p>
<p>This routine is similar to <a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in the ASCII text format used by plantri.">plantri()</a>, but with two significant differences:</p>
<ul>
<li>This routine does not preserve the labelling of nodes and the order of arcs around each node. Instead it reorders the nodes and arcs so that any two relabellings of the "same" planar embedding will produce the same <a class="el" href="group__link.html#gab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in the plantri ASCII format, using a canonical relabellin...">canonicalPlantri()</a> output. By "same" we allow for relabelling and isotopy (sliding the graph around the sphere); if the argument <em>useReflection</em> is <code>true</code> then we allow for reflection also.</li>
<li>If the argument <em>tight</em> is <code>true</code>, then this routine uses an abbreviated output format. The resulting compression is only trivial (it reduces the length by roughly 40%), but the resulting string is still human-parseable (though with a little more effort required). This compression will simply remove the commas, and for each node it will suppress the destination of the first arc (since this can be deduced from the canonical labelling).</li>
</ul>
<p>Regardless of whether <em>tight</em> is <code>true</code> or <code>false</code>, the resulting string can be parsed by <a class="el" href="group__link.html#ga7d7937582581020a947d0e728e950a8f" title="Builds a graph from a line of plantri output.">fromPlantri()</a> to reconstruct the original graph. Note however that, due to the canonical labelling, the resulting graph might be a relabelling of the original (and might even be a reflection of the original, if <em>useReflection</em> was passed as <code>true</code>).</p>
<p>See <a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in the ASCII text format used by plantri.">plantri()</a> for further details on the ASCII format itself.</p>
<p>The running time for this routine is quadratic in the size of the graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected. </dd>
<dd>
This graph has between 1 and 26 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useReflection</td><td><code>true</code> if a graph and its reflection should be considered the same (i.e., produce the same canonical output), or <code>false</code> if they should be considered different. Of course, if a graph is symmetric under reflection then the graph and its reflection will produce the same canonical output regardless of this parameter. </td></tr>
    <tr><td class="paramname">tight</td><td><code>false</code> if the usual <em>plantri</em> ASCII format should be used (as described by <a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="group__link.html#ga7d7937582581020a947d0e728e950a8f" title="Builds a graph from a line of plantri output.">fromPlantri()</a>), or <code>true</code> if the abbreviated format should be used as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optionally compressed <em>plantri</em> ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="ga8303a75b3d50bd5d568d9d12c86ab3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8303a75b3d50bd5d568d9d12c86ab3df">&#9670;&nbsp;</a></span>cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraphCells::cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 2-cell that lies to the left of the given arc. </p>
<p>Specifically, this function returns the number of the cell that lies to the left of the given arc as you walk along it away from <code>arc.node()</code>.</p>
<p>For any arc <em>a</em>, calling <code>arc(cell(a), cellPos(a))</code> will return the same arc <em>a</em> again.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>the given arc of the underlying graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the cell that lies to the left of the given arc; this will be an integer between 0 and <code><a class="el" href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad" title="Returns the number of 2-cells in this cellular decomposition.">countCells()</a>-1</code> inclusive. </dd></dl>

</div>
</div>
<a id="gafb166a8ee596ad4178d706e6fadb4283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb166a8ee596ad4178d706e6fadb4283">&#9670;&nbsp;</a></span>cellPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraphCells::cellPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> where the given arc appears along the boundary of the 2-cell to its left. </p>
<p>Consider the cell <em>c</em> to the left of the given arc as you follow the arc away from <code>arc.node()</code>. The routine <a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3" title="Returns the given arc along the boundary of the given 2-cell.">arc()</a> can be used to enumerate the sequence of arcs along the boundary of this cell <em>c</em>, in order as you walk anticlockwise around the cell boundary. The purpose of this routine is to identify <em>where</em> in this sequence the given arc occurs.</p>
<p>For any arc <em>a</em>, calling <code>arc(cell(a), cellPos(a))</code> will return the same arc <em>a</em> again.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>the given arc of the underlying graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the given arc on the boundary of the cell to its left; this will be an integer between 0 and <code>size(cell(arc))-1</code> inclusive. </dd></dl>

</div>
</div>
<a id="ga4b314d226abfebfe9ba4ed26bfaf6b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b314d226abfebfe9ba4ed26bfaf6b23">&#9670;&nbsp;</a></span>cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp; regina::ModelLinkGraph::cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the cellular decomposition of the sphere that is induced by this graph. </p>
<p>This cellular decomposition will only be computed on demand. This means that the first call to this function will take linear time (as the decomposition is computed), but subsequent calls will be constant time (since the decomposition is cached).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the induced cellular decomposition of the sphere. </dd></dl>

</div>
</div>
<a id="ga0d386bea941e436ae6548aa8663a005b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d386bea941e436ae6548aa8663a005b">&#9670;&nbsp;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of the given crossing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0546dc7f2bde7b63c31f3e057a8c04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0546dc7f2bde7b63c31f3e057a8c04db">&#9670;&nbsp;</a></span>changeAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::changeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the diagram. </p>
<p>This operation corresponds to reflecting the link diagram through the plane on which it is drawn. </p>

</div>
</div>
<a id="ga0efe758c243da18417406ed5bff41ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0efe758c243da18417406ed5bff41ee8">&#9670;&nbsp;</a></span>changeAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::changeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the tangle. </p>
<p>This operation corresponds to reflecting the tangle through the plane on which the diagram is drawn. </p>

</div>
</div>
<a id="ga2b02a5c5a55f174df916132eb1b74d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b02a5c5a55f174df916132eb1b74d54">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::Link::complement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an ideal triangulation of the complement of this link in the 3-sphere. </p>
<p>The triangulation will have one ideal vertex for each link component. Assuming you pass <em>simplify</em> as <code>true</code> (the default), there will typically be no internal vertices; however, this is not guaranteed.</p>
<p>Initially, the triangulation will be oriented. In particular, each tetrahedron will be oriented according to a right-hand rule: the thumb of the right hand points from vertices 0 to 1, and the fingers curl around to point from vertices 2 to 3.</p>
<p>What happens next depends upon the argument <em>simplify:</em> </p>
<ul>
<li>If you pass <em>simplify</em> as <code>true</code>, then Regina will attempt to simplify the triangulation to as few tetrahedra as possible. As a result, the orientation described above will be lost.</li>
<li>If you pass <em>simplify</em> as <code>false</code>, then Regina will leave the triangulation as is. This will preserve the orientation, but it means that the triangulation will contain both ideal and internal vertices (and, in general, far more tetrahedra than are necessary).</li>
</ul>
<p>The triangulation will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if and only if the triangulation of the complement should be simplified (thereby losing information about the orientation), as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complement of this link, as a newly-created object. </dd></dl>

</div>
</div>
<a id="ga3425a2a6994fbc87baf890e9b429ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3425a2a6994fbc87baf890e9b429ef6f">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a strand in the given component of this link. </p>
<p>For each component of the link, this routine returns a "starting strand". You can traverse the entire component by beginning at this starting strand and repeatedly incrementing it through a routine such as <a class="el" href="group__link.html#gaca9f21431143267c5f4d7142f604559f" title="Moves this reference forward along the direction of the link until it reaches the next crossing.">StrandRef::operator++</a> or <a class="el" href="group__link.html#ga0f3ce62d47997b0e320735c7e32fd54a" title="Returns the crossing reference that comes immediately after this when walking forward along the direc...">StrandRef::next()</a>.</p>
<p>If a component has no crossings (which means it must be a separate unknot component), then this routine will return a null reference (i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">StrandRef::crossing()</a> will return <code>null</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="group__link.html#gab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a "starting strand" for traversing the component at the given index, or a null reference if the requested component has no crossings. </dd></dl>

</div>
</div>
<a id="ga28355f40d08c312c5f2e6cceb68bc1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28355f40d08c312c5f2e6cceb68bc1b4">&#9670;&nbsp;</a></span>composeWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::composeWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the composition of this with the given link. </p>
<p>This link will be altered directly.</p>
<p>Specifically, the first component of the given link will be grafted into the first component of this link, in a way that preserves orientations and crossing signs. If the given link has any additional components, then they will be copied into this link directly with no modification.</p>
<p>This routine may be expanded in future versions of Regina to allow more flexibility (in particular, to allow you to choose which components of the two links to graft together, and/or at which strands to graft them).</p>
<p>If either link is empty (i.e., contains no components at all), then the result will simply be a clone of the other link (with no composition operation performed).</p>
<p>It is allowed to pass this link as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link with which this should be composed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc783777826fcf17af86d21a343118d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc783777826fcf17af86d21a343118d5">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram. </p>
<p>Here "the underlying 4-valent graph" means the multigraph whose vertices are the crossings and whose edges are the arcs between crossings. In particular</p>
<ul>
<li>two crossings may be connected even if they involve entirely different components of the link;</li>
<li>if two crossings are not connected then the underlying link must be splittable (though this need not happen in the other direction: one can have a diagram of a splittable link in which all crossings are connected with each other).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow (linear time), since it may need to perform a depth-first search through the graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first of the two crossings to examine. </td></tr>
    <tr><td class="paramname">b</td><td>the second of the two crossings to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two given crossings are connected. </dd></dl>

</div>
</div>
<a id="ga60e8c2042f255636ca66d4dc491a8e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e8c2042f255636ca66d4dc491a8e6f">&#9670;&nbsp;</a></span>conway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::conway </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 11-crossing Conway knot. </p>
<p>This is the reflection of <em>K11n34</em> in the Knot Atlas, and is a mutant of the Kinoshita-Terasaka knot.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga4c0d54a49192f9ee3a54c486e0bd42ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0d54a49192f9ee3a54c486e0bd42ad">&#9670;&nbsp;</a></span>countCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraphCells::countCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of 2-cells in this cellular decomposition. </p>
<p>If <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> returns <code>false</code> (i.e., the underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is either empty or does not describe a planar embedding), then this routine will return 0 instead. Note that this routine <em>cannot</em> be used to test for connectivity, which is a non-negotiable precondition required by the class constructor.</p>
<p>Note that, if <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> returns <code>true</code>, then <a class="el" href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad" title="Returns the number of 2-cells in this cellular decomposition.">countCells()</a> will always return <em>n</em>+2 where <em>n</em> is the number of nodes in the underlying graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a strictly positive number of 2-cells if <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> returns <code>true</code>, or 0 if <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="gab4fb9a0932d786dfca9eef2f6e45ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4fb9a0932d786dfca9eef2f6e45ec60">&#9670;&nbsp;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of components in this link. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="gabe5e3028eaf7ee815e082000d17154ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe5e3028eaf7ee815e082000d17154ad">&#9670;&nbsp;</a></span>crossing() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::StrandRef::crossing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The crossing that this reference points to. </p>
<p>The information returned by <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> and <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f" title="Indicates whether this reference points to the upper or lower strand of the relevant crossing.">strand()</a> together pinpoint exactly which strand of the link this reference points to.</p>
<dl class="section return"><dt>Returns</dt><dd>the crossing, or <code>null</code> if this is a null reference. </dd></dl>

</div>
</div>
<a id="ga2b47712bc419c15659a634ae6ea97b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b47712bc419c15659a634ae6ea97b91">&#9670;&nbsp;</a></span>crossing() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Link::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this link. </p>
<p>For a link with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="group__link.html#ga32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="gaf1c92cf6b883589c87ef9ce24d36e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c92cf6b883589c87ef9ce24d36e318">&#9670;&nbsp;</a></span>crossing() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Tangle::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this tangle. </p>
<p>For a tangle with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="group__link.html#ga3e255ebc40070d5c43f14fb3848f2827" title="Returns the number of crossings in this tangle.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="ga2b74ac162fbb0142f35b992b922d24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b74ac162fbb0142f35b992b922d24e2">&#9670;&nbsp;</a></span>CrossingIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CrossingIterator::CrossingIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a singular iterator. </p>

</div>
</div>
<a id="ga5091d6e2cdacfbddb80999db666ea836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5091d6e2cdacfbddb80999db666ea836">&#9670;&nbsp;</a></span>CrossingIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CrossingIterator::CrossingIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="gadcdc1488025337c77393e1d92ba27430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcdc1488025337c77393e1d92ba27430">&#9670;&nbsp;</a></span>CrossingIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CrossingIterator::CrossingIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given crossing of the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the underlying knot/link. </td></tr>
    <tr><td class="paramname">index</td><td>the index of the crossing to point to. This must be between 0 and link.size()-1 for a deferencable iterator, or must be exactly link.size() for a past-the-end iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga002a4457f62aa27863893eb3e7988a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002a4457f62aa27863893eb3e7988a73">&#9670;&nbsp;</a></span>denClosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a>* regina::Tangle::denClosure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the denominator closure of this tangle. </p>
<p>This is the link created by joining the two left endpoints of this tangle, and also joining the two right endpoints.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created link that is the denominator closure of this tangle. </dd></dl>

</div>
</div>
<a id="ga34359ae0aeda30012164cd24256dd29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34359ae0aeda30012164cd24256dd29d">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga7394cd7aa9cb8d14cb4d7d39f9d96478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7394cd7aa9cb8d14cb4d7d39f9d96478">&#9670;&nbsp;</a></span>dt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this knot using Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, Regina supports two variants of this notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will return the empty string if the alphabetical variant is requested.</li>
</ul>
<p>In general, Dowker-Thistlethwaite notation does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same sequence of integers; moreover, for composite knots, the same Dowker-Thistlethwaite notation can describe inequivalent knots (even when allowing for reflections). If you need notation that specifies the knot uniquely, consider using the oriented Gauss code instead, as output by <a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>.</p>
<p>Currently Regina only supports Dowker-Thistlethwaite notation for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Dowker-Thistlethwaite notation for this knot diagram. This routine will return the empty string if this link has zero or multiple components, or if <em>alpha</em> is <code>true</code> and the knot has more than 26 crossings. </dd></dl>

</div>
</div>
<a id="ga6e48b3891b1ec16cff1190f781e3ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e48b3891b1ec16cff1190f781e3ebd0">&#9670;&nbsp;</a></span>dt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this knot to the given output stream using Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, Regina supports two variants of this notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will output nothing at all if the alphabetical variant is requested.</li>
</ul>
<p>In general, Dowker-Thistlethwaite notation does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same sequence of integers; moreover, for composite knots, the same Dowker-Thistlethwaite notation can describe inequivalent knots (even when allowing for reflections). If you need notation that specifies the knot uniquely, consider using the oriented Gauss code instead, as output by <a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>.</p>
<p>Currently Regina only supports Dowker-Thistlethwaite notation for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available in Python. Instead, Python users can use the variant <a class="el" href="group__link.html#ga7394cd7aa9cb8d14cb4d7d39f9d96478" title="Outputs this knot using Dowker-Thistlethwaite notation.">dt()</a>, which takes just the optional <em>alpha</em> argument and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga718258433d47de780e6905585a00bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga718258433d47de780e6905585a00bd29">&#9670;&nbsp;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used to reconstruct this link. </p>
<p>This code will use the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> constructor that takes a series of hard-coded C++11 initialiser lists.</p>
<p>The main purpose of this routine is to generate these hard-coded initialiser lists, which can be tedious and error-prone to write by hand.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="ga85986cfd37035eaaa0f49a1bd4abb459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85986cfd37035eaaa0f49a1bd4abb459">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing closest to the end of the given string. </p>
<p>Recall from the class notes that string 0 is always attached to the top-left endpoint. Recall also that strings are oriented from left-to-right for a horizontal or diagonal tangle, and from top-to-bottom for a vertical tangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>indicates which of the two strings in this tangle to query; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing closest to the end of the given string, or a null reference if the given string contains no crossings. </dd></dl>

</div>
</div>
<a id="ga4f82d487196daed2ecec41f69477b4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f82d487196daed2ecec41f69477b4b0">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> * regina::ModelLinkGraphCells::end </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the end of an iterator range for walking around the boundary of the given 2-cell. </p>
<p>As is usual for iterator ranges, this is a past-the-end value (i.e., this iterator cannot be dereferenced).</p>
<p>Suppose that the <em>i</em>th cell is a <em>k</em>-gon. Then the iterator range described by <code>begin(i)</code> and <code>end(i)</code> will iterate through the <em>k</em> arcs along the boundary of the <em>i</em>th cell in the same order as described by <a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3" title="Returns the given arc along the boundary of the given 2-cell.">arc()</a>; that is, walking anticlockwise around the cell boundary with the cell to the left of each arc.</p>
<p>Dereferencing the <em>j</em>th iterator in this range gives the same result as calling <code>arc(cell, j)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="group__link.html#ga82a2312e1d7864ab49cc946915d5ebe3" title="Returns the given arc along the boundary of the given 2-cell.">arc()</a> and <a class="el" href="group__link.html#ga4043ef70f0d094c3ff49d8422e581529" title="Returns the number of arcs aloung the boundary of the given 2-cell.">size()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the end of an iterator range for the boundary of the given cell. </dd></dl>

</div>
</div>
<a id="ga9eceeda8be99a7fbb24789da450b24ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eceeda8be99a7fbb24789da450b24ba">&#9670;&nbsp;</a></span>endContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLLinkReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__link.html#ga7fcee2a779b45b242dca26dff055a569" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gaf3b2f1c9aeb8ab01472b71e1c8d089be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b2f1c9aeb8ab01472b71e1c8d089be">&#9670;&nbsp;</a></span>figureEight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::figureEight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a four-crossing diagram of the figure eight knot. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf992e58cf4215079603fb3d4d5c6bd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf992e58cf4215079603fb3d4d5c6bd62">&#9670;&nbsp;</a></span>findFlype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&gt; regina::ModelLinkGraph::findFlype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: Flype is between arc&ndash; and arc, i.e., over the region defined by cell(arc). </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> (null, null) iff <a class="el" href="group__link.html#ga910f24b1a0045104f092fedb2f16dcd6" title="TODO: Document.">flype()</a> will refuse to work with this. Otherwise returns (left outgoing arc, right outgoing arc).</p>
<p>Conditions that explicitly return <code>null:</code> </p>
<ul>
<li>The upper and lower cells are the same.</li>
<li>The common cell is the inside cell at from.node().</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected and TODO: valid.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a C++ pair, this routine returns a Python tuple containing two <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects. </dd></dl>

</div>
</div>
<a id="gac56039020f86dbf85efbdb9b96075280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac56039020f86dbf85efbdb9b96075280">&#9670;&nbsp;</a></span>flype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> * regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: Document. </p>

</div>
</div>
<a id="ga910f24b1a0045104f092fedb2f16dcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga910f24b1a0045104f092fedb2f16dcd6">&#9670;&nbsp;</a></span>flype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>* regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: Document. </p>
<pre class="fragment">       Cell A

    __   __
      \ /                    ----&gt; left
       X         Cell B
    __/ \__from              ----&gt; right

       Cell C
</pre><p>Conditions that explicitly return 0:</p>
<ul>
<li>Neither left nor right ends at from.node().</li>
<li>The upper and lower bounding cells are distinct,</li>
<li>The cell between left and right is not the inside cell where the flype begins from from.node(). </li>
</ul>

</div>
</div>
<a id="ga080cbca4af7eadcab1aea5aec456d2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080cbca4af7eadcab1aea5aec456d2ba">&#9670;&nbsp;</a></span>fromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>crossingSigns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Args &gt;...&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from hard-coded information about its crossings and components. </p>
<p>This constructor takes a series of C++11 initialiser lists (each a list of integers), which makes it useful for creating hard-coded examples directly in C++ code.</p>
<p>For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The lists that you must pass to this routine are as follows:</p>
<ul>
<li>The first list contains the signs of crossings 1, ..., <em>n</em> in order, where each sign is either +1 or -1.</li>
<li>Each subsequent list describes a single component of the link. The list identifies which crossings you visit in order when traversing the component; a positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>. Empty lists are allowed (these denote separate unknot components).</li>
<li>If a component has no crossings, then you should pass the list { 0 }, not the empty list. (This is because the C++ compiler cannot deduce the type of an empty list.)</li>
</ul>
<p>Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the left-hand trefoil and the Hopf link as follows:</p>
<div class="fragment"><div class="line">trefoil = <a class="code" href="group__link.html#ga080cbca4af7eadcab1aea5aec456d2ba">Link::fromData</a>({ -1, -1, -1 }, { 1, -2, 3, -1, 2, -3 });</div>
<div class="line">hopf = <a class="code" href="group__link.html#ga080cbca4af7eadcab1aea5aec456d2ba">Link::fromData</a>({ +1, +1 }, { 1, -2 }, { -1, 2 });</div>
<div class="ttc" id="agroup__link_html_ga080cbca4af7eadcab1aea5aec456d2ba"><div class="ttname"><a href="group__link.html#ga080cbca4af7eadcab1aea5aec456d2ba">regina::Link::fromData</a></div><div class="ttdeci">static Link * fromData(std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... components)</div><div class="ttdoc">Creates a new link from hard-coded information about its crossings and components.</div></div>
</div><!-- fragment --><p>The topology of the link is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you have an existing link that you would like to hard-code, the routine <a class="el" href="group__link.html#ga718258433d47de780e6905585a00bd29" title="Returns C++ code that can be used to reconstruct this link.">dumpConstruction()</a> will output C++ code that can reconstruct the link by calling this constructor.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossingSigns</td><td>a list containing the signs of the crossings; each sign must be either +1 or -1. </td></tr>
    <tr><td class="paramname">components</td><td>one list for each link component that describes the crossings that are visited along that component, as described in the detailed notes above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga34d838c4975af256e7c8b40842d370dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d838c4975af256e7c8b40842d370dc">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, the input may be in one of two forms:</p>
<ul>
<li><em>numerical</em> Dowker-Thistlethwaite notation, which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li><em>alphabetical</em> Dowker-Thistlethwaite notation, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used to describe knots with 26 crossings or fewer.</li>
</ul>
<p>Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing Dowker-Thistlethwaite notation is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm. These issues are resolved using oriented Gauss codes, as used by the routines <a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a> and <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>.</p>
<p>As an example, you can construct the trefoil using either of the following variants of Dowker-Thistlethwaite notation:</p>
<pre class="fragment">4 6 2
bca
</pre><p>There are two variants of this routine. This variant takes a single string, which is either the alphabetical notation (in which any whitespace within the string will be ignored), or the numerical notation where the integers have been combined together and separated by whitespace. The other variant of this routine is only for the numerical variant, and it takes a sequence of integers defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>either the alphabetical or numerical Dowker-Thistlethwaite notation for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga7b8e6024307a59835117f2910eac5a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8e6024307a59835117f2910eac5a99">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an integer sequence using the numerical variant of Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, this must be a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p>See <a class="el" href="group__link.html#ga34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>Regina can also reconstruct a knot from <em>alphabetical</em> Dowker-Thistlethwaite notation, but for this you must use the other version of this routine that takes a single string argument.</p>
<p>For numerical Dowker-Thistlethwaite notation, there are two variants of this routine that you can use. The other variant (<a class="el" href="group__link.html#ga34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the integers have been combined together and separated by whitespace. This variant takes a sequence of integers, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces an integer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="gad24bafb845a51157cecfdbdd66f6f30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad24bafb845a51157cecfdbdd66f6f30c">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing a Gauss code is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm. These issues are resolved using <em>oriented</em> Gauss codes, as used by the routines <a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a> and <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>.</p>
<p>The Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers, representing strands that pass over and under crossings respectively. Regina's implementation of Gauss codes comes with the following restrictions:</p>
<ul>
<li>It can only be used for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot have be arbitrary natural numbers).</li>
</ul>
<p>The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. Whenever you pass crossing <em>k</em>, write the integer <code><em>k</em></code> if you pass over the crossing, or <code>-<em>k</em></code> if you pass under the crossing.</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p>There are two variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variant takes a sequence of integers, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a classical Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga552933848162ccc80e1ee0b4399f9866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552933848162ccc80e1ee0b4399f9866">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code. </p>
<p>See <a class="el" href="group__link.html#gad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>There are two variants of this routine. The other variant (<a class="el" href="group__link.html#gad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the integers have been combined together and separated by whitespace. This variant takes a sequence of integers, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces an integer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for a classical Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for a classical Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="gac206f9e3697de7472ee9ec151c106df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac206f9e3697de7472ee9ec151c106df0">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a link from the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>In this format, a link is described by a sequence of integers separated by whitespace - the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of this sequence is also allowed.</p>
<p>We assume that there are <em>n</em> crossings in the link, labelled arbitrarily as 0, 1, ..., <em>n</em>-1. The sequence of integers must contain, in order:</p>
<ul>
<li>the number of components in the link;</li>
<li>for each link component:<ul>
<li>the number of times you pass a crossing when traversing the component (i.e., the length of the component);</li>
<li>two integers for each crossing that you pass in such a traversal: the crossing label, and then either +1 or -1 according to whether you pass over or under the crossing respectively;</li>
</ul>
</li>
<li>for each crossing:<ul>
<li>the crossing label;</li>
<li>the sign of the crossing (either +1 or -1).</li>
</ul>
</li>
</ul>
<p>As an example, you could construct the left-hand trefoil using the following sequence:</p>
<pre class="fragment">1
6   0 1   1 -1   2 1   0 -1   1 1   2 -1
0 -1   1 -1   2 -1
</pre><p>Another example is the Hopf link, which you could construct using the following sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p>The topology of the knot is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<p>There are two variants of this routine. This variant takes a single string containing the integer sequence. The other variant takes an input stream, from which the sequence of integers will be read.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can export an existing link in Jenkins' format by calling the routine <a class="el" href="group__link.html#ga194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link as a string using the text representation described by Bob Jenkins.">jenkins()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string containing a sequence of integers separated by whitespace that describes a link, as detailed above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="gae02aeec8648b7d97f889a3cb231ae226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02aeec8648b7d97f889a3cb231ae226">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a link from the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>See <a class="el" href="group__link.html#gac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins(const std::string&amp;)</a> for a detailed description of this format.</p>
<p>There are two variants of this routine. The other variant takes a single string containing the integer sequence. This variant takes an input stream, from which the sequence of integers will be read.</p>
<p>In this variant, this routine reads the integers that describe the link and then leaves the remainder of the input stream untouched (in particular, the stream may contain additional material, which can be read by the user after this routine has finished).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that begins with a sequence of integers separated by whitespace that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga2fa67a9f8642ba7682baeade317ded53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa67a9f8642ba7682baeade317ded53">&#9670;&nbsp;</a></span>fromKnotSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromKnotSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a knot diagram from its signature. </p>
<p>See <a class="el" href="group__link.html#ga96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> for more information on knot signatures.</p>
<p>The knot that is returned will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<p>Calling <a class="el" href="group__link.html#ga96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> followed by <a class="el" href="group__link.html#ga2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> is not guaranteed to produce an <em>identical</em> knot diagram to the original, but it is guaranteed to produce one that is related by relabelling, rotation, and optionally (according to the arguments that were passed to <a class="el" href="group__link.html#ga96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a>) reflection and/or reversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the knot diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated knot if the reconstruction was successful, or <code>null</code> if the given string was not a valid knot signature. </dd></dl>

</div>
</div>
<a id="ga7f23add46272acfdedb83be5fd5f7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f23add46272acfdedb83be5fd5f7d3c">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing a Gauss code is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</p>
<p>Andreeva et al. describe a variant of the Gauss code that includes extra information about the embedding, so as to remove both the ambiguity and the complexity in the conversion procedure. With this extra information, the knot and its orientation are well-defined (but the diagram is still ambiguous - see the note below).</p>
<p>This "oriented" format is described at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>. Regina adds two additional restrictions on this format:</p>
<ul>
<li>It can only be used for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot have be arbitrary natural numbers).</li>
</ul>
<p>The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. At every crossing that you pass, write a token of the form <code>+&lt;<em>k</em></code>, <code>-&lt;<em>k</em></code>, <code>+&gt;<em>k</em></code> or <code>-&gt;<em>k</em></code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right.</li>
</ul>
</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the left-hand trefoil using the following code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p>The topology of the knot is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<p>There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an "oriented" Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="gad9fb20a28b2e91fb8c5a72de9f2e0e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9fb20a28b2e91fb8c5a72de9f2e0e19">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a>* regina::Tangle::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tangle from an oriented Gauss code. </p>
<p>Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p>The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Write one of the tokens <code>-</code>, <code></code>| or <code>x</code> to represent a horizontal, vertical or diagonal tangle respectively.</li>
<li>Start at the top-left endpoint and follow this string to its other endpoint. At every crossing that you pass, write a token of the form <code>+&lt;<em>k</em></code>, <code>-&lt;<em>k</em></code>, <code>+&gt;<em>k</em></code> or <code>-&gt;<em>k</em></code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right.</li>
</ul>
</li>
<li>Write the token <code>_</code> to indicate that the first string has finished.</li>
<li>Start at the beginning of the other string (for horizontal or diagonal tangles, this is the bottom-left endpoint, and for vertical tangles this is the top-right endpoint). As before, follow this string to its other endpoint, writing a token of the form <code>+&lt;<em>k</em></code>, <code>-&lt;<em>k</em></code>, <code>+&gt;<em>k</em></code> or <code>-&gt;<em>k</em></code> at every crossing that you pass.</li>
</ul>
<p>Be aware that, once the tangle has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Tangle.html" title="Represents a 2-tangle in the 3-ball.">Tangle</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the rational tangle -3/4 using the following code:</p>
<pre class="fragment">| -&lt;1 +&gt;2 -&lt;3 +&gt;4 _ -&lt;5 -&lt;4 +&gt;3 -&lt;2 +&gt;1 +&gt;5
</pre><p>There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for the viability of the diagram (i.e., whether the given crossings with the given signs actually produce a tangle of the given type with the correct endpoints). Of course non-viable inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an oriented Gauss code for a tangle, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tangle, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga2d9ccfdf468272086377417cf8a3df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d9ccfdf468272086377417cf8a3df27">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code. </p>
<p>This format is described by Andreeva et al. at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>, though Regina limits its use to knots (i.e., one-component links), and insists that the crossings be numbered 1, ..., <em>n</em> (not arbitrary natural numbers).</p>
<p>See <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>There are two variants of this routine. The other variant (<a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the tokens have been combined together and separated by whitespace. This variant takes a sequence of tokens, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces either a C-style string (which can be cast to <code>const char*</code>) or a C++-style string (which can be cast to <code>const std::string&amp;</code>).</dd>
<dd>
The tokens in the input sequence do not contain any whitespace.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an "oriented" Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an "oriented" Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga12f4811a5e2ff79985524443c1d4a00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f4811a5e2ff79985524443c1d4a00c">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a>* regina::Tangle::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tangle from an oriented Gauss code. </p>
<p>Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p>See <a class="el" href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>There are two variants of this routine. The other variant (<a class="el" href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the tokens have been combined together and separated by whitespace. This variant takes a sequence of tokens, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces either a C-style string (which can be cast to <code>const char*</code>) or a C++-style string (which can be cast to <code>const std::string&amp;</code>).</dd>
<dd>
The tokens in the input sequence do not contain any whitespace.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for the viability of the diagram (i.e., whether the given crossings with the given signs actually produce a tangle of the given type with the correct endpoints). Of course non-viable inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an oriented Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an oriented Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tangle, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ga7d7937582581020a947d0e728e950a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7937582581020a947d0e728e950a8f">&#9670;&nbsp;</a></span>fromPlantri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>* regina::ModelLinkGraph::fromPlantri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>plantri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a graph from a line of <em>plantri</em> output. </p>
<p>The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine converts a piece of output from <em>plantri</em> into a <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> object that Regina can work with directly.</p>
<p>The output from <em>plantri</em> must be in ASCII format, and must be the dual graph of a simple quadrangulation of the sphere. The corresponding flags that must be passed to <em>plantri</em> to obtain such output are <code>-adq</code> (although you will may wish to pass additional flags to expand or restrict the classes of graphs that <em>plantri</em> builds).</p>
<p>When run with these flags, <em>plantri</em> produces output in the following form:</p>
<pre class="fragment">6 bbcd,adca,abee,affb,cffc,deed
6 bcdd,aeec,abfd,acfa,bffb,ceed
6 bcde,affc,abfd,acee,addf,becb
</pre><p>Each line consists of an integer (the number of nodes in the graph), followed by a comma-separated sequence of alphabetical strings that encode the edges leaving each node.</p>
<p>This function <em>only</em> takes the comma-separated sequence of alphabetical strings. So, for example, to construct the graph correpsonding to the second line of output above, you could call:</p>
<div class="fragment"><div class="line"><a class="code" href="group__link.html#ga7d7937582581020a947d0e728e950a8f">fromPlantri</a>(<span class="stringliteral">&quot;bcdd,aeec,abfd,acfa,bffb,ceed&quot;</span>);</div>
<div class="ttc" id="agroup__link_html_ga7d7937582581020a947d0e728e950a8f"><div class="ttname"><a href="group__link.html#ga7d7937582581020a947d0e728e950a8f">regina::ModelLinkGraph::fromPlantri</a></div><div class="ttdeci">static ModelLinkGraph * fromPlantri(const std::string &amp;plantri)</div><div class="ttdoc">Builds a graph from a line of plantri output.</div></div>
</div><!-- fragment --><p>Regina can only recognise graphs in this format with up to 26 nodes. If the graph contains more than 27 nodes then the <em>plantri</em> output will contain punctuation, Regina will not be able to parse it, and this function will return <code>null</code>.</p>
<p>The given string does not <em>need</em> to be come from the program <em>plantri</em> itself. Whereas <em>plantri</em> always outputs graphs with a particular canonical labelling, this function can accept an arbitrary ordering of nodes and arcs - in particular, it can accept the string <code>g.plantri()</code> for any graph <em>g</em> that meets the preconditions below. Nevertheless, the graph must still meet these preconditions, since otherwise the <em>plantri</em> format might not be enough to uniquely reconstruct the graph and its planar embedding.</p>
<p>This routine can also interpret the "tight" format that is output by the member function <a class="el" href="group__link.html#gab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in the plantri ASCII format, using a canonical relabellin...">canonicalPlantri()</a> (even though such output would certainly <em>not</em> be produced by the program <em>plantri</em>).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the graph. Of course <em>plantri</em> does not output non-planar graphs, but if a user constructs one by hand and passes it to this routine then the resulting behaviour is undefined.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph being described is connected. </dd>
<dd>
The graph being described has between 1 and 26 nodes inclusive. </dd>
<dd>
The graph being described is dual to a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plantri</td><td>a string containing the comma-separated sequence of alphabetical strings output by <em>plantri</em>, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed graph, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="gac05b65401950517d86be107268233b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05b65401950517d86be107268233b09">&#9670;&nbsp;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::gauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a classical Gauss code for this knot. </p>
<p>In general, the classical Gauss code does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same Gauss code; moreover, for composite knots, the Gauss code can describe inequivalent knots (even when allowing for reflections). If you need a code that specifies the knot uniquely, consider using the <em>oriented</em> Gauss code instead.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code for this knot, or the empty string if this is a link with zero or multiple components. </dd></dl>

</div>
</div>
<a id="ga5d8c0d2be78044e3fc4108e092d086a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8c0d2be78044e3fc4108e092d086a5">&#9670;&nbsp;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::gauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a classical Gauss code for this knot to the given output stream. </p>
<p>In general, the classical Gauss code does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same Gauss code; moreover, for composite knots, the Gauss code can describe inequivalent knots (even when allowing for reflections). If you need a code that specifies the knot uniquely, consider using the <em>oriented</em> Gauss code instead.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available in Python. Instead, Python users can use the variant <a class="el" href="group__link.html#gac05b65401950517d86be107268233b09" title="Outputs a classical Gauss code for this knot.">gauss()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab69f103fedadb0c410b518fb76b3092a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab69f103fedadb0c410b518fb76b3092a">&#9670;&nbsp;</a></span>generateMinimalLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::generateMinimalLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__link.html#ga8395d3783317af74eb30822e96e96c0f">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: Document. </p>
<p>Only aims for minimal, ignores reflections.</p>
<p>Node n will become crossing n.</p>
<p>Arc (0,0) will always be forwards, and crossing 0 will always be positive.</p>
<p>TODO: PRE: Knot, not link.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>

</div>
</div>
<a id="ga41f1ec5a0b7dc12df56ed35cf6db2b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41f1ec5a0b7dc12df56ed35cf6db2b1a">&#9670;&nbsp;</a></span>gordian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::gordian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> Haken's Gordian unknot, a 141-crossing diagram of the unknot that is difficult to untangle. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga9d02023afe905c817dd1df95a563b74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d02023afe905c817dd1df95a563b74e">&#9670;&nbsp;</a></span>gst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::gst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 48-crossing potential counterexample to the slice-ribbon conjecture, as described by Gompf, Scharlemann and Thompson. </p>
<p>Specifically, this knot is Figure 2 from their paper "Fibered knots and potential counterexamples to the property
2R and slice-ribbon conjectures", arXiv:1103.1601.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gacb6293eb60b5477b5cac84363c43286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6293eb60b5477b5cac84363c43286a">&#9670;&nbsp;</a></span>hasReducingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasReducingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether this knot has a pass move that will reduce the number of crossings. </p>
<p>Currently this routine is only available for knots, not multiple-component links.</p>
<p>A <em>pass</em> move involves taking a section of the knot that involves only over-crossings (or only under-crossings), and then lifting that section above (or beneath respectively) the diagram and placing it back again in a different location. In particular, this routine searches for a different location that will involve fewer crossings than the original location.</p>
<p>This routine does not actually <em>perform</em> the pass move; it simply determines whether one exists.</p>
<p>The running time is cubic in the number of crossings.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link is actually a knot (i.e., it contains exactly one component).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is a pass move that reduces the number of crossings. </dd></dl>

</div>
</div>
<a id="gaa3cdae63725a633c32868737d44cb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3cdae63725a633c32868737d44cb7c7">&#9670;&nbsp;</a></span>homfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp; regina::Link::homfly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>This routine is simply an alias for <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. See the documentation for <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> for further details.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyVarX, Link::homflyVarY)</code>.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="ga173ba85ab3f36b64631816894ff4809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173ba85ab3f36b64631816894ff4809f">&#9670;&nbsp;</a></span>homflyAZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::homflyAZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>This variant of the HOMFLY polynomial is described (amongst other places) in G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>alpha</em> and <em>z</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p>If the HOMFLY polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="ga8165708806e390b41b33655bdbb40af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8165708806e390b41b33655bdbb40af5">&#9670;&nbsp;</a></span>homflyLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::homflyLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>. </p>
<p>This variant of the HOMFLY polynomial is described (amongst other places) in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>l</em> and <em>m</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p>If the HOMFLY polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="ga90aa8d21c77cac76343313154f74e22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90aa8d21c77cac76343313154f74e22b">&#9670;&nbsp;</a></span>hopf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::hopf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-crossing diagram of the Hopf link. </p>
<p>This is the variant in which both crossings are positive.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gadd61713b60a4536a94461656e93298b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd61713b60a4536a94461656e93298b2">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::StrandRef::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An integer that uniquely identifies this strand within the link. </p>
<p>This integer will be 2<em>c</em>+<em>s</em>, where <em>c</em> is the index of the crossing, and <em>s</em> is 0 or 1 for the lower or upper strand respectively.</p>
<p>If this is a null reference, then <a class="el" href="group__link.html#gadd61713b60a4536a94461656e93298b2" title="An integer that uniquely identifies this strand within the link.">id()</a> will return -1.</p>
<p>A strand can be restored from its ID by calling <a class="el" href="group__link.html#ga411f710b2b7a73d1999cf0ea44cc7a4a" title="Returns the strand in the link with the given integer ID.">Link::strand()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the unique ID of this strand within the link. </dd></dl>

</div>
</div>
<a id="ga8447c727708dce6bf6bd536da00a379c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8447c727708dce6bf6bd536da00a379c">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::Crossing::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this crossing within the overall link. </p>
<p>If the link contains <em>n</em> crossings, then the index will be a number between 0 and <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>The index of this crossing might change if other crossings are added or removed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of this crossing. </dd></dl>

</div>
</div>
<a id="gacd0f916b26fe60795d1b78c59c3dfa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd0f916b26fe60795d1b78c59c3dfa96">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::ModelLinkGraphNode::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this node within the overall graph. </p>
<p>If the graph contains <em>n</em> nodes, then the index will be a number between 0 and <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>The index of this node might change if other nodes are added or removed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of this node. </dd></dl>

</div>
</div>
<a id="ga72ef883dde5628b57a152221f190861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ef883dde5628b57a152221f190861e">&#9670;&nbsp;</a></span>initialChars() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLLinkConnectionsReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga48568fbbfc05a92588119ad31434fc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48568fbbfc05a92588119ad31434fc51">&#9670;&nbsp;</a></span>initialChars() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLLinkComponentsReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gadafc83aa265e5959176acd2883b6d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadafc83aa265e5959176acd2883b6d547">&#9670;&nbsp;</a></span>initialChars() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLLinkCrossingsReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gaa11d6d31315c7b000cb653901a0a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11d6d31315c7b000cb653901a0a711c">&#9670;&nbsp;</a></span>insertTorusLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertTorusLink </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new (<em>p</em>, <em>q</em>) torus link into this link. </p>
<p>The parameters <em>p</em> and <em>q</em> must be non-negative, but they do not need to be coprime.</p>
<p>All of the crossings in the new torus link component(s) will be positive if the argument <em>positive</em> is <code>true</code>, or negative otherwise.</p>
<p>The new crossings and components will be inserted at the end of the respective lists in this link.</p>
<p>If your aim is to create a new torus link (as opposed to inserting one into an existing link), it is simpler to just call <a class="el" href="group__link.html#ga96f37e1919de78b6d37143a4e5b634c4" title="Returns the (p,q) torus link.">ExampleLink::torus()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the first parameter of the new torus link; this must be non-negative. </td></tr>
    <tr><td class="paramname">q</td><td>the second parameter of the new torus link; this must also be non-negative. </td></tr>
    <tr><td class="paramname">positive</td><td><code>true</code> if the crossings in the new torus link should be positive, or <code>false</code> if they should be negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fc961ba707da75f2b71d3585c994cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc961ba707da75f2b71d3585c994cc9">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the link diagram using fast and greedy heuristics. </p>
<p>Specifically, this routine tries combinations of Reidemeister moves with the aim of reducing the number of crossings.</p>
<p>Currently this routine uses <a class="el" href="group__link.html#ga3adf6c87c3dc80de018d659e686b48ef" title="Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number o...">simplifyToLocalMinimum()</a> in combination with random type III Reidemeister moves.</p>
<p>Although <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> often works well, it can sometimes get stuck. If this link is a knot (i.e., it has precisely one component), then in such cases you can try the more powerful but (much) slower <a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> instead.</p>
<p>This routine will never reflect or reverse the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same link may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina. </dd></dl>

</div>
</div>
<a id="gaa36d8a4b0c964cafb2cbac86b0d5e272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa36d8a4b0c964cafb2cbac86b0d5e272">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Link::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="ga821a3c1d060bdc5f3807ee1a64064775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga821a3c1d060bdc5f3807ee1a64064775">&#9670;&nbsp;</a></span>isAlternating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isAlternating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this knot diagram is alternating. </p>
<p>Note that this routine cannot tell whether the <em>knot</em> is alternating (i.e., whether there <em>exists</em> an alternating diagram). Instead, it simply returns whether this specific diagram is alternating or not.</p>
<p>The empty diagram and any zero-crossing unknot components will be considered alternating.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an alternating diagram, or <code>false</code> if this is a non-alternating diagram. </dd></dl>

</div>
</div>
<a id="gad12a7e69700971494486e299bbc39c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12a7e69700971494486e299bbc39c57">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link is empty. </p>
<p>An empty link is one with no components at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link is empty. </dd></dl>

</div>
</div>
<a id="ga0ae15c42db3ab8321a751201bfeaef19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae15c42db3ab8321a751201bfeaef19">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraphCells::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is already known to be connected. </p>
<p>As described in the class notes, this class can only work with non-empty connected graphs where the corresponding <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> object also describes a planar embedding.</p>
<p>The constructor for this class requires you to pass a graph that is already known to be connected. However, <em>assuming</em> the graph is connected, the constructor then tests for the remaining conditions. This routine returns the results of these tests: if the underlying graph is empty or does not describe a planar embedding, then this routine will return <code>false</code>.</p>
<p>This routine is constant time, since the necessary work will have already been completed by the class constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Most of the routines in this class require <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> to return <code>true</code>. Essentially, if <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a> returns <code>false</code>, you should not attempt to query the details of the cell decomposition. See the preconditions on individual routines for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> describes a planar embedding of a non-empty graph. </dd></dl>

</div>
</div>
<a id="ga194f84f5ad2fb28ab1a0da34aa69d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga194f84f5ad2fb28ab1a0da34aa69d8a8">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link as a string using the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>Jenkins' text format uses a sequence of integers separated by whitespace. For details of this format, see the documentation for <a class="el" href="group__link.html#gac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The string will contain multiple lines, and will end in a newline.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' text format. </dd></dl>

</div>
</div>
<a id="ga6509ca2eaf2920bf4dc7e69eb5f5f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6509ca2eaf2920bf4dc7e69eb5f5f499">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link to the given output stream using the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>Jenkins' text format uses a sequence of integers separated by whitespace. For details of this format, see the documentation from <a class="el" href="group__link.html#gac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins()</a>, which imports links using this format.</p>
<p>The output will contain multiple lines, and will end in a newline.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available in Python. Instead, Python users can use the variant <a class="el" href="group__link.html#ga194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link as a string using the text representation described by Bob Jenkins.">jenkins()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad74edbfadfccb443efa6a6f1852ab9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad74edbfadfccb443efa6a6f1852ab9b5">&#9670;&nbsp;</a></span>jones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::jones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Jones polynomial of this link, but with all exponents doubled. </p>
<p>By "all exponents doubled", we are indicating that the Jones polynomial is in fact a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>. So, for example:</p>
<ul>
<li>The right-hand trefoil has Jones polynomial <code>1/t + 1/t^3 - 1/t^4</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>x^-2 + x^-6 - x^-8</code>.</li>
<li>The Hopf link has Jones polynomial <code>-1/sqrt(x) - 1/sqrt(x^5)</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>-x^-1 - x^-5</code>.</li>
</ul>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Regina follows the conventions described in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994. If you wish to convert to the conventions used by Khovanov as described in Dror Bar-Natan, "On Khovanov's categorifiction of the Jones
polynomial", Algebraic &amp; Geometric Topology 2 (2002), 337-370, you can simply take the polynomial returned by this routine and replace the variable <em>x</em> (which represents the square root of <em>t</em>) with the expression -<em>q</em>.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> should be called again; this will be instantaneous if the Jones polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the requested invariant has already been computed, then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently less than the number of bits in a long, which on a typical machine is 64). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jones polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="gaa80ba478d0d57d52d71f9fe25b3ce86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80ba478d0d57d52d71f9fe25b3ce86a">&#9670;&nbsp;</a></span>jump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::StrandRef::jump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Jumps to the other strand at the same crossing. </p>
<p>This reference will be changed directly. The crossing will remain the same, but the strand will switch from lower to upper or vice versa. </p>

</div>
</div>
<a id="ga7b61afa22793bb6a289a4d4d192b6357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b61afa22793bb6a289a4d4d192b6357">&#9670;&nbsp;</a></span>kinoshitaTerasaka()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::kinoshitaTerasaka </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 11-crossing Kinoshita-Terasaka knot. </p>
<p>This is the reflection of <em>K11n42</em> in the Knot Atlas, and is a mutant of the Conway knot. It has trivial Alexander polynomial.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga96e305e2721276730a7783e84bc0bc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e305e2721276730a7783e84bc0bc04">&#9670;&nbsp;</a></span>knotSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::knotSig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReflection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReversal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <em>signature</em> for this knot diagram. </p>
<p>A <em>signature</em> is a compact text representation of a knot diagram that unique determines the knot up to relabelling, rotation, and (optionally) reflection and/or reversal.</p>
<p>Currently signatures are only implemented for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will return the empty string.</p>
<p>The signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of crossings.</p>
<p>The routine <a class="el" href="group__link.html#ga2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> can be used to recover a knot from its signature. The resulting knot might not be identical to the original, but it will be related by zero or more applications of relabelling, rotation, and/or (according to the arguments) reflection and reversal.</p>
<p>This routine runs in quadratic time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useReflection</td><td><code>true</code> if the reflection of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reflection). </td></tr>
    <tr><td class="paramname">useReversal</td><td><code>true</code> if the reversal of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reversal). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature for this knot diagram. </dd></dl>

</div>
</div>
<a id="ga6a432a4f3024e537920770c0eb60d2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a432a4f3024e537920770c0eb60d2e2">&#9670;&nbsp;</a></span>knowsBracket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsBracket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="group__link.html#gafd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="gae7100ef279d1f9a4ed7a739e76d5c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7100ef279d1f9a4ed7a739e76d5c5d4">&#9670;&nbsp;</a></span>knowsHomfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsHomfly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>, <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> will all be very fast (simply returning the precalculated values).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="ga13a2acb5efa330841a89e91d28e5d64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13a2acb5efa330841a89e91d28e5d64a">&#9670;&nbsp;</a></span>knowsJones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsJones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Jones polynomial of this link diagram already known? See <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="gaff4dc84be20b66314534c2dcc7466324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff4dc84be20b66314534c2dcc7466324">&#9670;&nbsp;</a></span>Link() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty link. </p>
<p>This will have zero components. </p>

</div>
</div>
<a id="ga359918be5fb86081d1122cc2f2260a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga359918be5fb86081d1122cc2f2260a5f">&#9670;&nbsp;</a></span>Link() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link. </p>
<p>The packet tree structure and packet label are <em>not</em> copied.</p>
<p>This will clone any computed properties (such as Jones polynomial and so on) of the given link also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaef22c9d7355dc008bfc0282c1f99e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef22c9d7355dc008bfc0282c1f99e4b">&#9670;&nbsp;</a></span>Link() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given link (such as Jones polynomial and so on), or <code>false</code> if the new link should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b233fb32a24925705b616b5dc23b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b233fb32a24925705b616b5dc23b219">&#9670;&nbsp;</a></span>Link() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a link. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>knot signatures, as used by <a class="el" href="group__link.html#ga2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a>;</li>
<li>oriented Gauss codes, as used by <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>;</li>
<li>classical Gauss codes, as used by <a class="el" href="group__link.html#gad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss()</a>;</li>
<li>numeric or alphabetical Dowker-Thistlethwaite strings, as used by <a class="el" href="group__link.html#ga34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT()</a>.</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<p>Regina will also set the packet label accordingly.</p>
<p>If Regina cannot interpret the given string, this will be left as the empty link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a knot or link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6b717f99561f93f6b09118cdf770803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b717f99561f93f6b09118cdf770803">&#9670;&nbsp;</a></span>Link() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unknots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the unlink with the given number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unknots</td><td>the number of (unknotted) components in the new unlink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8cdacd0939c10de129dcf4c9a72f209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cdacd0939c10de129dcf4c9a72f209c">&#9670;&nbsp;</a></span>linking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::linking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the linking number of this link. </p>
<p>This is an invariant of the link, computed as half the sum of the signs of all crossings that involve different link components.</p>
<p>The algorithm to compute linking number is linear time.</p>
<dl class="section return"><dt>Returns</dt><dd>the linking number. </dd></dl>

</div>
</div>
<a id="gaaf2b9f54049a9d814d6a6abe87de3edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2b9f54049a9d814d6a6abe87de3edc">&#9670;&nbsp;</a></span>lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::lower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running under this crossing. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>this</code>, 0).</p>
<p>Note that <a class="el" href="group__link.html#gaaf2b9f54049a9d814d6a6abe87de3edc" title="Returns a reference to the strand running under this crossing.">lower()</a> and <a class="el" href="group__link.html#ga5ed3d9d76a5e1554c595c79f5d5bce61" title="Returns a reference to the strand running under this crossing.">under()</a> are synonyms.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the lower strand for this crossing. </dd></dl>

</div>
</div>
<a id="gabe9bd8331a5d5de03e0ce35c0ee669a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe9bd8331a5d5de03e0ce35c0ee669a0">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty graph. </p>

</div>
</div>
<a id="ga9a8824307f9623abdf194742ad462890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8824307f9623abdf194742ad462890">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the graph to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade3b1a19d19db7d06137445bb45a620c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade3b1a19d19db7d06137445bb45a620c">&#9670;&nbsp;</a></span>ModelLinkGraphArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraphArc::ModelLinkGraphArc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this to a null arc. </p>
<p>The pointer returned by <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> will be <code>null</code>, and the integer returned by <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a> will be 0. </p>

</div>
</div>
<a id="ga008baf2f96fc05cc1f124c97c3190cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga008baf2f96fc05cc1f124c97c3190cc1">&#9670;&nbsp;</a></span>ModelLinkGraphArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraphArc::ModelLinkGraphArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="gad784951ef84c86486a0eba995f22e1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad784951ef84c86486a0eba995f22e1f4">&#9670;&nbsp;</a></span>ModelLinkGraphArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraphArc::ModelLinkGraphArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this to the given arc exiting the given node of a model graph. </p>
<p>Recall that the four arcs exiting a node are numbered 0,1,2,3 in a clockwise order around the node.</p>
<p>The given node may be <code>null</code>, in which case this will become a null arc. If you are creating a null arc, then it is highly recommended that you pass <em>arc</em> as 0 also, so that comparison tests treat this null reference as equal to a null reference created by the zero-argument constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node of the model graph that this arc exits. </td></tr>
    <tr><td class="paramname">arc</td><td>an integer in the range 0 to 3 inclusive, indicating which of the four arcs exiting <em>node</em> this represents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3fd877d1650803abb8a00127a43f921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3fd877d1650803abb8a00127a43f921">&#9670;&nbsp;</a></span>monster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::monster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the monster unknot, a 10-crossing diagram of the unknot that is difficult to untangle. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf8d50a1e2852266c95d1e87618af48b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d50a1e2852266c95d1e87618af48b5">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reflects this tangle through the diagonal axis running from the top-left to bottom-right corners of the diagram. </p>
<p>In Conway's notation, this negates the tangle. </p>

</div>
</div>
<a id="ga0f3ce62d47997b0e320735c7e32fd54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3ce62d47997b0e320735c7e32fd54a">&#9670;&nbsp;</a></span>next() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::StrandRef::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that comes immediately after this when walking forward along the direction of the link. </p>
<p>Equivalently, this routine returns the reference that would be obtained by calling the increment (++) operator (but, unlike the increment operator, this routine does not actually change the current reference).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing reference that follows this. </dd></dl>

</div>
</div>
<a id="ga1aa071855b5a2d42aa2d18cc0aefbbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa071855b5a2d42aa2d18cc0aefbbd9">&#9670;&nbsp;</a></span>next() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next arc after this when walking through the graph as though it were a link, in a direction away from the current node. </p>
<p>This routine will move to the other endpoint of the graph edge described by this arc, and will then return the <em>opposite</em> arc at the resulting node (i.e., not just pointing backwards along the same edge).</p>
<p>For any arc <em>a</em>, calling <code>a.next()</code> is equivalent to calling <code>a.traverse().<a class="el" href="group__link.html#ga397d518a7eb8ecf0e6d9f5b82c3e7439" title="Returns the arc that exits the same node as this, but from the opposite side.">opposite()</a></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the next arc after this when walking through the graph as though it were a link. </dd></dl>

</div>
</div>
<a id="gaf17087fab18a03a777c04d2d6eba29b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf17087fab18a03a777c04d2d6eba29b8">&#9670;&nbsp;</a></span>next() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::next </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strand</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that immediately follows this when walking forward in the direction of the link along one of the two strands that pass at this crossing. </p>
<p>Which strand we follow is indicated by the argument <em>strand</em>.</p>
<p>Note that for a crossing <em>c</em>, calling <code>c.next(s)</code> is equivalent to calling <code>c.strand(s).<a class="el" href="group__link.html#gaf17087fab18a03a777c04d2d6eba29b8" title="Returns the crossing reference that immediately follows this when walking forward in the direction of...">next()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strand</td><td>either 1 to walk forward along the upper strand, or 0 to walk forward along the lower strand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the next crossing after this along the given strand. </dd></dl>

</div>
</div>
<a id="gadf9867163e5b6defa9aa85d9bd8d9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9867163e5b6defa9aa85d9bd8d9963">&#9670;&nbsp;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::Link::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram. </p>
<p>This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of this graph.</p>
<p>See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p>This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p>The tree decomposition will be cached, so that if this routine is called a second time (and the underlying link has not been changed) then the same tree decomposition will be returned immediately.</p>
<p>If you wish to supply your own tree decomposition (as opposed to relying on the greedy heuristics that Regina implements), then you can supply it by calling <a class="el" href="group__link.html#ga7b845088fe7d44ab3da72b9fa9abddc0" title="Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree d...">useTreeDecomposition()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of this link diagram. </dd></dl>

</div>
</div>
<a id="ga0646e70ea3216d097bbbb1c99d6b54c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0646e70ea3216d097bbbb1c99d6b54c1">&#9670;&nbsp;</a></span>node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> * regina::ModelLinkGraphArc::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The node of the model graph from which this arc exits. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding node, or <code>null</code> if this is a null arc. </dd></dl>

</div>
</div>
<a id="ga32048d7c0d574234df71c03cf8afcb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32048d7c0d574234df71c03cf8afcb33">&#9670;&nbsp;</a></span>node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> * regina::ModelLinkGraph::node </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the node at the given index within this graph. </p>
<p>For a graph with <em>n</em> nodes, the nodes are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some nodes are added or removed then the indices of other nodes might change. If you wish to track a particular node through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested node. This must be between 0 and <a class="el" href="group__link.html#ga8ae830ab12408759e526ae15d16e0be5" title="Returns the number of nodes in this graph.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node at the given index. </dd></dl>

</div>
</div>
<a id="ga494c34d7a968a65694c9a9c6b09c8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494c34d7a968a65694c9a9c6b09c8357">&#9670;&nbsp;</a></span>numClosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a>* regina::Tangle::numClosure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the numerator closure of this tangle. </p>
<p>This is the link created by joining the two top endpoints of this tangle, and also joining the two bottom endpoints.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created link that is the numerator closure of this tangle. </dd></dl>

</div>
</div>
<a id="ga50ef609692c6491885504dad1d09459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ef609692c6491885504dad1d09459d">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StrandRef::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this is a non-null reference. </p>
<dl class="section user"><dt>Python</dt><dd>This is not available to python users. Instead you can simply test whether <code><a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> == None</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is not a null reference (i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return a null pointer), or <code>false</code> if this is a null reference. </dd></dl>

</div>
</div>
<a id="ga8a986c8e02432f9f02a446bd5b7d7aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a986c8e02432f9f02a446bd5b7d7aa6">&#9670;&nbsp;</a></span>operator bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraphArc::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this is a non-null arc. </p>
<dl class="section user"><dt>Python</dt><dd>This is not available to python users. Instead you can simply test whether <code><a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> == None</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is not a null arc (i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return a null pointer), or <code>false</code> if this is a null arc. </dd></dl>

</div>
</div>
<a id="gafbd054a653caeec40936205c8efabd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd054a653caeec40936205c8efabd13">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ArcIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the indices of the crossings and the upper/lower strand markings. It does not examine whether this and the given iterator refer to the same underlying link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="gab20fa2514d5d12886c3e8208977e71b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20fa2514d5d12886c3e8208977e71b2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CrossingIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the indices of the crossings. It does not examine whether this and the given iterator refer to the same underlying link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="gabe39709055f575f5859ce63a51c0b665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe39709055f575f5859ce63a51c0b665">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraphArc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given arc reference are not identical. </p>
<p>Two references are identical if and only if they return the same values for both <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> and <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you create a null arc by calling <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>null</code>, <em>i</em>) for some non-zero <em>i</em>, then this will <em>not</em> be considered equal to the null arc created by calling <a class="el" href="group__link.html#gade3b1a19d19db7d06137445bb45a620c" title="Initialises this to a null arc.">ModelLinkGraphArc()</a>, since the latter is equivalent to calling <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>null</code>, 0).</dd></dl>
<p><code>true</code> if and only if this and <em>rhs</em> are not identical. </p>

</div>
</div>
<a id="gaf636decd24394b8cc3c9b349ae8d2d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf636decd24394b8cc3c9b349ae8d2d1d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::StrandRef::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given reference are not identical. </p>
<p>Two references are identical if and only if they return the same values for both <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> and <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f" title="Indicates whether this reference points to the upper or lower strand of the relevant crossing.">strand()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you create a null reference by calling <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>null</code>, 1) then this will <em>not</em> be considered equal to the null reference created by calling <a class="el" href="group__link.html#gac1b246253bcd288646085f9930003399" title="Initialises this to a null reference.">StrandRef()</a>, since the latter is equivalent to calling <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>null</code>, 0).</dd></dl>
<p><code>true</code> if and only if this and <em>rhs</em> are not identical. </p>

</div>
</div>
<a id="ga4bb7aa49c38e92fca330eab98a741a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb7aa49c38e92fca330eab98a741a78">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::CrossingIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing to which this iterator points. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing to which this iterator points. </dd></dl>

</div>
</div>
<a id="gaadc6b9ba22ea5720a8614f1517606ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc6b9ba22ea5720a8614f1517606ad8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::ArcIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the directed arc to which this iterator points. </p>
<p>See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for details on how a <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object is used to identify a directed arc.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the directed arc to which this iterator points. </dd></dl>

</div>
</div>
<a id="gaca9f21431143267c5f4d7142f604559f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9f21431143267c5f4d7142f604559f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp; regina::StrandRef::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this reference forward along the direction of the link until it reaches the next crossing. </p>
<p>(Of course, if the link contains a trivial twist then this may in fact return to the same crossing but the other strand).</p>
<p>This is a preincrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postincrement operator is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="gaf3df1c038e0e74c0650bf2ee8567b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3df1c038e0e74c0650bf2ee8567b42d">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp; regina::CrossingIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga265281688e0ff3631b6fafde3e5e46ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265281688e0ff3631b6fafde3e5e46ec">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp; regina::ArcIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gacd6da1ee39acdb0f069a502aec5e8f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd6da1ee39acdb0f069a502aec5e8f0f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp; regina::ModelLinkGraphArc::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes to the next outgoing link arc from the same node. </p>
<p>This effectively rotates the arc in a clockwise direction around the node. In particular, it increments the value returned by <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>, modulo 4.</p>
<p>This is a preincrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postincrement operator is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga6a82768f76ba5970aaec59c4e62d37f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a82768f76ba5970aaec59c4e62d37f4">&#9670;&nbsp;</a></span>operator++() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::StrandRef::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this reference forward along the direction of the link until it reaches the next crossing. </p>
<p>(Of course, if the link contains a trivial twist then this may in fact return to the same crossing but the other strand).</p>
<p>This is a postincrement operator: the object will be changed, but a copy of the original reference will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="ga696cc505076ba63d8c0c30a78e2f6d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696cc505076ba63d8c0c30a78e2f6d21">&#9670;&nbsp;</a></span>operator++() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> regina::CrossingIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga1624b6b018063fb2ee8c88f188c97da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1624b6b018063fb2ee8c88f188c97da1">&#9670;&nbsp;</a></span>operator++() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> regina::ArcIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="gae8380bee08f0311c799062af1435ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8380bee08f0311c799062af1435ed0b">&#9670;&nbsp;</a></span>operator++() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes to the next outgoing link arc from the same node. </p>
<p>This effectively rotates the arc in a clockwise direction around the node. In particular, it increments the value returned by <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>, modulo 4.</p>
<p>This is a postincrement operator: the object will be changed, but a copy of the original arc will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="gabb370668021e61df5e583dad6d05d9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb370668021e61df5e583dad6d05d9b4">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp; regina::StrandRef::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this reference backward against the direction of the link until it reaches the previous crossing. </p>
<p>(Of course, if the link contains a trivial twist then this may in fact return to the same crossing but the other strand).</p>
<p>This is a preincrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postincrement operator is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga9719945553f519a11026175141c0eb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9719945553f519a11026175141c0eb20">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp; regina::ModelLinkGraphArc::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes to the previous outgoing link arc from the same node. </p>
<p>This effectively rotates the arc in an anticlockwise direction around the node. In particular, it decrements the value returned by <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>, modulo 4.</p>
<p>This is a predecrement operator: the object will be changed, and then a reference to it will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available; however, the postdecrement operator is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga6fd3eb1f35d2466c578acc8b6a2d6ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd3eb1f35d2466c578acc8b6a2d6ab5">&#9670;&nbsp;</a></span>operator--() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::StrandRef::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this reference backward against the direction of the link until it reaches the previous crossing. </p>
<p>(Of course, if the link contains a trivial twist then this may in fact return to the same crossing but the other strand).</p>
<p>This is a postincrement operator: the object will be changed, but a copy of the original reference will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="ga585c6903d3d5ff419fc52ff60bc50d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585c6903d3d5ff419fc52ff60bc50d14">&#9670;&nbsp;</a></span>operator--() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes to the previous outgoing link arc from the same node. </p>
<p>This effectively rotates the arc in an anticlockwise direction around the node. In particular, it decrements the value returned by <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>, modulo 4.</p>
<p>This is a postdecrement operator: the object will be changed, but a copy of the original arc will be returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available under the name dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this object before the change took place. </dd></dl>

</div>
</div>
<a id="ga16afe99ca314816df9ad6790018b3d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16afe99ca314816df9ad6790018b3d3c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a depiction of the given arc reference to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">a</td><td>the arc reference to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gabf19ebfb95d12c438417a04f15511f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf19ebfb95d12c438417a04f15511f20">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a depiction of the given strand reference to the given output stream. </p>
<p>The reference will be written in the form <code>^n</code> or <code>_n</code>, denoting the upper or lower strand at crossing <em>n</em> respectively. For example, the upper strand of crossing 7 will be written as <code>^7</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the reference to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga5b8dff9a165080ec57f9e52222907cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8dff9a165080ec57f9e52222907cdc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a>&amp; regina::ArcIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gaec89329bc8a4d0788109cc9c6ef4b02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec89329bc8a4d0788109cc9c6ef4b02d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a>&amp; regina::CrossingIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gaad2b187c2d08eb862024e53f351566f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2b187c2d08eb862024e53f351566f8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>&amp; regina::ModelLinkGraphArc::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga00aaff7af2cd3c63d3a20116964b016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00aaff7af2cd3c63d3a20116964b016e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&amp; regina::StrandRef::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="ga96ce7402d8274dd999715d30568d080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ce7402d8274dd999715d30568d080b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ArcIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ArcIterator.html">ArcIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the indices of the crossings and the upper/lower strand markings. It does not examine whether this and the given iterator refer to the same underlying link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="ga5d6c163ac97344e96b5f4fd6b4b592bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d6c163ac97344e96b5f4fd6b4b592bc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CrossingIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CrossingIterator.html">CrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the indices of the crossings. It does not examine whether this and the given iterator refer to the same underlying link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="gafb27406e070d9116d3e5b21921d26391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb27406e070d9116d3e5b21921d26391">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraphArc::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given arc reference are identical. </p>
<p>Two references are identical if and only if they return the same values for both <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> and <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you create a null arc by calling <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>null</code>, <em>i</em>) for some non-zero <em>i</em>, then this will <em>not</em> be considered equal to the null arc created by calling <a class="el" href="group__link.html#gade3b1a19d19db7d06137445bb45a620c" title="Initialises this to a null arc.">ModelLinkGraphArc()</a>, since the latter is equivalent to calling <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a>(<code>null</code>, 0).</dd></dl>
<p><code>true</code> if and only if this and <em>rhs</em> are identical. </p>

</div>
</div>
<a id="gafdd818191c3f9c02682058565617d936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd818191c3f9c02682058565617d936">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::StrandRef::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given reference are identical. </p>
<p>Two references are identical if and only if they return the same values for both <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> and <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f" title="Indicates whether this reference points to the upper or lower strand of the relevant crossing.">strand()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you create a null reference by calling <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>null</code>, 1) then this will <em>not</em> be considered equal to the null reference created by calling <a class="el" href="group__link.html#gac1b246253bcd288646085f9930003399" title="Initialises this to a null reference.">StrandRef()</a>, since the latter is equivalent to calling <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>null</code>, 0).</dd></dl>
<p><code>true</code> if and only if this and <em>rhs</em> are identical. </p>

</div>
</div>
<a id="ga397d518a7eb8ecf0e6d9f5b82c3e7439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397d518a7eb8ecf0e6d9f5b82c3e7439">&#9670;&nbsp;</a></span>opposite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::opposite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the arc that exits the same node as this, but from the opposite side. </p>
<p>Recall that the four arcs exiting each node are numbered in clockwise order. The return value will therefore have the same <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> as this, but its <a class="el" href="group__link.html#ga6d86898f011332b930717e67d4039ae8" title="Indicates which arc this is amongst the four arcs exiting the underlying node of the model graph.">arc()</a> value will be two more than this (modulo 4).</p>
<p>Note that, for any arc <em>a</em>, <code>a.opposite().<a class="el" href="group__link.html#ga397d518a7eb8ecf0e6d9f5b82c3e7439" title="Returns the arc that exits the same node as this, but from the opposite side.">opposite()</a></code> is identical to <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the opposite arc exiting the same node. </dd></dl>

</div>
</div>
<a id="gab8d81af83901af217da0bee17b6bf120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d81af83901af217da0bee17b6bf120">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an oriented Gauss code for this knot. </p>
<p>The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. For details of this format, see the documentation for <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The key advantage of using the oriented Gauss code (as opposed to the classical Gauss code) is that an oriented Gauss code always describes a unique knot, and moreover (for knots that are not equivalent to their reflections) it describes a unique reflection of that knot.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this knot, or the empty string if this is a link with zero or multiple components. </dd></dl>

</div>
</div>
<a id="ga4901f74db4ad01ee8987de6b2e87191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4901f74db4ad01ee8987de6b2e87191e">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Tangle::orientedGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an oriented Gauss code for this tangle. </p>
<p>Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p>For a full explanation of how oriented Gauss codes work for tangles, see the documentation for <a class="el" href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports tangles in this format.</p>
<p>The string that is returned will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this tangle. </dd></dl>

</div>
</div>
<a id="ga21eaa9351a071dc7ddcf8e4d1101d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21eaa9351a071dc7ddcf8e4d1101d584">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this knot to the given output stream. </p>
<p>The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. For details of this format, see the documentation for <a class="el" href="group__link.html#ga7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The key advantage of using the oriented Gauss code (as opposed to the classical Gauss code) is that an oriented Gauss code always describes a unique knot, and moreover (for knots that are not equivalent to their reflections) it describes a unique reflection of that knot.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available in Python. Instead, Python users can use the variant <a class="el" href="group__link.html#gab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57ad9e44a76bac84d1e314a2f60a6fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ad9e44a76bac84d1e314a2f60a6fe8">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this tangle to the given output stream. </p>
<p>Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p>For a full explanation of how oriented Gauss codes work for tangles, see the documentation for <a class="el" href="group__link.html#gad9fb20a28b2e91fb8c5a72de9f2e0e19" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports tangles in this format.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is not available in Python. Instead, Python users can use the variant <a class="el" href="group__link.html#ga4901f74db4ad01ee8987de6b2e87191e" title="Outputs an oriented Gauss code for this tangle.">orientedGauss()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3dd364d5dc16aaa052accbc0131585b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd364d5dc16aaa052accbc0131585b4">&#9670;&nbsp;</a></span>over()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::over </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running over this crossing. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>this</code>, 1).</p>
<p>Note that <a class="el" href="group__link.html#ga8b28abed9edb209f54747b5e926530b8" title="Returns a reference to the strand running over this crossing.">upper()</a> and <a class="el" href="group__link.html#ga3dd364d5dc16aaa052accbc0131585b4" title="Returns a reference to the strand running over this crossing.">over()</a> are synonyms.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the upper strand for this crossing. </dd></dl>

</div>
</div>
<a id="ga6b21aaa8020908478576e1f9325d4f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b21aaa8020908478576e1f9325d4f91">&#9670;&nbsp;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of the underlying planar 4-valent multigraph, using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a>.</p>
<p>This routine simply returns the output of <a class="el" href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a> as a string, instead of writing it to an output stream.</p>
<p>See the <a class="el" href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="group__link.html#ga8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a>, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="gaf49ae8900301d590eb89ffed050abac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf49ae8900301d590eb89ffed050abac9">&#9670;&nbsp;</a></span>packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLLinkReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga2d9da32820ca345fb6056f0cc149c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d9da32820ca345fb6056f0cc149c872">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::parallel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a>&#160;</td>
          <td class="paramname"><em>framing</em> = <code><a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <em>k</em> cables of this link, all parallel to each other using the given framing. </p>
<p>This routine creates a new link by:</p>
<ul>
<li>treating each component of this link as a ribbon, using the given framing;</li>
<li>creating <em>k</em> parallel copies of the original link, following each other side-by-side along these ribbons.</li>
</ul>
<p>This link will not be modified.</p>
<p>The result will returned as a new link, and it is the responsibility of the caller of this routine to destroy it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of parallel copies to create. This must be non-negative. </td></tr>
    <tr><td class="paramname">framing</td><td>the framing under which these copies will be parallel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>k</em> parallel copies of this link, as a newly-created object. </dd></dl>

</div>
</div>
<a id="ga3b794563bcc89728bf2dab6f6952a5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b794563bcc89728bf2dab6f6952a5c5">&#9670;&nbsp;</a></span>plantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::plantri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this graph in the ASCII text format used by <em>plantri</em>. </p>
<p>The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine outputs this graph in a format that mimics <em>plantri's</em> own dual ASCII format (i.e., the format that <em>plantri</em> outputs when run with the flags <code>-adq</code>).</p>
<p>Specifically, the output will be a comma-separated sequence of alphabetical strings. The <em>i</em>th such string will consist of four lower-case letters, encoding the endpoints of the four edges in clockwise order that leave node <em>i</em>. The letters <code>a</code>,<code>b</code>,<code>c</code>,... represent nodes 0,1,2,... respectively. An example of such a string is:</p>
<pre class="fragment">bcdd,aeec,abfd,acfa,bffb,ceed
</pre><p>This routine is an inverse to <a class="el" href="group__link.html#ga7d7937582581020a947d0e728e950a8f" title="Builds a graph from a line of plantri output.">fromPlantri()</a>: for any graph <em>g</em> that satisfies the preconditions below, <code>fromPlantri(g.plantri())</code> is identical to <em>g</em>. Likewise, for any string <em>s</em> that satisfies the preconditions for <a class="el" href="group__link.html#ga7d7937582581020a947d0e728e950a8f" title="Builds a graph from a line of plantri output.">fromPlantri()</a>, calling <code>fromPlantri(s).<a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in the ASCII text format used by plantri.">plantri()</a></code> will recover the original string <em>s</em>.</p>
<p>It is important to note the preconditions below: in particular, that this graph must be dual to a <em>simple</em> quadrangulation of the sphere. This is because the planar embeddings for more general graphs (i.e., the duals of non-simple quadrangulations) cannot always be uniquely reconstructed from their <em>plantri</em> output.</p>
<dl class="section note"><dt>Note</dt><dd>The output of this function might not correspond to any possible output from the program <em>plantri</em> itself. This is because <em>plantri</em> only outputs graphs with a certain canonical labelling. In contrast, <a class="el" href="group__link.html#ga3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in the ASCII text format used by plantri.">plantri()</a> can be called on any graph that satisfies the preconditions below, and it will preserve the labels of the nodes and the order of the arcs around each node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected. </dd>
<dd>
This graph has between 1 and 26 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <em>plantri</em> format ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="ga09918c5b00d7cdfa08d0bb3edf2d1d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09918c5b00d7cdfa08d0bb3edf2d1d0a">&#9670;&nbsp;</a></span>prev() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::StrandRef::prev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that comes immediately before this when walking backward against the direction of the link. </p>
<p>Equivalently, this routine returns the reference that would be obtained by calling the decrement (&ndash;) operator (but, unlike the decrement operator, this routine does not actually change the current reference).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null reference, i.e., <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing reference that precedes this. </dd></dl>

</div>
</div>
<a id="ga12029ae31f68fc95cc0f8cffe861de93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12029ae31f68fc95cc0f8cffe861de93">&#9670;&nbsp;</a></span>prev() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::prev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the previous arc before this when walking through the graph as though it were a link, in a direction away from the* current node. </p>
<p>This routine will jump to the opposite arc at the current node, and then move to the other endpoint of the graph edge described by that opposite arc.</p>
<p>For any arc <em>a</em>, calling <code>a.prev()</code> is equivalent to calling <code>a.opposite().<a class="el" href="group__link.html#gab9e9710e3cb111fc0e4826f41d024db5" title="Returns the same edge of the model graph, but seen from the other endpoint.">traverse()</a></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the previous arc before this when walking through the graph as though it were a link. </dd></dl>

</div>
</div>
<a id="gab9f537596ed523115aad084089553836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9f537596ed523115aad084089553836">&#9670;&nbsp;</a></span>prev() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::prev </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strand</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the crossing reference that immediately precedes this when walking backward against the direction of the link along one of the two strands that pass at this crossing. </p>
<p>Which strand we follow is indicated by the argument <em>strand</em>.</p>
<p>Note that for a crossing <em>c</em>, calling <code>c.prev(s)</code> is equivalent to calling <code>c.strand(s).<a class="el" href="group__link.html#gab9f537596ed523115aad084089553836" title="Returns the crossing reference that immediately precedes this when walking backward against the direc...">prev()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strand</td><td>either 1 to walk backward along the upper strand, or 0 to walk backward along the lower strand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the previous crossing before this along the given strand. </dd></dl>

</div>
</div>
<a id="ga23a70af4f63bbd4f7dea13a04a3b984a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23a70af4f63bbd4f7dea13a04a3b984a">&#9670;&nbsp;</a></span>r1() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to remove a crossing. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>crossing</em>, which indicates the crossing that will be removed. Specifically, this move involves undoing a trivial twist at the given crossing.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because one crossing is being removed, the other crossings in the link may be reindexed. However, no crossings other than the one involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga75456efb18f88399f5e800fb52c3d70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75456efb18f88399f5e800fb52c3d70d">&#9670;&nbsp;</a></span>r1() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to remove a crossing. </p>
<p>Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p>The behaviour of this routine is identical to the <a class="el" href="group__link.html#ga75456efb18f88399f5e800fb52c3d70d" title="Tests for and/or performs a type I Reidemeister move to remove a crossing.">r1()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="group__link.html#ga23a70af4f63bbd4f7dea13a04a3b984a" title="Tests for and/or performs a type I Reidemeister move to remove a crossing.">Link::r1()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga9535918349c0ada298fcabeac5638ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9535918349c0ada298fcabeac5638ec8">&#9670;&nbsp;</a></span>r1() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to add a new crossing. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves adding a trivial twist to the given arc; the arguments <em>side</em> and <em>sign</em> indicate on which side of the arc and with which orientation the new twist will be made. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If <em>arc</em> is a null reference, then the new twist will be added to a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If <em>arc</em> is null but there is no zero-crossing component then the move cannot be performed, and if <em>arc</em> is null but there are multiple zero-crossing components then the first such component will be used.</p>
<p>This move is almost always able to be performed: the only situation in which it <em>cannot</em> be performed is if <em>arc</em> is a null reference but this link contains no zero-crossing components, as discussed above.</p>
<p>The existing crossings in this link will keep the same indices, and the new crossing will be given the next index that is available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga050794f44093f3ec4740eb6b2653d40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050794f44093f3ec4740eb6b2653d40e">&#9670;&nbsp;</a></span>r2() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>crossing</em>, Specifically, this move involves pulling apart two arcs of the link (one upper, one lower) that both run between the same pair of crossings. The given crossing should be the start point of the upper arc; that is, when following the upper arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. Note that <em>crossing</em> is one of the two crossings that will be removed by this move.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaaa71c2b2601ab277179d44e8f62176d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa71c2b2601ab277179d44e8f62176d8">&#9670;&nbsp;</a></span>r2() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p>The behaviour of this routine is identical to the <a class="el" href="group__link.html#gaf80f087595912ee502a37bf2c7980c33" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">r2()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="group__link.html#gafaf3e0d6eaa504eba071e3950a939028" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">Link::r2()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gafaf3e0d6eaa504eba071e3950a939028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf3e0d6eaa504eba071e3950a939028">&#9670;&nbsp;</a></span>r2() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves pulling apart two arcs of the link that surround a bigon; the given arc must be one of these two arcs. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaf80f087595912ee502a37bf2c7980c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80f087595912ee502a37bf2c7980c33">&#9670;&nbsp;</a></span>r2() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p>The behaviour of this routine is identical to the <a class="el" href="group__link.html#gaf80f087595912ee502a37bf2c7980c33" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">r2()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="group__link.html#gafaf3e0d6eaa504eba071e3950a939028" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">Link::r2()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga92d15fe6c6ad9a04ae0e05c9fea67cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d15fe6c6ad9a04ae0e05c9fea67cea">&#9670;&nbsp;</a></span>r2() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>upperArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>lowerArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to add two new crossings. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>upperArc</em>, <em>upperSide</em>, <em>lowerArc</em> and <em>lowerSide</em>. Specifically, this move involves taking the arc <em>upperArc</em> and pushing it over <em>lowerArc</em> so that the two arcs overlap. The arguments <em>upperSide</em> and <em>lowerSide</em> indicate on which side of each arc the overlap takes place. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If either <em>upperArc</em> or <em>lowerArc</em> is a null reference, then the move will be performed upon a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If one of these arguments is a null reference but there is no zero-crossing component then the move cannot be performed, and if there are multiple zero-crossing components then the first such component will be used.</p>
<p>Likewise, if <em>both</em> arcs are null references, then the move will be performed upon two <em>different</em> zero-crossing unknot components. In this case, if there are fewer than two such components then the move cannot be performed, and otherwise <em>upperArc</em> will be the first such component and <em>lowerArc</em> will be the second.</p>
<p>Currently, Regina cannot perform the move when <em>upperArc</em> and <em>lowerArc</em> represent the same arc (or the same zero-crossing unknot component). In this case there is a workaround: you can achieve the same effect by performing two type I Reidemeister moves (i.e., by adding two twists).</p>
<p>The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for this move is expensive (linear time), since it includes testing whether both sides-of-arcs belong to the same 2-cell of the knot diagram.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies the arc of the link which will be passed over the other, as described above. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies the arc of the link which will be passed beneath the other, as described above. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gae0ba90169324b005d88587e4597ad129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ba90169324b005d88587e4597ad129">&#9670;&nbsp;</a></span>r3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>crossing</em> and <em>side</em>. Specifically, this move takes place around a triangle, and one of the arcs of this triangle is <em>uppermost</em> (in that it passes above the other two arcs). The given crossing should be the start point of this uppermost arc; that is, when following the arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. The additional argument <em>side</em> indicates on which side of the uppermost arc the third crossing is located.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gad29467a23ac123cbab680b1e406e34bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad29467a23ac123cbab680b1e406e34bc">&#9670;&nbsp;</a></span>r3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>arc</em> and <em>side</em>. Specifically, this move takes place around a triangle; the given arc must form one of the three edges of this triangle. The argument <em>side</em> indicates on which side of the arc the third crossing is located. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga8b4396c9fcb99dbb3bb4ba7176b859c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b4396c9fcb99dbb3bb4ba7176b859c4">&#9670;&nbsp;</a></span>reflect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this link into its reflection. </p>
<p>This routine changes the sign of every crossing, but leaves the upper and lower strands the same. This operation corresponds to reflecting the link diagram about some axis in the plane. </p>

</div>
</div>
<a id="gad89a103eeda5359e83684d10b5f3444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89a103eeda5359e83684d10b5f3444d">&#9670;&nbsp;</a></span>reflect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this graph into its reflection. </p>
<p>This routine simply reverses (and also cycles) the order of outgoing arcs around every node. </p>

</div>
</div>
<a id="ga6da54fa7f3352392989e34629c314a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6da54fa7f3352392989e34629c314a91">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves the given crossing. </p>
<p>The two incoming strands will switch connections with the two outgoing strands, with the result that the given crossing is removed entirely.</p>
<dl class="section note"><dt>Note</dt><dd>The number of components in the link <em>will</em> change as a result of this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to resolve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9326a4e30a7cfb373020c4c6084775fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9326a4e30a7cfb373020c4c6084775fc">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of every component of this link. </p>
<p>This routine preserves both the sign and the upper/lower positions at every crossing, but switches all incoming strands with outgoing strands and vice versa (so next() becomes prev(), and prev() becomes next()). </p>

</div>
</div>
<a id="gaeadc3ba80f5f033f8b306a718b06566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeadc3ba80f5f033f8b306a718b06566c">&#9670;&nbsp;</a></span>rewrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::rewrite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings. </p>
<p>This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will return immediately (as described below).</p>
<p>This routine iterates through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number. With the current implementation, these diagrams <b>could become reflected and/or reversed</b>, and moreover each diagram will only be considered once up to reflection and/or reversal; be aware that this behaviour could change and/or become configurable in a future version of Regina.</p>
<p>For every such knot diagram (including this starting diagram), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take at least one argument. The first argument will be of type <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>&amp;, and will reference the knot diagram that has been found. If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more knot diagrams will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this knot (i.e., the original knot upon which <a class="el" href="group__link.html#gaeadc3ba80f5f033f8b306a718b06566c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a> was called). This will not affect the search: all knot diagrams that this routine visits will be obtained via Reidemeister moves from the original knot diagram, before any subsequent changes (if any) were made.</li>
<li><em>action</em> may, if it chooses, make changes to the knot that is passed in its argument (though it must not delete it). This will likewise not affect the search, since the knot diagram that is passed to <em>action</em> will be destroyed immediately after <em>action</em> is called.</li>
<li><em>action</em> will only be called once for each knot diagram (including this starting diagram). In other words, no knot diagram will be revisited a second time in a single call to <a class="el" href="group__link.html#gaeadc3ba80f5f033f8b306a718b06566c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a>.</li>
</ul>
<p>This routine can be very slow and very memory-intensive, since the number of knot diagrams it visits may be exponential in the number of crossings, and it records every knot diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some knot diagram that is passed to it.</p>
<p>If a progress tracker is passed, then the exploration of knot diagrams will take place in a new thread and this routine will return immediately.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time).</p>
<p>If this link does not have precisely one component, then this routine will do nothing. If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="section warning"><dt>Warning</dt><dd>By default, the arguments <em>args</em> will be copied (or moved) when they are passed to <em>action</em>. If you need to pass some argument(s) by reference, you must wrap them in std::ref or std::cref.</dd>
<dd>
The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this knot diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call upon each knot diagram that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial knot argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="ga078b8f0dd10461df6f5b535fb3991bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga078b8f0dd10461df6f5b535fb3991bce">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::rotate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this link diagram, converting it into a different diagram of the same link. </p>
<p>This routine keeps the sign of each crossing fixed, but switches the upper and lower strands. This operation corresponds to a 3-dimensional rotation about some axis in the plane. </p>

</div>
</div>
<a id="gab06b875567dda4c15e075ecc4e62d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab06b875567dda4c15e075ecc4e62d724">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::Crossing::sign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of this crossing. </p>
<p>This will be +1 for a positive crossing, or -1 for a negative crossing.</p>
<p>See the <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> class notes for diagrams of positive and negative crossings</p>
<dl class="section return"><dt>Returns</dt><dd>the sign of this crossing. </dd></dl>

</div>
</div>
<a id="ga7701e3dd1fdbe8d8106363d118ec887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7701e3dd1fdbe8d8106363d118ec887d">&#9670;&nbsp;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph. </p>
<p>This routine is more powerful but much slower than <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p>Unlike <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>, this routine <b>could potentially reflect or reverse the link</b>.</p>
<p>This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will return immediately (as described below).</p>
<p>This routine will iterate through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number.</p>
<p>If at any stage it finds a diagram with <em>fewer</em> crossings than the original, then this routine will call <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> to simplify the diagram further if possible and will then return <code>true</code>. If it cannot find a diagram with fewer crossings then it will leave this knot diagram unchanged and return <code>false</code>.</p>
<p>This routine can be very slow and very memory-intensive: the number of knot diagrams it visits may be exponential in the number of crossings, and it records every diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will not terminate until a simpler diagram is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p>If you want a <em>fast</em> simplification routine, you should call <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> instead. The benefit of <a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is that, for very stubborn knot diagrams where <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> finds itself stuck at a local minimum, <a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p>If a progress tracker is passed, then the exhaustive simplification will take place in a new thread and this routine will return immediately. In this case, you will need to use some other means to determine whether the knot diagram was eventually simplified (e.g., by examining <a class="el" href="group__link.html#ga32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a> after the tracker indicates that the operation has finished).</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either the diagram was simplified or the search was exhausted).</p>
<p>If this routine is unable to simplify the knot diagram, then this knot diagram will not be changed.</p>
<p>If this link does not have precisely one component, then this routine will do nothing. If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if and only if this diagram was successfully simplified to fewer crossings. </dd></dl>

</div>
</div>
<a id="ga3adf6c87c3dc80de018d659e686b48ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3adf6c87c3dc80de018d659e686b48ef">&#9670;&nbsp;</a></span>simplifyToLocalMinimum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings. </p>
<p>End users will probably not want to call this routine. You should call <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> if you want a fast (and usually effective) means of simplifying a link. If this link is a knot (i.e., it has precisely one component), then you can also call <a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p>Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine. Such moves do however feature in <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p>This routine will never reflect or reverse the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="gaa82854b84b334083c2dd8ccd5e23ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa82854b84b334083c2dd8ccd5e23ee41">&#9670;&nbsp;</a></span>simplifyToLocalMinimum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the tangle monotonically to some local minimum number of crossings. </p>
<p>Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine.</p>
<p>Unlike links, tangle do not (at present) offer stronger simplification routines (such as the much better <a class="el" href="group__link.html#ga5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">Link::intelligentSimplify()</a> and <a class="el" href="group__link.html#ga7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">Link::simplifyExhaustive()</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="ga32c6f34794cc62574fcfca388f3f66d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c6f34794cc62574fcfca388f3f66d9">&#9670;&nbsp;</a></span>size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this link. </p>
<p>Note that a link can have more components than crossings (since it may contain additional zero-crossing unknot components).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="ga8ae830ab12408759e526ae15d16e0be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae830ab12408759e526ae15d16e0be5">&#9670;&nbsp;</a></span>size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of nodes in this graph. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes. </dd></dl>

</div>
</div>
<a id="ga3e255ebc40070d5c43f14fb3848f2827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e255ebc40070d5c43f14fb3848f2827">&#9670;&nbsp;</a></span>size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Tangle::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this tangle. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="ga4043ef70f0d094c3ff49d8422e581529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4043ef70f0d094c3ff49d8422e581529">&#9670;&nbsp;</a></span>size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraphCells::size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs aloung the boundary of the given 2-cell. </p>
<p>If the given cell is a <em>k</em>-gon, then this routine returns the integer <em>k</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> is non-empty, connected, and describes a planar graph embedding. Note that connectivity is already required by the class constructor, and you can test the remaining conditions by calling <a class="el" href="group__link.html#ga0ae15c42db3ab8321a751201bfeaef19" title="Determines whether the underlying graph is non-empty with a planar embedding, assuming that it is alr...">isValid()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>indicates which cell to query; this must be between 0 and <a class="el" href="group__link.html#ga4c0d54a49192f9ee3a54c486e0bd42ad" title="Returns the number of 2-cells in this cellular decomposition.">countCells()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the correpsonding 2-cell. </dd></dl>

</div>
</div>
<a id="ga7fcee2a779b45b242dca26dff055a569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcee2a779b45b242dca26dff055a569">&#9670;&nbsp;</a></span>startContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * regina::XMLLinkReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga009e243aef258b3a6e8b37abd4274c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga009e243aef258b3a6e8b37abd4274c8f">&#9670;&nbsp;</a></span>startElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLLinkComponentsReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gad3c3fff79af8436854a3ffec13398f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c3fff79af8436854a3ffec13398f51">&#9670;&nbsp;</a></span>startElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLLinkCrossingsReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga167bb9ba6ba78767f7753ff7f3317e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167bb9ba6ba78767f7753ff7f3317e3f">&#9670;&nbsp;</a></span>strand() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::StrandRef::strand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this reference points to the upper or lower strand of the relevant crossing. </p>
<p>A value of 1 denotes the upper strand (which passes over the crossing), and a value of 0 denotes the lower strand (which passes under the crossing).</p>
<p>The information returned by <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> and <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f" title="Indicates whether this reference points to the upper or lower strand of the relevant crossing.">strand()</a> together pinpoint exactly which strand of the link this reference points to.</p>
<dl class="section return"><dt>Returns</dt><dd>either 0 or 1 to indicate the strand. </dd></dl>

</div>
</div>
<a id="ga411f710b2b7a73d1999cf0ea44cc7a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga411f710b2b7a73d1999cf0ea44cc7a4a">&#9670;&nbsp;</a></span>strand() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::strand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the strand in the link with the given integer ID. </p>
<p>Each strand ID is of the form 2<em>c</em>+<em>s</em>, where <em>c</em> is the index of the crossing, and <em>s</em> is 0 or 1 for the lower or upper strand respectively. A null strand reference (as used to indicate 0-crossing unknot components) has an ID of -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an integer between -1 and 2*size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the strand of this link with the corresponding ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__link.html#gadd61713b60a4536a94461656e93298b2" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> </dd></dl>

</div>
</div>
<a id="ga3fa943c46328c17f931283d95c01b55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa943c46328c17f931283d95c01b55a">&#9670;&nbsp;</a></span>strand() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::strand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two strands of the link that pass each other at this crossing. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>this</code>, <em>which</em>).</p>
<p>Note that <a class="el" href="group__link.html#ga8b28abed9edb209f54747b5e926530b8" title="Returns a reference to the strand running over this crossing.">upper()</a> and <a class="el" href="group__link.html#ga3dd364d5dc16aaa052accbc0131585b4" title="Returns a reference to the strand running over this crossing.">over()</a> are synonyms for strand(1), and <a class="el" href="group__link.html#gaaf2b9f54049a9d814d6a6abe87de3edc" title="Returns a reference to the strand running under this crossing.">lower()</a> and <a class="el" href="group__link.html#ga5ed3d9d76a5e1554c595c79f5d5bce61" title="Returns a reference to the strand running under this crossing.">under()</a> are synonyms for strand(0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>either 1 to indicate the upper strand, or 0 to indicate the lower strand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given strand at this crossing. </dd></dl>

</div>
</div>
<a id="gac1b246253bcd288646085f9930003399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b246253bcd288646085f9930003399">&#9670;&nbsp;</a></span>StrandRef() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StrandRef::StrandRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this to a null reference. </p>
<p>The pointer returned by <a class="el" href="group__link.html#gabe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">crossing()</a> will be <code>null</code>, and the integer returned by <a class="el" href="group__link.html#ga167bb9ba6ba78767f7753ff7f3317e3f" title="Indicates whether this reference points to the upper or lower strand of the relevant crossing.">strand()</a> will be 0. </p>

</div>
</div>
<a id="ga8608c1da51c291b35e6f5c4a5a8ceae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8608c1da51c291b35e6f5c4a5a8ceae7">&#9670;&nbsp;</a></span>StrandRef() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StrandRef::StrandRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="ga6d8c0893752bbeacf59c06937b8d31dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8c0893752bbeacf59c06937b8d31dd">&#9670;&nbsp;</a></span>StrandRef() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StrandRef::StrandRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this to the given strand of the given crossing. </p>
<p>The given crossing may be <code>null</code>, in which case this will become a null reference. If you are creating a null reference, then it is highly recommended that you pass <em>strand</em> as 0, so that comparison tests treat this null reference as equal to a null reference created by the zero-argument constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>the crossing being identified. </td></tr>
    <tr><td class="paramname">strand</td><td>0 to denote the strand running under the crossing, or 1 to denote the strand running over the crossing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15ae448f3fa16932d01d4c5a165e408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ae448f3fa16932d01d4c5a165e408c">&#9670;&nbsp;</a></span>swapContents() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given link. </p>
<p>All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link. Likewise, all cached properties (e.g., tree decompositions) will be swapped.</p>
<p>In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a13d94cb957cd445bb446c8f56dd90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a13d94cb957cd445bb446c8f56dd90d">&#9670;&nbsp;</a></span>swapContents() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given graph. </p>
<p>All nodes that belong to this graph will be moved to <em>other</em>, and all nodes that belong to <em>other</em> will be moved to this graph.</p>
<p>In particular, any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> pointers or references and any <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac361e059c41aa061a0b0130b02cc2ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac361e059c41aa061a0b0130b02cc2ccb">&#9670;&nbsp;</a></span>swapContents() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given tangle. </p>
<p>All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link. Likewise, all cached properties (e.g., tree decompositions) will be swapped.</p>
<p>In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga683a15a679a274e4cd2c905ef381d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga683a15a679a274e4cd2c905ef381d287">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the zero tangle. </p>
<p>This is the horizontal tangle with no crossings. </p>

</div>
</div>
<a id="gadbe69c31e2d787bf47ccd21513d9f302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe69c31e2d787bf47ccd21513d9f302">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>knot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a tangle from two parallel copies of the given knot. </p>
<p>Specifically, the tangle will consist of two parallel copies of the given knot diagram, which will be broken just before the starting strand as returned by <code>knot.component(0)</code>.</p>
<p>The two resulting endpoints that appear just before the starting strand will form the top-left and bottom-left endpoints of this tangle, and the endpoints on the other side of the break (which will be just after the parallel copies of the final strand <code>knot.component(0).prev()</code>) will form the top-right and bottom-right endpoints of this tangle.</p>
<p>The tangle will contain <code>4 * knot.size()</code> crossings in total.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument contains exactly one component (i.e., it is actually a knot, and not empty or a multiple-component link).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knot</td><td>the knot to break and duplicate to form this tangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d96f9728fe44d1b8d0802d789e538c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d96f9728fe44d1b8d0802d789e538c9">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given tangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the tangle to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08a5f998255d48ee62fdd3c53b04c162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a5f998255d48ee62fdd3c53b04c162">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rational tangle with the given parameters. </p>
<p>Here we use the following convention (following the description that Adams gives in <em>The Knot Book</em>):</p>
<ul>
<li>the zero tangle is horizontal with no crossings;</li>
<li>the infinity tangle is vertical with no crossings;</li>
<li>the +1 tangle is diagonal with one crossing, where the upper string runs from bottom-left to top-right.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given arguments are coprime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>the numerator of the rational number that describes this tangle. </td></tr>
    <tr><td class="paramname">den</td><td>the denominator of the rational number that describes this tangle; this may be 0 (representing the infinity tangle). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae23fbb1a389e483e32f99c9eb1e3a3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23fbb1a389e483e32f99c9eb1e3a3e9">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>twists</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a tangle from the given number of twists. </p>
<p>If <em>twists</em> is positive, then the new tangle will consist of <em>twists</em> positive twists, stacked from left to right. If <em>twists</em> is negative, then the new tangle will consist of -(<em>twists</em>) negative twists, likewise stacked from left to right. If <em>twists</em> is zero, then the new tangle will be a horizontal tangle with no crossings at all.</p>
<p>In all cases, this is equivalent to calling the rational tangle constructor <a class="el" href="classregina_1_1Tangle.html" title="Represents a 2-tangle in the 3-ball.">Tangle</a>(<em>twists</em>, 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twists</td><td>the number of twists to perform; this may be positive, negative or zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96f37e1919de78b6d37143a4e5b634c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f37e1919de78b6d37143a4e5b634c4">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::torus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the (<em>p</em>,<em>q</em>) torus link. </p>
<p>The parameters <em>p</em> and <em>q</em> must be non-negative, but they do not need to be coprime.</p>
<p>All of the crossings in the resulting link will be positive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the first parameter of the torus link; this must be strictly non-negative. </td></tr>
    <tr><td class="paramname">q</td><td>the second parameter of the torus link; this must also be strictly non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (<em>p</em>, <em>q</em>) torus link. </dd></dl>

</div>
</div>
<a id="gaa4d5e4637efe2ed81e2c9588aaa76591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d5e4637efe2ed81e2c9588aaa76591">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference for some other link into the corresponding strand reference for this link. </p>
<p>Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other link, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this link.</p>
<p>This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this link. </dd></dl>

</div>
</div>
<a id="ga013419d2ffd00eb93d85b4aaae713209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013419d2ffd00eb93d85b4aaae713209">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference for some other tangle into the corresponding strand reference for this tangle. </p>
<p>Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other tangle, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this tangle.</p>
<p>This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this tangle. </dd></dl>

</div>
</div>
<a id="gab9e9710e3cb111fc0e4826f41d024db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e9710e3cb111fc0e4826f41d024db5">&#9670;&nbsp;</a></span>traverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> regina::ModelLinkGraphArc::traverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the same edge of the model graph, but seen from the other endpoint. </p>
<p>Recall that each undirected edge of a model graph has two corresponding <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects, one for each of its endpoints. If this object represents one of these arcs for some underlying edge of the graph, then then return value represents the other.</p>
<p>Note that, for any arc <em>a</em>, <code>a.traverse().<a class="el" href="group__link.html#gab9e9710e3cb111fc0e4826f41d024db5" title="Returns the same edge of the model graph, but seen from the other endpoint.">traverse()</a></code> is identical to <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not a null arc, i.e., <a class="el" href="group__link.html#ga0646e70ea3216d097bbbb1c99d6b54c1" title="The node of the model graph from which this arc exits.">node()</a> does not return <code>null</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the arc at the other end of the underlying edge of the model graph. </dd></dl>

</div>
</div>
<a id="ga505f8c04024d001dcfc0bfa56d37dc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505f8c04024d001dcfc0bfa56d37dc2e">&#9670;&nbsp;</a></span>trefoil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::trefoil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the right-hand trefoil. </p>
<p>This returns the same knot as <a class="el" href="group__link.html#ga7e853bc606868629122e542e48ec6430" title="Returns a three-crossing diagram of the right-hand trefoil.">trefoilRight()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaeb3ec2cdad02e186e7d2d89f563aaeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3ec2cdad02e186e7d2d89f563aaeca">&#9670;&nbsp;</a></span>trefoilLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::trefoilLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the left-hand trefoil. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga7e853bc606868629122e542e48ec6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e853bc606868629122e542e48ec6430">&#9670;&nbsp;</a></span>trefoilRight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::trefoilRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a three-crossing diagram of the right-hand trefoil. </p>
<p>This returns the same knot as <a class="el" href="group__link.html#ga505f8c04024d001dcfc0bfa56d37dc2e" title="Returns a three-crossing diagram of the right-hand trefoil.">trefoil()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gabfe8878a670f2cea6734f336cb9d563f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfe8878a670f2cea6734f336cb9d563f">&#9670;&nbsp;</a></span>turn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::turn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this tangle by 90 degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>either 1 if the tangle should be rotated clockwise, or -1 if the tangle should be rotated anticlockwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1bf4a4fa65f6b91f929833f55fb2c06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf4a4fa65f6b91f929833f55fb2c06f">&#9670;&nbsp;</a></span>twist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::twist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a twist to the right-hand end of this tangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>either 1 if we should perform a positive twist (dragging the bottom-right endpoint up over the top-right endpoint), or -1 if we should perform a negative twist (dragging the bottom-right endpoint up beneath the top-right endpoint). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab88015bcdf131873362ba1da8e26507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab88015bcdf131873362ba1da8e26507c">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::Tangle::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the type of this tangle. </p>
<p>This will be one of the characters <code>-</code>, <code></code>| or <code>x</code>, indicating a horizontal, vertical or diagonal type as described in the class notes.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this crossing. </dd></dl>

</div>
</div>
<a id="ga5ed3d9d76a5e1554c595c79f5d5bce61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed3d9d76a5e1554c595c79f5d5bce61">&#9670;&nbsp;</a></span>under()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::under </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running under this crossing. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>this</code>, 0).</p>
<p>Note that <a class="el" href="group__link.html#gaaf2b9f54049a9d814d6a6abe87de3edc" title="Returns a reference to the strand running under this crossing.">lower()</a> and <a class="el" href="group__link.html#ga5ed3d9d76a5e1554c595c79f5d5bce61" title="Returns a reference to the strand running under this crossing.">under()</a> are synonyms.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the lower strand for this crossing. </dd></dl>

</div>
</div>
<a id="ga6eb25d5d808233928b2756621f3b47b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eb25d5d808233928b2756621f3b47b6">&#9670;&nbsp;</a></span>unknot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::unknot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a zero-crossing diagram of the unknot. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga8b28abed9edb209f54747b5e926530b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b28abed9edb209f54747b5e926530b8">&#9670;&nbsp;</a></span>upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Crossing::upper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the strand running over this crossing. </p>
<p>This is equivalent to directly constructing <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a>(<code>this</code>, 1).</p>
<p>Note that <a class="el" href="group__link.html#ga8b28abed9edb209f54747b5e926530b8" title="Returns a reference to the strand running over this crossing.">upper()</a> and <a class="el" href="group__link.html#ga3dd364d5dc16aaa052accbc0131585b4" title="Returns a reference to the strand running over this crossing.">over()</a> are synonyms.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the upper strand for this crossing. </dd></dl>

</div>
</div>
<a id="ga7b845088fe7d44ab3da72b9fa9abddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b845088fe7d44ab3da72b9fa9abddc0">&#9670;&nbsp;</a></span>useTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::useTreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td>
          <td class="paramname"><em>td</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link. </p>
<p>For some link routines, including <a class="el" href="group__link.html#gadf9867163e5b6defa9aa85d9bd8d9963" title="Returns a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.">niceTreeDecomposition()</a> as well as computations such as <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> that support the option ALG_TREEWIDTH, Regina needs a tree decomposition of the planar 4-valent multigraph formed by this link diagram.</p>
<p>By default, Regina will compute (and then cache) such a tree decomposition itself, using in-built greedy heuristics. This routine allows you to supply your <em>own</em> tree decomposition (which, for example, might be a smaller-width tree decomposition that you found using third-party software). By supplying your own tree decomposition <em>td</em> through this routine, Regina will throw away any pre-computed tree decomposition that it has cached, and will instead cache <em>td</em> for future use instead.</p>
<p>Regina will not claim ownership of <em>td</em>, and will not edit it in any way. Instead, it will make a deep copy of <em>td</em> and then modify this copy for its purposes.</p>
<p>In particular, <em>td</em> does not need to be a <em>nice</em> tree decomposition (indeed, it does not need to have any special properties beyond the definition of a tree decomposition). Regina will automatically create a nice tree decomposition from it if <em>td</em> is not nice already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">td</td><td>a tree decomposition of the planar 4-valent multigraph formed by this link diagram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66bec3dc74f7d1fc1ef2ce9cde5508ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66bec3dc74f7d1fc1ef2ce9cde5508ae">&#9670;&nbsp;</a></span>whitehead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::ExampleLink::whitehead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a five-crossing diagram of the Whitehead link. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga8f682deb7aeb5c9e3b06c8db4aec3b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f682deb7aeb5c9e3b06c8db4aec3b92">&#9670;&nbsp;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the underlying planar 4-valent multigraph using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>In summary, the output will consist of several lines of text:</p>
<ul>
<li>If this link has a packet label, then the output will begin with a descriptive comment line of the form <code>c <em>label</em></code>. Otherwise this initial comment line will be omitted.</li>
<li>Next will be a line of the form <code>p&#160;tw&#160;<em>num_vertices</em>&#160;<em>num_edges</em></code>. Note that, since the underlying graph comes from a link diagram, we will always have <em>num_edges</em> equal to twice <em>num_vertices</em>.</li>
<li>Following this will be <em>num_edges</em> lines, one for each edge, each of the form <code><em>u&#160;v</em></code>, indicating an edge from vertex number <em>u</em> to vertex number <em>v</em>. In this format, vertices are numbered 1,2,...,<em>num_vertices</em>.</li>
</ul>
<p>An example of this text format is as follows:</p>
<pre class="fragment">c Figure eight knot
p tw 4 8
1 2
1 4
1 2
2 3
3 4
1 3
3 4
2 4
</pre><dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ga083ba1db333340322c8645943960b27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083ba1db333340322c8645943960b27b">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Crossing::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga975bbe195b67d788056adf21946d8025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975bbe195b67d788056adf21946d8025">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraphNode::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this node to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89355292f9354c4d8bfc7d5468ee26f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89355292f9354c4d8bfc7d5468ee26f5">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae17ec70fa784c46ac7103fbe705b9a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae17ec70fa784c46ac7103fbe705b9a62">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraphCells::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafafb3ede468c74cd0a7280f8a5d0fcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafafb3ede468c74cd0a7280f8a5d0fcc2">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this tangle to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58309b754fc2392ea83ee63c77a961b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58309b754fc2392ea83ee63c77a961b8">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga3c68b505c86d79080a75532d920580d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c68b505c86d79080a75532d920580d8">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Crossing::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b5a0123fd3b826b561da8f88c5cb74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5a0123fd3b826b561da8f88c5cb74a">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraphNode::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this node to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab4b88c8eb92b6c9abe6f557c3221486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4b88c8eb92b6c9abe6f557c3221486">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93a19ea743c6ed6d3908043a0ef9dc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a19ea743c6ed6d3908043a0ef9dc2e">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraphCells::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc9da0489723b099bd15bf729a401933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc9da0489723b099bd15bf729a401933">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this tangle to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga645147f6f603066ea0eb85a8d0978578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645147f6f603066ea0eb85a8d0978578">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="ga4df95452d2c6fdd8ec754c5adbaf9505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df95452d2c6fdd8ec754c5adbaf9505">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="gaed6e5a318a8fdab39ebea49912074d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6e5a318a8fdab39ebea49912074d19">&#9670;&nbsp;</a></span>writhe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writhe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the writhe of this link diagram. </p>
<p>This is <em>not</em> an invariant of the link; instead it depends on the particular link diagram. It is computed as the sum of the signs of all crossings. It is preserved under Reidemeister moves II and III, but not I.</p>
<dl class="section return"><dt>Returns</dt><dd>the writhe. </dd></dl>

</div>
</div>
<a id="ga30157129e97cea92b3dd4f860c8d113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30157129e97cea92b3dd4f860c8d113e">&#9670;&nbsp;</a></span>XMLLinkComponentsReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLLinkComponentsReader::XMLLinkComponentsReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new components reader. </p>
<p>The given link should have all its crossings and connections set up, but should have an empty list of components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link being read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcd8b63fbd08aeb21c39ad013f45fe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd8b63fbd08aeb21c39ad013f45fe9b">&#9670;&nbsp;</a></span>XMLLinkConnectionsReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLLinkConnectionsReader::XMLLinkConnectionsReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new connections reader. </p>
<p>The given link should have its crossings initialised, but with no connections between them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link being read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f438ca8890283c5a3b830d79798491a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f438ca8890283c5a3b830d79798491a">&#9670;&nbsp;</a></span>XMLLinkCrossingsReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLLinkCrossingsReader::XMLLinkCrossingsReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new crossings reader. </p>
<p>The given link should be empty; its crossings will be created by this reader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link being read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae24c90c6bbf8bf637565fed530eb96f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24c90c6bbf8bf637565fed530eb96f2">&#9670;&nbsp;</a></span>XMLLinkReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLLinkReader::XMLLinkReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot/link reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca93be82c5a263db9e3dc28a928fb4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca93be82c5a263db9e3dc28a928fb4ba">&#9670;&nbsp;</a></span>~Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::~Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this link. </p>
<p>The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this link will also be destroyed. </p>

</div>
</div>
<a id="gac9a6e5615cb448d21f99332ba6ffcbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a6e5615cb448d21f99332ba6ffcbe1">&#9670;&nbsp;</a></span>~ModelLinkGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::~ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this graph. </p>
<p>The <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> objects contained in this graph will also be destroyed. </p>

</div>
</div>
<a id="ga9f4806ed0e22f0f4461479e1f80b28c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f4806ed0e22f0f4461479e1f80b28c2">&#9670;&nbsp;</a></span>~ModelLinkGraphCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraphCells::~ModelLinkGraphCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this cellular decomposition. </p>

</div>
</div>
<a id="gabda30f07f41d668822fb525b8253b8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabda30f07f41d668822fb525b8253b8d0">&#9670;&nbsp;</a></span>~Tangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::~Tangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tangle. </p>
<p>The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this tangle will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf6b2ca40f892a2375f27159cf11314ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b2ca40f892a2375f27159cf11314ac">&#9670;&nbsp;</a></span>homflyAZVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the mathematical symbol <em>alpha</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="ga0a3c7bb6dae63c7e28696f33f79ac6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3c7bb6dae63c7e28696f33f79ac6db">&#9670;&nbsp;</a></span>homflyAZVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="group__link.html#ga173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the single character <em>z</em>.</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="gabf4891884482d63762104e45c064375c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4891884482d63762104e45c064375c">&#9670;&nbsp;</a></span>homflyLMVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the mathematical script symbol for <em>l</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="gace9dcc4b15180a96d0d2c8d0cbb157ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9dcc4b15180a96d0d2c8d0cbb157ab">&#9670;&nbsp;</a></span>homflyLMVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="group__link.html#ga8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the single character <em>m</em>.</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="ga65375567e9a939248cef8a464e1ea0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65375567e9a939248cef8a464e1ea0c7">&#9670;&nbsp;</a></span>homflyVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarX. See the documentation for homflyAZVarX for further details. </p>

</div>
</div>
<a id="ga79b39da1b23893a682ff22b388041fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b39da1b23893a682ff22b388041fdc">&#9670;&nbsp;</a></span>homflyVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="group__link.html#gaa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarY. See the documentation for homflyAZVarY for further details. </p>

</div>
</div>
<a id="ga7063f2022a096350cb8e25cd937a94cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7063f2022a096350cb8e25cd937a94cc">&#9670;&nbsp;</a></span>jonesVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::jonesVar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Jones polynomial, as returned by <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>. </p>
<p>This is provided to help with pretty-printing Jones polynomials for human consumption.</p>
<p>Since <a class="el" href="group__link.html#gad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>, this string is just a human-readable representation of the square root of <em>t</em> (encoded in UTF-8).</p>
<p>To pretty-print the Jones polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
