<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::HSVectorStandard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1HSVectorStandard.html">HSVectorStandard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1HSVectorStandard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::HSVectorStandard Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A normal hypersurface vector using standard tetrahedron-prism coordinates.  
 <a href="classregina_1_1HSVectorStandard.html#details">More...</a></p>

<p><code>#include &lt;hypersurface/hsvectorstandard.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::HSVectorStandard:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1HSVectorStandard.png" usemap="#regina::HSVectorStandard_map" alt=""/>
  <map id="regina::HSVectorStandard_map" name="regina::HSVectorStandard_map">
<area href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation." alt="regina::NormalHypersurfaceVector" shape="rect" coords="0,0,210,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9335c20b89d0000a3f24b47b7c5e3a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html#a9335c20b89d0000a3f24b47b7c5e3a8b">HSVectorStandard</a> (size_t length)</td></tr>
<tr class="memdesc:a9335c20b89d0000a3f24b47b7c5e3a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#a9335c20b89d0000a3f24b47b7c5e3a8b">More...</a><br /></td></tr>
<tr class="separator:a9335c20b89d0000a3f24b47b7c5e3a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12ebadec57a732b15f170bd3c4e4d2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html#ab12ebadec57a732b15f170bd3c4e4d2c">HSVectorStandard</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ab12ebadec57a732b15f170bd3c4e4d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#ab12ebadec57a732b15f170bd3c4e4d2c">More...</a><br /></td></tr>
<tr class="separator:ab12ebadec57a732b15f170bd3c4e4d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3034b9229803e759b39cc4f9cc3bb093"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html#a3034b9229803e759b39cc4f9cc3bb093">tetrahedra</a> (size_t pentIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:a3034b9229803e759b39cc4f9cc3bb093"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="#a3034b9229803e759b39cc4f9cc3bb093">More...</a><br /></td></tr>
<tr class="separator:a3034b9229803e759b39cc4f9cc3bb093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8a380fc2a185f6e045c9707f1d5983"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html#a1a8a380fc2a185f6e045c9707f1d5983">prisms</a> (size_t pentIndex, int prismType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:a1a8a380fc2a185f6e045c9707f1d5983"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="#a1a8a380fc2a185f6e045c9707f1d5983">More...</a><br /></td></tr>
<tr class="separator:a1a8a380fc2a185f6e045c9707f1d5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8360d22d501c9c135decdd73708c00bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html#a8360d22d501c9c135decdd73708c00bd">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:a8360d22d501c9c135decdd73708c00bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="#a8360d22d501c9c135decdd73708c00bd">More...</a><br /></td></tr>
<tr class="separator:a8360d22d501c9c135decdd73708c00bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccc8e495f977c5d2d8ae949ac420673"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a2ccc8e495f977c5d2d8ae949ac420673">coords</a> () const</td></tr>
<tr class="memdesc:a2ccc8e495f977c5d2d8ae949ac420673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="#a2ccc8e495f977c5d2d8ae949ac420673">More...</a><br /></td></tr>
<tr class="separator:a2ccc8e495f977c5d2d8ae949ac420673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470f49e212ea52daeb876f0befd5338a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a470f49e212ea52daeb876f0befd5338a">clone</a> () const =0</td></tr>
<tr class="memdesc:a470f49e212ea52daeb876f0befd5338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#a470f49e212ea52daeb876f0befd5338a">More...</a><br /></td></tr>
<tr class="separator:a470f49e212ea52daeb876f0befd5338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafcf1b859ef233f5193551626a5c30b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#aeafcf1b859ef233f5193551626a5c30b">size</a> () const</td></tr>
<tr class="memdesc:aeafcf1b859ef233f5193551626a5c30b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="#aeafcf1b859ef233f5193551626a5c30b">More...</a><br /></td></tr>
<tr class="separator:aeafcf1b859ef233f5193551626a5c30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1980760753447daa6075c86305e03121"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a1980760753447daa6075c86305e03121">operator []</a> (size_t index) const</td></tr>
<tr class="memdesc:a1980760753447daa6075c86305e03121"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="#a1980760753447daa6075c86305e03121">More...</a><br /></td></tr>
<tr class="separator:a1980760753447daa6075c86305e03121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c275dac12626724b3c4f87eb99cd7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a9a8c275dac12626724b3c4f87eb99cd7">setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:a9a8c275dac12626724b3c4f87eb99cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="#a9a8c275dac12626724b3c4f87eb99cd7">More...</a><br /></td></tr>
<tr class="separator:a9a8c275dac12626724b3c4f87eb99cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03282d464e943ec673ae5d04a33533a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a03282d464e943ec673ae5d04a33533a2">operator+=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;other)</td></tr>
<tr class="memdesc:a03282d464e943ec673ae5d04a33533a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#a03282d464e943ec673ae5d04a33533a2">More...</a><br /></td></tr>
<tr class="separator:a03282d464e943ec673ae5d04a33533a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242996a39b1ab9b3198610b2f4d2e7a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a242996a39b1ab9b3198610b2f4d2e7a4">scaleDown</a> ()</td></tr>
<tr class="memdesc:a242996a39b1ab9b3198610b2f4d2e7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a242996a39b1ab9b3198610b2f4d2e7a4">More...</a><br /></td></tr>
<tr class="separator:a242996a39b1ab9b3198610b2f4d2e7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac3e7f7cce9c678b91073859a9395ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a6ac3e7f7cce9c678b91073859a9395ca">isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:a6ac3e7f7cce9c678b91073859a9395ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is compact (has finitely many pieces).  <a href="#a6ac3e7f7cce9c678b91073859a9395ca">More...</a><br /></td></tr>
<tr class="separator:a6ac3e7f7cce9c678b91073859a9395ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38e0ba79fe11756f4a68620fad07f2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#af38e0ba79fe11756f4a68620fad07f2b">isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:af38e0ba79fe11756f4a68620fad07f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is vertex linking.  <a href="#af38e0ba79fe11756f4a68620fad07f2b">More...</a><br /></td></tr>
<tr class="separator:af38e0ba79fe11756f4a68620fad07f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6257bfb963173e01255bd29864ca9482"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a6257bfb963173e01255bd29864ca9482">isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:a6257bfb963173e01255bd29864ca9482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex.  <a href="#a6257bfb963173e01255bd29864ca9482">More...</a><br /></td></tr>
<tr class="separator:a6257bfb963173e01255bd29864ca9482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8cefb8b876ef5c98ece1f393313ec3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a0b8cefb8b876ef5c98ece1f393313ec3">isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:a0b8cefb8b876ef5c98ece1f393313ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge.  <a href="#a0b8cefb8b876ef5c98ece1f393313ec3">More...</a><br /></td></tr>
<tr class="separator:a0b8cefb8b876ef5c98ece1f393313ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7ee890b4675a4687db07a5e68e9e5012"><td class="memItemLeft" align="right" valign="top"><a id="a7ee890b4675a4687db07a5e68e9e5012"></a>
static <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:a7ee890b4675a4687db07a5e68e9e5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69434561e0e2a95461d9c38701aab0ae"><td class="memItemLeft" align="right" valign="top"><a id="a69434561e0e2a95461d9c38701aab0ae"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:a69434561e0e2a95461d9c38701aab0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210183287c873acec33a517efb58cdc"><td class="memItemLeft" align="right" valign="top"><a id="ad210183287c873acec33a517efb58cdc"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:ad210183287c873acec33a517efb58cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a08e1b5afcd3630b9ec7fd7244d53776c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a08e1b5afcd3630b9ec7fd7244d53776c">coords_</a></td></tr>
<tr class="memdesc:a08e1b5afcd3630b9ec7fd7244d53776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="#a08e1b5afcd3630b9ec7fd7244d53776c">More...</a><br /></td></tr>
<tr class="separator:a08e1b5afcd3630b9ec7fd7244d53776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A normal hypersurface vector using standard tetrahedron-prism coordinates. </p>
<p>If there are <em>p</em> pentachora in the underlying triangulation, there must be precisely 15<em>p</em> coordinates. The first 15 coordinates will be for the first pentachoron, the next 15 for the second pentachoron and so on. For each pentachoron, the first five represent the number of tetrahedron pieces about vertex 0,...,4, and the next ten represent the number of prism pieces of type 0,...,9 (see <a class="el" href="classregina_1_1NormalHypersurface.html#a34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurface::prisms()</a> for details).</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9335c20b89d0000a3f24b47b7c5e3a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9335c20b89d0000a3f24b47b7c5e3a8b">&#9670;&nbsp;</a></span>HSVectorStandard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HSVectorStandard::HSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab12ebadec57a732b15f170bd3c4e4d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12ebadec57a732b15f170bd3c4e4d2c">&#9670;&nbsp;</a></span>HSVectorStandard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HSVectorStandard::HSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a470f49e212ea52daeb876f0befd5338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470f49e212ea52daeb876f0befd5338a">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::NormalHypersurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="a2ccc8e495f977c5d2d8ae949ac420673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccc8e495f977c5d2d8ae949ac420673">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalHypersurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="a8360d22d501c9c135decdd73708c00bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8360d22d501c9c135decdd73708c00bd">&#9670;&nbsp;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NormalHypersurface.html#ae0661d930754b6c681e6a23595a36476" title="Returns the number of times this normal hypersurface crosses the given edge.">NormalHypersurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;4&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#aa1957334b91441cd0c21c3da25c105c8">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<a id="a6ac3e7f7cce9c678b91073859a9395ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac3e7f7cce9c678b91073859a9395ca">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalHypersurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is compact (has finitely many pieces). </p>
<p>The default implementation for this routine simply runs through every piece type until a piece type with infinite piece count is found or all piece types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is compact. </dd></dl>

</div>
</div>
<a id="a0b8cefb8b876ef5c98ece1f393313ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8cefb8b876ef5c98ece1f393313ec3">&#9670;&nbsp;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;4&gt;* regina::NormalHypersurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by this hypersurface, or 0 if this hypersurface is not a thin edge link. </dd></dl>

</div>
</div>
<a id="a6257bfb963173e01255bd29864ca9482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6257bfb963173e01255bd29864ca9482">&#9670;&nbsp;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;4&gt;* regina::NormalHypersurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this hypersurface, or 0 if this hypersurface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a id="af38e0ba79fe11756f4a68620fad07f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38e0ba79fe11756f4a68620fad07f2b">&#9670;&nbsp;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalHypersurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>The default implementation for this routine simply runs through every non-tetrahedron piece type ensuring that each has no corresponding pieces. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="a1980760753447daa6075c86305e03121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1980760753447daa6075c86305e03121">&#9670;&nbsp;</a></span>operator []()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalHypersurfaceVector::operator [] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#aeafcf1b859ef233f5193551626a5c30b" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="a03282d464e943ec673ae5d04a33533a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03282d464e943ec673ae5d04a33533a2">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal hypersurfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a8a380fc2a185f6e045c9707f1d5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8a380fc2a185f6e045c9707f1d5983">&#9670;&nbsp;</a></span>prisms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="classregina_1_1NormalHypersurface.html#a34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurface::prisms()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prism pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a0d96a0eb204333f4deff8f7cacefdb00">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<a id="a242996a39b1ab9b3198610b2f4d2e7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242996a39b1ab9b3198610b2f4d2e7a4">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

</div>
</div>
<a id="a9a8c275dac12626724b3c4f87eb99cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8c275dac12626724b3c4f87eb99cd7">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must e between 0 and <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#aeafcf1b859ef233f5193551626a5c30b" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeafcf1b859ef233f5193551626a5c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafcf1b859ef233f5193551626a5c30b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="a3034b9229803e759b39cc4f9cc3bb093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3034b9229803e759b39cc4f9cc3bb093">&#9670;&nbsp;</a></span>tetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="classregina_1_1NormalHypersurface.html#a5e571077474b0899732e60f6c3c393df" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NormalHypersurface::tetrahedra()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested tetrahedron pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested tetrahedron pieces lie; this should be between 0 and 4 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#abcecbbd6ed6b1c905604345e755e9a23">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a08e1b5afcd3630b9ec7fd7244d53776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e1b5afcd3630b9ec7fd7244d53776c">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalHypersurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hypersurface/<a class="el" href="hsvectorstandard_8h.html">hsvectorstandard.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
