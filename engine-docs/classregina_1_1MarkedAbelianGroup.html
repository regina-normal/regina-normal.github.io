<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::MarkedAbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1MarkedAbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::MarkedAbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a finitely generated abelian group given by a chain complex.  
 <a href="classregina_1_1MarkedAbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/markedabeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::MarkedAbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1MarkedAbelianGroup.png" usemap="#regina::MarkedAbelianGroup_map" alt=""/>
  <map id="regina::MarkedAbelianGroup_map" name="regina::MarkedAbelianGroup_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; MarkedAbelianGroup, true &gt;" shape="rect" coords="0,56,315,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; MarkedAbelianGroup, supportsUtf8 &gt;" shape="rect" coords="0,0,315,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af2ffa5d54abe1ead15dc3cf8db0e7426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#af2ffa5d54abe1ead15dc3cf8db0e7426">MarkedAbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="classregina_1_1MarkedAbelianGroup.html#a746b854c7cfea2e4c5852a72565058b4">M</a>, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="classregina_1_1MarkedAbelianGroup.html#a48c5e7997650a39ab835814a0ed5cc61">N</a>)</td></tr>
<tr class="memdesc:af2ffa5d54abe1ead15dc3cf8db0e7426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex.  <a href="#af2ffa5d54abe1ead15dc3cf8db0e7426">More...</a><br /></td></tr>
<tr class="separator:af2ffa5d54abe1ead15dc3cf8db0e7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ac7d4799e5082c5454caef301a60d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ada0ac7d4799e5082c5454caef301a60d">MarkedAbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="classregina_1_1MarkedAbelianGroup.html#a746b854c7cfea2e4c5852a72565058b4">M</a>, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="classregina_1_1MarkedAbelianGroup.html#a48c5e7997650a39ab835814a0ed5cc61">N</a>, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;pcoeff)</td></tr>
<tr class="memdesc:ada0ac7d4799e5082c5454caef301a60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex with coefficients in Z_p.  <a href="#ada0ac7d4799e5082c5454caef301a60d">More...</a><br /></td></tr>
<tr class="separator:ada0ac7d4799e5082c5454caef301a60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ac293e56e8222e2e5ff7a75fb5d6a8b36">MarkedAbelianGroup</a> (unsigned long rk, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:ac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a free Z_p-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z &ndash;p--&gt; Z --&gt; 0</code>.  <a href="#ac293e56e8222e2e5ff7a75fb5d6a8b36">More...</a><br /></td></tr>
<tr class="separator:ac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41084d6f839ceb295e3aaadf022c8c4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a41084d6f839ceb295e3aaadf022c8c4e">MarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a41084d6f839ceb295e3aaadf022c8c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="#a41084d6f839ceb295e3aaadf022c8c4e">More...</a><br /></td></tr>
<tr class="separator:a41084d6f839ceb295e3aaadf022c8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466303b009840a96e49874e0f139854d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a466303b009840a96e49874e0f139854d">isChainComplex</a> () const</td></tr>
<tr class="memdesc:a466303b009840a96e49874e0f139854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the defining maps for this group actually give a chain complex.  <a href="#a466303b009840a96e49874e0f139854d">More...</a><br /></td></tr>
<tr class="separator:a466303b009840a96e49874e0f139854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ce1a1c59819c497cd964486be934f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a000ce1a1c59819c497cd964486be934f">rank</a> () const</td></tr>
<tr class="memdesc:a000ce1a1c59819c497cd964486be934f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group.  <a href="#a000ce1a1c59819c497cd964486be934f">More...</a><br /></td></tr>
<tr class="separator:a000ce1a1c59819c497cd964486be934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f15cbf9347b95351868181735e7dbd"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a99f15cbf9347b95351868181735e7dbd">torsionRank</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;<a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:a99f15cbf9347b95351868181735e7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="#a99f15cbf9347b95351868181735e7dbd">More...</a><br /></td></tr>
<tr class="separator:a99f15cbf9347b95351868181735e7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dca8084edda8307373869fd840fe586"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a2dca8084edda8307373869fd840fe586">torsionRank</a> (unsigned long <a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:a2dca8084edda8307373869fd840fe586"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="#a2dca8084edda8307373869fd840fe586">More...</a><br /></td></tr>
<tr class="separator:a2dca8084edda8307373869fd840fe586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25dc94bfeb64347d3d88ed3505334d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5">countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:aa25dc94bfeb64347d3d88ed3505334d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group.  <a href="#aa25dc94bfeb64347d3d88ed3505334d5">More...</a><br /></td></tr>
<tr class="separator:aa25dc94bfeb64347d3d88ed3505334d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e8b466766eb274146277ac9bd98a55"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab5e8b466766eb274146277ac9bd98a55">minNumberOfGenerators</a> () const</td></tr>
<tr class="memdesc:ab5e8b466766eb274146277ac9bd98a55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the minimum number of generators for the group.  <a href="#ab5e8b466766eb274146277ac9bd98a55">More...</a><br /></td></tr>
<tr class="separator:ab5e8b466766eb274146277ac9bd98a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a1646cf2d9cb4bc31b0b0df1f1f4289a4">invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group.  <a href="#a1646cf2d9cb4bc31b0b0df1f1f4289a4">More...</a><br /></td></tr>
<tr class="separator:a1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2511bd16caaaeb926df617a731c965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a1b2511bd16caaaeb926df617a731c965">isTrivial</a> () const</td></tr>
<tr class="memdesc:a1b2511bd16caaaeb926df617a731c965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="#a1b2511bd16caaaeb926df617a731c965">More...</a><br /></td></tr>
<tr class="separator:a1b2511bd16caaaeb926df617a731c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65d588478bdbfc871d9d8e94d690ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a7c65d588478bdbfc871d9d8e94d690ff">isZ</a> () const</td></tr>
<tr class="memdesc:a7c65d588478bdbfc871d9d8e94d690ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="#a7c65d588478bdbfc871d9d8e94d690ff">More...</a><br /></td></tr>
<tr class="separator:a7c65d588478bdbfc871d9d8e94d690ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04a54db050fca088bad38c7b5b9c980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad04a54db050fca088bad38c7b5b9c980">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ad04a54db050fca088bad38c7b5b9c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are isomorphic.  <a href="#ad04a54db050fca088bad38c7b5b9c980">More...</a><br /></td></tr>
<tr class="separator:ad04a54db050fca088bad38c7b5b9c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c17b81d8ed166a87d1f57d0864d61e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a7c17b81d8ed166a87d1f57d0864d61e7">equalTo</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a7c17b81d8ed166a87d1f57d0864d61e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the two MarkedAbelianGroups are identical, which means they have exactly the same presentation matrices.  <a href="#a7c17b81d8ed166a87d1f57d0864d61e7">More...</a><br /></td></tr>
<tr class="separator:a7c17b81d8ed166a87d1f57d0864d61e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db2c8ef127dba9ee3717e8660a7da43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a7db2c8ef127dba9ee3717e8660a7da43">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:a7db2c8ef127dba9ee3717e8660a7da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>.  <a href="#a7db2c8ef127dba9ee3717e8660a7da43">More...</a><br /></td></tr>
<tr class="separator:a7db2c8ef127dba9ee3717e8660a7da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e2133542af695b8b850b6281ee6feb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#af0e2133542af695b8b850b6281ee6feb">freeRep</a> (unsigned long index) const</td></tr>
<tr class="memdesc:af0e2133542af695b8b850b6281ee6feb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested free generator in the original chain complex defining the group.  <a href="#af0e2133542af695b8b850b6281ee6feb">More...</a><br /></td></tr>
<tr class="separator:af0e2133542af695b8b850b6281ee6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdebf3efcd47ef18d96369b243794b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a2cdebf3efcd47ef18d96369b243794b9">torsionRep</a> (unsigned long index) const</td></tr>
<tr class="memdesc:a2cdebf3efcd47ef18d96369b243794b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested generator of the torsion subgroup but represented in the original chain complex defining the group.  <a href="#a2cdebf3efcd47ef18d96369b243794b9">More...</a><br /></td></tr>
<tr class="separator:a2cdebf3efcd47ef18d96369b243794b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77834f35e4900eed8e928688ce898f2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a77834f35e4900eed8e928688ce898f2a">ccRep</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;SNFRep) const</td></tr>
<tr class="memdesc:a77834f35e4900eed8e928688ce898f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of freeRep and torsionRep, this routine takes a vector which represents an element in the group in the SNF coordinates and returns a corresponding vector in the original chain complex.  <a href="#a77834f35e4900eed8e928688ce898f2a">More...</a><br /></td></tr>
<tr class="separator:a77834f35e4900eed8e928688ce898f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf137dca4e97dfa1ef9f703f2787008"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aebf137dca4e97dfa1ef9f703f2787008">ccRep</a> (unsigned long SNFRep) const</td></tr>
<tr class="memdesc:aebf137dca4e97dfa1ef9f703f2787008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ccRep(const std::vector&lt;Integer&gt;&amp;), but we assume you only want the chain complex representation of a standard basis vector from SNF coordinates.  <a href="#aebf137dca4e97dfa1ef9f703f2787008">More...</a><br /></td></tr>
<tr class="separator:aebf137dca4e97dfa1ef9f703f2787008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63e1b742025e5d366ee982cbf618ec8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ae63e1b742025e5d366ee982cbf618ec8">cycleProjection</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;ccelt) const</td></tr>
<tr class="memdesc:ae63e1b742025e5d366ee982cbf618ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an element of the chain complex to the subspace of cycles.  <a href="#ae63e1b742025e5d366ee982cbf618ec8">More...</a><br /></td></tr>
<tr class="separator:ae63e1b742025e5d366ee982cbf618ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b08ed9f51b87f8390c5f38996b82e38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a1b08ed9f51b87f8390c5f38996b82e38">cycleProjection</a> (unsigned long ccindx) const</td></tr>
<tr class="memdesc:a1b08ed9f51b87f8390c5f38996b82e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an element of the chain complex to the subspace of cycles.  <a href="#a1b08ed9f51b87f8390c5f38996b82e38">More...</a><br /></td></tr>
<tr class="separator:a1b08ed9f51b87f8390c5f38996b82e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df135646b8e56fa438477a849f4c9bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a6df135646b8e56fa438477a849f4c9bc">isCycle</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:a6df135646b8e56fa438477a849f4c9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector, determines if it represents a cycle in the chain complex.  <a href="#a6df135646b8e56fa438477a849f4c9bc">More...</a><br /></td></tr>
<tr class="separator:a6df135646b8e56fa438477a849f4c9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8c72fcfbf384f9c72742f7fc024f70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#abf8c72fcfbf384f9c72742f7fc024f70">boundaryMap</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;CCrep) const</td></tr>
<tr class="memdesc:abf8c72fcfbf384f9c72742f7fc024f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differential of the given vector in the chain complex whose kernel is the cycles.  <a href="#abf8c72fcfbf384f9c72742f7fc024f70">More...</a><br /></td></tr>
<tr class="separator:abf8c72fcfbf384f9c72742f7fc024f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8266305f2c94b9f7c7880715eba189e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa8266305f2c94b9f7c7880715eba189e">isBoundary</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:aa8266305f2c94b9f7c7880715eba189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector, determines if it represents a boundary in the chain complex.  <a href="#aa8266305f2c94b9f7c7880715eba189e">More...</a><br /></td></tr>
<tr class="separator:aa8266305f2c94b9f7c7880715eba189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea2ed41e910b2c52a6d5736283caa3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a94ea2ed41e910b2c52a6d5736283caa3">writeAsBoundary</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:a94ea2ed41e910b2c52a6d5736283caa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given vector as a boundary in the chain complex (if the vector is indeed a boundary at all).  <a href="#a94ea2ed41e910b2c52a6d5736283caa3">More...</a><br /></td></tr>
<tr class="separator:a94ea2ed41e910b2c52a6d5736283caa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f90140da9a0ab47482cb68a29078432"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a6f90140da9a0ab47482cb68a29078432">rankCC</a> () const</td></tr>
<tr class="memdesc:a6f90140da9a0ab47482cb68a29078432"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the chain complex supporting the homology computation.  <a href="#a6f90140da9a0ab47482cb68a29078432">More...</a><br /></td></tr>
<tr class="separator:a6f90140da9a0ab47482cb68a29078432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0563fc60015d3690c89776aaf94c956b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a0563fc60015d3690c89776aaf94c956b">snfRep</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;v) const</td></tr>
<tr class="memdesc:a0563fc60015d3690c89776aaf94c956b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given vector as a combination of free and torsion generators.  <a href="#a0563fc60015d3690c89776aaf94c956b">More...</a><br /></td></tr>
<tr class="separator:a0563fc60015d3690c89776aaf94c956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac714d64e8dca4bc06cce32c3ed26b8db"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#ac714d64e8dca4bc06cce32c3ed26b8db">minNumberCycleGens</a> () const</td></tr>
<tr class="memdesc:ac714d64e8dca4bc06cce32c3ed26b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators of ker(M), where M is one of the defining matrices of the chain complex.  <a href="#ac714d64e8dca4bc06cce32c3ed26b8db">More...</a><br /></td></tr>
<tr class="separator:ac714d64e8dca4bc06cce32c3ed26b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ec35918dfa4fb844982feac3fff28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#af38ec35918dfa4fb844982feac3fff28">cycleGen</a> (unsigned long i) const</td></tr>
<tr class="memdesc:af38ec35918dfa4fb844982feac3fff28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>i</em>th generator of the cycles, i.e., the kernel of M in the chain complex.  <a href="#af38ec35918dfa4fb844982feac3fff28">More...</a><br /></td></tr>
<tr class="separator:af38ec35918dfa4fb844982feac3fff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b854c7cfea2e4c5852a72565058b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a746b854c7cfea2e4c5852a72565058b4">M</a> () const</td></tr>
<tr class="memdesc:a746b854c7cfea2e4c5852a72565058b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;right&rsquo; matrix used in defining the chain complex.  <a href="#a746b854c7cfea2e4c5852a72565058b4">More...</a><br /></td></tr>
<tr class="separator:a746b854c7cfea2e4c5852a72565058b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c5e7997650a39ab835814a0ed5cc61"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a48c5e7997650a39ab835814a0ed5cc61">N</a> () const</td></tr>
<tr class="memdesc:a48c5e7997650a39ab835814a0ed5cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;left&rsquo; matrix used in defining the chain complex.  <a href="#a48c5e7997650a39ab835814a0ed5cc61">More...</a><br /></td></tr>
<tr class="separator:a48c5e7997650a39ab835814a0ed5cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1d6947da29e7eb4e2765f268da6d64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#abd1d6947da29e7eb4e2765f268da6d64">coefficients</a> () const</td></tr>
<tr class="memdesc:abd1d6947da29e7eb4e2765f268da6d64"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coefficients used for the computation of homology.  <a href="#abd1d6947da29e7eb4e2765f268da6d64">More...</a><br /></td></tr>
<tr class="separator:abd1d6947da29e7eb4e2765f268da6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964cf786ad3ed296a325f03f6d8bf51c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#a964cf786ad3ed296a325f03f6d8bf51c">torsionSubgroup</a> () const</td></tr>
<tr class="memdesc:a964cf786ad3ed296a325f03f6d8bf51c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> representing the torsion subgroup of this group.  <a href="#a964cf786ad3ed296a325f03f6d8bf51c">More...</a><br /></td></tr>
<tr class="separator:a964cf786ad3ed296a325f03f6d8bf51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9882af6b8ec2757932ac1c49833633"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html#aaa9882af6b8ec2757932ac1c49833633">torsionInclusion</a> () const</td></tr>
<tr class="memdesc:aaa9882af6b8ec2757932ac1c49833633"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the inclusion of the torsion subgroup into this group.  <a href="#aaa9882af6b8ec2757932ac1c49833633">More...</a><br /></td></tr>
<tr class="separator:aaa9882af6b8ec2757932ac1c49833633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74474b48927e2ff60bb026f5f4fa4eec"><td class="memItemLeft" align="right" valign="top"><a id="a74474b48927e2ff60bb026f5f4fa4eec"></a>
<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;)=delete</td></tr>
<tr class="separator:a74474b48927e2ff60bb026f5f4fa4eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:affec81b08826210c7ee5fa33e4de25e2"><td class="memItemLeft" align="right" valign="top"><a id="affec81b08826210c7ee5fa33e4de25e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HomMarkedAbelianGroup</b></td></tr>
<tr class="separator:affec81b08826210c7ee5fa33e4de25e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a finitely generated abelian group given by a chain complex. </p>
<p>This class is initialized with a chain complex. The chain complex is given in terms of two integer matrices <em>M</em> and <em>N</em> such that M*N=0. The abelian group is the kernel of <em>M</em> mod the image of <em>N</em>.</p>
<p>In other words, we are computing the homology of the chain complex <code>Z^a &ndash;N--&gt; Z^b &ndash;M--&gt; Z^c</code> where a=N.columns(), M.columns()=b=N.rows(), and c=M.rows(). An additional constructor allows one to take the homology with coefficients in an arbitrary cyclic group.</p>
<p>This class allows one to retrieve the invariant factors, the rank, and the corresponding vectors in the kernel of <em>M</em>. Moreover, given a vector in the kernel of <em>M</em>, it decribes the homology class of the vector (the free part, and its position in the invariant factors).</p>
<p>The purpose of this class is to allow one to not only represent homology groups, but it gives coordinates on the group allowing for the construction of homomorphisms, and keeping track of subgroups.</p>
<p>Some routines in this class refer to the internal <em>presentation matrix</em>. This is a proper presentation matrix for the abelian group, and is created by constructing the product MRBi() * <em>N</em>, and then removing the first rankM() rows.</p>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like. </p>
<p class="enddd">Testsuite additions: <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa8266305f2c94b9f7c7880715eba189e" title="Given a vector, determines if it represents a boundary in the chain complex.">isBoundary()</a>, <a class="el" href="classregina_1_1MarkedAbelianGroup.html#abf8c72fcfbf384f9c72742f7fc024f70" title="Computes the differential of the given vector in the chain complex whose kernel is the cycles.">boundaryMap()</a>, writeAsBdry(), <a class="el" href="classregina_1_1MarkedAbelianGroup.html#af38ec35918dfa4fb844982feac3fff28" title="Returns the ith generator of the cycles, i.e., the kernel of M in the chain complex.">cycleGen()</a>. </p>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af2ffa5d54abe1ead15dc3cf8db0e7426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ffa5d54abe1ead15dc3cf8db0e7426">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex. </p>
<p>This constructor assumes you're interested in homology with integer coefficents of the chain complex. Creates a marked abelian group given by the quotient of the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p>See the class notes for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada0ac7d4799e5082c5454caef301a60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0ac7d4799e5082c5454caef301a60d">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>pcoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex with coefficients in Z_p. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">pcoeff</td><td>specifies the coefficient ring, Z_pcoeff. We require <em>pcoeff</em> &gt;= 0. If you know beforehand that <em>pcoeff=0</em>, it's more efficient to use the previous constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac293e56e8222e2e5ff7a75fb5d6a8b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e56e8222e2e5ff7a75fb5d6a8b36">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a free Z_p-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z &ndash;p--&gt; Z --&gt; 0</code>. </p>
<p>So this group is isomorphic to <code>n Z_p</code>. Moreover, if constructed using the previous constructor, <em>M</em> would be zero and <em>N</em> would be diagonal and square with <em>p</em> down the diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>the rank of the group as a Z_p-module. That is, if the group is <code>n Z_p</code>, then <em>rk</em> should be <em>n</em>. </td></tr>
    <tr><td class="paramname">p</td><td>describes the type of ring that we use to talk about the "free" module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41084d6f839ceb295e3aaadf022c8c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41084d6f839ceb295e3aaadf022c8c4e">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf8c72fcfbf384f9c72742f7fc024f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8c72fcfbf384f9c72742f7fc024f70">&#9670;&nbsp;</a></span>boundaryMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::boundaryMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>CCrep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the differential of the given vector in the chain complex whose kernel is the cycles. </p>
<p>In other words, this routine returns <code>M*CCrep</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CCrep</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the differential, expressed as a vector of length M.rows(). </dd></dl>

</div>
</div>
<a id="a77834f35e4900eed8e928688ce898f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77834f35e4900eed8e928688ce898f2a">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SNFRep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of freeRep and torsionRep, this routine takes a vector which represents an element in the group in the SNF coordinates and returns a corresponding vector in the original chain complex. </p>
<p>This routine is the inverse to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a0563fc60015d3690c89776aaf94c956b" title="Expresses the given vector as a combination of free and torsion generators.">snfRep()</a> described below.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SNFRep</td><td>a vector of size the number of generators of the group, i.e., it must be valid in the SNF coordinates. If not, an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex; see the class notes for details. </dd></dl>

</div>
</div>
<a id="aebf137dca4e97dfa1ef9f703f2787008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf137dca4e97dfa1ef9f703f2787008">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>SNFRep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as ccRep(const std::vector&lt;Integer&gt;&amp;), but we assume you only want the chain complex representation of a standard basis vector from SNF coordinates. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SNFRep</td><td>specifies which standard basis vector from SNF coordinates; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab5e8b466766eb274146277ac9bd98a55" title="Returns the minimum number of generators for the group.">minNumberOfGenerators()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex; see the class notes for details. </dd></dl>

</div>
</div>
<a id="abd1d6947da29e7eb4e2765f268da6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1d6947da29e7eb4e2765f268da6d64">&#9670;&nbsp;</a></span>coefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp; regina::MarkedAbelianGroup::coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coefficients used for the computation of homology. </p>
<p>That is, this routine returns the integer <em>p</em> where we use coefficients in Z_p. If we use coefficients in the integers Z, then this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the coefficients used in the homology calculation. </dd></dl>

</div>
</div>
<a id="aa25dc94bfeb64347d3d88ed3505334d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25dc94bfeb64347d3d88ed3505334d5">&#9670;&nbsp;</a></span>countInvariantFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group. </p>
<p>This is the minimal number of torsion generators. See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="af38ec35918dfa4fb844982feac3fff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38ec35918dfa4fb844982feac3fff28">&#9670;&nbsp;</a></span>cycleGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleGen </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>i</em>th generator of the cycles, i.e., the kernel of M in the chain complex. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, as it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>between 0 and minNumCycleGens()-1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding generator in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ae63e1b742025e5d366ee982cbf618ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63e1b742025e5d366ee982cbf618ec8">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ccelt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an element of the chain complex to the subspace of cycles. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an empty vector if the input element does not have dimensions of the chain complex.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccelt</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector, also in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="a1b08ed9f51b87f8390c5f38996b82e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b08ed9f51b87f8390c5f38996b82e38">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ccindx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an element of the chain complex to the subspace of cycles. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an empty vector if the input index is out of bounds.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccindx</td><td>the index of the standard basis vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting projection, in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7c17b81d8ed166a87d1f57d0864d61e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c17b81d8ed166a87d1f57d0864d61e7">&#9670;&nbsp;</a></span>equalTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::equalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the two MarkedAbelianGroups are identical, which means they have exactly the same presentation matrices. </p>
<p>This is useful for determining if two HomMarkedAbelianGroups are composable. See <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ad04a54db050fca088bad38c7b5b9c980" title="Determines whether this and the given abelian group are isomorphic.">isIsomorphicTo()</a> if all you care about is the isomorphism relation among groups defined by presentation matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have identical chain-complex definitions. </dd></dl>

</div>
</div>
<a id="af0e2133542af695b8b850b6281ee6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e2133542af695b8b850b6281ee6feb">&#9670;&nbsp;</a></span>freeRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::freeRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested free generator in the original chain complex defining the group. </p>
<p>As described in the class overview, this marked abelian group is defined by matrices <em>M</em> and <em>N</em> where M*N = 0. If <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix, then this routine returns the (<em>index</em>)th free generator of ker(M)/img(N) in <em>Z^l</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which free generator to look up; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a000ce1a1c59819c497cd964486be934f" title="Returns the rank of the group.">rank()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the free generator in the nullspace of <em>M</em>; this vector will have length M.columns() (or equivalently, N.rows()). If this generator does not exist, you will receive an empty vector. </dd></dl>

</div>
</div>
<a id="a1646cf2d9cb4bc31b0b0df1f1f4289a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1646cf2d9cb4bc31b0b0df1f1f4289a4">&#9670;&nbsp;</a></span>invariantFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp; regina::MarkedAbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<p>If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="aa8266305f2c94b9f7c7880715eba189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8266305f2c94b9f7c7880715eba189e">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector, determines if it represents a boundary in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a boundary. </dd></dl>

</div>
</div>
<a id="a466303b009840a96e49874e0f139854d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466303b009840a96e49874e0f139854d">&#9670;&nbsp;</a></span>isChainComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isChainComplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the defining maps for this group actually give a chain complex. </p>
<p>This is helpful for debugging.</p>
<p>Specifically, this routine returns <code>true</code> if and only if M*N = 0 where M and N are the definining matrices.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if M*N = 0. </dd></dl>

</div>
</div>
<a id="a6df135646b8e56fa438477a849f4c9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df135646b8e56fa438477a849f4c9bc">&#9670;&nbsp;</a></span>isCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isCycle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector, determines if it represents a cycle in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a cycle. </dd></dl>

</div>
</div>
<a id="ad04a54db050fca088bad38c7b5b9c980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04a54db050fca088bad38c7b5b9c980">&#9670;&nbsp;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are isomorphic. </dd></dl>

</div>
</div>
<a id="a1b2511bd16caaaeb926df617a731c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2511bd16caaaeb926df617a731c965">&#9670;&nbsp;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="a7c65d588478bdbfc871d9d8e94d690ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65d588478bdbfc871d9d8e94d690ff">&#9670;&nbsp;</a></span>isZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="a746b854c7cfea2e4c5852a72565058b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746b854c7cfea2e4c5852a72565058b4">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;right&rsquo; matrix used in defining the chain complex. </p>
<p>Our group was defined as the kernel of <em>M</em> mod the image of <em>N</em>. This is the matrix <em>M</em>.</p>
<p>This is a copy of the matrix <em>M</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix M. </dd></dl>

</div>
</div>
<a id="ac714d64e8dca4bc06cce32c3ed26b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac714d64e8dca4bc06cce32c3ed26b8db">&#9670;&nbsp;</a></span>minNumberCycleGens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::minNumberCycleGens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators of ker(M), where M is one of the defining matrices of the chain complex. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators of ker(M). </dd></dl>

</div>
</div>
<a id="ab5e8b466766eb274146277ac9bd98a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e8b466766eb274146277ac9bd98a55">&#9670;&nbsp;</a></span>minNumberOfGenerators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::minNumberOfGenerators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the minimum number of generators for the group. </p>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of generators. </dd></dl>

</div>
</div>
<a id="a48c5e7997650a39ab835814a0ed5cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c5e7997650a39ab835814a0ed5cc61">&#9670;&nbsp;</a></span>N()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;left&rsquo; matrix used in defining the chain complex. </p>
<p>Our group was defined as the kernel of <em>M</em> mod the image of <em>N</em>. This is the matrix <em>N</em>.</p>
<p>This is a copy of the matrix <em>N</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix N. </dd></dl>

</div>
</div>
<a id="a000ce1a1c59819c497cd964486be934f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ce1a1c59819c497cd964486be934f">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group. </p>
<p>This is the number of included copies of <em>Z</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the group. </dd></dl>

</div>
</div>
<a id="a6f90140da9a0ab47482cb68a29078432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f90140da9a0ab47482cb68a29078432">&#9670;&nbsp;</a></span>rankCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::rankCC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the chain complex supporting the homology computation. </p>
<p>In the description of this class, this is also given by M.columns() and N.rows() from the constructor that takes as input two matrices, M and N.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the chain complex. </dd></dl>

</div>
</div>
<a id="a0563fc60015d3690c89776aaf94c956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0563fc60015d3690c89776aaf94c956b">&#9670;&nbsp;</a></span>snfRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::snfRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given vector as a combination of free and torsion generators. </p>
<p>This answer is coordinate dependant, meaning the answer may change depending on how the Smith Normal Form is computed.</p>
<p>Recall that this marked abelian was defined by matrices <em>M</em> and <em>N</em> with M*N=0; suppose that <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix. This abelian group is then the quotient ker(M)/img(N) in <em>Z^l</em>.</p>
<p>When it is constructed, this group is computed to be isomorphic to some Z_{d0} + ... + Z_{dk} + Z^d, where:</p>
<ul>
<li><em>d</em> is the number of free generators, as returned by <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a000ce1a1c59819c497cd964486be934f" title="Returns the rank of the group.">rank()</a>;</li>
<li><em>d1</em>, ..., <em>dk</em> are the invariant factors that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<p>This routine takes a single argument <em>v</em>, which must be a vector in <em>Z^l</em>.</p>
<p>If <em>v</em> belongs to ker(M), this routine describes how it projects onto the group ker(M)/img(N). Specifically, it returns a vector of length <em>d</em> + <em>k</em>, where:</p>
<ul>
<li>The first <em>k</em> elements describe the projection of <em>v</em> to the torsion component Z_{d1} + ... + Z_{dk}. These elements are returned as non-negative integers modulo <em>d1</em>, ..., <em>dk</em> respectively.</li>
<li>The remaining <em>d</em> elements describe the projection of <em>v</em> to the free component <em>Z^d</em>.</li>
</ul>
<p>In other words, suppose <em>v</em> belongs to ker(M) and snfRep(v) returns the vector (<em>b1</em>, ..., <em>bk</em>, <em>a1</em>, ..., <em>ad</em>). Suppose furthermore that the free generators returned by freeRep(0..(d-1)) are <em>f1</em>, ..., <em>fd</em> respectively, and that the torsion generators returned by torsionRep(0..(k-1)) are <em>t1</em>, ..., <em>tk</em> respectively. Then <em>v</em> = <em>b1.t1</em> + ... + <em>bk.tk</em> + <em>a1.f1</em> + ... + <em>ad.fd</em> modulo img(N).</p>
<p>If <em>v</em> does not belong to ker(M), this routine simply returns the empty vector.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, as it depends on the choice of Smith normal form.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> <em>v</em> has length M.columns(), or equivalently N.rows().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of length M.columns(). M.columns() is also <a class="el" href="classregina_1_1MarkedAbelianGroup.html#a6f90140da9a0ab47482cb68a29078432" title="Returns the rank of the chain complex supporting the homology computation.">rankCC()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector that describes <em>v</em> in the standard Z_{d1} + ... + Z_{dk} + Z^d form, or the empty vector if <em>v</em> is not in the kernel of <em>M</em>. k+d is equal to <a class="el" href="classregina_1_1MarkedAbelianGroup.html#ab5e8b466766eb274146277ac9bd98a55" title="Returns the minimum number of generators for the group.">minNumberOfGenerators()</a>. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:\n In addition to str(), this is also used as the</dt><dd>Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aaa9882af6b8ec2757932ac1c49833633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9882af6b8ec2757932ac1c49833633">&#9670;&nbsp;</a></span>torsionInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::MarkedAbelianGroup::torsionInclusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the inclusion of the torsion subgroup into this group. </p>

</div>
</div>
<a id="a99f15cbf9347b95351868181735e7dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f15cbf9347b95351868181735e7dbd">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="a2dca8084edda8307373869fd840fe586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dca8084edda8307373869fd840fe586">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="a2cdebf3efcd47ef18d96369b243794b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdebf3efcd47ef18d96369b243794b9">&#9670;&nbsp;</a></span>torsionRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::torsionRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested generator of the torsion subgroup but represented in the original chain complex defining the group. </p>
<p>As described in the class overview, this marked abelian group is defined by matrices <em>M</em> and <em>N</em> where M*N = 0. If <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix, then this routine returns the (<em>index</em>)th torsion generator of ker(M)/img(N) in <em>Z^l</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which generator in the torsion subgroup; this must be at least 0 and strictly less than the number of non-trivial invariant factors. If not, you receive an empty vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the generator in the nullspace of <em>M</em>; this vector will have length M.columns() (or equivalently, N.rows()). </dd></dl>

</div>
</div>
<a id="a964cf786ad3ed296a325f03f6d8bf51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964cf786ad3ed296a325f03f6d8bf51c">&#9670;&nbsp;</a></span>torsionSubgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&gt; regina::MarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> representing the torsion subgroup of this group. </p>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a94ea2ed41e910b2c52a6d5736283caa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ea2ed41e910b2c52a6d5736283caa3">&#9670;&nbsp;</a></span>writeAsBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::writeAsBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given vector as a boundary in the chain complex (if the vector is indeed a boundary at all). </p>
<p>This routine uses chain complex coordinates for both the input and the return value.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you're using mod-p coefficients and if your element projects to a non-trivial element of TOR, then Nv != input as elements of TOR aren't in the image of N. In this case, input-Nv represents the projection to TOR.</dd>
<dd>
The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a length zero vector if the input is not a boundary; otherwise a vector <em>v</em> such that <code>Nv=input</code>. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db2c8ef127dba9ee3717e8660a7da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db2c8ef127dba9ee3717e8660a7da43">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::MarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. </p>
<p>The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="markedabeliangroup_8h.html">markedabeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
