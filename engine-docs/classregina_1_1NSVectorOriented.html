<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::NSVectorOriented Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NSVectorOriented.html">NSVectorOriented</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NSVectorOriented-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NSVectorOriented Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A normal surface vector using transversely oriented standard (triangle-quad) coordinates.  
 <a href="classregina_1_1NSVectorOriented.html#details">More...</a></p>

<p><code>#include &lt;surfaces/nsvectororiented.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NSVectorOriented:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NSVectorOriented.png" usemap="#regina::NSVectorOriented_map" alt=""/>
  <map id="regina::NSVectorOriented_map" name="regina::NSVectorOriented_map">
<area href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold." alt="regina::NormalSurfaceVector" shape="rect" coords="0,0,177,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36acf25acf48e1228d0beba925325559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a36acf25acf48e1228d0beba925325559">NSVectorOriented</a> (size_t length)</td></tr>
<tr class="memdesc:a36acf25acf48e1228d0beba925325559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#a36acf25acf48e1228d0beba925325559">More...</a><br /></td></tr>
<tr class="separator:a36acf25acf48e1228d0beba925325559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b9351b2c46ce4cdbf3f5c2923b44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a909b9351b2c46ce4cdbf3f5c2923b44b">NSVectorOriented</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a909b9351b2c46ce4cdbf3f5c2923b44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#a909b9351b2c46ce4cdbf3f5c2923b44b">More...</a><br /></td></tr>
<tr class="separator:a909b9351b2c46ce4cdbf3f5c2923b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58437850c881385ebd4c4f5cf4e2e6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#ae58437850c881385ebd4c4f5cf4e2e6b">triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ae58437850c881385ebd4c4f5cf4e2e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="#ae58437850c881385ebd4c4f5cf4e2e6b">More...</a><br /></td></tr>
<tr class="separator:ae58437850c881385ebd4c4f5cf4e2e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a5185cb4b3afd73b98e9a8c8a5eebcb6f">quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:a5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="#a5185cb4b3afd73b98e9a8c8a5eebcb6f">More...</a><br /></td></tr>
<tr class="separator:a5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a3a4137d110e610a9ba8dfa5dbc1c4f1c">orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:a3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="#a3a4137d110e610a9ba8dfa5dbc1c4f1c">More...</a><br /></td></tr>
<tr class="separator:a3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6015659e0c8fee455cea5877c075c47a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a6015659e0c8fee455cea5877c075c47a">orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:a6015659e0c8fee455cea5877c075c47a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#a6015659e0c8fee455cea5877c075c47a">More...</a><br /></td></tr>
<tr class="separator:a6015659e0c8fee455cea5877c075c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf522a2ab69035a41dfde5bcc70ab7ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#acf522a2ab69035a41dfde5bcc70ab7ea">octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:acf522a2ab69035a41dfde5bcc70ab7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="#acf522a2ab69035a41dfde5bcc70ab7ea">More...</a><br /></td></tr>
<tr class="separator:acf522a2ab69035a41dfde5bcc70ab7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108ca7175f0e6bd106c19373f3fcbf2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#a4108ca7175f0e6bd106c19373f3fcbf2">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:a4108ca7175f0e6bd106c19373f3fcbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="#a4108ca7175f0e6bd106c19373f3fcbf2">More...</a><br /></td></tr>
<tr class="separator:a4108ca7175f0e6bd106c19373f3fcbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html#ab5de36fdaeb65ecb4ce02fa95ec8fe30">arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#ab5de36fdaeb65ecb4ce02fa95ec8fe30">More...</a><br /></td></tr>
<tr class="separator:ab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64145ed248bd3b24af3d65a7500aadb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#af64145ed248bd3b24af3d65a7500aadb">coords</a> () const</td></tr>
<tr class="memdesc:af64145ed248bd3b24af3d65a7500aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="#af64145ed248bd3b24af3d65a7500aadb">More...</a><br /></td></tr>
<tr class="separator:af64145ed248bd3b24af3d65a7500aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a919f098d3c43f1e68a5dc3ba9c9da227">clone</a> () const =0</td></tr>
<tr class="memdesc:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#a919f098d3c43f1e68a5dc3ba9c9da227">More...</a><br /></td></tr>
<tr class="separator:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85">size</a> () const</td></tr>
<tr class="memdesc:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="#a680b7b7ac5f45b6404644ee9fb1afb85">More...</a><br /></td></tr>
<tr class="separator:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238f18a8ba972f206f34a0302dc863cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a238f18a8ba972f206f34a0302dc863cf">operator []</a> (size_t index) const</td></tr>
<tr class="memdesc:a238f18a8ba972f206f34a0302dc863cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="#a238f18a8ba972f206f34a0302dc863cf">More...</a><br /></td></tr>
<tr class="separator:a238f18a8ba972f206f34a0302dc863cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c548a7bcd676dceef9b01ec96ab8da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a24c548a7bcd676dceef9b01ec96ab8da">setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:a24c548a7bcd676dceef9b01ec96ab8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="#a24c548a7bcd676dceef9b01ec96ab8da">More...</a><br /></td></tr>
<tr class="separator:a24c548a7bcd676dceef9b01ec96ab8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a87bf86f895cf3f97281cf98c6e9ac8ef">operator+=</a> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;other)</td></tr>
<tr class="memdesc:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#a87bf86f895cf3f97281cf98c6e9ac8ef">More...</a><br /></td></tr>
<tr class="separator:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f95b5cc7d6e00e85cd78283227fb17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a19f95b5cc7d6e00e85cd78283227fb17">scaleDown</a> ()</td></tr>
<tr class="memdesc:a19f95b5cc7d6e00e85cd78283227fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a19f95b5cc7d6e00e85cd78283227fb17">More...</a><br /></td></tr>
<tr class="separator:a19f95b5cc7d6e00e85cd78283227fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b5594a67c7a695ab21adaa862a8d38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a44b5594a67c7a695ab21adaa862a8d38">allowsAlmostNormal</a> () const =0</td></tr>
<tr class="memdesc:a44b5594a67c7a695ab21adaa862a8d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#a44b5594a67c7a695ab21adaa862a8d38">More...</a><br /></td></tr>
<tr class="separator:a44b5594a67c7a695ab21adaa862a8d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d54c737adf4198657a237f31d8851"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ab07d54c737adf4198657a237f31d8851">allowsSpun</a> () const =0</td></tr>
<tr class="memdesc:ab07d54c737adf4198657a237f31d8851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles.  <a href="#ab07d54c737adf4198657a237f31d8851">More...</a><br /></td></tr>
<tr class="separator:ab07d54c737adf4198657a237f31d8851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a8c2541a7dcdecfafd908ad50d98cd9d1">allowsOriented</a> () const =0</td></tr>
<tr class="memdesc:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces.  <a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">More...</a><br /></td></tr>
<tr class="separator:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a207ab6ce67f8c4f322f64fd0494e3a88">hasMultipleOctDiscs</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <a href="#a207ab6ce67f8c4f322f64fd0494e3a88">More...</a><br /></td></tr>
<tr class="separator:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ace3f3ccef51ec75544ee6cc6875a6cda">isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is compact (has finitely many discs).  <a href="#ace3f3ccef51ec75544ee6cc6875a6cda">More...</a><br /></td></tr>
<tr class="separator:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf49b14b890535f0deee9d8db62dc4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aecf49b14b890535f0deee9d8db62dc4c">isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:aecf49b14b890535f0deee9d8db62dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is vertex linking.  <a href="#aecf49b14b890535f0deee9d8db62dc4c">More...</a><br /></td></tr>
<tr class="separator:aecf49b14b890535f0deee9d8db62dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a48f860e909873a8ab2449f36c7d3cfb3">isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a48f860e909873a8ab2449f36c7d3cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="#a48f860e909873a8ab2449f36c7d3cfb3">More...</a><br /></td></tr>
<tr class="separator:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07535a32a2da710490b864bb23f93ea1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a07535a32a2da710490b864bb23f93ea1">isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a07535a32a2da710490b864bb23f93ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the thin link of a single edge.  <a href="#a07535a32a2da710490b864bb23f93ea1">More...</a><br /></td></tr>
<tr class="separator:a07535a32a2da710490b864bb23f93ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da454072e9b44e9ccbf23523006dae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ae4da454072e9b44e9ccbf23523006dae">isSplitting</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ae4da454072e9b44e9ccbf23523006dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a splitting surface in the given triangulation.  <a href="#ae4da454072e9b44e9ccbf23523006dae">More...</a><br /></td></tr>
<tr class="separator:ae4da454072e9b44e9ccbf23523006dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f211dde81cc1505e475d48da6f1aafa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a7f211dde81cc1505e475d48da6f1aafa">isCentral</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a7f211dde81cc1505e475d48da6f1aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a central surface in the given triangulation.  <a href="#a7f211dde81cc1505e475d48da6f1aafa">More...</a><br /></td></tr>
<tr class="separator:a7f211dde81cc1505e475d48da6f1aafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a37bd4b605880d84a49c4def169ec43a8"><td class="memItemLeft" align="right" valign="top"><a id="a37bd4b605880d84a49c4def169ec43a8"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:a37bd4b605880d84a49c4def169ec43a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e649f29ba31fd83a8ec4b3494af521"><td class="memItemLeft" align="right" valign="top"><a id="a53e649f29ba31fd83a8ec4b3494af521"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:a53e649f29ba31fd83a8ec4b3494af521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a6bacf21e7c7829a7d213a1f7dc01"><td class="memItemLeft" align="right" valign="top"><a id="ac40a6bacf21e7c7829a7d213a1f7dc01"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ac40a6bacf21e7c7829a7d213a1f7dc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aed283d890443594e39ba1ea13c81046d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aed283d890443594e39ba1ea13c81046d">coords_</a></td></tr>
<tr class="memdesc:aed283d890443594e39ba1ea13c81046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="#aed283d890443594e39ba1ea13c81046d">More...</a><br /></td></tr>
<tr class="separator:aed283d890443594e39ba1ea13c81046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A normal surface vector using transversely oriented standard (triangle-quad) coordinates. </p>
<p>If there are <em>t</em> tetrahedra in the underlying triangulation, there must be precisely 14<em>t</em> coordinates. For each <em>i</em>, coordinates 2<em>i</em> and 2<em>i</em>+1 represent the <code>true</code> and <code>false</code> orientations for coordinate <em>i</em> in the 7<em>t</em>-dimensional standard coordinate system. See <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> for further details.</p>
<dl class="section warning"><dt>Warning</dt><dd>Support for transversely oriented normal surfaces is still experimental, and some features <b>will</b> break (e.g., testing connectedness, disjointness or embeddedness).</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36acf25acf48e1228d0beba925325559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36acf25acf48e1228d0beba925325559">&#9670;&nbsp;</a></span>NSVectorOriented() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOriented::NSVectorOriented </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a909b9351b2c46ce4cdbf3f5c2923b44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b9351b2c46ce4cdbf3f5c2923b44b">&#9670;&nbsp;</a></span>NSVectorOriented() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOriented::NSVectorOriented </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a44b5594a67c7a695ab21adaa862a8d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b5594a67c7a695ab21adaa862a8d38">&#9670;&nbsp;</a></span>allowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> octagonal discs.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="a8c2541a7dcdecfafd908ad50d98cd9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">&#9670;&nbsp;</a></span>allowsOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="ab07d54c737adf4198657a237f31d8851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d54c737adf4198657a237f31d8851">&#9670;&nbsp;</a></span>allowsSpun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> infinitely many triangles.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun-normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="ab5de36fdaeb65ecb4ce02fa95ec8fe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5de36fdaeb65ecb4ce02fa95ec8fe30">&#9670;&nbsp;</a></span>arcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#ad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a919f098d3c43f1e68a5dc3ba9c9da227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f098d3c43f1e68a5dc3ba9c9da227">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="af64145ed248bd3b24af3d65a7500aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64145ed248bd3b24af3d65a7500aadb">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="a4108ca7175f0e6bd106c19373f3fcbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4108ca7175f0e6bd106c19373f3fcbf2">&#9670;&nbsp;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a207ab6ce67f8c4f322f64fd0494e3a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ab6ce67f8c4f322f64fd0494e3a88">&#9670;&nbsp;</a></span>hasMultipleOctDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<p>The default implementation for this routine simply calculates all the octagonal coordinates and returns as soon as a positive or negative result can be established. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<p>If a subclass does not allow for almost normal surfaces, this routine will never be called and thus does not need to be overwritten.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface. </dd>
<dd>
This normal surface vector is using a coordinate system that allows for almost normal surfaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a id="a7f211dde81cc1505e475d48da6f1aafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f211dde81cc1505e475d48da6f1aafa">&#9670;&nbsp;</a></span>isCentral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::isCentral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a central surface in the given triangulation. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If the surface is central, the number of tetrahedra it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that the surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="ace3f3ccef51ec75544ee6cc6875a6cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3f3ccef51ec75544ee6cc6875a6cda">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is compact (has finitely many discs). </p>
<p>The default implementation for this routine simply runs through every disc type until a disc type with infinite disc count is found or all disc types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is compact. </dd></dl>

</div>
</div>
<a id="ae4da454072e9b44e9ccbf23523006dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da454072e9b44e9ccbf23523006dae">&#9670;&nbsp;</a></span>isSplitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isSplitting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a splitting surface in the given triangulation. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is a splitting surface. </dd></dl>

</div>
</div>
<a id="a07535a32a2da710490b864bb23f93ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07535a32a2da710490b864bb23f93ea1">&#9670;&nbsp;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*&gt; regina::NormalSurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which the surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If the surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If the surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="a48f860e909873a8ab2449f36c7d3cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f860e909873a8ab2449f36c7d3cfb3">&#9670;&nbsp;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;3&gt;* regina::NormalSurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a98d612c1b934bd3d64908cbc42e4e81e">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorQuadOct.html#a34afa9a4f7444f2b985adb80aaf2054f">regina::NSVectorQuadOct</a>, and <a class="el" href="classregina_1_1NSVectorQuad.html#af5b5ea3db1bb195bb2ac85d61c478c6a">regina::NSVectorQuad</a>.</p>

</div>
</div>
<a id="aecf49b14b890535f0deee9d8db62dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf49b14b890535f0deee9d8db62dc4c">&#9670;&nbsp;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>The default implementation for this routine simply runs through every non-triangular disc type ensuring that each has no corresponding discs. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="acf522a2ab69035a41dfde5bcc70ab7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf522a2ab69035a41dfde5bcc70ab7ea">&#9670;&nbsp;</a></span>octs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#ab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a238f18a8ba972f206f34a0302dc863cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238f18a8ba972f206f34a0302dc863cf">&#9670;&nbsp;</a></span>operator []()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalSurfaceVector::operator [] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="a87bf86f895cf3f97281cf98c6e9ac8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bf86f895cf3f97281cf98c6e9ac8ef">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <em>this</em>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also needs adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal surfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a654e738a0d9768a39697c79c8b2e74b7">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="a6015659e0c8fee455cea5877c075c47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6015659e0c8fee455cea5877c075c47a">&#9670;&nbsp;</a></span>orientedQuads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#ad6d15dfef9d0dca32bc66c8ac506d196">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a3a4137d110e610a9ba8dfa5dbc1c4f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4137d110e610a9ba8dfa5dbc1c4f1c">&#9670;&nbsp;</a></span>orientedTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#a2ce2cc2fbd8b46b97d8ea787535282d0">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a5185cb4b3afd73b98e9a8c8a5eebcb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5185cb4b3afd73b98e9a8c8a5eebcb6f">&#9670;&nbsp;</a></span>quads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a19f95b5cc7d6e00e85cd78283227fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f95b5cc7d6e00e85cd78283227fb17">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a7607f80141d61419e9fc05bb2c266c97">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="a24c548a7bcd676dceef9b01ec96ab8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c548a7bcd676dceef9b01ec96ab8da">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a09f01421c3a687edc63fada1808c063f">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="a680b7b7ac5f45b6404644ee9fb1afb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680b7b7ac5f45b6404644ee9fb1afb85">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="ae58437850c881385ebd4c4f5cf4e2e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58437850c881385ebd4c4f5cf4e2e6b">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aed283d890443594e39ba1ea13c81046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed283d890443594e39ba1ea13c81046d">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalSurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="nsvectororiented_8h.html">nsvectororiented.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
