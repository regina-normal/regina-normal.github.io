<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous helper classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorByType.html">regina::BitManipulatorByType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the underlying data type.  <a href="classregina_1_1BitManipulatorByType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorBySize.html">regina::BitManipulatorBySize&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the size of the underlying data type.  <a href="classregina_1_1BitManipulatorBySize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulator.html">regina::BitManipulator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised class for bitwise analysis and manipulation of native data types.  <a href="classregina_1_1BitManipulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask that can store arbitrarily many true-or-false bits.  <a href="classregina_1_1Bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) true-or-false bits.  <a href="classregina_1_1Bitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) true-or-false bits.  <a href="classregina_1_1Bitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoolSet.html">regina::BoolSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of booleans.  <a href="classregina_1_1BoolSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Flags.html">regina::Flags&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a bitwise combination of flags defined by an enumeration type.  <a href="classregina_1_1Flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1Locale.html">regina::i18n::Locale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class with static routines for querying information about the current locale.  <a href="classregina_1_1i18n_1_1Locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">regina::i18n::IConvStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream buffer that translates between character encodings.  <a href="classregina_1_1i18n_1_1IConvStreamBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStream.html">regina::i18n::IConvStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream that converts between character encodings.  <a href="classregina_1_1i18n_1_1IConvStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaInteger.html">regina::IsReginaInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's own integer types.  <a href="structregina_1_1IsReginaInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>exactly</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>at least</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfMinSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListOnCall.html">regina::ListOnCall&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers a hard-coded list of expensive objects that should only be created if they are required.  <a href="classregina_1_1ListOnCall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html">regina::MarkedElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for elements of <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="classregina_1_1MarkedElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of objects with fast, space-efficient reverse lookup of array indices.  <a href="classregina_1_1MarkedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__istream.html">regina::mem_istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input stream that reads an array of characters in memory.  <a href="classregina_1_1mem__istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__streambuf.html">regina::mem_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer that provides the implementation details for <a class="el" href="classregina_1_1mem__istream.html" title="An input stream that reads an array of characters in memory.">mem_istream</a>.  <a href="classregina_1_1mem__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNew.html">regina::FuncNew&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable generator used to create objects using default constructors.  <a href="structregina_1_1FuncNew.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using the <code>clone()</code> method.  <a href="structregina_1_1FuncNewClonePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to deallocate objects.  <a href="structregina_1_1FuncDelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by value.  <a href="classregina_1_1StoreValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by constant pointer.  <a href="classregina_1_1StoreConstPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classregina_1_1Property.html" title="Stores a calculable property of an object.">Property</a> storage policy indicating that the property should be held by pointer and that the property wrapper will also take responsibility for memory management.  <a href="classregina_1_1StoreManagedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Property.html">regina::Property&lt; T, Storage &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a calculable property of an object.  <a href="classregina_1_1Property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref&lt; T, Comp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable binary function used to compare the objects to which pointers are pointing.  <a href="classregina_1_1LessDeref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1RandomEngine.html">regina::RandomEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers threadsafe access to Regina's global uniform random bit generator.  <a href="classregina_1_1RandomEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Returns.html">regina::Returns&lt; ReturnType_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience base class for a non-void function object, which does nothing beyond provide a <em>ReturnType</em> typedef.  <a href="structregina_1_1Returns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HasReturnType.html">regina::HasReturnType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal to <a class="el" href="structregina_1_1ReturnsTraits.html" title="Helper class to assist with compile-time analysis of Regina&#39;s function objects.">ReturnsTraits</a>.  <a href="classregina_1_1HasReturnType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ReturnsTraitsImplementation.html">regina::ReturnsTraitsImplementation&lt; T, hasReturnType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the implementation of <a class="el" href="structregina_1_1ReturnsTraits.html" title="Helper class to assist with compile-time analysis of Regina&#39;s function objects.">ReturnsTraits</a>.  <a href="structregina_1_1ReturnsTraitsImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ReturnsTraits.html">regina::ReturnsTraits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to assist with compile-time analysis of Regina's function objects.  <a href="structregina_1_1ReturnsTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NewFunction.html">regina::NewFunction&lt; Base &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object that creates a new object subclassed from <em>Base</em>, where the particular subclass is chosen according to the template argument to operator().  <a href="structregina_1_1NewFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for objects of type <em>T</em> to be referenceable by a <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a>.  <a href="classregina_1_1SafePointeeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePtr.html">regina::SafePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference counted smart pointer that supports alternate models of ownership.  <a href="classregina_1_1SafePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight class for storing a random-access sequence of objects.  <a href="classregina_1_1LightweightSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie-like data structure for storing and retriving sets.  <a href="classregina_1_1TrieSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tritmask1.html">regina::Tritmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1Tritmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tritmask2.html">regina::Tritmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1Tritmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a map from property names to property values.  <a href="classregina_1_1xml_1_1XMLPropertyDict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">regina::xml::XMLParserCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the callbacks for an <a class="el" href="classregina_1_1xml_1_1XMLParser.html" title="Used to parse an entire XML file.">XMLParser</a>.  <a href="classregina_1_1xml_1_1XMLParserCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParser.html">regina::xml::XMLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to parse an entire XML file.  <a href="classregina_1_1xml_1_1XMLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5ffec6ccec6eaaf2e875fd1533a50c05">INT128_AVAILABLE</a></td></tr>
<tr class="memdesc:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined if and only if native 128-bit arithmetic is available on this platform.  <a href="#ga5ffec6ccec6eaaf2e875fd1533a50c05">More...</a><br /></td></tr>
<tr class="separator:ga5ffec6ccec6eaaf2e875fd1533a50c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">regina::BitmaskLen8</a></td></tr>
<tr class="memdesc:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">More...</a><br /></td></tr>
<tr class="separator:ga29eb3c97f12b01fc84bb5edfdcb9a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79171eb0dd3165e733ca97b8240b861b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">regina::BitmaskLen16</a></td></tr>
<tr class="memdesc:ga79171eb0dd3165e733ca97b8240b861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">More...</a><br /></td></tr>
<tr class="separator:ga79171eb0dd3165e733ca97b8240b861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb60aab55cbe801e14a1654bccbeee20"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">regina::BitmaskLen32</a></td></tr>
<tr class="memdesc:gadb60aab55cbe801e14a1654bccbeee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">More...</a><br /></td></tr>
<tr class="separator:gadb60aab55cbe801e14a1654bccbeee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecadfef5ba587ad7030165a79b277ec5"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">regina::BitmaskLen64</a></td></tr>
<tr class="memdesc:gaecadfef5ba587ad7030165a79b277ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">More...</a><br /></td></tr>
<tr class="separator:gaecadfef5ba587ad7030165a79b277ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">regina::NBoolSet</a></td></tr>
<tr class="memdesc:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">More...</a><br /></td></tr>
<tr class="separator:gaa647c98d25c28ffc52757c31bfc3eee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bc959ede9feeded32f0e82d889287b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">regina::QitmaskLen8</a></td></tr>
<tr class="memdesc:ga99bc959ede9feeded32f0e82d889287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">More...</a><br /></td></tr>
<tr class="separator:ga99bc959ede9feeded32f0e82d889287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa396173f6b9d24d6e5f0412386813651"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">regina::QitmaskLen16</a></td></tr>
<tr class="memdesc:gaa396173f6b9d24d6e5f0412386813651"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">More...</a><br /></td></tr>
<tr class="separator:gaa396173f6b9d24d6e5f0412386813651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db96e54efcf3eda083368b3cc77abd3"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">regina::QitmaskLen32</a></td></tr>
<tr class="memdesc:ga2db96e54efcf3eda083368b3cc77abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">More...</a><br /></td></tr>
<tr class="separator:ga2db96e54efcf3eda083368b3cc77abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b4c70291965332b28e1891b86ea054"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">regina::QitmaskLen64</a></td></tr>
<tr class="memdesc:gaf4b4c70291965332b28e1891b86ea054"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">More...</a><br /></td></tr>
<tr class="separator:gaf4b4c70291965332b28e1891b86ea054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">regina::TritmaskLen8</a></td></tr>
<tr class="memdesc:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">More...</a><br /></td></tr>
<tr class="separator:ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a71a872e94df27800252dbd7a105758"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">regina::TritmaskLen16</a></td></tr>
<tr class="memdesc:ga4a71a872e94df27800252dbd7a105758"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">More...</a><br /></td></tr>
<tr class="separator:ga4a71a872e94df27800252dbd7a105758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8ecc460b8fec9c1630a0830e57469eb"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen32 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">regina::TritmaskLen32</a></td></tr>
<tr class="memdesc:gae8ecc460b8fec9c1630a0830e57469eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">More...</a><br /></td></tr>
<tr class="separator:gae8ecc460b8fec9c1630a0830e57469eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen64 ::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">regina::TritmaskLen64</a></td></tr>
<tr class="memdesc:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">More...</a><br /></td></tr>
<tr class="separator:gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">regina::base64Length</a> (size_t bytes)</td></tr>
<tr class="memdesc:gaa8d632b73943b5c52e395d56f8e03af2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes.  <a href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">More...</a><br /></td></tr>
<tr class="separator:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">regina::isBase64</a> (char ch)</td></tr>
<tr class="memdesc:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given character is a base64 printable character as used by the base64 routines in Regina.  <a href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">More...</a><br /></td></tr>
<tr class="separator:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d322bec8070a889aba14d5988ae80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">regina::base64Encode</a> (const char *in, size_t inlen, char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga081d322bec8070a889aba14d5988ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer.  <a href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">More...</a><br /></td></tr>
<tr class="separator:ga081d322bec8070a889aba14d5988ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541f612d6bb0f94db16da14169813e29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">regina::base64Encode</a> (const char *in, size_t inlen, char **out)</td></tr>
<tr class="memdesc:ga541f612d6bb0f94db16da14169813e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">More...</a><br /></td></tr>
<tr class="separator:ga541f612d6bb0f94db16da14169813e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">regina::base64Decode</a> (const char *in, size_t inlen, char *out, size_t *outlen)</td></tr>
<tr class="memdesc:ga6811ec511cb61bfc071467ba5d0e8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer.  <a href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">More...</a><br /></td></tr>
<tr class="separator:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d6c710ee070d88c4b670b48bec3878"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">regina::base64Decode</a> (const char *in, size_t inlen, char **out, size_t *outlen)</td></tr>
<tr class="memdesc:ga47d6c710ee070d88c4b670b48bec3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">More...</a><br /></td></tr>
<tr class="separator:ga47d6c710ee070d88c4b670b48bec3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687edae41955adbcf9e58c8cce90ea68"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:ga687edae41955adbcf9e58c8cce90ea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">More...</a><br /></td></tr>
<tr class="separator:ga687edae41955adbcf9e58c8cce90ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e53899b74d99054f31035492d5890a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42e53899b74d99054f31035492d5890a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga42e53899b74d99054f31035492d5890a">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga42e53899b74d99054f31035492d5890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga42e53899b74d99054f31035492d5890a">More...</a><br /></td></tr>
<tr class="separator:ga42e53899b74d99054f31035492d5890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0dc9ea5844d6e3886aae7e101929e85e">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga0dc9ea5844d6e3886aae7e101929e85e">More...</a><br /></td></tr>
<tr class="separator:ga0dc9ea5844d6e3886aae7e101929e85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e140a57f469e663d87f1d3e14a90187"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7e140a57f469e663d87f1d3e14a90187">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;set)</td></tr>
<tr class="memdesc:ga7e140a57f469e663d87f1d3e14a90187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="group__utilities.html#ga7e140a57f469e663d87f1d3e14a90187">More...</a><br /></td></tr>
<tr class="separator:ga7e140a57f469e663d87f1d3e14a90187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3439925c61c42453159e0b50bdff960"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">regina::i18n::utf8ValidTo</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gad3439925c61c42453159e0b50bdff960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">More...</a><br /></td></tr>
<tr class="separator:gad3439925c61c42453159e0b50bdff960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9952c5bb8780ca8f54d450350cc640d7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9952c5bb8780ca8f54d450350cc640d7">regina::i18n::utf8ValidTo</a> (const char *s)</td></tr>
<tr class="memdesc:ga9952c5bb8780ca8f54d450350cc640d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#ga9952c5bb8780ca8f54d450350cc640d7">More...</a><br /></td></tr>
<tr class="separator:ga9952c5bb8780ca8f54d450350cc640d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a> (IntType n)</td></tr>
<tr class="memdesc:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits required to store integers in the range 0,...,<em>n</em>-1.  <a href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">More...</a><br /></td></tr>
<tr class="separator:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">regina::nextPowerOfTwo</a> (IntType n)</td></tr>
<tr class="memdesc:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smallest integer power of two that is greater than or equal to the given argument <em>n</em>.  <a href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">More...</a><br /></td></tr>
<tr class="separator:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c8776c5329496a0b34c914706031e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga52c8776c5329496a0b34c914706031e4">regina::writeResUsage</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga52c8776c5329496a0b34c914706031e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes time and memory usage for the current process to the given output stream.  <a href="group__utilities.html#ga52c8776c5329496a0b34c914706031e4">More...</a><br /></td></tr>
<tr class="separator:ga52c8776c5329496a0b34c914706031e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a20ee136c5a257176ff117f0eafb4a0">regina::clonePtr</a> (T *cloneMe)</td></tr>
<tr class="memdesc:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="group__utilities.html#ga3a20ee136c5a257176ff117f0eafb4a0">More...</a><br /></td></tr>
<tr class="separator:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae9fe03c364fe26a4f0e93c59a198b267">regina::clonePtr</a> (const std::unique_ptr&lt; T &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gae9fe03c364fe26a4f0e93c59a198b267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="group__utilities.html#gae9fe03c364fe26a4f0e93c59a198b267">More...</a><br /></td></tr>
<tr class="separator:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1fc8fedcb72b9db35901807c795486c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1fc8fedcb72b9db35901807c795486c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1fc8fedcb72b9db35901807c795486c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gab1fc8fedcb72b9db35901807c795486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#gab1fc8fedcb72b9db35901807c795486c">More...</a><br /></td></tr>
<tr class="separator:gab1fc8fedcb72b9db35901807c795486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a04e46c3516672d83a09e6f07b85876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0a04e46c3516672d83a09e6f07b85876"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0a04e46c3516672d83a09e6f07b85876">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga0a04e46c3516672d83a09e6f07b85876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#ga0a04e46c3516672d83a09e6f07b85876">More...</a><br /></td></tr>
<tr class="separator:ga0a04e46c3516672d83a09e6f07b85876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:gaa0c5c9157147686a6bfc401312b8d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given sequence to the given output stream.  <a href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">More...</a><br /></td></tr>
<tr class="separator:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga69b2411865af18bf506a1afb7d2bc2ca">regina::duplicate</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new C string that is a duplicate of the given C++ string.  <a href="group__utilities.html#ga69b2411865af18bf506a1afb7d2bc2ca">More...</a><br /></td></tr>
<tr class="separator:ga69b2411865af18bf506a1afb7d2bc2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4056bad007750e92b40959aca2c4f987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">regina::startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga4056bad007750e92b40959aca2c4f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given C++ string begins with the given prefix.  <a href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">More...</a><br /></td></tr>
<tr class="separator:ga4056bad007750e92b40959aca2c4f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa678d35fabfebccce72406d01076829c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">regina::stripWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa678d35fabfebccce72406d01076829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all whitespace from the beginning and end of the given C++ string.  <a href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">More...</a><br /></td></tr>
<tr class="separator:gaa678d35fabfebccce72406d01076829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c2e62bf0908919834ea10762def19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">regina::valueOf</a> (const std::string &amp;str, int8_t &amp;dest)</td></tr>
<tr class="memdesc:gae40c2e62bf0908919834ea10762def19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">More...</a><br /></td></tr>
<tr class="separator:gae40c2e62bf0908919834ea10762def19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">regina::valueOf</a> (const std::string &amp;str, uint8_t &amp;dest)</td></tr>
<tr class="memdesc:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">More...</a><br /></td></tr>
<tr class="separator:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384de19626353085bf20eedc89c3c30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">regina::valueOf</a> (const std::string &amp;str, short &amp;dest)</td></tr>
<tr class="memdesc:ga384de19626353085bf20eedc89c3c30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">More...</a><br /></td></tr>
<tr class="separator:ga384de19626353085bf20eedc89c3c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183ba5dd849f33e9153c3363323abf5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">regina::valueOf</a> (const std::string &amp;str, unsigned short &amp;dest)</td></tr>
<tr class="memdesc:ga183ba5dd849f33e9153c3363323abf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">More...</a><br /></td></tr>
<tr class="separator:ga183ba5dd849f33e9153c3363323abf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">regina::valueOf</a> (const std::string &amp;str, int &amp;dest)</td></tr>
<tr class="memdesc:ga896ae2c6783d6d6dc4081bddabb22518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">More...</a><br /></td></tr>
<tr class="separator:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a77f98013a0274540b1d0b06519f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">regina::valueOf</a> (const std::string &amp;str, unsigned &amp;dest)</td></tr>
<tr class="memdesc:ga974a77f98013a0274540b1d0b06519f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">More...</a><br /></td></tr>
<tr class="separator:ga974a77f98013a0274540b1d0b06519f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">regina::valueOf</a> (const std::string &amp;str, long &amp;dest)</td></tr>
<tr class="memdesc:gaad0bb367f8c8f4172e6a979751907c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">More...</a><br /></td></tr>
<tr class="separator:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007abfa18426eedc6277f644ded3e068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">regina::valueOf</a> (const std::string &amp;str, unsigned long &amp;dest)</td></tr>
<tr class="memdesc:ga007abfa18426eedc6277f644ded3e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">More...</a><br /></td></tr>
<tr class="separator:ga007abfa18426eedc6277f644ded3e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5eebbe6059d16231b0e41966e2056a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">regina::valueOf</a> (const std::string &amp;str, long long &amp;dest)</td></tr>
<tr class="memdesc:gacd5eebbe6059d16231b0e41966e2056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">More...</a><br /></td></tr>
<tr class="separator:gacd5eebbe6059d16231b0e41966e2056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bc034686407302e3ad597e39933a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">regina::valueOf</a> (const std::string &amp;str, unsigned long long &amp;dest)</td></tr>
<tr class="memdesc:gad0bc034686407302e3ad597e39933a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">More...</a><br /></td></tr>
<tr class="separator:gad0bc034686407302e3ad597e39933a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;dest)</td></tr>
<tr class="memdesc:ga4c91417b8ffbca35aa32c82532f5330f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">More...</a><br /></td></tr>
<tr class="separator:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">regina::valueOf</a> (const std::string &amp;str, double &amp;dest)</td></tr>
<tr class="memdesc:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a double precision real number and reports whether this conversion was successful.  <a href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">More...</a><br /></td></tr>
<tr class="separator:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e706f7f722922798776b74f9933bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">regina::valueOf</a> (const std::string &amp;str, bool &amp;dest)</td></tr>
<tr class="memdesc:ga17e706f7f722922798776b74f9933bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a boolean and reports whether this conversion was successful.  <a href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">More...</a><br /></td></tr>
<tr class="separator:ga17e706f7f722922798776b74f9933bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;dest)</td></tr>
<tr class="memdesc:ga6083d66d2dcac7dce8637e6282c6c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a set of booleans and reports whether this conversion was successful.  <a href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">More...</a><br /></td></tr>
<tr class="separator:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">regina::basicTokenise</a> (OutputIterator results, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes the given string into tokens.  <a href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">More...</a><br /></td></tr>
<tr class="separator:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga36927634ca1155f6e5fb60b3ce8f2278">regina::stringToToken</a> (const char *str)</td></tr>
<tr class="memdesc:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="group__utilities.html#ga36927634ca1155f6e5fb60b3ce8f2278">More...</a><br /></td></tr>
<tr class="separator:ga36927634ca1155f6e5fb60b3ce8f2278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c74082b6559d30c0073ff0a889e09e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga80c74082b6559d30c0073ff0a889e09e">regina::stringToToken</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga80c74082b6559d30c0073ff0a889e09e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="group__utilities.html#ga80c74082b6559d30c0073ff0a889e09e">More...</a><br /></td></tr>
<tr class="separator:ga80c74082b6559d30c0073ff0a889e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">regina::superscript</a> (T value)</td></tr>
<tr class="memdesc:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode superscript string.  <a href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">More...</a><br /></td></tr>
<tr class="separator:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">regina::subscript</a> (T value)</td></tr>
<tr class="memdesc:ga61ea966075c340b411ef07cc5aee1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode subscript string.  <a href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">More...</a><br /></td></tr>
<tr class="separator:ga61ea966075c340b411ef07cc5aee1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabf61c8a34e52f0aeb02f200c88026c1c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#gabf61c8a34e52f0aeb02f200c88026c1c">More...</a><br /></td></tr>
<tr class="separator:gabf61c8a34e52f0aeb02f200c88026c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac720197cc16b77f2647c6cfdeccd8038"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac720197cc16b77f2647c6cfdeccd8038"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac720197cc16b77f2647c6cfdeccd8038">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gac720197cc16b77f2647c6cfdeccd8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="group__utilities.html#gac720197cc16b77f2647c6cfdeccd8038">More...</a><br /></td></tr>
<tr class="separator:gac720197cc16b77f2647c6cfdeccd8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabae034cbea5ca43c01df1f5a1696b9f3">regina::xml::xmlString</a> (xmlChar *str, bool free=true)</td></tr>
<tr class="memdesc:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given string from libxml into a C++ string, optionally deallocating the original libxml string.  <a href="group__utilities.html#gabae034cbea5ca43c01df1f5a1696b9f3">More...</a><br /></td></tr>
<tr class="separator:gabae034cbea5ca43c01df1f5a1696b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">regina::xml::xmlEncodeSpecialChars</a> (const std::string &amp;original)</td></tr>
<tr class="memdesc:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities.  <a href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">More...</a><br /></td></tr>
<tr class="separator:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">regina::xml::xmlEncodeComment</a> (const std::string &amp;comment)</td></tr>
<tr class="memdesc:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment.  <a href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">More...</a><br /></td></tr>
<tr class="separator:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">regina::xml::xmlValueTag</a> (const std::string &amp;tagName, const T &amp;value)</td></tr>
<tr class="memdesc:gacb9d9d42e182de0dc67e4176414cb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value.  <a href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">More...</a><br /></td></tr>
<tr class="separator:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous helper classes and functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5ffec6ccec6eaaf2e875fd1533a50c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffec6ccec6eaaf2e875fd1533a50c05">&#9670;&nbsp;</a></span>INT128_AVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INT128_AVAILABLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined if and only if native 128-bit arithmetic is available on this platform. </p>
<p>If this macro is defined, then you can access native signed and unsigned 128-bit integers through the types IntOfSize&lt;16&gt;::type and IntOfSize&lt;16&gt;::utype respectively.</p>
<p>If this macro is not defined, then the types IntOfSize&lt;16&gt;::type and IntOfSize&lt;16&gt;::utype will both be <code>void</code>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga79171eb0dd3165e733ca97b8240b861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79171eb0dd3165e733ca97b8240b861b">&#9670;&nbsp;</a></span>BitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#ga79171eb0dd3165e733ca97b8240b861b">regina::BitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gadb60aab55cbe801e14a1654bccbeee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb60aab55cbe801e14a1654bccbeee20">&#9670;&nbsp;</a></span>BitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen32 ::Type <a class="el" href="group__utilities.html#gadb60aab55cbe801e14a1654bccbeee20">regina::BitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gaecadfef5ba587ad7030165a79b277ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecadfef5ba587ad7030165a79b277ec5">&#9670;&nbsp;</a></span>BitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen64 ::Type <a class="el" href="group__utilities.html#gaecadfef5ba587ad7030165a79b277ec5">regina::BitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or the template class <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga29eb3c97f12b01fc84bb5edfdcb9a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29eb3c97f12b01fc84bb5edfdcb9a09d">&#9670;&nbsp;</a></span>BitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga29eb3c97f12b01fc84bb5edfdcb9a09d">regina::BitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gaa647c98d25c28ffc52757c31bfc3eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa647c98d25c28ffc52757c31bfc3eee6">&#9670;&nbsp;</a></span>NBoolSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> <a class="el" href="group__utilities.html#gaa647c98d25c28ffc52757c31bfc3eee6">regina::NBoolSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000231">Deprecated:</a></b></dt><dd>The class NBoolSet has now been renamed to <a class="el" href="classregina_1_1BoolSet.html" title="A set of booleans.">BoolSet</a>. </dd></dl>

</div>
</div>
<a id="gaa396173f6b9d24d6e5f0412386813651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa396173f6b9d24d6e5f0412386813651">&#9670;&nbsp;</a></span>QitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#gaa396173f6b9d24d6e5f0412386813651">regina::QitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga2db96e54efcf3eda083368b3cc77abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db96e54efcf3eda083368b3cc77abd3">&#9670;&nbsp;</a></span>QitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen32 ::Type <a class="el" href="group__utilities.html#ga2db96e54efcf3eda083368b3cc77abd3">regina::QitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gaf4b4c70291965332b28e1891b86ea054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b4c70291965332b28e1891b86ea054">&#9670;&nbsp;</a></span>QitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen64 ::Type <a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">regina::QitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a> or the template class <a class="el" href="classregina_1_1Qitmask2.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U) ...">Qitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga99bc959ede9feeded32f0e82d889287b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99bc959ede9feeded32f0e82d889287b">&#9670;&nbsp;</a></span>QitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga99bc959ede9feeded32f0e82d889287b">regina::QitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga4a71a872e94df27800252dbd7a105758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a71a872e94df27800252dbd7a105758">&#9670;&nbsp;</a></span>TritmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;unsigned int&gt; <a class="el" href="group__utilities.html#ga4a71a872e94df27800252dbd7a105758">regina::TritmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gae8ecc460b8fec9c1630a0830e57469eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8ecc460b8fec9c1630a0830e57469eb">&#9670;&nbsp;</a></span>TritmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen32 ::Type <a class="el" href="group__utilities.html#gae8ecc460b8fec9c1630a0830e57469eb">regina::TritmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gae4ad14dfbe683fc9a13b1fdb9cf7bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">&#9670;&nbsp;</a></span>TritmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen64 ::Type <a class="el" href="group__utilities.html#gae4ad14dfbe683fc9a13b1fdb9cf7bfd2">regina::TritmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a> or the template class <a class="el" href="classregina_1_1Tritmask2.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U)...">Tritmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga1e6b4c5fb1f5cfb89c1e4ed334b9d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">&#9670;&nbsp;</a></span>TritmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga1e6b4c5fb1f5cfb89c1e4ed334b9d465">regina::TritmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Tritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;,...">Tritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6811ec511cb61bfc071467ba5d0e8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6811ec511cb61bfc071467ba5d0e8076">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer. </p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found, or the output buffer is exhausted, this routine will write as many output bytes as it can and then return <code>false</code>. Otherwise (on success) it will return <code>true</code>. Either way, it will reset <em>outlen</em> to the total number of bytes that were written.</p>
<p>The total number of output bytes is important to know, since the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting raw bytes will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>must contain the length of the output buffer on entry, and on exit contains the number of output bytes that were successfully written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if the output buffer was exhausted or an unexpected input character was found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga47d6c710ee070d88c4b670b48bec3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d6c710ee070d88c4b670b48bec3878">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, and <em>outlen</em> will be set to the number of raw bytes in this output array. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found or the output buffer is exhausted, this routine will return <code>false</code>, set <em>out</em> to <code>null</code>, and leave <em>outlen</em> undefined. Otherwise (on success) it will return <code>true</code> and set <em>outlen</em> to the total number of output bytes.</p>
<p>If the user is not interested in the length of the output array, a null pointer may be passed in the <em>outlen</em> argument. Note however that the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of raw bytes (or which will be set to <code>null</code> on failure). </td></tr>
    <tr><td class="paramname">outlen</td><td>the address of an integer which will be set to the length of the output array (or which will be left undefined on failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if an unexpected input character was found or some other error occurred.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga081d322bec8070a889aba14d5988ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081d322bec8070a889aba14d5988ae80">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer. </p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If the number of base64 characters required is less than <em>outlen</em>, a terminating <code>null</code> will be written to the end of the output sequence. If the number of base64 characters is <em>outlen</em> or greater, this routine will output as many base64 characters as possible, up to a maximum of <em>outlen</em>.</p>
<p>The routine <a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2" title="Returns the number of base64 characters required to encode the given number of bytes.">base64Length()</a> can be used to precalculate precisely how many output characters will be required.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting base64 characters will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>the length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga541f612d6bb0f94db16da14169813e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541f612d6bb0f94db16da14169813e29">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, which will be null-terminated. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>If the output array is too large (in particular, the expected size will overflow a <code>size_t</code>), the <em>out</em> pointer will be set to <code>null</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of base64 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output array, not counting the terminating null.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="gaa8d632b73943b5c52e395d56f8e03af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d632b73943b5c52e395d56f8e03af2">&#9670;&nbsp;</a></span>base64Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes. </p>
<p>This is the number of characters used (excluding the null terminator) by the routine <a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29" title="Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing...">base64Encode(const char*, size_t, char**)</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the number of raw input bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding number of base64 printable output characters. </dd></dl>

</div>
</div>
<a id="ga032b26a588e2bdbcc5a74e05f8c37fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032b26a588e2bdbcc5a74e05f8c37fa9">&#9670;&nbsp;</a></span>basicTokenise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the given string into tokens. </p>
<p>This is an extremely simple tokeniser; tokens are defined to be separated by whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting tokens will be written; this must accept objects of type <code>const std::string&amp;</code>. </td></tr>
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tokens found. </dd></dl>

</div>
</div>
<a id="gaf3cfd88109df8473b8ae9647ff96d35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3cfd88109df8473b8ae9647ff96d35a">&#9670;&nbsp;</a></span>bitsRequired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr int regina::bitsRequired </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits required to store integers in the range 0,...,<em>n</em>-1. </p>
<p>This is simply the number of bits in the binary expansion of <em>n</em>-1.</p>
<p>If <em>n</em> is non-positive then this function will return 0.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bits required to store 0,...,<em>n</em>-1.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a20ee136c5a257176ff117f0eafb4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a20ee136c5a257176ff117f0eafb4a0">&#9670;&nbsp;</a></span>clonePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a id="gae9fe03c364fe26a4f0e93c59a198b267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9fe03c364fe26a4f0e93c59a198b267">&#9670;&nbsp;</a></span>clonePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>Note that, even though this routine takes a std::unique_ptr, it returns a raw pointer. The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a id="ga69b2411865af18bf506a1afb7d2bc2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b2411865af18bf506a1afb7d2bc2ca">&#9670;&nbsp;</a></span>duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* regina::duplicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new C string that is a duplicate of the given C++ string. </p>
<p>The deallocation of the new C string is the responsibility of the caller of this routine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the C++ string to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new duplicate C string. </dd></dl>

</div>
</div>
<a id="ga231a1c1fdf6cc37e09fbc77ea2cf14ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">&#9670;&nbsp;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given character is a base64 printable character as used by the base64 routines in Regina. </p>
<p>The base64 printable characters are the letters (both upper-case and lower-case), digits, plus (+), and forward slash (/).</p>
<p>Note that the equals sign (=) is padding, and is not considered by this routine to be a base64 printable character.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>any character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given character is one of the base64 printable characters used in Regina, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="gaf8ad7790348b617ffd8fdf50736cd9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ad7790348b617ffd8fdf50736cd9cf">&#9670;&nbsp;</a></span>nextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::nextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the smallest integer power of two that is greater than or equal to the given argument <em>n</em>. </p>
<p>If <em>n</em> is non-positive then this function will return 1.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the return value is the same type as the argument <em>n</em>, this routine may still overflow. For example, if <em>IntType</em> is a signed char then nextPowerOfTwo(127) will return -128, and if <em>IntType</em> is an unsigned char then nextPowerOfTwo(255) will return 0. Be sure that <em>IntType</em> is large enough for your requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest integer power of two that is &ge; <em>n</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1fc8fedcb72b9db35901807c795486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1fc8fedcb72b9db35901807c795486c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gabf61c8a34e52f0aeb02f200c88026c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf61c8a34e52f0aeb02f200c88026c1c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask1.html">Tritmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0a04e46c3516672d83a09e6f07b85876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a04e46c3516672d83a09e6f07b85876">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga7e140a57f469e663d87f1d3e14a90187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e140a57f469e663d87f1d3e14a90187">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p>The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gaa0c5c9157147686a6bfc401312b8d90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c5c9157147686a6bfc401312b8d90c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given sequence to the given output stream. </p>
<p>No newline will be written.</p>
<p>The sequence will be written in the form <code>(a, b, c, ...)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An object <em>x</em> of type <em>T</em> can be written to an output stream using the syntax <code>out &lt;&lt; x</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the sequence to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga687edae41955adbcf9e58c8cce90ea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687edae41955adbcf9e58c8cce90ea68">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga42e53899b74d99054f31035492d5890a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e53899b74d99054f31035492d5890a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gac720197cc16b77f2647c6cfdeccd8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac720197cc16b77f2647c6cfdeccd8038">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tritmask2.html">Tritmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0dc9ea5844d6e3886aae7e101929e85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc9ea5844d6e3886aae7e101929e85e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga4056bad007750e92b40959aca2c4f987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4056bad007750e92b40959aca2c4f987">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given C++ string begins with the given prefix. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the full C++ string to examine. </td></tr>
    <tr><td class="paramname">prefix</td><td>the prefix whose presence we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>str</em> begins with <em>prefix</em>. </dd></dl>

</div>
</div>
<a id="ga36927634ca1155f6e5fb60b3ce8f2278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36927634ca1155f6e5fb60b3ce8f2278">&#9670;&nbsp;</a></span>stringToToken() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="ga80c74082b6559d30c0073ff0a889e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c74082b6559d30c0073ff0a889e09e">&#9670;&nbsp;</a></span>stringToToken() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="gaa678d35fabfebccce72406d01076829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa678d35fabfebccce72406d01076829c">&#9670;&nbsp;</a></span>stripWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips all whitespace from the beginning and end of the given C++ string. </p>
<p>The new stripped string is returned; the original string is not altered.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be stripped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting stripped string. </dd></dl>

</div>
</div>
<a id="ga61ea966075c340b411ef07cc5aee1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ea966075c340b411ef07cc5aee1213">&#9670;&nbsp;</a></span>subscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::subscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode subscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga92f5f4f8be21a36101e67ed4b461ba19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f5f4f8be21a36101e67ed4b461ba19">&#9670;&nbsp;</a></span>superscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::superscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode superscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="gad3439925c61c42453159e0b50bdff960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3439925c61c42453159e0b50bdff960">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p>The substring from <code>s.begin()</code> to the iterator that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return <code>s.end()</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="ga9952c5bb8780ca8f54d450350cc640d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9952c5bb8780ca8f54d450350cc640d7">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p>The substring from <em>s</em> until just before the pointer that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return a pointer to the null terminator of <em>s</em>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="gae40c2e62bf0908919834ea10762def19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c2e62bf0908919834ea10762def19">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf9eaa1f183454edc0db4f915d98c0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9eaa1f183454edc0db4f915d98c0a73">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga384de19626353085bf20eedc89c3c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga384de19626353085bf20eedc89c3c30a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga183ba5dd849f33e9153c3363323abf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183ba5dd849f33e9153c3363323abf5a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga896ae2c6783d6d6dc4081bddabb22518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896ae2c6783d6d6dc4081bddabb22518">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga974a77f98013a0274540b1d0b06519f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a77f98013a0274540b1d0b06519f3">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaad0bb367f8c8f4172e6a979751907c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0bb367f8c8f4172e6a979751907c6c">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga007abfa18426eedc6277f644ded3e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007abfa18426eedc6277f644ded3e068">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gacd5eebbe6059d16231b0e41966e2056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5eebbe6059d16231b0e41966e2056a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad0bc034686407302e3ad597e39933a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0bc034686407302e3ad597e39933a99">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4c91417b8ffbca35aa32c82532f5330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c91417b8ffbca35aa32c82532f5330f">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting arbitrary precision integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d3266c3fb5264747ed7af53464ac7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3266c3fb5264747ed7af53464ac7a9">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a double precision real number and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the real number that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga17e706f7f722922798776b74f9933bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e706f7f722922798776b74f9933bd0">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a boolean and reports whether this conversion was successful. </p>
<p>If the given string begins with <code>T</code>, <code>t</code> or <code>1</code>, then the string will be successfully converted to <code>true</code>. If the given string begins with <code>F</code>, <code>f</code> or <code>0</code>, then the string will be successfully converted to <code>false</code>. Otherwise the conversion will be unsuccessful and argument <em>dest</em> will be set to <code>false</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6083d66d2dcac7dce8637e6282c6c679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6083d66d2dcac7dce8637e6282c6c679">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a set of booleans and reports whether this conversion was successful. </p>
<p>A set of booleans is represented by one of the four strings <code>&ndash;</code>, <code>T-</code>, <code>-F</code> or <code>TF</code>. If the conversion is unsuccessful, argument <em>dest</em> will be set to <a class="el" href="classregina_1_1BoolSet.html#ac99098499b5705ba13a480097906deed" title="The empty set.">BoolSet::sNone</a> and <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting set of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga52c8776c5329496a0b34c914706031e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c8776c5329496a0b34c914706031e4">&#9670;&nbsp;</a></span>writeResUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::writeResUsage </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes time and memory usage for the current process to the given output stream. </p>
<p>Information is gathered from the <code>/proc</code> filesystem, which means that this routine will only write meaningful information under a Linux system where <code>/proc</code> is mounted.</p>
<p>Specifically, this routine reads information on the running process from <code>/proc/self/stat</code>, and writes a short string to the given output stream of the form:</p>
<div class="fragment"><div class="line">utime=..., stime=..., vsize=...</div></div><!-- fragment --><p>The three ellipses in the example above will be replaced with integers, representing:</p>
<ul>
<li>the number jiffies that this process has been scheduled in user mode (the <em>utime</em> field);</li>
<li>the number jiffies that this process has been scheduled in kernel mode (the <em>stime</em> field);</li>
<li>the the virtual memory size in bytes (the <em>vsize</em> field).</li>
</ul>
<p>The description of these three fields is taken directly from the <code>proc(5)</code> manpage. Note that the length of a jiffy can differ from system to system; see the <code>time(7)</code> manpage for details.</p>
<p>The output will not contain a newline, and the given output stream will not be flushed.</p>
<p>If <code>/proc/self/stat</code> cannot be read, this routine will write a short message to that effect to the given output stream (which means that this utility is safe to call under non-Linux operating systems, although it will of course be useless in such scenarios).</p>
<p>If <code>/proc/self/stat</code> can be read but contains unexpected information, the behaviour of this routine is undefined.</p>
<dl class="section user"><dt>Python</dt><dd>This routine does not take any arguments; instead the stream <em>out</em> is assumed to be standard output.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine allows at most 255 characters for the <em>comm</em> field in <code>/proc/self/stat</code> (which stores the executable filename along with surrounding parentheses). If the <em>comm</em> field is too long (i.e., the executable filename is too long), then this routine will not be able to parse <code>/proc/self/stat</code>, and will write a note to this effect to the given output stream. If you encounter this problem, you should be able to fix it by renaming your executable to something shorter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which usage information will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d9135c01a79c7fcfa32caafd8bb4652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9135c01a79c7fcfa32caafd8bb4652">&#9670;&nbsp;</a></span>xmlEncodeComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment. </p>
<p>As well as converting special characters to XML entities, this routine will replace dashes with underscores to avoid double-hyphens (which are illegal in XML comments).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string converted to be usable inside an XML comment. </dd></dl>

</div>
</div>
<a id="ga3a9273b1e8e9c18b33d73012b77c1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9273b1e8e9c18b33d73012b77c1b3f">&#9670;&nbsp;</a></span>xmlEncodeSpecialChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeSpecialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities. </p>
<p>For instance, the string <code>"a \&lt; b"</code> would be converted to <code>"a \&amp;lt; b"</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string with special characters replaced by XML entities. </dd></dl>

</div>
</div>
<a id="gabae034cbea5ca43c01df1f5a1696b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae034cbea5ca43c01df1f5a1696b9f3">&#9670;&nbsp;</a></span>xmlString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlString </td>
          <td>(</td>
          <td class="paramtype">xmlChar *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given string from libxml into a C++ string, optionally deallocating the original libxml string. </p>
<p>The given libxml string <em>str</em> may be <code>null</code>, in which case the resulting C++ string will be the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">free</td><td><code>true</code> if the original libxml string <em>str</em> should be deallocated, or <code>false</code> if it should be preserved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given string as a C++ string. </dd></dl>

</div>
</div>
<a id="gacb9d9d42e182de0dc67e4176414cb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9d9d42e182de0dc67e4176414cb07d">&#9670;&nbsp;</a></span>xmlValueTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlValueTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value. </p>
<p>The tag will be of the form <code>&lt;tagName value="..."/&gt;</code>.</p>
<p>The value itself will be written to the tag string using the standard output stream operator &lt;&lt;.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The property value when written to an output stream does not contain any special characters (such as <code>&lt;</code> or <code>&amp;</code>) that need to be encoded as XML entities.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the XML tag to create. </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to the <em>value</em> property of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding XML tag. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
