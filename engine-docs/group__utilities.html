<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Miscellaneous Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous helper classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceregina"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceregina.html">regina</a></td></tr>
<tr class="memdesc:namespaceregina"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the entire Regina calculation engine. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GenericBitManipulator.html">regina::GenericBitManipulator&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic class for bitwise analysis and manipulation of native data types.  <a href="classregina_1_1GenericBitManipulator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulator.html">regina::BitManipulator&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised class for bitwise analysis and manipulation of native data types.  <a href="classregina_1_1BitManipulator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Flags.html">regina::Flags&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a bitwise combination of flags defined by an enumeration type.  <a href="classregina_1_1Flags.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1Locale.html">regina::i18n::Locale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class with static routines for querying information about the current locale.  <a href="classregina_1_1i18n_1_1Locale.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">regina::i18n::IConvStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream buffer that translates between character encodings.  <a href="classregina_1_1i18n_1_1IConvStreamBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStream.html">regina::i18n::IConvStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream that converts between character encodings.  <a href="classregina_1_1i18n_1_1IConvStream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNew.html">regina::FuncNew&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable generator used to create objects using default constructors.  <a href="structregina_1_1FuncNew.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyPtr.html">regina::FuncNewCopyPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewCopyRef.html">regina::FuncNewCopyRef&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using copy constructors.  <a href="structregina_1_1FuncNewCopyRef.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncNewClonePtr.html">regina::FuncNewClonePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to create objects using the <code>clone()</code> method.  <a href="structregina_1_1FuncNewClonePtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FuncDelete.html">regina::FuncDelete&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable unary function used to deallocate objects.  <a href="structregina_1_1FuncDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NBitmask.html">regina::NBitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask that can store arbitrarily many true-or-false bits.  <a href="classregina_1_1NBitmask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NBitmask1.html">regina::NBitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) true-or-false bits.  <a href="classregina_1_1NBitmask1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NBitmask2.html">regina::NBitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) true-or-false bits.  <a href="classregina_1_1NBitmask2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NBoolSet.html">regina::NBoolSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of booleans.  <a href="classregina_1_1NBoolSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NListOnCall.html">regina::NListOnCall&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers a hard-coded list of expensive objects that should only be created if they are required.  <a href="classregina_1_1NListOnCall.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMarkedElement.html">regina::NMarkedElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for elements of <a class="el" href="classregina_1_1NMarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">NMarkedVector</a>.  <a href="classregina_1_1NMarkedElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMarkedVector.html">regina::NMarkedVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of objects with fast, space-efficient reverse lookup of array indices.  <a href="classregina_1_1NMarkedVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreValue.html">regina::StoreValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classregina_1_1NProperty.html" title="Stores a calculable property of an object.">NProperty</a> storage policy indicating that the property should be held by value.  <a href="classregina_1_1StoreValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreConstPtr.html">regina::StoreConstPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classregina_1_1NProperty.html" title="Stores a calculable property of an object.">NProperty</a> storage policy indicating that the property should be held by constant pointer.  <a href="classregina_1_1StoreConstPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StoreManagedPtr.html">regina::StoreManagedPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classregina_1_1NProperty.html" title="Stores a calculable property of an object.">NProperty</a> storage policy indicating that the property should be held by pointer and that the property wrapper will also take responsibility for memory management.  <a href="classregina_1_1StoreManagedPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPropertyBase.html">regina::NPropertyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class that provides routines shared by all properties, regardless of their individual <a class="el" href="classregina_1_1NProperty.html" title="Stores a calculable property of an object.">NProperty</a> template parameters.  <a href="classregina_1_1NPropertyBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NProperty.html">regina::NProperty&lt; T, Storage &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a calculable property of an object.  <a href="classregina_1_1NProperty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NQitmask1.html">regina::NQitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1NQitmask1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NQitmask2.html">regina::NQitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1NQitmask2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMutex.html">regina::NMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated class that provides mutexes for use with multithreaded code.  <a href="classregina_1_1NMutex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NThread.html">regina::NThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated class that provides very basic thread handling.  <a href="classregina_1_1NThread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTrieSet.html">regina::NTrieSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie-like data structure for storing and retriving sets.  <a href="classregina_1_1NTrieSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTritmask1.html">regina::NTritmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1NTritmask1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTritmask2.html">regina::NTritmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "ternary bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "trits", each equal to 0, 1 or 2.  <a href="classregina_1_1NTritmask2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LessDeref.html">regina::LessDeref&lt; T, Comp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptable binary function used to compare the objects to which pointers are pointing.  <a href="classregina_1_1LessDeref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for objects of type <em>T</em> to be referenceable by a <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a>.  <a href="classregina_1_1SafePointeeBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SafeRemnant.html">regina::detail::SafeRemnant&lt; class &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a>.  <a href="classregina_1_1detail_1_1SafeRemnant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a map from property names to property values.  <a href="classregina_1_1xml_1_1XMLPropertyDict.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParserCallback.html">regina::xml::XMLParserCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the callbacks for an <a class="el" href="classregina_1_1xml_1_1XMLParser.html" title="Used to parse an entire XML file.">XMLParser</a>.  <a href="classregina_1_1xml_1_1XMLParserCallback.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1xml_1_1XMLParser.html">regina::xml::XMLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to parse an entire XML file.  <a href="classregina_1_1xml_1_1XMLParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga856b7c263f702b31e6ab6492768e16eb"><td class="memItemLeft" align="right" valign="top">typedef NBitmask1&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga856b7c263f702b31e6ab6492768e16eb">regina::NBitmaskLen8</a></td></tr>
<tr class="memdesc:ga856b7c263f702b31e6ab6492768e16eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits.  <a href="#ga856b7c263f702b31e6ab6492768e16eb">More...</a><br/></td></tr>
<tr class="separator:ga856b7c263f702b31e6ab6492768e16eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa4f7fbb606adb68cf454158e5f46bf1"><td class="memItemLeft" align="right" valign="top">typedef NBitmask1&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafa4f7fbb606adb68cf454158e5f46bf1">regina::NBitmaskLen16</a></td></tr>
<tr class="memdesc:gafa4f7fbb606adb68cf454158e5f46bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits.  <a href="#gafa4f7fbb606adb68cf454158e5f46bf1">More...</a><br/></td></tr>
<tr class="separator:gafa4f7fbb606adb68cf454158e5f46bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05ef08fcf7ada59a3b75f1965b6ab86"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen32::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae05ef08fcf7ada59a3b75f1965b6ab86">regina::NBitmaskLen32</a></td></tr>
<tr class="memdesc:gae05ef08fcf7ada59a3b75f1965b6ab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits.  <a href="#gae05ef08fcf7ada59a3b75f1965b6ab86">More...</a><br/></td></tr>
<tr class="separator:gae05ef08fcf7ada59a3b75f1965b6ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5dc002a55971b9852525f0247c20ac2"><td class="memItemLeft" align="right" valign="top">typedef InternalBitmaskLen64::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa5dc002a55971b9852525f0247c20ac2">regina::NBitmaskLen64</a></td></tr>
<tr class="memdesc:gaa5dc002a55971b9852525f0247c20ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits.  <a href="#gaa5dc002a55971b9852525f0247c20ac2">More...</a><br/></td></tr>
<tr class="separator:gaa5dc002a55971b9852525f0247c20ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50604f6c41ea71fc02d84eb990cf8a0a"><td class="memItemLeft" align="right" valign="top">typedef NQitmask1&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga50604f6c41ea71fc02d84eb990cf8a0a">regina::NQitmaskLen8</a></td></tr>
<tr class="memdesc:ga50604f6c41ea71fc02d84eb990cf8a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits.  <a href="#ga50604f6c41ea71fc02d84eb990cf8a0a">More...</a><br/></td></tr>
<tr class="separator:ga50604f6c41ea71fc02d84eb990cf8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fb31652119e190e12efe6f7b301cf2"><td class="memItemLeft" align="right" valign="top">typedef NQitmask1&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf1fb31652119e190e12efe6f7b301cf2">regina::NQitmaskLen16</a></td></tr>
<tr class="memdesc:gaf1fb31652119e190e12efe6f7b301cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits.  <a href="#gaf1fb31652119e190e12efe6f7b301cf2">More...</a><br/></td></tr>
<tr class="separator:gaf1fb31652119e190e12efe6f7b301cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0524036897c9570c5edb0f6815f9d5b3"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen32::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0524036897c9570c5edb0f6815f9d5b3">regina::NQitmaskLen32</a></td></tr>
<tr class="memdesc:ga0524036897c9570c5edb0f6815f9d5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits.  <a href="#ga0524036897c9570c5edb0f6815f9d5b3">More...</a><br/></td></tr>
<tr class="separator:ga0524036897c9570c5edb0f6815f9d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427affa54f1729171f7520939437e080"><td class="memItemLeft" align="right" valign="top">typedef InternalQitmaskLen64::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga427affa54f1729171f7520939437e080">regina::NQitmaskLen64</a></td></tr>
<tr class="memdesc:ga427affa54f1729171f7520939437e080"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits.  <a href="#ga427affa54f1729171f7520939437e080">More...</a><br/></td></tr>
<tr class="separator:ga427affa54f1729171f7520939437e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e15d0d3827cbfbb2839be32dade7c04"><td class="memItemLeft" align="right" valign="top">typedef pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1e15d0d3827cbfbb2839be32dade7c04">regina::NThreadID</a></td></tr>
<tr class="memdesc:ga1e15d0d3827cbfbb2839be32dade7c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used for a thread identifier.  <a href="#ga1e15d0d3827cbfbb2839be32dade7c04">More...</a><br/></td></tr>
<tr class="separator:ga1e15d0d3827cbfbb2839be32dade7c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dec25dbb2f2aa026f713c5b2f3deaa0"><td class="memItemLeft" align="right" valign="top">typedef NTritmask1&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga0dec25dbb2f2aa026f713c5b2f3deaa0">regina::NTritmaskLen8</a></td></tr>
<tr class="memdesc:ga0dec25dbb2f2aa026f713c5b2f3deaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits.  <a href="#ga0dec25dbb2f2aa026f713c5b2f3deaa0">More...</a><br/></td></tr>
<tr class="separator:ga0dec25dbb2f2aa026f713c5b2f3deaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0731ddd73d80517452eb147ca0ecc3d"><td class="memItemLeft" align="right" valign="top">typedef NTritmask1&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae0731ddd73d80517452eb147ca0ecc3d">regina::NTritmaskLen16</a></td></tr>
<tr class="memdesc:gae0731ddd73d80517452eb147ca0ecc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits.  <a href="#gae0731ddd73d80517452eb147ca0ecc3d">More...</a><br/></td></tr>
<tr class="separator:gae0731ddd73d80517452eb147ca0ecc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec4e85295ad88e01df2b7096005b955"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen32::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga1ec4e85295ad88e01df2b7096005b955">regina::NTritmaskLen32</a></td></tr>
<tr class="memdesc:ga1ec4e85295ad88e01df2b7096005b955"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits.  <a href="#ga1ec4e85295ad88e01df2b7096005b955">More...</a><br/></td></tr>
<tr class="separator:ga1ec4e85295ad88e01df2b7096005b955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4449d54218214b1c0ea7707586549a2d"><td class="memItemLeft" align="right" valign="top">typedef InternalTritmaskLen64::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4449d54218214b1c0ea7707586549a2d">regina::NTritmaskLen64</a></td></tr>
<tr class="memdesc:ga4449d54218214b1c0ea7707586549a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits.  <a href="#ga4449d54218214b1c0ea7707586549a2d">More...</a><br/></td></tr>
<tr class="separator:ga4449d54218214b1c0ea7707586549a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">regina::base64Length</a> (size_t bytes)</td></tr>
<tr class="memdesc:gaa8d632b73943b5c52e395d56f8e03af2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes.  <a href="#gaa8d632b73943b5c52e395d56f8e03af2">More...</a><br/></td></tr>
<tr class="separator:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">regina::isBase64</a> (char ch)</td></tr>
<tr class="memdesc:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given character is a base64 printable character as used by the base64 routines in Regina.  <a href="#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">More...</a><br/></td></tr>
<tr class="separator:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fdf6a4d8231d67b64be11a60097efa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga9fdf6a4d8231d67b64be11a60097efa2">regina::base64Encode</a> (const char *in, size_t inlen, char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga9fdf6a4d8231d67b64be11a60097efa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer.  <a href="#ga9fdf6a4d8231d67b64be11a60097efa2">More...</a><br/></td></tr>
<tr class="separator:ga9fdf6a4d8231d67b64be11a60097efa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911d5ebf028b600b5df5a2d80533ba84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga911d5ebf028b600b5df5a2d80533ba84">regina::base64Encode</a> (const char *in, size_t inlen, char **out)</td></tr>
<tr class="memdesc:ga911d5ebf028b600b5df5a2d80533ba84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results.  <a href="#ga911d5ebf028b600b5df5a2d80533ba84">More...</a><br/></td></tr>
<tr class="separator:ga911d5ebf028b600b5df5a2d80533ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1e4932763e99fa8ae1beda11f6c880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaad1e4932763e99fa8ae1beda11f6c880">regina::base64Decode</a> (const char *in, size_t inlen, char *out, size_t *outlen)</td></tr>
<tr class="memdesc:gaad1e4932763e99fa8ae1beda11f6c880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer.  <a href="#gaad1e4932763e99fa8ae1beda11f6c880">More...</a><br/></td></tr>
<tr class="separator:gaad1e4932763e99fa8ae1beda11f6c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04538955fe2582f6b7365585c4528a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga04538955fe2582f6b7365585c4528a11">regina::base64Decode</a> (const char *in, size_t inlen, char **out, size_t *outlen)</td></tr>
<tr class="memdesc:ga04538955fe2582f6b7365585c4528a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results.  <a href="#ga04538955fe2582f6b7365585c4528a11">More...</a><br/></td></tr>
<tr class="separator:ga04538955fe2582f6b7365585c4528a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2a96ed25fecca35188a79267f9d4f4ae">regina::i18n::Locale::codeset</a> ()</td></tr>
<tr class="memdesc:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character encoding used in the current locale.  <a href="#ga2a96ed25fecca35188a79267f9d4f4ae">More...</a><br/></td></tr>
<tr class="separator:ga2a96ed25fecca35188a79267f9d4f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3334747d42a32a95043a910a6dd173bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3334747d42a32a95043a910a6dd173bc">regina::i18n::IConvStreamBuffer::IConvStreamBuffer</a> ()</td></tr>
<tr class="memdesc:ga3334747d42a32a95043a910a6dd173bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stream buffer.  <a href="#ga3334747d42a32a95043a910a6dd173bc">More...</a><br/></td></tr>
<tr class="separator:ga3334747d42a32a95043a910a6dd173bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61810bdda48b4a95ef66c577f62eadf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61810bdda48b4a95ef66c577f62eadf4">regina::i18n::IConvStreamBuffer::~IConvStreamBuffer</a> ()</td></tr>
<tr class="memdesc:ga61810bdda48b4a95ef66c577f62eadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this stream buffer.  <a href="#ga61810bdda48b4a95ef66c577f62eadf4">More...</a><br/></td></tr>
<tr class="separator:ga61810bdda48b4a95ef66c577f62eadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8170e81f5d3a805161cc1ff9800e458f"><td class="memItemLeft" align="right" valign="top">IConvStreamBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8170e81f5d3a805161cc1ff9800e458f">regina::i18n::IConvStreamBuffer::open</a> (std::ostream &amp;dest, const char *srcCode, const char *destCode)</td></tr>
<tr class="memdesc:ga8170e81f5d3a805161cc1ff9800e458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new stream buffer that wraps around the given output stream.  <a href="#ga8170e81f5d3a805161cc1ff9800e458f">More...</a><br/></td></tr>
<tr class="separator:ga8170e81f5d3a805161cc1ff9800e458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="memItemLeft" align="right" valign="top">IConvStreamBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaec85de7b3e74749b1dd1d5d8b5f6c1aa">regina::i18n::IConvStreamBuffer::close</a> ()  throw ()</td></tr>
<tr class="memdesc:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this stream buffer.  <a href="#gaec85de7b3e74749b1dd1d5d8b5f6c1aa">More...</a><br/></td></tr>
<tr class="separator:gaec85de7b3e74749b1dd1d5d8b5f6c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga14a3b54d5a102597eb6abfbb173bce7b">regina::i18n::IConvStreamBuffer::overflow</a> (int_type c)</td></tr>
<tr class="memdesc:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends buffered data to the destination output stream, converting between character sets en route.  <a href="#ga14a3b54d5a102597eb6abfbb173bce7b">More...</a><br/></td></tr>
<tr class="separator:ga14a3b54d5a102597eb6abfbb173bce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830d349d83cfdb64fee00d58d65f4aab"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga830d349d83cfdb64fee00d58d65f4aab">regina::i18n::IConvStreamBuffer::underflow</a> ()</td></tr>
<tr class="memdesc:ga830d349d83cfdb64fee00d58d65f4aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply returns EOF (since this is not an input stream).  <a href="#ga830d349d83cfdb64fee00d58d65f4aab">More...</a><br/></td></tr>
<tr class="separator:ga830d349d83cfdb64fee00d58d65f4aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadd2ef9bdf704ed5c23eea6db04fb40e4">regina::i18n::IConvStreamBuffer::sync</a> ()</td></tr>
<tr class="memdesc:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all output buffers.  <a href="#gadd2ef9bdf704ed5c23eea6db04fb40e4">More...</a><br/></td></tr>
<tr class="separator:gadd2ef9bdf704ed5c23eea6db04fb40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08add9882e50e93fb34b4e420725d90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae08add9882e50e93fb34b4e420725d90">regina::i18n::IConvStream::IConvStream</a> (std::ostream &amp;dest, const char *srcCode, const char *destCode)</td></tr>
<tr class="memdesc:gae08add9882e50e93fb34b4e420725d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>; see the class notes for details.  <a href="#gae08add9882e50e93fb34b4e420725d90">More...</a><br/></td></tr>
<tr class="separator:gae08add9882e50e93fb34b4e420725d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc0473e45f8344efa6a5a3c482b979c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8fc0473e45f8344efa6a5a3c482b979c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NBitmask &amp;mask)</td></tr>
<tr class="memdesc:ga8fc0473e45f8344efa6a5a3c482b979c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="#ga8fc0473e45f8344efa6a5a3c482b979c">More...</a><br/></td></tr>
<tr class="separator:ga8fc0473e45f8344efa6a5a3c482b979c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e79147cbb0c81232ec5b87c23840b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1e79147cbb0c81232ec5b87c23840b8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa1e79147cbb0c81232ec5b87c23840b8">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NBitmask1&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gaa1e79147cbb0c81232ec5b87c23840b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="#gaa1e79147cbb0c81232ec5b87c23840b8">More...</a><br/></td></tr>
<tr class="separator:gaa1e79147cbb0c81232ec5b87c23840b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992d56119e51a4ce310f093c59383871"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga992d56119e51a4ce310f093c59383871"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga992d56119e51a4ce310f093c59383871">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NBitmask2&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga992d56119e51a4ce310f093c59383871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="#ga992d56119e51a4ce310f093c59383871">More...</a><br/></td></tr>
<tr class="separator:ga992d56119e51a4ce310f093c59383871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf767f617d0f1fa9c32fb9cb85b829e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacf767f617d0f1fa9c32fb9cb85b829e0">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NBoolSet &amp;set)</td></tr>
<tr class="memdesc:gacf767f617d0f1fa9c32fb9cb85b829e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="#gacf767f617d0f1fa9c32fb9cb85b829e0">More...</a><br/></td></tr>
<tr class="separator:gacf767f617d0f1fa9c32fb9cb85b829e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8043adf05b720dec3cd4516a4cb18b48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8043adf05b720dec3cd4516a4cb18b48"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8043adf05b720dec3cd4516a4cb18b48">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NQitmask1&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga8043adf05b720dec3cd4516a4cb18b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="#ga8043adf05b720dec3cd4516a4cb18b48">More...</a><br/></td></tr>
<tr class="separator:ga8043adf05b720dec3cd4516a4cb18b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91cdcf0d41e666bedfa9b68cc7d8063"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab91cdcf0d41e666bedfa9b68cc7d8063"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab91cdcf0d41e666bedfa9b68cc7d8063">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NQitmask2&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gab91cdcf0d41e666bedfa9b68cc7d8063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="#gab91cdcf0d41e666bedfa9b68cc7d8063">More...</a><br/></td></tr>
<tr class="separator:gab91cdcf0d41e666bedfa9b68cc7d8063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac575cc2bf6295ad09eef8727d28324"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5ac575cc2bf6295ad09eef8727d28324"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5ac575cc2bf6295ad09eef8727d28324">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NTritmask1&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga5ac575cc2bf6295ad09eef8727d28324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="#ga5ac575cc2bf6295ad09eef8727d28324">More...</a><br/></td></tr>
<tr class="separator:ga5ac575cc2bf6295ad09eef8727d28324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717790baf4392e32dcffc67e3cdea383"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga717790baf4392e32dcffc67e3cdea383"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga717790baf4392e32dcffc67e3cdea383">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NTritmask2&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga717790baf4392e32dcffc67e3cdea383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2).  <a href="#ga717790baf4392e32dcffc67e3cdea383">More...</a><br/></td></tr>
<tr class="separator:ga717790baf4392e32dcffc67e3cdea383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a20ee136c5a257176ff117f0eafb4a0">regina::clonePtr</a> (T *cloneMe)</td></tr>
<tr class="memdesc:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="#ga3a20ee136c5a257176ff117f0eafb4a0">More...</a><br/></td></tr>
<tr class="separator:ga3a20ee136c5a257176ff117f0eafb4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae9fe03c364fe26a4f0e93c59a198b267">regina::clonePtr</a> (const std::unique_ptr&lt; T &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gae9fe03c364fe26a4f0e93c59a198b267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple routine for cloning an object if and only if it exists.  <a href="#gae9fe03c364fe26a4f0e93c59a198b267">More...</a><br/></td></tr>
<tr class="separator:gae9fe03c364fe26a4f0e93c59a198b267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0458a035bc263e30fb2cbcab1d75f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac0458a035bc263e30fb2cbcab1d75f06">regina::duplicate</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gac0458a035bc263e30fb2cbcab1d75f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new C string that is a duplicate of the given C++ string.  <a href="#gac0458a035bc263e30fb2cbcab1d75f06">More...</a><br/></td></tr>
<tr class="separator:gac0458a035bc263e30fb2cbcab1d75f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa165a570bab53541de3037867f7625b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa165a570bab53541de3037867f7625b6">regina::startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:gaa165a570bab53541de3037867f7625b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given C++ string begins with the given prefix.  <a href="#gaa165a570bab53541de3037867f7625b6">More...</a><br/></td></tr>
<tr class="separator:gaa165a570bab53541de3037867f7625b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02338283854929eddc31e24ef7bc721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae02338283854929eddc31e24ef7bc721">regina::stripWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae02338283854929eddc31e24ef7bc721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all whitespace from the beginning and end of the given C++ string.  <a href="#gae02338283854929eddc31e24ef7bc721">More...</a><br/></td></tr>
<tr class="separator:gae02338283854929eddc31e24ef7bc721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a315730e1f40f171023afdddd872f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7a315730e1f40f171023afdddd872f56">regina::valueOf</a> (const std::string &amp;str, int8_t &amp;dest)</td></tr>
<tr class="memdesc:ga7a315730e1f40f171023afdddd872f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an 8-bit integer and reports whether this conversion was successful.  <a href="#ga7a315730e1f40f171023afdddd872f56">More...</a><br/></td></tr>
<tr class="separator:ga7a315730e1f40f171023afdddd872f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb53fedbdba579f4d8c60c6353a69e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabdb53fedbdba579f4d8c60c6353a69e2">regina::valueOf</a> (const std::string &amp;str, uint8_t &amp;dest)</td></tr>
<tr class="memdesc:gabdb53fedbdba579f4d8c60c6353a69e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful.  <a href="#gabdb53fedbdba579f4d8c60c6353a69e2">More...</a><br/></td></tr>
<tr class="separator:gabdb53fedbdba579f4d8c60c6353a69e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7ee33ca7b3e676a6f9738ce3cfcf2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8f7ee33ca7b3e676a6f9738ce3cfcf2e">regina::valueOf</a> (const std::string &amp;str, short &amp;dest)</td></tr>
<tr class="memdesc:ga8f7ee33ca7b3e676a6f9738ce3cfcf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a short integer and reports whether this conversion was successful.  <a href="#ga8f7ee33ca7b3e676a6f9738ce3cfcf2e">More...</a><br/></td></tr>
<tr class="separator:ga8f7ee33ca7b3e676a6f9738ce3cfcf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae502d79612d04bb7574cc8e2ecb9f9e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae502d79612d04bb7574cc8e2ecb9f9e9">regina::valueOf</a> (const std::string &amp;str, unsigned short &amp;dest)</td></tr>
<tr class="memdesc:gae502d79612d04bb7574cc8e2ecb9f9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned short integer and reports whether this conversion was successful.  <a href="#gae502d79612d04bb7574cc8e2ecb9f9e9">More...</a><br/></td></tr>
<tr class="separator:gae502d79612d04bb7574cc8e2ecb9f9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2e44c931822cb4f57315906ef06e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8a2e44c931822cb4f57315906ef06e4f">regina::valueOf</a> (const std::string &amp;str, int &amp;dest)</td></tr>
<tr class="memdesc:ga8a2e44c931822cb4f57315906ef06e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an integer and reports whether this conversion was successful.  <a href="#ga8a2e44c931822cb4f57315906ef06e4f">More...</a><br/></td></tr>
<tr class="separator:ga8a2e44c931822cb4f57315906ef06e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10a1a76d6c53daf9fef5b88b93c30aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa10a1a76d6c53daf9fef5b88b93c30aa">regina::valueOf</a> (const std::string &amp;str, unsigned &amp;dest)</td></tr>
<tr class="memdesc:gaa10a1a76d6c53daf9fef5b88b93c30aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned integer and reports whether this conversion was successful.  <a href="#gaa10a1a76d6c53daf9fef5b88b93c30aa">More...</a><br/></td></tr>
<tr class="separator:gaa10a1a76d6c53daf9fef5b88b93c30aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cad8417fc673fc05844f7764f03717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga85cad8417fc673fc05844f7764f03717">regina::valueOf</a> (const std::string &amp;str, long &amp;dest)</td></tr>
<tr class="memdesc:ga85cad8417fc673fc05844f7764f03717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long integer and reports whether this conversion was successful.  <a href="#ga85cad8417fc673fc05844f7764f03717">More...</a><br/></td></tr>
<tr class="separator:ga85cad8417fc673fc05844f7764f03717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f52260006f223aa8e6421a277f9658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga75f52260006f223aa8e6421a277f9658">regina::valueOf</a> (const std::string &amp;str, unsigned long &amp;dest)</td></tr>
<tr class="memdesc:ga75f52260006f223aa8e6421a277f9658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long integer and reports whether this conversion was successful.  <a href="#ga75f52260006f223aa8e6421a277f9658">More...</a><br/></td></tr>
<tr class="separator:ga75f52260006f223aa8e6421a277f9658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29af8bd898ad38776a9650b4e8e8bc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga29af8bd898ad38776a9650b4e8e8bc46">regina::valueOf</a> (const std::string &amp;str, long long &amp;dest)</td></tr>
<tr class="memdesc:ga29af8bd898ad38776a9650b4e8e8bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long long integer and reports whether this conversion was successful.  <a href="#ga29af8bd898ad38776a9650b4e8e8bc46">More...</a><br/></td></tr>
<tr class="separator:ga29af8bd898ad38776a9650b4e8e8bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65abee6c367f37903ebd7faf63cfb53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga65abee6c367f37903ebd7faf63cfb53d">regina::valueOf</a> (const std::string &amp;str, unsigned long long &amp;dest)</td></tr>
<tr class="memdesc:ga65abee6c367f37903ebd7faf63cfb53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful.  <a href="#ga65abee6c367f37903ebd7faf63cfb53d">More...</a><br/></td></tr>
<tr class="separator:ga65abee6c367f37903ebd7faf63cfb53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee54f0940c114e5fb4c91e5405ad762"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:gabee54f0940c114e5fb4c91e5405ad762"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gabee54f0940c114e5fb4c91e5405ad762">regina::valueOf</a> (const std::string &amp;str, NIntegerBase&lt; supportInfinity &gt; &amp;dest)</td></tr>
<tr class="memdesc:gabee54f0940c114e5fb4c91e5405ad762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful.  <a href="#gabee54f0940c114e5fb4c91e5405ad762">More...</a><br/></td></tr>
<tr class="separator:gabee54f0940c114e5fb4c91e5405ad762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6084865e81b1123c5784f495ef26c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf6084865e81b1123c5784f495ef26c2a">regina::valueOf</a> (const std::string &amp;str, double &amp;dest)</td></tr>
<tr class="memdesc:gaf6084865e81b1123c5784f495ef26c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a double precision real number and reports whether this conversion was successful.  <a href="#gaf6084865e81b1123c5784f495ef26c2a">More...</a><br/></td></tr>
<tr class="separator:gaf6084865e81b1123c5784f495ef26c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36246bf219177a5c29e748f8a2372568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga36246bf219177a5c29e748f8a2372568">regina::valueOf</a> (const std::string &amp;str, bool &amp;dest)</td></tr>
<tr class="memdesc:ga36246bf219177a5c29e748f8a2372568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a boolean and reports whether this conversion was successful.  <a href="#ga36246bf219177a5c29e748f8a2372568">More...</a><br/></td></tr>
<tr class="separator:ga36246bf219177a5c29e748f8a2372568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54d8054a7f57b607af01c536c6aeeda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf54d8054a7f57b607af01c536c6aeeda">regina::valueOf</a> (const std::string &amp;str, NBoolSet &amp;dest)</td></tr>
<tr class="memdesc:gaf54d8054a7f57b607af01c536c6aeeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a set of booleans and reports whether this conversion was successful.  <a href="#gaf54d8054a7f57b607af01c536c6aeeda">More...</a><br/></td></tr>
<tr class="separator:gaf54d8054a7f57b607af01c536c6aeeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">regina::basicTokenise</a> (OutputIterator results, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes the given string into tokens.  <a href="#ga032b26a588e2bdbcc5a74e05f8c37fa9">More...</a><br/></td></tr>
<tr class="separator:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02423c926a34ad5052dad7ee1f420932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga02423c926a34ad5052dad7ee1f420932">regina::stringToToken</a> (const char *str)</td></tr>
<tr class="memdesc:ga02423c926a34ad5052dad7ee1f420932"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="#ga02423c926a34ad5052dad7ee1f420932">More...</a><br/></td></tr>
<tr class="separator:ga02423c926a34ad5052dad7ee1f420932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387aacc2048e118fb4159654b26bccb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga387aacc2048e118fb4159654b26bccb4">regina::stringToToken</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga387aacc2048e118fb4159654b26bccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string.  <a href="#ga387aacc2048e118fb4159654b26bccb4">More...</a><br/></td></tr>
<tr class="separator:ga387aacc2048e118fb4159654b26bccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">regina::superscript</a> (T value)</td></tr>
<tr class="memdesc:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given native C++ integer into a unicode superscript string.  <a href="#ga92f5f4f8be21a36101e67ed4b461ba19">More...</a><br/></td></tr>
<tr class="separator:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">regina::subscript</a> (T value)</td></tr>
<tr class="memdesc:ga61ea966075c340b411ef07cc5aee1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given native C++ integer into a unicode subscript string.  <a href="#ga61ea966075c340b411ef07cc5aee1213">More...</a><br/></td></tr>
<tr class="separator:ga61ea966075c340b411ef07cc5aee1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc38cdf17c6d0ea2ce1c735739bd19ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafc38cdf17c6d0ea2ce1c735739bd19ad">regina::xml::xmlEncodeSpecialChars</a> (const std::string &amp;original)</td></tr>
<tr class="memdesc:gafc38cdf17c6d0ea2ce1c735739bd19ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities.  <a href="#gafc38cdf17c6d0ea2ce1c735739bd19ad">More...</a><br/></td></tr>
<tr class="separator:gafc38cdf17c6d0ea2ce1c735739bd19ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0929ed8d58025412052a644276fda7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac0929ed8d58025412052a644276fda7a">regina::xml::xmlEncodeComment</a> (const std::string &amp;comment)</td></tr>
<tr class="memdesc:gac0929ed8d58025412052a644276fda7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment.  <a href="#gac0929ed8d58025412052a644276fda7a">More...</a><br/></td></tr>
<tr class="separator:gac0929ed8d58025412052a644276fda7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">regina::xml::xmlValueTag</a> (const std::string &amp;tagName, const T &amp;value)</td></tr>
<tr class="memdesc:gacb9d9d42e182de0dc67e4176414cb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value.  <a href="#gacb9d9d42e182de0dc67e4176414cb07d">More...</a><br/></td></tr>
<tr class="separator:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous helper classes and functions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gafa4f7fbb606adb68cf454158e5f46bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NBitmask1&lt;unsigned int&gt; <a class="el" href="group__utilities.html#gafa4f7fbb606adb68cf454158e5f46bf1">regina::NBitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NBitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits...">NBitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="gae05ef08fcf7ada59a3b75f1965b6ab86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen32 ::Type <a class="el" href="group__utilities.html#gae05ef08fcf7ada59a3b75f1965b6ab86">regina::NBitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NBitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits...">NBitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5dc002a55971b9852525f0247c20ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalBitmaskLen64 ::Type <a class="el" href="group__utilities.html#gaa5dc002a55971b9852525f0247c20ac2">regina::NBitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1NBitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits...">NBitmask1</a> or the template class <a class="el" href="classregina_1_1NBitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">NBitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga856b7c263f702b31e6ab6492768e16eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NBitmask1&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga856b7c263f702b31e6ab6492768e16eb">regina::NBitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NBitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits...">NBitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1fb31652119e190e12efe6f7b301cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NQitmask1&lt;unsigned int&gt; <a class="el" href="group__utilities.html#gaf1fb31652119e190e12efe6f7b301cf2">regina::NQitmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NQitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;...">NQitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0524036897c9570c5edb0f6815f9d5b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen32 ::Type <a class="el" href="group__utilities.html#ga0524036897c9570c5edb0f6815f9d5b3">regina::NQitmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NQitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;...">NQitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga427affa54f1729171f7520939437e080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalQitmaskLen64 ::Type <a class="el" href="group__utilities.html#ga427affa54f1729171f7520939437e080">regina::NQitmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1NQitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;...">NQitmask1</a> or the template class <a class="el" href="classregina_1_1NQitmask2.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U) ...">NQitmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50604f6c41ea71fc02d84eb990cf8a0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NQitmask1&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga50604f6c41ea71fc02d84eb990cf8a0a">regina::NQitmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits. </p>
<p>This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NQitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;...">NQitmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e15d0d3827cbfbb2839be32dade7c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pthread_t <a class="el" href="group__utilities.html#ga1e15d0d3827cbfbb2839be32dade7c04">regina::NThreadID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used for a thread identifier. </p>

</div>
</div>
<a class="anchor" id="gae0731ddd73d80517452eb147ca0ecc3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NTritmask1&lt;unsigned int&gt; <a class="el" href="group__utilities.html#gae0731ddd73d80517452eb147ca0ecc3d">regina::NTritmaskLen16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 16 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NTritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;...">NTritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ec4e85295ad88e01df2b7096005b955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen32 ::Type <a class="el" href="group__utilities.html#ga1ec4e85295ad88e01df2b7096005b955">regina::NTritmaskLen32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 32 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NTritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;...">NTritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4449d54218214b1c0ea7707586549a2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalTritmaskLen64 ::Type <a class="el" href="group__utilities.html#ga4449d54218214b1c0ea7707586549a2d">regina::NTritmaskLen64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 64 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1NTritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;...">NTritmask1</a> or the template class <a class="el" href="classregina_1_1NTritmask2.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U)...">NTritmask2</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dec25dbb2f2aa026f713c5b2f3deaa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NTritmask1&lt;unsigned char&gt; <a class="el" href="group__utilities.html#ga0dec25dbb2f2aa026f713c5b2f3deaa0">regina::NTritmaskLen8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef that gives a small and extremely fast tritmask class capable of holding at least 8 true-or-false bits. </p>
<p>This tritmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1NTritmask1.html" title="A small but extremely fast &quot;ternary bitmask&quot; class that can store up to 8 * sizeof(T) &quot;trits&quot;...">NTritmask1</a>.</p>
<p>The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaad1e4932763e99fa8ae1beda11f6c880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer. </p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found, or the output buffer is exhausted, this routine will write as many output bytes as it can and then return <code>false</code>. Otherwise (on success) it will return <code>true</code>. Either way, it will reset <em>outlen</em> to the total number of bytes that were written.</p>
<p>The total number of output bytes is important to know, since the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting raw bytes will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>must contain the length of the output buffer on entry, and on exit contains the number of output bytes that were successfully written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if the output buffer was exhausted or an unexpected input character was found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64...">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04538955fe2582f6b7365585c4528a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, and <em>outlen</em> will be set to the number of raw bytes in this output array. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found or the output buffer is exhausted, this routine will return <code>false</code>, set <em>out</em> to <code>null</code>, and leave <em>outlen</em> undefined. Otherwise (on success) it will return <code>true</code> and set <em>outlen</em> to the total number of output bytes.</p>
<p>If the user is not interested in the length of the output array, a null pointer may be passed in the <em>outlen</em> argument. Note however that the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of raw bytes (or which will be set to <code>null</code> on failure). </td></tr>
    <tr><td class="paramname">outlen</td><td>the address of an integer which will be set to the length of the output array (or which will be left undefined on failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if an unexpected input character was found or some other error occurred.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64...">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fdf6a4d8231d67b64be11a60097efa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer. </p>
<p>The length of the output buffer is passed as the argument <em>outlen</em>. If the number of base64 characters required is less than <em>outlen</em>, a terminating <code>null</code> will be written to the end of the output sequence. If the number of base64 characters is <em>outlen</em> or greater, this routine will output as many base64 characters as possible, up to a maximum of <em>outlen</em>.</p>
<p>The routine <a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2" title="Returns the number of base64 characters required to encode the given number of bytes.">base64Length()</a> can be used to precalculate precisely how many output characters will be required.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting base64 characters will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>the length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64...">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga911d5ebf028b600b5df5a2d80533ba84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> size_t regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results. </p>
<p>The <em>out</em> pointer will be set to this new array, which will be null-terminated. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p>If the output array is too large (in particular, the expected size will overflow a <code>size_t</code>), the <em>out</em> pointer will be set to <code>null</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of base64 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output array, not counting the terminating null.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64...">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8d632b73943b5c52e395d56f8e03af2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of base64 characters required to encode the given number of bytes. </p>
<p>This is the number of characters used (excluding the null terminator) by the routine <a class="el" href="group__utilities.html#ga911d5ebf028b600b5df5a2d80533ba84" title="Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing...">base64Encode(const char*, size_t, char**)</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the number of raw input bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding number of base64 printable output characters. </dd></dl>

</div>
</div>
<a class="anchor" id="ga032b26a588e2bdbcc5a74e05f8c37fa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the given string into tokens. </p>
<p>This is an extremely simple tokeniser; tokens are defined to be separated by whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting tokens will be written; this must accept objects of type <code>const std::string&amp;</code>. </td></tr>
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tokens found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a20ee136c5a257176ff117f0eafb4a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9fe03c364fe26a4f0e93c59a198b267"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* regina::clonePtr </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple routine for cloning an object if and only if it exists. </p>
<p>If the given pointer is non-null, this routine returns a new clone of the object, created using the copy constructor for type <em>T</em>. Otherwise this routine simply returns a null pointer.</p>
<p>Note that, even though this routine takes a std::unique_ptr, it returns a raw pointer. The caller of this routine is responsible for deleting the new clone when it is no longer required.</p>
<p>This routine can be useful when implementing copy constructors for classes that only initialise internal data members on demand.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a pointer to the object to clone; this may be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated copy of the given object, or the null pointer if <em>cloneMe</em> is null. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec85de7b3e74749b1dd1d5d8b5f6c1aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IConvStreamBuffer* regina::i18n::IConvStreamBuffer::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes this stream buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>this stream buffer on success, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a96ed25fecca35188a79267f9d4f4ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* regina::i18n::Locale::codeset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character encoding used in the current locale. </p>
<p>This is a plain string, such as "UTF-8" or "ISO-8859-1".</p>
<dl class="section return"><dt>Returns</dt><dd>the character encoding for the current locale. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0458a035bc263e30fb2cbcab1d75f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> char* regina::duplicate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new C string that is a duplicate of the given C++ string. </p>
<p>The deallocation of the new C string is the responsibility of the caller of this routine.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the C++ string to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new duplicate C string. </dd></dl>

</div>
</div>
<a class="anchor" id="gae08add9882e50e93fb34b4e420725d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStream::IConvStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>; see the class notes for details. </p>
<p>If the given encodings are invalid, this stream will still forward data to the given output stream but no conversion will take place.</p>
<p>See the <em>iconv</em> documentation for information on what encodings are supported. For the GNU C library implementation, valid encodings can be found by running <code>iconv &ndash;list</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination output stream is already open.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination output stream. </td></tr>
    <tr><td class="paramname">srcCode</td><td>the character encoding for data that is to be written into this <a class="el" href="classregina_1_1i18n_1_1IConvStream.html" title="An output stream that converts between character encodings.">IConvStream</a>. </td></tr>
    <tr><td class="paramname">destCode</td><td>the character encoding for the translated data that will subsequently be written to the destination output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3334747d42a32a95043a910a6dd173bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStreamBuffer::IConvStreamBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new stream buffer. </p>

</div>
</div>
<a class="anchor" id="ga231a1c1fdf6cc37e09fbc77ea2cf14ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given character is a base64 printable character as used by the base64 routines in Regina. </p>
<p>The base64 printable characters are the letters (both upper-case and lower-case), digits, plus (+), and forward slash (/).</p>
<p>Note that the equals sign (=) is padding, and is not considered by this routine to be a base64 printable character.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>any character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given character is one of the base64 printable characters used in Regina, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8170e81f5d3a805161cc1ff9800e458f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IConvStreamBuffer* regina::i18n::IConvStreamBuffer::open </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a new stream buffer that wraps around the given output stream. </p>
<p>If this stream buffer is already open, it will be closed and then reopened with the given parameters.</p>
<p>Any data that is sent to this stream buffer will be translated from <em>srcCode</em> to <em>destCode</em> and passed on to the given output stream.</p>
<p>If the given encodings are invalid, this stream will still forward data to the given output stream but no conversion will take place.</p>
<p>See the <em>iconv</em> documentation for information on what encodings are supported. For the GNU C library implementation, valid encodings can be found by running <code>iconv &ndash;list</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination output stream is already open.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination output stream. </td></tr>
    <tr><td class="paramname">srcCode</td><td>the character encoding for data that is to be written into this stream buffer. </td></tr>
    <tr><td class="paramname">destCode</td><td>the character encoding for the translated data that will subsequently be written to the destination output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this stream buffer on success, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8043adf05b720dec3cd4516a4cb18b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NQitmask1&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ac575cc2bf6295ad09eef8727d28324"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTritmask1&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="gab91cdcf0d41e666bedfa9b68cc7d8063"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NQitmask2&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p>Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf767f617d0f1fa9c32fb9cb85b829e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NBoolSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p>The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fc0473e45f8344efa6a5a3c482b979c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NBitmask &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1e79147cbb0c81232ec5b87c23840b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NBitmask1&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga717790baf4392e32dcffc67e3cdea383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTritmask2&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given tritmask to the given output stream as a sequence of digits (0, 1 and/or 2). </p>
<p>Since the length of the tritmask is not stored, the number of trits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the tritmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga992d56119e51a4ce310f093c59383871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NBitmask2&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14a3b54d5a102597eb6abfbb173bce7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_type regina::i18n::IConvStreamBuffer::overflow </td>
          <td>(</td>
          <td class="paramtype">int_type&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends buffered data to the destination output stream, converting between character sets en route. </p>
<p>The buffer will be flushed as far as possible, and any invalid characters will be replaced with one or more question marks. If the buffer ends in an incomplete multibyte character, this incomplete character will be held back (since it presumably needs to be combined with later input).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an extra character to send that did not fit in the internal buffer, or EOF if we simply wish to flush the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or EOF on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa165a570bab53541de3037867f7625b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given C++ string begins with the given prefix. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the full C++ string to examine. </td></tr>
    <tr><td class="paramname">prefix</td><td>the prefix whose presence we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>str</em> begins with <em>prefix</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02423c926a34ad5052dad7ee1f420932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a class="anchor" id="ga387aacc2048e118fb4159654b26bccb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a token derived from the given string. </p>
<p>All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a class="anchor" id="gae02338283854929eddc31e24ef7bc721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string regina::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips all whitespace from the beginning and end of the given C++ string. </p>
<p>The new stripped string is returned; the original string is not altered.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be stripped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting stripped string. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61ea966075c340b411ef07cc5aee1213"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::subscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given native C++ integer into a unicode subscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to NInteger or NLargeInteger.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to NInteger and NLargeInteger. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92f5f4f8be21a36101e67ed4b461ba19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::superscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given native C++ integer into a unicode superscript string. </p>
<p>The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to NInteger or NLargeInteger.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to NInteger and NLargeInteger. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd2ef9bdf704ed5c23eea6db04fb40e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::i18n::IConvStreamBuffer::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all output buffers. </p>
<p>The buffers for both this stream and the destination output stream will be flushed.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga830d349d83cfdb64fee00d58d65f4aab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IConvStreamBuffer::int_type regina::i18n::IConvStreamBuffer::underflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply returns EOF (since this is not an input stream). </p>
<dl class="section return"><dt>Returns</dt><dd>EOF. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a315730e1f40f171023afdddd872f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gabdb53fedbdba579f4d8c60c6353a69e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f7ee33ca7b3e676a6f9738ce3cfcf2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae502d79612d04bb7574cc8e2ecb9f9e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned short integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a2e44c931822cb4f57315906ef06e4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa10a1a76d6c53daf9fef5b88b93c30aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85cad8417fc673fc05844f7764f03717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75f52260006f223aa8e6421a277f9658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29af8bd898ad38776a9650b4e8e8bc46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65abee6c367f37903ebd7faf63cfb53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gabee54f0940c114e5fb4c91e5405ad762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NIntegerBase&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting arbitrary precision integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6084865e81b1123c5784f495ef26c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a double precision real number and reports whether this conversion was successful. </p>
<p>The given string should contain no whitespace or other characters that are not a part of the real number that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36246bf219177a5c29e748f8a2372568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a boolean and reports whether this conversion was successful. </p>
<p>If the given string begins with <code>T</code> or <code>F</code> (either upper- or lower-case), the string will be successfully converted to <code>true</code> or <code>false</code> respectively. Otherwise the conversion will be unsuccessful and argument <em>dest</em> will be set to <code>false</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf54d8054a7f57b607af01c536c6aeeda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NBoolSet &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a set of booleans and reports whether this conversion was successful. </p>
<p>A set of booleans is represented by one of the four strings <code>&ndash;</code>, <code>T-</code>, <code>-F</code> or <code>TF</code>. If the conversion is unsuccessful, argument <em>dest</em> will be set to <a class="el" href="classregina_1_1NBoolSet.html#a871d50b71b7f7fd8fede72eeeb22b2e5" title="The empty set.">NBoolSet::sNone</a> and <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting set of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0929ed8d58025412052a644276fda7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string regina::xml::xmlEncodeComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string encoded so it is suitable for use inside an XML comment. </p>
<p>As well as converting special characters to XML entities, this routine will replace dashes with underscores to avoid double-hyphens (which are illegal in XML comments).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string converted to be usable inside an XML comment. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc38cdf17c6d0ea2ce1c735739bd19ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::string regina::xml::xmlEncodeSpecialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given string with special characters converted to XML entities. </p>
<p>For instance, the string <code>"a \&lt; b"</code> would be converted to <code>"a \&amp;lt; b"</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string with special characters replaced by XML entities. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb9d9d42e182de0dc67e4176414cb07d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlValueTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an XML tag with a single property containing the given value. </p>
<p>The tag will be of the form <code>&lt;tagName value="..."/&gt;</code>.</p>
<p>The value itself will be written to the tag string using the standard output stream operator &lt;&lt;.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The property value when written to an output stream does not contain any special characters (such as <code>&lt;</code> or <code>&amp;</code>) that need to be encoded as XML entities.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the XML tag to create. </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to the <em>value</em> property of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding XML tag. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61810bdda48b4a95ef66c577f62eadf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::i18n::IConvStreamBuffer::~IConvStreamBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this stream buffer. </p>
<p>This stream buffer will be closed, but the destination output stream will not be. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
