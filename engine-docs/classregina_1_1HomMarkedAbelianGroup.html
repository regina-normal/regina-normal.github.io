<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::HomMarkedAbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1HomMarkedAbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::HomMarkedAbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a homomorphism of finitely generated abelian groups.  
 <a href="classregina_1_1HomMarkedAbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/markedabeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::HomMarkedAbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1HomMarkedAbelianGroup.png" usemap="#regina::HomMarkedAbelianGroup_map" alt=""/>
  <map id="regina::HomMarkedAbelianGroup_map" name="regina::HomMarkedAbelianGroup_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; HomMarkedAbelianGroup &gt;" shape="rect" coords="0,0,261,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2226807b3a0d0d3ddf9f0acc0a3a5029">HomMarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;dom, const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;ran, const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;mat)</td></tr>
<tr class="memdesc:a2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent.  <a href="#a2226807b3a0d0d3ddf9f0acc0a3a5029">More...</a><br/></td></tr>
<tr class="separator:a2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbde369a4fe315e50c0a8c4a9d327912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#adbde369a4fe315e50c0a8c4a9d327912">HomMarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;h)</td></tr>
<tr class="memdesc:adbde369a4fe315e50c0a8c4a9d327912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#adbde369a4fe315e50c0a8c4a9d327912">More...</a><br/></td></tr>
<tr class="separator:adbde369a4fe315e50c0a8c4a9d327912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0882d4131e137378cf2885f49ae431"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2f0882d4131e137378cf2885f49ae431">~HomMarkedAbelianGroup</a> ()</td></tr>
<tr class="memdesc:a2f0882d4131e137378cf2885f49ae431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2f0882d4131e137378cf2885f49ae431">More...</a><br/></td></tr>
<tr class="separator:a2f0882d4131e137378cf2885f49ae431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198ab736ed51c7911b859d0a1bcfc61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad198ab736ed51c7911b859d0a1bcfc61">isChainMap</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;other) const </td></tr>
<tr class="memdesc:ad198ab736ed51c7911b859d0a1bcfc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given homomorphism together form a chain map.  <a href="#ad198ab736ed51c7911b859d0a1bcfc61">More...</a><br/></td></tr>
<tr class="separator:ad198ab736ed51c7911b859d0a1bcfc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107c9844b601e5674d552aa3fc93001c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a107c9844b601e5674d552aa3fc93001c">isCycleMap</a> () const </td></tr>
<tr class="memdesc:a107c9844b601e5674d552aa3fc93001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage.  <a href="#a107c9844b601e5674d552aa3fc93001c">More...</a><br/></td></tr>
<tr class="separator:a107c9844b601e5674d552aa3fc93001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e24be95e470f6544ac42ee4c1a80830"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a9e24be95e470f6544ac42ee4c1a80830">isEpic</a> () const </td></tr>
<tr class="memdesc:a9e24be95e470f6544ac42ee4c1a80830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an epic homomorphism?  <a href="#a9e24be95e470f6544ac42ee4c1a80830">More...</a><br/></td></tr>
<tr class="separator:a9e24be95e470f6544ac42ee4c1a80830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2752e40a127418ed390c186baf7a2479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2752e40a127418ed390c186baf7a2479">isMonic</a> () const </td></tr>
<tr class="memdesc:a2752e40a127418ed390c186baf7a2479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a monic homomorphism?  <a href="#a2752e40a127418ed390c186baf7a2479">More...</a><br/></td></tr>
<tr class="separator:a2752e40a127418ed390c186baf7a2479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3602db57d35105479025ea57e6b5c243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a3602db57d35105479025ea57e6b5c243">isIsomorphism</a> () const </td></tr>
<tr class="memdesc:a3602db57d35105479025ea57e6b5c243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an isomorphism?  <a href="#a3602db57d35105479025ea57e6b5c243">More...</a><br/></td></tr>
<tr class="separator:a3602db57d35105479025ea57e6b5c243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc9ba5f01c0271007065f4ae606593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a26dc9ba5f01c0271007065f4ae606593">isZero</a> () const </td></tr>
<tr class="memdesc:a26dc9ba5f01c0271007065f4ae606593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the zero map?  <a href="#a26dc9ba5f01c0271007065f4ae606593">More...</a><br/></td></tr>
<tr class="separator:a26dc9ba5f01c0271007065f4ae606593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a758e22f13f31b85917ae5fda08194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a45a758e22f13f31b85917ae5fda08194">isIdentity</a> () const </td></tr>
<tr class="memdesc:a45a758e22f13f31b85917ae5fda08194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the identity automorphism?  <a href="#a45a758e22f13f31b85917ae5fda08194">More...</a><br/></td></tr>
<tr class="separator:a45a758e22f13f31b85917ae5fda08194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae181be7729b306a4649e551f38ee7675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ae181be7729b306a4649e551f38ee7675">kernel</a> () const </td></tr>
<tr class="memdesc:ae181be7729b306a4649e551f38ee7675"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the kernel of this homomorphism.  <a href="#ae181be7729b306a4649e551f38ee7675">More...</a><br/></td></tr>
<tr class="separator:ae181be7729b306a4649e551f38ee7675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec693aaa4ee85bf9aef4adc158713884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aec693aaa4ee85bf9aef4adc158713884">cokernel</a> () const </td></tr>
<tr class="memdesc:aec693aaa4ee85bf9aef4adc158713884"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cokernel of this homomorphism.  <a href="#aec693aaa4ee85bf9aef4adc158713884">More...</a><br/></td></tr>
<tr class="separator:aec693aaa4ee85bf9aef4adc158713884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e948dce36667698251f10174c2b9594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5e948dce36667698251f10174c2b9594">image</a> () const </td></tr>
<tr class="memdesc:a5e948dce36667698251f10174c2b9594"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this homomorphism.  <a href="#a5e948dce36667698251f10174c2b9594">More...</a><br/></td></tr>
<tr class="separator:a5e948dce36667698251f10174c2b9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd89bcb1f011249053461ac18f118e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a89cd89bcb1f011249053461ac18f118e">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a89cd89bcb1f011249053461ac18f118e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short text representation.  <a href="#a89cd89bcb1f011249053461ac18f118e">More...</a><br/></td></tr>
<tr class="separator:a89cd89bcb1f011249053461ac18f118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbaec50262bbe0083b142c2374a9f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a1dbaec50262bbe0083b142c2374a9f17">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1dbaec50262bbe0083b142c2374a9f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more detailed text representation of the homomorphism.  <a href="#a1dbaec50262bbe0083b142c2374a9f17">More...</a><br/></td></tr>
<tr class="separator:a1dbaec50262bbe0083b142c2374a9f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f91ea27bc41b00340a2b73e548be8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad67f91ea27bc41b00340a2b73e548be8">domain</a> () const </td></tr>
<tr class="memdesc:ad67f91ea27bc41b00340a2b73e548be8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the domain of this homomorphism.  <a href="#ad67f91ea27bc41b00340a2b73e548be8">More...</a><br/></td></tr>
<tr class="separator:ad67f91ea27bc41b00340a2b73e548be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771baf668e8085aa948efc6288470a58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a771baf668e8085aa948efc6288470a58">range</a> () const </td></tr>
<tr class="memdesc:a771baf668e8085aa948efc6288470a58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the range of this homomorphism.  <a href="#a771baf668e8085aa948efc6288470a58">More...</a><br/></td></tr>
<tr class="separator:a771baf668e8085aa948efc6288470a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c840734fc679c32e4aa8b9319d25c0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2c840734fc679c32e4aa8b9319d25c0f">definingMatrix</a> () const </td></tr>
<tr class="memdesc:a2c840734fc679c32e4aa8b9319d25c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the defining matrix for the homomorphism.  <a href="#a2c840734fc679c32e4aa8b9319d25c0f">More...</a><br/></td></tr>
<tr class="separator:a2c840734fc679c32e4aa8b9319d25c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2e384aea0b25b9d18efa886806dd86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a3b2e384aea0b25b9d18efa886806dd86">reducedMatrix</a> () const </td></tr>
<tr class="memdesc:a3b2e384aea0b25b9d18efa886806dd86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the internal reduced matrix representing the homomorphism.  <a href="#a3b2e384aea0b25b9d18efa886806dd86">More...</a><br/></td></tr>
<tr class="separator:a3b2e384aea0b25b9d18efa886806dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6da7132c38986615b8972458b4c70b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ace6da7132c38986615b8972458b4c70b">evalCC</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const </td></tr>
<tr class="memdesc:ace6da7132c38986615b8972458b4c70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates.  <a href="#ace6da7132c38986615b8972458b4c70b">More...</a><br/></td></tr>
<tr class="separator:ace6da7132c38986615b8972458b4c70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa358a24f5fd11855933ad217637298ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aa358a24f5fd11855933ad217637298ae">evalSNF</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const </td></tr>
<tr class="memdesc:aa358a24f5fd11855933ad217637298ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates.  <a href="#aa358a24f5fd11855933ad217637298ae">More...</a><br/></td></tr>
<tr class="separator:aa358a24f5fd11855933ad217637298ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70926e8d8eabdf9bd8b71cc1ae66a1d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad70926e8d8eabdf9bd8b71cc1ae66a1d">inverseHom</a> () const </td></tr>
<tr class="memdesc:ad70926e8d8eabdf9bd8b71cc1ae66a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>.  <a href="#ad70926e8d8eabdf9bd8b71cc1ae66a1d">More...</a><br/></td></tr>
<tr class="separator:ad70926e8d8eabdf9bd8b71cc1ae66a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bb928098505dc7bfccdd427a1da78a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad0bb928098505dc7bfccdd427a1da78a">operator*</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;X) const </td></tr>
<tr class="memdesc:ad0bb928098505dc7bfccdd427a1da78a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the composition of two homomorphisms.  <a href="#ad0bb928098505dc7bfccdd427a1da78a">More...</a><br/></td></tr>
<tr class="separator:ad0bb928098505dc7bfccdd427a1da78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ac0d33ebb6e35c616f3d041ff0163"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aef9ac0d33ebb6e35c616f3d041ff0163">torsionSubgroup</a> () const </td></tr>
<tr class="memdesc:aef9ac0d33ebb6e35c616f3d041ff0163"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups.  <a href="#aef9ac0d33ebb6e35c616f3d041ff0163">More...</a><br/></td></tr>
<tr class="separator:aef9ac0d33ebb6e35c616f3d041ff0163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b8ba222e006b9cb870c4478e3fe920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a15b8ba222e006b9cb870c4478e3fe920">writeReducedMatrix</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a15b8ba222e006b9cb870c4478e3fe920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable version of the reduced matrix to the given output stream.  <a href="#a15b8ba222e006b9cb870c4478e3fe920">More...</a><br/></td></tr>
<tr class="separator:a15b8ba222e006b9cb870c4478e3fe920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a homomorphism of finitely generated abelian groups. </p>
<p>One initializes such a homomorphism by providing:</p>
<ul>
<li>two finitely generated abelian groups, which act as domain and range;</li>
<li>a matrix describing the linear map between the free abelian groups in the centres of the respective chain complexes that were used to define the domain and range. If the abelian groups are computed via homology with coefficients, the range coefficients must be a quotient of the domain coefficients.</li>
</ul>
<p>So for example, if the domain was initialized by the chain complex <code>Z^a &ndash;A&ndash;&gt; Z^b &ndash;B&ndash;&gt; Z^c</code> with mod p coefficients, and the range was initialized by <code>Z^d &ndash;D&ndash;&gt; Z^e &ndash;E&ndash;&gt; Z^f</code> with mod q coefficients, then the matrix needs to be an e-by-b matrix. Furthermore, you only obtain a well-defined homomorphism if this matrix extends to a cycle map, which this class assumes but which the user can confirm with <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a107c9844b601e5674d552aa3fc93001c" title="Is this at least a cycle map? If not, pretty much any further computations you try with this class wi...">isCycleMap()</a>. Moreover, <em>q</em> should divide <em>p:</em> this allows for <em>q</em> &gt; 0 and <em>p</em> = 0, which means the domain has Z coefficients and the range has mod <em>q</em> coefficients.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> preImageOf in CC and SNF coordinates. This routine would return a generating list of elements in the preimage, thought of as an affine subspace. Or maybe just one element together with the kernel inclusion. IMO smarter to be a list because that way there's a more pleasant way to make it empty. Or we could have a variety of routines among these themes. Store some minimal data for efficient computations of preImage, eventually replacing the internals of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad70926e8d8eabdf9bd8b71cc1ae66a1d" title="Returns the inverse to a HomMarkedAbelianGroup.">inverseHom()</a> with a more flexible set of tools. Also add an isInImage() in various coordinates.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a89cd89bcb1f011249053461ac18f118e" title="Short text representation.">writeTextShort()</a> have completely different set of descriptors if an endomorphism domain = range (not so important at the moment though). New descriptors would include things like automorphism, projection, differential, finite order, etc.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Add map factorization, so that every homomorphism can be split as a composite of a projection followed by an inclusion. Add kernelInclusion(), coKerMap(), etc. Add a liftMap() call, i.e., a procedure to find a lift of a map if one exists.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2226807b3a0d0d3ddf9f0acc0a3a5029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>ran</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent. </p>
<p>The roles of the two groups and the matrix are described in detail in the <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> class overview.</p>
<p>The matrix must be given in the chain-complex coordinates. Specifically, if the domain was defined via the chain complex <code>Z^a &ndash;N1&ndash;&gt; Z^b &ndash;M1&ndash;&gt; Z^c</code> and the range was defined via <code>Z^d &ndash;N2&ndash;&gt; Z^e &ndash;M2&ndash;&gt; Z^f</code>, then <em>mat</em> is an e-by-b matrix that describes a homomorphism from Z^b to Z^e.</p>
<p>In order for this to make sense as a homomorphism of the groups represented by the domain and range respectively, one requires img(mat*N1) to be a subset of img(N2). Similarly, ker(M1) must be sent into ker(M2). These facts are not checked, but are assumed as preconditions of this constructor.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrix <em>mat</em> has the required dimensions e-by-b, gives img(mat*N1) as a subset of img(N2), and sends ker(M1) into ker(M2), as explained in the detailed notes above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dom</td><td>the domain group. </td></tr>
    <tr><td class="paramname">ran</td><td>the range group. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix that describes the homomorphism from <em>dom</em> to <em>ran</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbde369a4fe315e50c0a8c4a9d327912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the homomorphism to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f0882d4131e137378cf2885f49ae431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::~HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aec693aaa4ee85bf9aef4adc158713884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::cokernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cokernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the cokernel of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c840734fc679c32e4aa8b9319d25c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::definingMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the defining matrix for the homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the matrix that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad67f91ea27bc41b00340a2b73e548be8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the domain of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the domain that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="ace6da7132c38986615b8972458b4c70b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::HomMarkedAbelianGroup::evalCC </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates. </p>
<p>This involves multiplication by the defining matrix.</p>
<dl class="section user"><dt>Python:</dt><dd>Not available yet. This routine will be made accessible to Python in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad67f91ea27bc41b00340a2b73e548be8" title="Returns the domain of this homomorphism.">domain()</a>.M().columns(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the range chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a771baf668e8085aa948efc6288470a58" title="Returns the range of this homomorphism.">range()</a>.M().columns(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa358a24f5fd11855933ad217637298ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::HomMarkedAbelianGroup::evalSNF </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates. </p>
<p>This is just multiplication by the reduced matrix, returning the empty vector if the input vector has the wrong dimensions.</p>
<dl class="section warning"><dt>Warning</dt><dd>Smith normal form coordinates are sensitive to the implementation of the Smith Normal Form, i.e., they are not canonical.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not available yet. This routine will be made accessible to Python in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain SNF coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad67f91ea27bc41b00340a2b73e548be8" title="Returns the domain of this homomorphism.">domain()</a>.minNumberOfGenerators(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the range chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a771baf668e8085aa948efc6288470a58" title="Returns the range of this homomorphism.">range()</a>.minNumberOfGenerators(). </dd></dl>

</div>
</div>
<a class="anchor" id="a5e948dce36667698251f10174c2b9594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the image of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a class="anchor" id="ad70926e8d8eabdf9bd8b71cc1ae66a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::inverseHom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. </p>
<p>If this homomorphism is not invertible, this routine returns the zero homomorphism.</p>
<p>If you are computing with mod-p coefficients, this routine will further require that this invertible map preserves the UCT splitting of the group, i.e., it gives an isomorphism of the tensor product parts and the TOR parts. At present this suffices since we're only using this to construct maps between homology groups in different coordinate systems.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse homomorphism, or the zero homomorphism if this is not invertible. </dd></dl>

</div>
</div>
<a class="anchor" id="ad198ab736ed51c7911b859d0a1bcfc61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isChainMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given homomorphism together form a chain map. </p>
<p>Given two HomMarkedAbelianGroups, you have two diagrams: </p>
<pre>
Z^a --N1--&gt; Z^b --M1--&gt; Z^c   Z^g --N3--&gt; Z^h --M3--&gt; Z^i
                  ^                             ^
                  |this.matrix                  |other.matrix
Z^d --N2--&gt; Z^e --M2--&gt; Z^f   Z^j --N4--&gt; Z^k --M4--&gt; Z^l
</pre><p> If c=g and f=j and M1=N3 and M2=N4, you can ask if these maps commute, i.e., whether you have a map of chain complexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other homomorphism to analyse in conjunction with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if c=g, M1=N3, f=j, M2=N4, and the diagram commutes. </dd></dl>

</div>
</div>
<a class="anchor" id="a107c9844b601e5674d552aa3fc93001c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isCycleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage. </p>
<p>Technically, this routine only checks that cycles are sent to cycles, since it only has access to three of the four maps you need to verify you have a cycle map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a chain map. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e24be95e470f6544ac42ee4c1a80830"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isEpic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an epic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is epic. </dd></dl>

</div>
</div>
<a class="anchor" id="a45a758e22f13f31b85917ae5fda08194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this the identity automorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the domain and range are defined via the same chain complexes and the induced map on homology is the identity. </dd></dl>

</div>
</div>
<a class="anchor" id="a3602db57d35105479025ea57e6b5c243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIsomorphism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an isomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is an isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a2752e40a127418ed390c186baf7a2479"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isMonic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a monic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is monic. </dd></dl>

</div>
</div>
<a class="anchor" id="a26dc9ba5f01c0271007065f4ae606593"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the zero map? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is the zero map. </dd></dl>

</div>
</div>
<a class="anchor" id="ae181be7729b306a4649e551f38ee7675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::kernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the kernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the kernel of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0bb928098505dc7bfccdd427a1da78a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the composition of two homomorphisms. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the homomorphisms must be composable, meaning that the range of X must have the same presentation matrices as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created composite homomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a771baf668e8085aa948efc6288470a58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the range of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the range that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b2e384aea0b25b9d18efa886806dd86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::reducedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the internal reduced matrix representing the homomorphism. </p>
<p>This is where the rows/columns of the matrix represent first the free generators, then the torsion summands in the order of the invariant factors: </p>
<pre class="fragment">        Z^d + Z_{d0} + ... + Z_{dk}
</pre><p> where:</p>
<ul>
<li><em>d</em> is the number of free generators, as returned by rank();</li>
<li><em>d1</em>, ..., <em>dk</em> are the invariant factors that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a copy of the internal representation of the homomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aef9ac0d33ebb6e35c616f3d041ff0163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups. </p>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a15b8ba222e006b9cb870c4478e3fe920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeReducedMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a human-readable version of the reduced matrix to the given output stream. </p>
<p>This is a description of the homomorphism in some specific coordinates at present only meant to be internal to <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. At present, these coordinates have the torsion factors of the group appearing first, followed by the free factors.</p>
<dl class="section user"><dt>Python:</dt><dd>The <em>out</em> argument is missing; instead this is assumed to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dbaec50262bbe0083b142c2374a9f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more detailed text representation of the homomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89cd89bcb1f011249053461ac18f118e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short text representation. </p>
<p>This will state some basic properties of the homomorphism, such as:</p>
<ul>
<li>whether the map is the identity;</li>
<li>whether the map is an isomorphism;</li>
<li>whether the map is monic or epic;</li>
<li>if it is not monic, describes the kernel;</li>
<li>if it is not epic, describes the co-kernel;</li>
<li>if it is neither monic nor epic, describes the image.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="markedabeliangroup_8h.html">markedabeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
