<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::SatAnnulus Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structregina_1_1SatAnnulus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::SatAnnulus Struct Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an annulus formed from a pair of triangles in a Seifert fibred space.  
 <a href="structregina_1_1SatAnnulus.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/satannulus.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a81c2692c140b8ed46d060fcc62fffa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a3a81c2692c140b8ed46d060fcc62fffa">SatAnnulus</a> ()</td></tr>
<tr class="memdesc:a3a81c2692c140b8ed46d060fcc62fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised structure.  <a href="#a3a81c2692c140b8ed46d060fcc62fffa">More...</a><br /></td></tr>
<tr class="separator:a3a81c2692c140b8ed46d060fcc62fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af020064341a684f10ed73f7d0720ee6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#af020064341a684f10ed73f7d0720ee6e">SatAnnulus</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:af020064341a684f10ed73f7d0720ee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given structure.  <a href="#af020064341a684f10ed73f7d0720ee6e">More...</a><br /></td></tr>
<tr class="separator:af020064341a684f10ed73f7d0720ee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ba5f29977e590d5cd897ce07ec61c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#af90ba5f29977e590d5cd897ce07ec61c">SatAnnulus</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r0, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r1)</td></tr>
<tr class="memdesc:af90ba5f29977e590d5cd897ce07ec61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure initialised to the given values.  <a href="#af90ba5f29977e590d5cd897ce07ec61c">More...</a><br /></td></tr>
<tr class="separator:af90ba5f29977e590d5cd897ce07ec61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593529f0a73e5d27cb720676f9432a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a593529f0a73e5d27cb720676f9432a14">operator=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a593529f0a73e5d27cb720676f9432a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this equal to a clone of the given structure.  <a href="#a593529f0a73e5d27cb720676f9432a14">More...</a><br /></td></tr>
<tr class="separator:a593529f0a73e5d27cb720676f9432a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422274dc01b3829898fc5bd9912c887e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a422274dc01b3829898fc5bd9912c887e">operator==</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:a422274dc01b3829898fc5bd9912c887e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe the same annulus with the same representation.  <a href="#a422274dc01b3829898fc5bd9912c887e">More...</a><br /></td></tr>
<tr class="separator:a422274dc01b3829898fc5bd9912c887e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2130ab5935bfd647c1d3138a1e8932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aaf2130ab5935bfd647c1d3138a1e8932">operator !=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:aaf2130ab5935bfd647c1d3138a1e8932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe the same annulus with the same representation.  <a href="#aaf2130ab5935bfd647c1d3138a1e8932">More...</a><br /></td></tr>
<tr class="separator:aaf2130ab5935bfd647c1d3138a1e8932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8efd019dec98bc14e74e6290ce7d5f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aee8efd019dec98bc14e74e6290ce7d5f">meetsBoundary</a> () const</td></tr>
<tr class="memdesc:aee8efd019dec98bc14e74e6290ce7d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many triangles of this annulus lie on the boundary of the triangulation.  <a href="#aee8efd019dec98bc14e74e6290ce7d5f">More...</a><br /></td></tr>
<tr class="separator:aee8efd019dec98bc14e74e6290ce7d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314169287c13371d490bfe8f156c2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a3314169287c13371d490bfe8f156c2e8">switchSides</a> ()</td></tr>
<tr class="memdesc:a3314169287c13371d490bfe8f156c2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a representation of the same annulus from the other side.  <a href="#a3314169287c13371d490bfe8f156c2e8">More...</a><br /></td></tr>
<tr class="separator:a3314169287c13371d490bfe8f156c2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1a05d4855418a5e4de2261f93ae9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#abe1a05d4855418a5e4de2261f93ae9ec">otherSide</a> () const</td></tr>
<tr class="memdesc:abe1a05d4855418a5e4de2261f93ae9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of the same annulus from the other side.  <a href="#abe1a05d4855418a5e4de2261f93ae9ec">More...</a><br /></td></tr>
<tr class="separator:abe1a05d4855418a5e4de2261f93ae9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb14f03e956c6a208d02226a4a684c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a8cb14f03e956c6a208d02226a4a684c2">reflectVertical</a> ()</td></tr>
<tr class="memdesc:a8cb14f03e956c6a208d02226a4a684c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the direction of the vertical fibres in this annulus representation.  <a href="#a8cb14f03e956c6a208d02226a4a684c2">More...</a><br /></td></tr>
<tr class="separator:a8cb14f03e956c6a208d02226a4a684c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cc54b9dfdf84f901beacaab63b9f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#ac1cc54b9dfdf84f901beacaab63b9f39">verticalReflection</a> () const</td></tr>
<tr class="memdesc:ac1cc54b9dfdf84f901beacaab63b9f39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of this annulus in which the vertical direction of the fibres has been reversed.  <a href="#ac1cc54b9dfdf84f901beacaab63b9f39">More...</a><br /></td></tr>
<tr class="separator:ac1cc54b9dfdf84f901beacaab63b9f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d10195c977f38a583700303629ebc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a53d10195c977f38a583700303629ebc8">reflectHorizontal</a> ()</td></tr>
<tr class="memdesc:a53d10195c977f38a583700303629ebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left-to-right reflection of this annulus representation.  <a href="#a53d10195c977f38a583700303629ebc8">More...</a><br /></td></tr>
<tr class="separator:a53d10195c977f38a583700303629ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aa7c5947d121ebf8a25e0849bdf5a7f7e">horizontalReflection</a> () const</td></tr>
<tr class="memdesc:aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a left-to-right reflected representation of this annulus.  <a href="#aa7c5947d121ebf8a25e0849bdf5a7f7e">More...</a><br /></td></tr>
<tr class="separator:aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea9c67b200888b3aeb42251ee31c3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aeea9c67b200888b3aeb42251ee31c3cc">rotateHalfTurn</a> ()</td></tr>
<tr class="memdesc:aeea9c67b200888b3aeb42251ee31c3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the representation of this annulus by 180 degrees.  <a href="#aeea9c67b200888b3aeb42251ee31c3cc">More...</a><br /></td></tr>
<tr class="separator:aeea9c67b200888b3aeb42251ee31c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2540d455af75c2d5d736267d4b78ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a3c2540d455af75c2d5d736267d4b78ff">halfTurnRotation</a> () const</td></tr>
<tr class="memdesc:a3c2540d455af75c2d5d736267d4b78ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 180 degree rotated representation of this annulus.  <a href="#a3c2540d455af75c2d5d736267d4b78ff">More...</a><br /></td></tr>
<tr class="separator:a3c2540d455af75c2d5d736267d4b78ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b751a2ac184f75c42ee18d6cde745"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#ab18b751a2ac184f75c42ee18d6cde745">isAdjacent</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other, bool *refVert, bool *refHoriz) const</td></tr>
<tr class="memdesc:ab18b751a2ac184f75c42ee18d6cde745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections.  <a href="#ab18b751a2ac184f75c42ee18d6cde745">More...</a><br /></td></tr>
<tr class="separator:ab18b751a2ac184f75c42ee18d6cde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166da7e172160fef0a9f818823a2c4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#ab166da7e172160fef0a9f818823a2c4d">isJoined</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other, Matrix2 &amp;matching) const</td></tr>
<tr class="memdesc:ab166da7e172160fef0a9f818823a2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent.  <a href="#ab166da7e172160fef0a9f818823a2c4d">More...</a><br /></td></tr>
<tr class="separator:ab166da7e172160fef0a9f818823a2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92bb7286c0fb03b929257a7bc4888f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#ab92bb7286c0fb03b929257a7bc4888f1">isTwoSidedTorus</a> () const</td></tr>
<tr class="memdesc:ab92bb7286c0fb03b929257a7bc4888f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation.  <a href="#ab92bb7286c0fb03b929257a7bc4888f1">More...</a><br /></td></tr>
<tr class="separator:ab92bb7286c0fb03b929257a7bc4888f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb34c281222b5a95a4d3a2bd4206fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aadb34c281222b5a95a4d3a2bd4206fcf">transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:aadb34c281222b5a95a4d3a2bd4206fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts this annulus representation according to the given isomorphism between triangulations.  <a href="#aadb34c281222b5a95a4d3a2bd4206fcf">More...</a><br /></td></tr>
<tr class="separator:aadb34c281222b5a95a4d3a2bd4206fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae35b903051842517e0c3be39eae2cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#aae35b903051842517e0c3be39eae2cee">image</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri) const</td></tr>
<tr class="memdesc:aae35b903051842517e0c3be39eae2cee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this annulus representation under the given isomorphism between triangulations.  <a href="#aae35b903051842517e0c3be39eae2cee">More...</a><br /></td></tr>
<tr class="separator:aae35b903051842517e0c3be39eae2cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ef9c6ac88ca6201299c32c99b6924a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a42ef9c6ac88ca6201299c32c99b6924a">attachLST</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, long alpha, long beta) const</td></tr>
<tr class="memdesc:a42ef9c6ac88ca6201299c32c99b6924a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a layered solid torus to the this saturated annulus.  <a href="#a42ef9c6ac88ca6201299c32c99b6924a">More...</a><br /></td></tr>
<tr class="separator:a42ef9c6ac88ca6201299c32c99b6924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a4e63bfd1ccfca9404d9af26e0f5bcfb3">tet</a> [2]</td></tr>
<tr class="memdesc:a4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which tetrahedra provide the first and second triangles.  <a href="#a4e63bfd1ccfca9404d9af26e0f5bcfb3">More...</a><br /></td></tr>
<tr class="separator:a4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561aae549a9dc09de541ea0b76dfcc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html#a561aae549a9dc09de541ea0b76dfcc7a">roles</a> [2]</td></tr>
<tr class="memdesc:a561aae549a9dc09de541ea0b76dfcc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how the first and second triangles match up with individual tetrahedron vertices.  <a href="#a561aae549a9dc09de541ea0b76dfcc7a">More...</a><br /></td></tr>
<tr class="separator:a561aae549a9dc09de541ea0b76dfcc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an annulus formed from a pair of triangles in a Seifert fibred space. </p>
<p>This annulus is saturated, i.e., a union of fibres. More than that, the fibres run parallel to the two boundary edges of the annulus.</p>
<p>The annulus is described from one side only. The description includes an array of indices <em>tet</em>[] describing which two tetrahedra provide the triangles of the annulus, as well as an array of permutations <em>roles</em>[] detailing how the annulus matches up with the individual tetrahedron vertices.</p>
<p>The annulus can be drawn as follows, with the upper edge identified with the lower:</p>
<pre>
           *---&gt;---*
           |0  2 / |
   First   |    / 1|  Second
  triangle |   /   | triangle
           |1 /    |
           | / 2  0|
           *---&gt;---*
</pre><p>Suppose that <em>tet</em>[0] and <em>tet</em>[1] are the tetrahedra providing the first and second triangles respectively. Then the markings 0..2 on the first triangle above correspond to vertices <em>roles</em>[0][0..2] of tetrahedron <em>tet</em>[0], and likewise the markings 0..2 on the second triangle above correspond to vertices <em>roles</em>[1][0..2] of tetrahedron <em>tet</em>[1].</p>
<p>Note that the diagram above can also be drawn as follows.</p>
<pre>
           *---&gt;---*
           | \ 2  1|
   First   |0 \    |  Second
  triangle |   \   | triangle
           |    \ 0|
           |1  2 \ |
           *---&gt;---*
</pre><p>Note also that the labelling of the tetrahedra and their vertices establishes an orientation on the vertical fibres, as well as a left-to-right direction across the annulus.</p>
<p>For convenience we refer to edges <em>roles</em>[][0-1] as <em>vertical</em>, edges <em>roles</em>[][0-2] as <em>horizontal</em>, and edge <em>roles</em>[][1-2] as <em>diagonal</em>. This is illustrated in the following diagrams.</p>
<pre>
        V  Horizontal       V   Diagonal
        e  *---&gt;---*        e  *---&gt;---*
        r  |   g / |        r  |H\ 2  1|
        t  |  a / 1|        t  | o\    |
        i  | i /   |        i  |  r\   |
        c  |D /    |        c  |   i\ 0|
        a  | / 2  0|        a  |    z\ |
        l  *---&gt;---*        l  *---&gt;---*
</pre><dl class="section user"><dt>Python:\n The member arrays <em>tet</em> and <em>roles</em> are accessed for</dt><dd>reading through functions <em><a class="el" href="structregina_1_1SatAnnulus.html#a4e63bfd1ccfca9404d9af26e0f5bcfb3" title="Describes which tetrahedra provide the first and second triangles.">tet()</a></em> and <em><a class="el" href="structregina_1_1SatAnnulus.html#a561aae549a9dc09de541ea0b76dfcc7a" title="Describes how the first and second triangles match up with individual tetrahedron vertices.">roles()</a></em> respectively. For instance, the first triangle tetrahedron for the saturated annulus <em>a</em> can be accessed as <code>a.tet(0)</code>. These same member arrays are accessed for writing through functions <em>setTet()</em> and <em>setRoles()</em>, so for instance the second triangle vertex roles for the saturated annulus <em>a</em> can be modified by calling <code>a.setRoles(1, newRoles)</code>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a81c2692c140b8ed46d060fcc62fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a81c2692c140b8ed46d060fcc62fffa">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised structure. </p>
<p>Both tetrahedra will be set to null pointers. </p>

</div>
</div>
<a id="af020064341a684f10ed73f7d0720ee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af020064341a684f10ed73f7d0720ee6e">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af90ba5f29977e590d5cd897ce07ec61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ba5f29977e590d5cd897ce07ec61c">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure initialised to the given values. </p>
<p>See the class notes for what the various tetrahedra and permutations mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>the tetrahedron to assign to <em>tet</em>[0]. </td></tr>
    <tr><td class="paramname">r0</td><td>the permutation to assign to <em>roles</em>[0]. </td></tr>
    <tr><td class="paramname">t1</td><td>the tetrahedron to assign to <em>tet</em>[1]. </td></tr>
    <tr><td class="paramname">r1</td><td>the permutation to assign to <em>roles</em>[1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42ef9c6ac88ca6201299c32c99b6924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ef9c6ac88ca6201299c32c99b6924a">&#9670;&nbsp;</a></span>attachLST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::attachLST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a layered solid torus to the this saturated annulus. </p>
<p>The layered solid torus will be attached so that the given values <em>alpha</em> and <em>beta</em> describe how the meridinal disc cuts the vertical and horizontal edges of the annulus respectively.</p>
<p>The result will effectively insert an (<em>alpha</em>, <em>beta</em>) exceptional fibre into the Seifert fibred space space, where the vertical edges run parallel to the fibres and the horizontal edges represent the base orbifold. The sign of the fibre is consistent with the fibre inserted by <a class="el" href="classregina_1_1SatLST.html#a63f7186370470f3f18d5ec009b4e8cca" title="Adjusts the given Seifert fibred space to insert the contents of this saturated block.">SatLST::adjustSFS()</a> (in particular, negating <em>beta</em> will negate the fibre).</p>
<p>In the case of a (2,1) fibre, the layered solid torus will be degenerate (i.e., the two triangles of the annulus will simply be joined together).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given value <em>alpha</em> is not zero. </dd>
<dd>
The given values <em>alpha</em> and <em>beta</em> are coprime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new tetrahedra should be inserted. </td></tr>
    <tr><td class="paramname">alpha</td><td>describes how the meridinal disc of the torus should cut the vertical edges. This may be positive or negative. </td></tr>
    <tr><td class="paramname">beta</td><td>describes how the meridinal disc of the torus should cut the horizontal edges. Again this may be positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c2540d455af75c2d5d736267d4b78ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2540d455af75c2d5d736267d4b78ff">&#9670;&nbsp;</a></span>halfTurnRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::halfTurnRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 180 degree rotated representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="structregina_1_1SatAnnulus.html#aeea9c67b200888b3aeb42251ee31c3cc" title="Rotates the representation of this annulus by 180 degrees.">rotateHalfTurn()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new 180 degree rotation of this annulus. </dd></dl>

</div>
</div>
<a id="aa7c5947d121ebf8a25e0849bdf5a7f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c5947d121ebf8a25e0849bdf5a7f7e">&#9670;&nbsp;</a></span>horizontalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::horizontalReflection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a left-to-right reflected representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="structregina_1_1SatAnnulus.html#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new left-to-right reflection of this annulus. </dd></dl>

</div>
</div>
<a id="aae35b903051842517e0c3be39eae2cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae35b903051842517e0c3be39eae2cee">&#9670;&nbsp;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this annulus representation under the given isomorphism between triangulations. </p>
<p>This annulus representation will not be changed. See <a class="el" href="structregina_1_1SatAnnulus.html#aadb34c281222b5a95a4d3a2bd4206fcf" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">transform()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the new annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18b751a2ac184f75c42ee18d6cde745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18b751a2ac184f75c42ee18d6cde745">&#9670;&nbsp;</a></span>isAdjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isAdjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>refVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>refHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections. </p>
<p>That is, this routine determines whether this and the given structure represent opposite sides of the same saturated annulus, where the fibres for both structures are consistent (though possibly reversed). See <a class="el" href="structregina_1_1SatAnnulus.html#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for details on what "opposite sides" means in this context, and see <a class="el" href="structregina_1_1SatAnnulus.html#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and <a class="el" href="structregina_1_1SatAnnulus.html#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for descriptions of the various types of reflection.</p>
<p>Information regarding reflections is returned via the two boolean pointers <em>refVert</em> and <em>refHoriz</em>. If the two annuli are identically opposite each other as described by <a class="el" href="structregina_1_1SatAnnulus.html#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a>, both booleans will be set to <code>false</code>. If the two annuli are identically opposite after one undergoes a vertical and/or horizontal reflection, then the booleans <em>refVert</em> and/or <em>refHoriz</em> will be set to <code>true</code> accordingly.</p>
<p>The critical difference between this routine and <a class="el" href="structregina_1_1SatAnnulus.html#ab166da7e172160fef0a9f818823a2c4d" title="Determines whether this and the given annulus are joined in some form, even if the fibres on each ann...">isJoined()</a> is that this routine insists that the fibres on each annulus be consistent. This routine is thus suitable for examining joins between different sections of the same Seifert fibred space, for example.</p>
<dl class="section user"><dt>Python:\n This routine only takes a single argument (the</dt><dd>annulus <em>other</em>). The return value is a tuple of three booleans: the usual return value, the value returned in <em>refVert</em>, and the value returned in <em>refHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
    <tr><td class="paramname">refVert</td><td>returns information on whether the annuli are adjacent modulo a vertical reflection. This is set to <code>true</code> if a vertical reflection is required and <code>false</code> if it is not. If no adjacency was found at all, this boolean is not touched. A null pointer may be passed, in which case this information will not be returned at all. </td></tr>
    <tr><td class="paramname">refHoriz</td><td>returns information on whether the annuli are adjacent modulo a horizontal reflection. This is set to <code>true</code> if a horizontal reflection is required and <code>false</code> if it is not. If no adjacency was found at all, this boolean is not touched. A null pointer may be passed, in which case this information will not be returned at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some adjacency was found (either with or without reflections), or <code>false</code> if no adjacency was found at all. </dd></dl>

</div>
</div>
<a id="ab166da7e172160fef0a9f818823a2c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab166da7e172160fef0a9f818823a2c4d">&#9670;&nbsp;</a></span>isJoined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isJoined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix2 &amp;&#160;</td>
          <td class="paramname"><em>matching</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent. </p>
<p>This routine treats each annulus as though its boundaries are identified to form a torus (though it does not actually test whether this is true). It then examines whether this and the given annulus represent opposite sides of the same torus. More specifically, it tests whether both annuli are formed from the same pair of triangles, and whether the mapping of 0/1/2 markings from one annulus to the other is the same for each triangle. Note that the triangles are allowed to be switched (i.e., the first triangle of one annulus may be the second triangle of the other).</p>
<p>The critical difference between this routine and <a class="el" href="structregina_1_1SatAnnulus.html#ab18b751a2ac184f75c42ee18d6cde745" title="Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal re...">isAdjacent()</a> is that this routine allows the fibres on each annulus to be inconsistent. This routine is thus suitable for examining joins between different Seifert fibred blocks in a graph manifold, for example.</p>
<p>If the two annuli are joined, the precise relationship between the curves on each annulus will be returned in the matrix <em>matching</em>. Specifically, let <em>x</em> and <em>y</em> be the oriented curves running from markings 0-1 and 0-2 respectively on the first triangle of this annulus. Likewise, let <em>x'</em> and <em>y'</em> run from markings 0-1 and 0-2 respectively on the first triangle of the annulus <em>other</em>. Then the joining between the two annuli can be expressed as follows:</p>
<pre>
    [x ]                [x']
    [  ]  =  matching * [  ].
    [y ]                [y']
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
    <tr><td class="paramname">matching</td><td>returns details on how the curves on each annulus are related. If the this and the given annulus are not joined, then this matrix is not touched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given annulus are found to be joined, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="ab92bb7286c0fb03b929257a7bc4888f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92bb7286c0fb03b929257a7bc4888f1">&#9670;&nbsp;</a></span>isTwoSidedTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isTwoSidedTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation. </p>
<p>It will be verified that:</p><ul>
<li>the two triangles of this annulus are joined along all three pairs of edges to form a torus;</li>
<li>the three edges of this torus remain distinct (i.e., different edges of the torus do not become identified within the larger triangulation);</li>
<li>this torus is two-sided within the surrounding triangulation.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this annulus forms an embedded two-sided torus as described above, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="aee8efd019dec98bc14e74e6290ce7d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8efd019dec98bc14e74e6290ce7d5f">&#9670;&nbsp;</a></span>meetsBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatAnnulus::meetsBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines how many triangles of this annulus lie on the boundary of the triangulation. </p>
<p>Note that this routine can also be used as a boolean function to determine whether any triangles of the annulus lie on the triangulation boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of triangles of this annulus that lie on the boundary of the triangulation; this will be 0, 1 or 2. </dd></dl>

</div>
</div>
<a id="aaf2130ab5935bfd647c1d3138a1e8932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2130ab5935bfd647c1d3138a1e8932">&#9670;&nbsp;</a></span>operator !=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe the same annulus with the same representation. </p>
<p>This requires both structures to have identical <em>tet</em>[] and <em>roles</em>[] arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the structures do not describe the same annulus with the same representation, or <code>false</code> if they do. </dd></dl>

</div>
</div>
<a id="a593529f0a73e5d27cb720676f9432a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593529f0a73e5d27cb720676f9432a14">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatAnnulus::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this equal to a clone of the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the structure to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this structure. </dd></dl>

</div>
</div>
<a id="a422274dc01b3829898fc5bd9912c887e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422274dc01b3829898fc5bd9912c887e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe the same annulus with the same representation. </p>
<p>This requires both structures to have identical <em>tet</em>[] and <em>roles</em>[] arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the structures describe the same annulus with the same representation, or <code>false</code> if they do not. </dd></dl>

</div>
</div>
<a id="abe1a05d4855418a5e4de2261f93ae9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1a05d4855418a5e4de2261f93ae9ec">&#9670;&nbsp;</a></span>otherSide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::otherSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of the same annulus from the other side. </p>
<p>This structure will not be changed. See <a class="el" href="structregina_1_1SatAnnulus.html#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus from the other side. </dd></dl>

</div>
</div>
<a id="a53d10195c977f38a583700303629ebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d10195c977f38a583700303629ebc8">&#9670;&nbsp;</a></span>reflectHorizontal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectHorizontal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left-to-right reflection of this annulus representation. </p>
<p>The vertical direction of the fibres will remain unchanged, but the first and second triangles will be switched (and the 0..2 markings changed to compensate). </p>

</div>
</div>
<a id="a8cb14f03e956c6a208d02226a4a684c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb14f03e956c6a208d02226a4a684c2">&#9670;&nbsp;</a></span>reflectVertical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectVertical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the direction of the vertical fibres in this annulus representation. </p>
<p>The first and second triangles (as described in the class notes) will remain unchanged, but the markings 0 and 1 on each triangle will be switched. </p>

</div>
</div>
<a id="aeea9c67b200888b3aeb42251ee31c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea9c67b200888b3aeb42251ee31c3cc">&#9670;&nbsp;</a></span>rotateHalfTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::rotateHalfTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the representation of this annulus by 180 degrees. </p>
<p>This has the effect of switching the first and second triangles and also reversing the direction of the vertical fibres.</p>
<p>Calling this routine is equivalent to calling <a class="el" href="structregina_1_1SatAnnulus.html#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and then <a class="el" href="structregina_1_1SatAnnulus.html#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a>. </p>

</div>
</div>
<a id="a3314169287c13371d490bfe8f156c2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314169287c13371d490bfe8f156c2e8">&#9670;&nbsp;</a></span>switchSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::switchSides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a representation of the same annulus from the other side. </p>
<p>The first and second triangles and their 0..2 markings (as described in the class notes) remain unchanged. However, the two tetrahedra that are used to describe the annulus will be replaced by their counterparts on the other side of the annulus (i.e., the two new tetrahedra that meet the two original tetrahedra along the annulus itself).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation. </dd></dl>

</div>
</div>
<a id="aadb34c281222b5a95a4d3a2bd4206fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb34c281222b5a95a4d3a2bd4206fcf">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts this annulus representation according to the given isomorphism between triangulations. </p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this annulus must refer to tetrahedra in <em>originalTri</em>. This routine will adjust this annulus according to the given isomorphism, so that it refers to the corresponding tetrahedra in <em>newTri</em> (with the <em>roles</em> permutations also updated accordingly).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This annulus refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1cc54b9dfdf84f901beacaab63b9f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cc54b9dfdf84f901beacaab63b9f39">&#9670;&nbsp;</a></span>verticalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::verticalReflection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of this annulus in which the vertical direction of the fibres has been reversed. </p>
<p>This structure will not be changed. See <a class="el" href="structregina_1_1SatAnnulus.html#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus in which fibres have been reversed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a561aae549a9dc09de541ea0b76dfcc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561aae549a9dc09de541ea0b76dfcc7a">&#9670;&nbsp;</a></span>roles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::SatAnnulus::roles[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes how the first and second triangles match up with individual tetrahedron vertices. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="a4e63bfd1ccfca9404d9af26e0f5bcfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e63bfd1ccfca9404d9af26e0f5bcfb3">&#9670;&nbsp;</a></span>tet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;* regina::SatAnnulus::tet[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes which tetrahedra provide the first and second triangles. </p>
<p>See the class notes for details. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="satannulus_8h.html">satannulus.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
