<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::XMLTreeResolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1XMLTreeResolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::XMLTreeResolver Class Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file.  
 <a href="classregina_1_1XMLTreeResolver.html#details">More...</a></p>

<p><code>#include &lt;packet/xmltreeresolver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9bcdb1301b1f56d445352a56fc9973fb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classregina_1_1Packet.html">Packet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#a9bcdb1301b1f56d445352a56fc9973fb">IDMap</a></td></tr>
<tr class="memdesc:a9bcdb1301b1f56d445352a56fc9973fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that maps internal IDs from the data file to the corresponding packets.  <a href="#a9bcdb1301b1f56d445352a56fc9973fb">More...</a><br /></td></tr>
<tr class="separator:a9bcdb1301b1f56d445352a56fc9973fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61fd37b6db545006a3016b721c99a15b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#a61fd37b6db545006a3016b721c99a15b">XMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:a61fd37b6db545006a3016b721c99a15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a resolver with no tasks queued.  <a href="#a61fd37b6db545006a3016b721c99a15b">More...</a><br /></td></tr>
<tr class="separator:a61fd37b6db545006a3016b721c99a15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4285bf757b67d109b1e86de9f07211de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#a4285bf757b67d109b1e86de9f07211de">~XMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:a4285bf757b67d109b1e86de9f07211de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys any tasks that were queued but not performed.  <a href="#a4285bf757b67d109b1e86de9f07211de">More...</a><br /></td></tr>
<tr class="separator:a4285bf757b67d109b1e86de9f07211de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaa9594b36a2acf51013b9b2092aa0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#aedaa9594b36a2acf51013b9b2092aa0c">queueTask</a> (<a class="el" href="classregina_1_1XMLTreeResolutionTask.html">XMLTreeResolutionTask</a> *task)</td></tr>
<tr class="memdesc:aedaa9594b36a2acf51013b9b2092aa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a task for processing.  <a href="#aedaa9594b36a2acf51013b9b2092aa0c">More...</a><br /></td></tr>
<tr class="separator:aedaa9594b36a2acf51013b9b2092aa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542bbef6c5302a1aebdbb39851fb01ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#a542bbef6c5302a1aebdbb39851fb01ca">storeID</a> (const std::string &amp;id, <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:a542bbef6c5302a1aebdbb39851fb01ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the fact that the given packet is stored in the data file using the given internal ID.  <a href="#a542bbef6c5302a1aebdbb39851fb01ca">More...</a><br /></td></tr>
<tr class="separator:a542bbef6c5302a1aebdbb39851fb01ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef35326137566ebe6f22533d8707e28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1XMLTreeResolver.html#a9bcdb1301b1f56d445352a56fc9973fb">IDMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#afef35326137566ebe6f22533d8707e28">ids</a> () const</td></tr>
<tr class="memdesc:afef35326137566ebe6f22533d8707e28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file.  <a href="#afef35326137566ebe6f22533d8707e28">More...</a><br /></td></tr>
<tr class="separator:afef35326137566ebe6f22533d8707e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deb2e7eb029a52c8c73af2dfdda9484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484">resolve</a> ()</td></tr>
<tr class="memdesc:a6deb2e7eb029a52c8c73af2dfdda9484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classregina_1_1XMLTreeResolutionTask.html#a6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for all queued tasks.  <a href="#a6deb2e7eb029a52c8c73af2dfdda9484">More...</a><br /></td></tr>
<tr class="separator:a6deb2e7eb029a52c8c73af2dfdda9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8405a2d4d3024719c931d256790a234b"><td class="memItemLeft" align="right" valign="top"><a id="a8405a2d4d3024719c931d256790a234b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>XMLTreeResolver</b> (const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;)=delete</td></tr>
<tr class="separator:a8405a2d4d3024719c931d256790a234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33e135cf48da11b0dfa514ecc685394"><td class="memItemLeft" align="right" valign="top"><a id="af33e135cf48da11b0dfa514ecc685394"></a>
<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;)=delete</td></tr>
<tr class="separator:af33e135cf48da11b0dfa514ecc685394"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file. </p>
<p>There are situations in which, when reading an XML data file, the data stored in an individual packet cannot be fully constructed until after the entire data file has been read. For instance, a packet might need to store pointers or references to other packets that could appear later in the packet tree (e.g., a script storing pointers to its variables).</p>
<p>This problem is solved by the <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> class. The complete process of reading an XML data file works as follows:</p>
<ul>
<li>The top-level routine managing the file I/O constructs a new <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a>. This resolver is then passed to each <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> in turn as each individual packet is read.</li>
<li>If an <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> is not able to fully flesh out its data because it requires information that is not yet available, it should create a new <a class="el" href="classregina_1_1XMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read.">XMLTreeResolutionTask</a> and queue this task to the resolver via <a class="el" href="classregina_1_1XMLTreeResolver.html#aedaa9594b36a2acf51013b9b2092aa0c" title="Queues a task for processing.">XMLTreeResolver::queueTask()</a>.</li>
<li>Once the entire packet tree has been read, the top-level file I/O manager will call <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">XMLTreeResolver::resolve()</a>. This will run <a class="el" href="classregina_1_1XMLTreeResolutionTask.html#a6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for each task in turn, whereby any missing data for individual packets can be resolved.</li>
</ul>
<p>Each task should be an instance of a subclass of <a class="el" href="classregina_1_1XMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read.">XMLTreeResolutionTask</a>, whose virtual <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> function is overridden to perform whatever "fleshing out" work is required for the type of packet under consideration. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9bcdb1301b1f56d445352a56fc9973fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcdb1301b1f56d445352a56fc9973fb">&#9670;&nbsp;</a></span>IDMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classregina_1_1Packet.html">Packet</a>*&gt; <a class="el" href="classregina_1_1XMLTreeResolver.html#a9bcdb1301b1f56d445352a56fc9973fb">regina::XMLTreeResolver::IDMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that maps internal IDs from the data file to the corresponding packets. </p>
<p>See <a class="el" href="classregina_1_1XMLTreeResolver.html#afef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a61fd37b6db545006a3016b721c99a15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd37b6db545006a3016b721c99a15b">&#9670;&nbsp;</a></span>XMLTreeResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTreeResolver::XMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a resolver with no tasks queued. </p>

</div>
</div>
<a id="a4285bf757b67d109b1e86de9f07211de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4285bf757b67d109b1e86de9f07211de">&#9670;&nbsp;</a></span>~XMLTreeResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTreeResolver::~XMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys any tasks that were queued but not performed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afef35326137566ebe6f22533d8707e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef35326137566ebe6f22533d8707e28">&#9670;&nbsp;</a></span>ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1XMLTreeResolver.html#a9bcdb1301b1f56d445352a56fc9973fb">XMLTreeResolver::IDMap</a> &amp; regina::XMLTreeResolver::ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file. </p>
<p>Packets in a data file may have individual string IDs stored alongside them, in the <em>id</em> attribute of the <code>&lt;packet&gt;</code> tag. These strings are optional, and do not need to be human-readable. Although packets are not required to have IDs, any IDs that <em>are</em> stored must be unique (i.e., two different packets cannot share the same ID).</p>
<p>Note that IDs read from the data file need not bear any relation to the IDs that are returned from <a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, although this is typically how they are constructed when a file is saved.</p>
<p>This map will be fleshed out as the data file is read. In particular, since each task runs <a class="el" href="classregina_1_1XMLTreeResolutionTask.html#a6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> only after the entire tree has been read, tasks may assume that this map contains all IDs that were explicitly stored in the data file.</p>
<p>Only packets with IDs will appear in this map (i.e., there may well be packets in the data file that do not appear in this map at all).</p>
<dl class="section return"><dt>Returns</dt><dd>the map from internal file IDs to packets. </dd></dl>

</div>
</div>
<a id="aedaa9594b36a2acf51013b9b2092aa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaa9594b36a2acf51013b9b2092aa0c">&#9670;&nbsp;</a></span>queueTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::queueTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolutionTask.html">XMLTreeResolutionTask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a task for processing. </p>
<p>When the file I/O manager calls <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a>, this will call <a class="el" href="classregina_1_1XMLTreeResolutionTask.html#a6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for each task that has been queued.</p>
<p>This object will claim ownership of the given task, and will destroy it after <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> has been called (or, if <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> is never called, when this <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> is destroyed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to be queued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6deb2e7eb029a52c8c73af2dfdda9484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6deb2e7eb029a52c8c73af2dfdda9484">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classregina_1_1XMLTreeResolutionTask.html#a6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for all queued tasks. </p>
<p>The tasks will then be destroyed and removed from the queue (so subsequent calls to <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> are safe and will do nothing). </p>

</div>
</div>
<a id="a542bbef6c5302a1aebdbb39851fb01ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542bbef6c5302a1aebdbb39851fb01ca">&#9670;&nbsp;</a></span>storeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::storeID </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the fact that the given packet is stored in the data file using the given internal ID. </p>
<p>Associations between IDs and packets can be queried through the <a class="el" href="classregina_1_1XMLTreeResolver.html#afef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> function. See <a class="el" href="classregina_1_1XMLTreeResolver.html#afef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for further information on internal IDs.</p>
<p>This will be called automatically by <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> as it processes packet tags in the data file. Users and/or subclasses of <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> do not need to call this function themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the internal ID of the given packet, as stored in the data file. </td></tr>
    <tr><td class="paramname">packet</td><td>the corresponding packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="xmltreeresolver_8h.html">xmltreeresolver.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
