<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Normal Hypersurfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Normal Hypersurfaces</div>  </div>
</div><!--header-->
<div class="contents">

<p>Normal hypersurfaces in 4-manifold triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HSVectorStandard.html">regina::HSVectorStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal hypersurface vector using standard tetrahedron-prism coordinates.  <a href="classregina_1_1HSVectorStandard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix&lt; T, ring &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements of the given type <em>T</em>.  <a href="classregina_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1HyperInfo.html">regina::HyperInfo&lt; coordType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular normal hypersurface coordinate system.  <a href="structregina_1_1HyperInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">regina::NormalHypersurfaceVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vector of a single normal hypersurface in a 4-manifold triangulation.  <a href="classregina_1_1NormalHypersurfaceVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html">regina::NormalHypersurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single normal hypersurface in a 4-manifold triangulation.  <a href="classregina_1_1NormalHypersurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html">regina::NormalHypersurfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.  <a href="classregina_1_1NormalHypersurfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">regina::NormalHypersurfaces::VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional iterator that runs through the raw vectors for hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">regina::NormalHypersurfaces::HypersurfaceInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator used to insert hypersurfaces into an <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>.  <a href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalHypersurfaceReader.html">regina::XMLNormalHypersurfaceReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single normal hypersurface in a 4-manifold triangulation.  <a href="classregina_1_1XMLNormalHypersurfaceReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalHypersurfacesReader.html">regina::XMLNormalHypersurfacesReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single normal hypersurface list.  <a href="classregina_1_1XMLNormalHypersurfacesReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7ac059871f52044cf4da2e74081d04f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga7ac059871f52044cf4da2e74081d04f2">REGINA_NORMAL_HYPERSURFACE_FLAVOUR</a>(class_,  id,  superclass)</td></tr>
<tr class="memdesc:ga7ac059871f52044cf4da2e74081d04f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of NormalHypersurfaceVector.  <a href="group__hypersurface.html#ga7ac059871f52044cf4da2e74081d04f2">More...</a><br /></td></tr>
<tr class="separator:ga7ac059871f52044cf4da2e74081d04f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga94aeb45ac06210cdb49a8a8ba97b0573"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HSVectorStandard.html">HSVectorStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga94aeb45ac06210cdb49a8a8ba97b0573">regina::NNormalHypersurfaceVectorStandard</a></td></tr>
<tr class="memdesc:ga94aeb45ac06210cdb49a8a8ba97b0573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__hypersurface.html#ga94aeb45ac06210cdb49a8a8ba97b0573">More...</a><br /></td></tr>
<tr class="separator:ga94aeb45ac06210cdb49a8a8ba97b0573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49a56378f69241c425c3345b7d6ddf4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">regina::HyperList</a></td></tr>
<tr class="memdesc:gac49a56378f69241c425c3345b7d6ddf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal hypersurface lists.  <a href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">More...</a><br /></td></tr>
<tr class="separator:gac49a56378f69241c425c3345b7d6ddf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c09d9f6738b5a29b8ae4cc46c7d3e9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">regina::HyperAlg</a></td></tr>
<tr class="memdesc:gad8c09d9f6738b5a29b8ae4cc46c7d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">More...</a><br /></td></tr>
<tr class="separator:gad8c09d9f6738b5a29b8ae4cc46c7d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20e731915f0691913bc317c0b73eab8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">regina::MatrixInt</a></td></tr>
<tr class="memdesc:gaf20e731915f0691913bc317c0b73eab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of arbitrary-precision integers.  <a href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">More...</a><br /></td></tr>
<tr class="separator:gaf20e731915f0691913bc317c0b73eab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae344b29cc907891828ec3f065b5deb40"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gae344b29cc907891828ec3f065b5deb40">regina::NNormalHypersurfaceVector</a></td></tr>
<tr class="memdesc:gae344b29cc907891828ec3f065b5deb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__hypersurface.html#gae344b29cc907891828ec3f065b5deb40">More...</a><br /></td></tr>
<tr class="separator:gae344b29cc907891828ec3f065b5deb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa65af5bc46550f786ce94642a658e48a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaa65af5bc46550f786ce94642a658e48a">regina::NNormalHypersurface</a></td></tr>
<tr class="memdesc:gaa65af5bc46550f786ce94642a658e48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__hypersurface.html#gaa65af5bc46550f786ce94642a658e48a">More...</a><br /></td></tr>
<tr class="separator:gaa65af5bc46550f786ce94642a658e48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bfb3415de96221074b6cb26335ed1af"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5bfb3415de96221074b6cb26335ed1af">regina::NNormalHypersurfaceList</a></td></tr>
<tr class="memdesc:ga5bfb3415de96221074b6cb26335ed1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__hypersurface.html#ga5bfb3415de96221074b6cb26335ed1af">More...</a><br /></td></tr>
<tr class="separator:ga5bfb3415de96221074b6cb26335ed1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga57526727019e919f8b9c3858318d2350"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">regina::HyperCoords</a> { <a class="el" href="group__hypersurface.html#gga57526727019e919f8b9c3858318d2350a0fddbcfd51d4cd1dd59e39c0a93601b8">regina::HS_STANDARD</a> = 0
, <a class="el" href="group__hypersurface.html#gga57526727019e919f8b9c3858318d2350ab9c4a4c7c61f149f7fa0ec0c6b0c7695">regina::HS_PRISM</a> = 1
, <a class="el" href="group__hypersurface.html#gga57526727019e919f8b9c3858318d2350a20231b069d7350f6da4840f48163efe1">regina::HS_EDGE_WEIGHT</a> = 200
 }</td></tr>
<tr class="memdesc:ga57526727019e919f8b9c3858318d2350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different coordinate systems that can be used for enumerating and displaying normal hypersurface within 4-manifold triangulations.  <a href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">More...</a><br /></td></tr>
<tr class="separator:ga57526727019e919f8b9c3858318d2350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3504d968f57efcd4379122ce3e37404d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">regina::HyperListFlags</a> { <br />
&#160;&#160;<a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c">regina::HS_LIST_DEFAULT</a> = 0x0000
, <a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da2e89c96e434f11dfdf829b9512af3b5b">regina::HS_EMBEDDED_ONLY</a> = 0x0001
, <a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da052965a4cf0ccdf6cacfe8488e57d0b9">regina::HS_IMMERSED_SINGULAR</a> = 0x0002
, <a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404dad37cf8bc509f58f8fe68374dd839f781">regina::HS_VERTEX</a> = 0x0004
, <br />
&#160;&#160;<a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404dabc9d522f05ebbb6a772df9bed2894529">regina::HS_FUNDAMENTAL</a> = 0x0008
, <a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404dac6f3050e7490163a92986fc0d7c5161b">regina::HS_LEGACY</a> = 0x4000
, <a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da8728e78556178e9d4048b5b43667492b">regina::HS_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:ga3504d968f57efcd4379122ce3e37404d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different lists of normal hypersurfaces that might be constructed for a given 4-manifold triangulation.  <a href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">More...</a><br /></td></tr>
<tr class="separator:ga3504d968f57efcd4379122ce3e37404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecd2a8d25ac496722f2d8d56ceced5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">regina::HyperAlgFlags</a> { <br />
&#160;&#160;<a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2">regina::HS_ALG_DEFAULT</a> = 0x0000
, <a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da436d0542be438b0cfe832d0a0d320fda">regina::HS_VERTEX_DD</a> = 0x0020
, <a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5dacdb7d45eea9f47cd8f70835b8d5a843a">regina::HS_HILBERT_PRIMAL</a> = 0x0100
, <a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5dac07e79838db18565d610b06066793700">regina::HS_HILBERT_DUAL</a> = 0x0200
, <br />
&#160;&#160;<a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5daa40403c71c93f04fc8d6c0ce242188b3">regina::HS_ALG_LEGACY</a> = 0x4000
, <a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da2c1c6e8b73b7a8087958d04f607d0f39">regina::HS_ALG_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:gaaecd2a8d25ac496722f2d8d56ceced5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents options and variants of algorithms for enumerating various types of normal hypersurfaces in 4-manifold triangulations.  <a href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">More...</a><br /></td></tr>
<tr class="separator:gaaecd2a8d25ac496722f2d8d56ceced5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga36de7c6e11fe8b3cf37d0ea7f6f90645"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga36de7c6e11fe8b3cf37d0ea7f6f90645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645">regina::forCoords</a> (<a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga36de7c6e11fe8b3cf37d0ea7f6f90645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of HyperCoords, which is not known until runtime.  <a href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645">More...</a><br /></td></tr>
<tr class="separator:ga36de7c6e11fe8b3cf37d0ea7f6f90645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1524fedf86f4155daa0791bfc99971"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gabd1524fedf86f4155daa0791bfc99971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gabd1524fedf86f4155daa0791bfc99971">regina::forCoords</a> (<a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabd1524fedf86f4155daa0791bfc99971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of HyperCoords, which is not known until runtime.  <a href="group__hypersurface.html#gabd1524fedf86f4155daa0791bfc99971">More...</a><br /></td></tr>
<tr class="separator:gabd1524fedf86f4155daa0791bfc99971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9335c20b89d0000a3f24b47b7c5e3a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga9335c20b89d0000a3f24b47b7c5e3a8b">regina::HSVectorStandard::HSVectorStandard</a> (size_t length)</td></tr>
<tr class="memdesc:ga9335c20b89d0000a3f24b47b7c5e3a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__hypersurface.html#ga9335c20b89d0000a3f24b47b7c5e3a8b">More...</a><br /></td></tr>
<tr class="separator:ga9335c20b89d0000a3f24b47b7c5e3a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12ebadec57a732b15f170bd3c4e4d2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gab12ebadec57a732b15f170bd3c4e4d2c">regina::HSVectorStandard::HSVectorStandard</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gab12ebadec57a732b15f170bd3c4e4d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__hypersurface.html#gab12ebadec57a732b15f170bd3c4e4d2c">More...</a><br /></td></tr>
<tr class="separator:gab12ebadec57a732b15f170bd3c4e4d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3034b9229803e759b39cc4f9cc3bb093"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga3034b9229803e759b39cc4f9cc3bb093">regina::HSVectorStandard::tetrahedra</a> (size_t pentIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga3034b9229803e759b39cc4f9cc3bb093"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#ga3034b9229803e759b39cc4f9cc3bb093">More...</a><br /></td></tr>
<tr class="separator:ga3034b9229803e759b39cc4f9cc3bb093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8a380fc2a185f6e045c9707f1d5983"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga1a8a380fc2a185f6e045c9707f1d5983">regina::HSVectorStandard::prisms</a> (size_t pentIndex, int prismType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga1a8a380fc2a185f6e045c9707f1d5983"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#ga1a8a380fc2a185f6e045c9707f1d5983">More...</a><br /></td></tr>
<tr class="separator:ga1a8a380fc2a185f6e045c9707f1d5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8360d22d501c9c135decdd73708c00bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga8360d22d501c9c135decdd73708c00bd">regina::HSVectorStandard::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga8360d22d501c9c135decdd73708c00bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="group__hypersurface.html#ga8360d22d501c9c135decdd73708c00bd">More...</a><br /></td></tr>
<tr class="separator:ga8360d22d501c9c135decdd73708c00bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee890b4675a4687db07a5e68e9e5012"><td class="memItemLeft" align="right" valign="top"><a id="ga7ee890b4675a4687db07a5e68e9e5012"></a>
static <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HSVectorStandard::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:ga7ee890b4675a4687db07a5e68e9e5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69434561e0e2a95461d9c38701aab0ae"><td class="memItemLeft" align="right" valign="top"><a id="ga69434561e0e2a95461d9c38701aab0ae"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HSVectorStandard::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:ga69434561e0e2a95461d9c38701aab0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad210183287c873acec33a517efb58cdc"><td class="memItemLeft" align="right" valign="top"><a id="gad210183287c873acec33a517efb58cdc"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HSVectorStandard::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="separator:gad210183287c873acec33a517efb58cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcd474e2d14be1d8379e2392607e031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5dcd474e2d14be1d8379e2392607e031">regina::operator|</a> (<a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a> lhs, <a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a> rhs)</td></tr>
<tr class="memdesc:ga5dcd474e2d14be1d8379e2392607e031"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__hypersurface.html#ga5dcd474e2d14be1d8379e2392607e031">More...</a><br /></td></tr>
<tr class="separator:ga5dcd474e2d14be1d8379e2392607e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535cafb0be3e098c5d28ed3835073b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga535cafb0be3e098c5d28ed3835073b2e">regina::operator|</a> (<a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a> lhs, <a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a> rhs)</td></tr>
<tr class="memdesc:ga535cafb0be3e098c5d28ed3835073b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__hypersurface.html#ga535cafb0be3e098c5d28ed3835073b2e">More...</a><br /></td></tr>
<tr class="separator:ga535cafb0be3e098c5d28ed3835073b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeeee38da5e3a901ebb4488cf7274ce4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gabeeee38da5e3a901ebb4488cf7274ce4">regina::NormalHypersurfaceVector::NormalHypersurfaceVector</a> (size_t length)</td></tr>
<tr class="memdesc:gabeeee38da5e3a901ebb4488cf7274ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__hypersurface.html#gabeeee38da5e3a901ebb4488cf7274ce4">More...</a><br /></td></tr>
<tr class="separator:gabeeee38da5e3a901ebb4488cf7274ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad167e6fba1d9b509ccd8a167cd0a1c42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad167e6fba1d9b509ccd8a167cd0a1c42">regina::NormalHypersurfaceVector::NormalHypersurfaceVector</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gad167e6fba1d9b509ccd8a167cd0a1c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__hypersurface.html#gad167e6fba1d9b509ccd8a167cd0a1c42">More...</a><br /></td></tr>
<tr class="separator:gad167e6fba1d9b509ccd8a167cd0a1c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061be85305688ec1eaa9c3f3e0d526df"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga061be85305688ec1eaa9c3f3e0d526df">regina::NormalHypersurfaceVector::~NormalHypersurfaceVector</a> ()</td></tr>
<tr class="memdesc:ga061be85305688ec1eaa9c3f3e0d526df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual destructor.  <a href="group__hypersurface.html#ga061be85305688ec1eaa9c3f3e0d526df">More...</a><br /></td></tr>
<tr class="separator:ga061be85305688ec1eaa9c3f3e0d526df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ccc8e495f977c5d2d8ae949ac420673"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga2ccc8e495f977c5d2d8ae949ac420673">regina::NormalHypersurfaceVector::coords</a> () const</td></tr>
<tr class="memdesc:ga2ccc8e495f977c5d2d8ae949ac420673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="group__hypersurface.html#ga2ccc8e495f977c5d2d8ae949ac420673">More...</a><br /></td></tr>
<tr class="separator:ga2ccc8e495f977c5d2d8ae949ac420673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470f49e212ea52daeb876f0befd5338a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga470f49e212ea52daeb876f0befd5338a">regina::NormalHypersurfaceVector::clone</a> () const =0</td></tr>
<tr class="memdesc:ga470f49e212ea52daeb876f0befd5338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="group__hypersurface.html#ga470f49e212ea52daeb876f0befd5338a">More...</a><br /></td></tr>
<tr class="separator:ga470f49e212ea52daeb876f0befd5338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafcf1b859ef233f5193551626a5c30b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaeafcf1b859ef233f5193551626a5c30b">regina::NormalHypersurfaceVector::size</a> () const</td></tr>
<tr class="memdesc:gaeafcf1b859ef233f5193551626a5c30b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="group__hypersurface.html#gaeafcf1b859ef233f5193551626a5c30b">More...</a><br /></td></tr>
<tr class="separator:gaeafcf1b859ef233f5193551626a5c30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff88752783b70349710da6368de3ba7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga4ff88752783b70349710da6368de3ba7">regina::NormalHypersurfaceVector::operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:ga4ff88752783b70349710da6368de3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="group__hypersurface.html#ga4ff88752783b70349710da6368de3ba7">More...</a><br /></td></tr>
<tr class="separator:ga4ff88752783b70349710da6368de3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8c275dac12626724b3c4f87eb99cd7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga9a8c275dac12626724b3c4f87eb99cd7">regina::NormalHypersurfaceVector::setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:ga9a8c275dac12626724b3c4f87eb99cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="group__hypersurface.html#ga9a8c275dac12626724b3c4f87eb99cd7">More...</a><br /></td></tr>
<tr class="separator:ga9a8c275dac12626724b3c4f87eb99cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03282d464e943ec673ae5d04a33533a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga03282d464e943ec673ae5d04a33533a2">regina::NormalHypersurfaceVector::operator+=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;other)</td></tr>
<tr class="memdesc:ga03282d464e943ec673ae5d04a33533a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="group__hypersurface.html#ga03282d464e943ec673ae5d04a33533a2">More...</a><br /></td></tr>
<tr class="separator:ga03282d464e943ec673ae5d04a33533a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242996a39b1ab9b3198610b2f4d2e7a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga242996a39b1ab9b3198610b2f4d2e7a4">regina::NormalHypersurfaceVector::scaleDown</a> ()</td></tr>
<tr class="memdesc:ga242996a39b1ab9b3198610b2f4d2e7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="group__hypersurface.html#ga242996a39b1ab9b3198610b2f4d2e7a4">More...</a><br /></td></tr>
<tr class="separator:ga242996a39b1ab9b3198610b2f4d2e7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac3e7f7cce9c678b91073859a9395ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6ac3e7f7cce9c678b91073859a9395ca">regina::NormalHypersurfaceVector::isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:ga6ac3e7f7cce9c678b91073859a9395ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is compact (has finitely many pieces).  <a href="group__hypersurface.html#ga6ac3e7f7cce9c678b91073859a9395ca">More...</a><br /></td></tr>
<tr class="separator:ga6ac3e7f7cce9c678b91073859a9395ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38e0ba79fe11756f4a68620fad07f2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf38e0ba79fe11756f4a68620fad07f2b">regina::NormalHypersurfaceVector::isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:gaf38e0ba79fe11756f4a68620fad07f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is vertex linking.  <a href="group__hypersurface.html#gaf38e0ba79fe11756f4a68620fad07f2b">More...</a><br /></td></tr>
<tr class="separator:gaf38e0ba79fe11756f4a68620fad07f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6257bfb963173e01255bd29864ca9482"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6257bfb963173e01255bd29864ca9482">regina::NormalHypersurfaceVector::isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:ga6257bfb963173e01255bd29864ca9482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex.  <a href="group__hypersurface.html#ga6257bfb963173e01255bd29864ca9482">More...</a><br /></td></tr>
<tr class="separator:ga6257bfb963173e01255bd29864ca9482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8cefb8b876ef5c98ece1f393313ec3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga0b8cefb8b876ef5c98ece1f393313ec3">regina::NormalHypersurfaceVector::isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const</td></tr>
<tr class="memdesc:ga0b8cefb8b876ef5c98ece1f393313ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge.  <a href="group__hypersurface.html#ga0b8cefb8b876ef5c98ece1f393313ec3">More...</a><br /></td></tr>
<tr class="separator:ga0b8cefb8b876ef5c98ece1f393313ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcecbbd6ed6b1c905604345e755e9a23"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gabcecbbd6ed6b1c905604345e755e9a23">regina::NormalHypersurfaceVector::tetrahedra</a> (size_t pentIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const =0</td></tr>
<tr class="memdesc:gabcecbbd6ed6b1c905604345e755e9a23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#gabcecbbd6ed6b1c905604345e755e9a23">More...</a><br /></td></tr>
<tr class="separator:gabcecbbd6ed6b1c905604345e755e9a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d96a0eb204333f4deff8f7cacefdb00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga0d96a0eb204333f4deff8f7cacefdb00">regina::NormalHypersurfaceVector::prisms</a> (size_t pentIndex, int prismType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ga0d96a0eb204333f4deff8f7cacefdb00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#ga0d96a0eb204333f4deff8f7cacefdb00">More...</a><br /></td></tr>
<tr class="separator:ga0d96a0eb204333f4deff8f7cacefdb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1957334b91441cd0c21c3da25c105c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaa1957334b91441cd0c21c3da25c105c8">regina::NormalHypersurfaceVector::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang) const =0</td></tr>
<tr class="memdesc:gaa1957334b91441cd0c21c3da25c105c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="group__hypersurface.html#gaa1957334b91441cd0c21c3da25c105c8">More...</a><br /></td></tr>
<tr class="separator:gaa1957334b91441cd0c21c3da25c105c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9766a882b15b01297fcfd3efc9758c7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga9766a882b15b01297fcfd3efc9758c7b">regina::NormalHypersurfaceVector::makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="memdesc:ga9766a882b15b01297fcfd3efc9758c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>.  <a href="group__hypersurface.html#ga9766a882b15b01297fcfd3efc9758c7b">More...</a><br /></td></tr>
<tr class="separator:ga9766a882b15b01297fcfd3efc9758c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga139188fcf2aadfc3f3e63405fd5255e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga139188fcf2aadfc3f3e63405fd5255e8">regina::NormalHypersurfaceVector::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="memdesc:ga139188fcf2aadfc3f3e63405fd5255e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal hypersurface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>.  <a href="group__hypersurface.html#ga139188fcf2aadfc3f3e63405fd5255e8">More...</a><br /></td></tr>
<tr class="separator:ga139188fcf2aadfc3f3e63405fd5255e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e83bf3a6865f7028184027941605f0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6e83bf3a6865f7028184027941605f0c">regina::NormalHypersurfaceVector::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation)</td></tr>
<tr class="memdesc:ga6e83bf3a6865f7028184027941605f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded.  <a href="group__hypersurface.html#ga6e83bf3a6865f7028184027941605f0c">More...</a><br /></td></tr>
<tr class="separator:ga6e83bf3a6865f7028184027941605f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1babd3db962696007d296b3a03ec91"><td class="memItemLeft" align="right" valign="top"><a id="ga7c1babd3db962696007d296b3a03ec91"></a>
<a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaceVector::operator=</b> (const <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;)=delete</td></tr>
<tr class="separator:ga7c1babd3db962696007d296b3a03ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ea52ceb2420115302f014a1fb621e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga79ea52ceb2420115302f014a1fb621e8">regina::NormalHypersurface::NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *<a class="el" href="group__hypersurface.html#ga5204ff2db3586315cccada33614e5fab">triangulation</a>, <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *vector)</td></tr>
<tr class="memdesc:ga79ea52ceb2420115302f014a1fb621e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector.  <a href="group__hypersurface.html#ga79ea52ceb2420115302f014a1fb621e8">More...</a><br /></td></tr>
<tr class="separator:ga79ea52ceb2420115302f014a1fb621e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1687ff1ed99e7a17c2b72e1fa9281f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gabf1687ff1ed99e7a17c2b72e1fa9281f">regina::NormalHypersurface::NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coordSystem, List allCoords)</td></tr>
<tr class="memdesc:gabf1687ff1ed99e7a17c2b72e1fa9281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that creates a new normal hypersurface inside the given triangulation with the given coordinate vector.  <a href="group__hypersurface.html#gabf1687ff1ed99e7a17c2b72e1fa9281f">More...</a><br /></td></tr>
<tr class="separator:gabf1687ff1ed99e7a17c2b72e1fa9281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30dbb81eda08334962f4e5328dded7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gab30dbb81eda08334962f4e5328dded7f">regina::NormalHypersurface::~NormalHypersurface</a> ()</td></tr>
<tr class="memdesc:gab30dbb81eda08334962f4e5328dded7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this normal hypersurface.  <a href="group__hypersurface.html#gab30dbb81eda08334962f4e5328dded7f">More...</a><br /></td></tr>
<tr class="separator:gab30dbb81eda08334962f4e5328dded7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98fdd9c300f021efe29514d23c2e0179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga98fdd9c300f021efe29514d23c2e0179">regina::NormalHypersurface::clone</a> () const</td></tr>
<tr class="memdesc:ga98fdd9c300f021efe29514d23c2e0179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this normal hypersurface.  <a href="group__hypersurface.html#ga98fdd9c300f021efe29514d23c2e0179">More...</a><br /></td></tr>
<tr class="separator:ga98fdd9c300f021efe29514d23c2e0179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854c8e7092542bc6f68a77c56aef547a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga854c8e7092542bc6f68a77c56aef547a">regina::NormalHypersurface::doubleHypersurface</a> () const</td></tr>
<tr class="memdesc:ga854c8e7092542bc6f68a77c56aef547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated hypersurface that is the double of this hypersurface.  <a href="group__hypersurface.html#ga854c8e7092542bc6f68a77c56aef547a">More...</a><br /></td></tr>
<tr class="separator:ga854c8e7092542bc6f68a77c56aef547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e571077474b0899732e60f6c3c393df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5e571077474b0899732e60f6c3c393df">regina::NormalHypersurface::tetrahedra</a> (size_t pentIndex, int vertex) const</td></tr>
<tr class="memdesc:ga5e571077474b0899732e60f6c3c393df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#ga5e571077474b0899732e60f6c3c393df">More...</a><br /></td></tr>
<tr class="separator:ga5e571077474b0899732e60f6c3c393df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34268af846d03f4016a3a6134e6f65d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga34268af846d03f4016a3a6134e6f65d5">regina::NormalHypersurface::prisms</a> (size_t pentIndex, int prismType) const</td></tr>
<tr class="memdesc:ga34268af846d03f4016a3a6134e6f65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="group__hypersurface.html#ga34268af846d03f4016a3a6134e6f65d5">More...</a><br /></td></tr>
<tr class="separator:ga34268af846d03f4016a3a6134e6f65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0661d930754b6c681e6a23595a36476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gae0661d930754b6c681e6a23595a36476">regina::NormalHypersurface::edgeWeight</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:gae0661d930754b6c681e6a23595a36476"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="group__hypersurface.html#gae0661d930754b6c681e6a23595a36476">More...</a><br /></td></tr>
<tr class="separator:gae0661d930754b6c681e6a23595a36476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea7b0d48ce30206f27014acbca16a3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga2ea7b0d48ce30206f27014acbca16a3f">regina::NormalHypersurface::countCoords</a> () const</td></tr>
<tr class="memdesc:ga2ea7b0d48ce30206f27014acbca16a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used.  <a href="group__hypersurface.html#ga2ea7b0d48ce30206f27014acbca16a3f">More...</a><br /></td></tr>
<tr class="separator:ga2ea7b0d48ce30206f27014acbca16a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5204ff2db3586315cccada33614e5fab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5204ff2db3586315cccada33614e5fab">regina::NormalHypersurface::triangulation</a> () const</td></tr>
<tr class="memdesc:ga5204ff2db3586315cccada33614e5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal hypersurface resides.  <a href="group__hypersurface.html#ga5204ff2db3586315cccada33614e5fab">More...</a><br /></td></tr>
<tr class="separator:ga5204ff2db3586315cccada33614e5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aca89d84f22f361520c25277521b9d9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6aca89d84f22f361520c25277521b9d9">regina::NormalHypersurface::name</a> () const</td></tr>
<tr class="memdesc:ga6aca89d84f22f361520c25277521b9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal hypersurface.  <a href="group__hypersurface.html#ga6aca89d84f22f361520c25277521b9d9">More...</a><br /></td></tr>
<tr class="separator:ga6aca89d84f22f361520c25277521b9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cdf3ef9c9407d10c5eabc69671207f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga1cdf3ef9c9407d10c5eabc69671207f5">regina::NormalHypersurface::setName</a> (const std::string &amp;<a class="el" href="group__hypersurface.html#ga6aca89d84f22f361520c25277521b9d9">name</a>)</td></tr>
<tr class="memdesc:ga1cdf3ef9c9407d10c5eabc69671207f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal hypersurface.  <a href="group__hypersurface.html#ga1cdf3ef9c9407d10c5eabc69671207f5">More...</a><br /></td></tr>
<tr class="separator:ga1cdf3ef9c9407d10c5eabc69671207f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac169d0bb98e129d7437ca45b97054b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gac169d0bb98e129d7437ca45b97054b47">regina::NormalHypersurface::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gac169d0bb98e129d7437ca45b97054b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates.  <a href="group__hypersurface.html#gac169d0bb98e129d7437ca45b97054b47">More...</a><br /></td></tr>
<tr class="separator:gac169d0bb98e129d7437ca45b97054b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77471d238bd9223eee6e581e2b046dd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga77471d238bd9223eee6e581e2b046dd7">regina::NormalHypersurface::writeRawVector</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga77471d238bd9223eee6e581e2b046dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the underlying coordinate vector to the given output stream in text format.  <a href="group__hypersurface.html#ga77471d238bd9223eee6e581e2b046dd7">More...</a><br /></td></tr>
<tr class="separator:ga77471d238bd9223eee6e581e2b046dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d013a7283675341079a93aaaba902ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga3d013a7283675341079a93aaaba902ad">regina::NormalHypersurface::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga3d013a7283675341079a93aaaba902ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal hypersurface and all of its properties.  <a href="group__hypersurface.html#ga3d013a7283675341079a93aaaba902ad">More...</a><br /></td></tr>
<tr class="separator:ga3d013a7283675341079a93aaaba902ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ac5d0891674f9dd46395d7099dcf6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gae6ac5d0891674f9dd46395d7099dcf6a">regina::NormalHypersurface::isEmpty</a> () const</td></tr>
<tr class="memdesc:gae6ac5d0891674f9dd46395d7099dcf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is empty (has no pieces whatsoever).  <a href="group__hypersurface.html#gae6ac5d0891674f9dd46395d7099dcf6a">More...</a><br /></td></tr>
<tr class="separator:gae6ac5d0891674f9dd46395d7099dcf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bc4b36bd5443133c33aed2b02177e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga49bc4b36bd5443133c33aed2b02177e1">regina::NormalHypersurface::isCompact</a> () const</td></tr>
<tr class="memdesc:ga49bc4b36bd5443133c33aed2b02177e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is compact (has finitely many pieces).  <a href="group__hypersurface.html#ga49bc4b36bd5443133c33aed2b02177e1">More...</a><br /></td></tr>
<tr class="separator:ga49bc4b36bd5443133c33aed2b02177e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99506625435eadb56c06968221623935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga99506625435eadb56c06968221623935">regina::NormalHypersurface::isOrientable</a> () const</td></tr>
<tr class="memdesc:ga99506625435eadb56c06968221623935"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is orientable.  <a href="group__hypersurface.html#ga99506625435eadb56c06968221623935">More...</a><br /></td></tr>
<tr class="separator:ga99506625435eadb56c06968221623935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad578abb2b7507a4bdac7cf8427389e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaad578abb2b7507a4bdac7cf8427389e0">regina::NormalHypersurface::isTwoSided</a> () const</td></tr>
<tr class="memdesc:gaad578abb2b7507a4bdac7cf8427389e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is two-sided.  <a href="group__hypersurface.html#gaad578abb2b7507a4bdac7cf8427389e0">More...</a><br /></td></tr>
<tr class="separator:gaad578abb2b7507a4bdac7cf8427389e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770ee1870e1ceb28a2b577356a4be33d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga770ee1870e1ceb28a2b577356a4be33d">regina::NormalHypersurface::isConnected</a> () const</td></tr>
<tr class="memdesc:ga770ee1870e1ceb28a2b577356a4be33d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is connected.  <a href="group__hypersurface.html#ga770ee1870e1ceb28a2b577356a4be33d">More...</a><br /></td></tr>
<tr class="separator:ga770ee1870e1ceb28a2b577356a4be33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga8fd89e9ad52cd1934f435ea1ecfae1ed">regina::NormalHypersurface::hasRealBoundary</a> () const</td></tr>
<tr class="memdesc:ga8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation.  <a href="group__hypersurface.html#ga8fd89e9ad52cd1934f435ea1ecfae1ed">More...</a><br /></td></tr>
<tr class="separator:ga8fd89e9ad52cd1934f435ea1ecfae1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842ced3478b08bde5ad883ef77724420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga842ced3478b08bde5ad883ef77724420">regina::NormalHypersurface::isVertexLinking</a> () const</td></tr>
<tr class="memdesc:ga842ced3478b08bde5ad883ef77724420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this hypersurface is vertex linking.  <a href="group__hypersurface.html#ga842ced3478b08bde5ad883ef77724420">More...</a><br /></td></tr>
<tr class="separator:ga842ced3478b08bde5ad883ef77724420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e8a721415302c5101e5064db14b153"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga54e8a721415302c5101e5064db14b153">regina::NormalHypersurface::isVertexLink</a> () const</td></tr>
<tr class="memdesc:ga54e8a721415302c5101e5064db14b153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this hypersurface is the link of a single vertex.  <a href="group__hypersurface.html#ga54e8a721415302c5101e5064db14b153">More...</a><br /></td></tr>
<tr class="separator:ga54e8a721415302c5101e5064db14b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8126f6c44dc69ca6e66fd6045313bd7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga8126f6c44dc69ca6e66fd6045313bd7b">regina::NormalHypersurface::isThinEdgeLink</a> () const</td></tr>
<tr class="memdesc:ga8126f6c44dc69ca6e66fd6045313bd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this hypersurface is the thin link of a single edge.  <a href="group__hypersurface.html#ga8126f6c44dc69ca6e66fd6045313bd7b">More...</a><br /></td></tr>
<tr class="separator:ga8126f6c44dc69ca6e66fd6045313bd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cfddf3340d89bc8e5c8414e3b2d17a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf5cfddf3340d89bc8e5c8414e3b2d17a">regina::NormalHypersurface::homology</a> () const</td></tr>
<tr class="memdesc:gaf5cfddf3340d89bc8e5c8414e3b2d17a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this hypersurface.  <a href="group__hypersurface.html#gaf5cfddf3340d89bc8e5c8414e3b2d17a">More...</a><br /></td></tr>
<tr class="separator:gaf5cfddf3340d89bc8e5c8414e3b2d17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10612a9cb4e27aa9162b2c8e05d082fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga10612a9cb4e27aa9162b2c8e05d082fa">regina::NormalHypersurface::triangulate</a> () const</td></tr>
<tr class="memdesc:ga10612a9cb4e27aa9162b2c8e05d082fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 3-manifold triangulation describing this normal hypersurface.  <a href="group__hypersurface.html#ga10612a9cb4e27aa9162b2c8e05d082fa">More...</a><br /></td></tr>
<tr class="separator:ga10612a9cb4e27aa9162b2c8e05d082fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf912cc475e68845a8b28e906d692d806"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf912cc475e68845a8b28e906d692d806">regina::NormalHypersurface::sameSurface</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const</td></tr>
<tr class="memdesc:gaf912cc475e68845a8b28e906d692d806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface in fact represent the same normal hypersurface.  <a href="group__hypersurface.html#gaf912cc475e68845a8b28e906d692d806">More...</a><br /></td></tr>
<tr class="separator:gaf912cc475e68845a8b28e906d692d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4f6c59a84e0cd88f91802d0524497b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gafe4f6c59a84e0cd88f91802d0524497b">regina::NormalHypersurface::embedded</a> () const</td></tr>
<tr class="memdesc:gafe4f6c59a84e0cd88f91802d0524497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this hypersurface is embedded.  <a href="group__hypersurface.html#gafe4f6c59a84e0cd88f91802d0524497b">More...</a><br /></td></tr>
<tr class="separator:gafe4f6c59a84e0cd88f91802d0524497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a7a0a235aec8da73213bbf1934aa41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaa4a7a0a235aec8da73213bbf1934aa41">regina::NormalHypersurface::locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const</td></tr>
<tr class="memdesc:gaa4a7a0a235aec8da73213bbf1934aa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface are locally compatible.  <a href="group__hypersurface.html#gaa4a7a0a235aec8da73213bbf1934aa41">More...</a><br /></td></tr>
<tr class="separator:gaa4a7a0a235aec8da73213bbf1934aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449322a000b093f813f8693cbb248f92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga449322a000b093f813f8693cbb248f92">regina::NormalHypersurface::rawVector</a> () const</td></tr>
<tr class="memdesc:ga449322a000b093f813f8693cbb248f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the raw vector that sits beneath this normal hypersurface.  <a href="group__hypersurface.html#ga449322a000b093f813f8693cbb248f92">More...</a><br /></td></tr>
<tr class="separator:ga449322a000b093f813f8693cbb248f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb032ad61334b77a023333049474428f"><td class="memItemLeft" align="right" valign="top"><a id="gafb032ad61334b77a023333049474428f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurface::NormalHypersurface</b> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;)=delete</td></tr>
<tr class="separator:gafb032ad61334b77a023333049474428f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61c52b981d61a516bfd3d25793a08f3"><td class="memItemLeft" align="right" valign="top"><a id="gab61c52b981d61a516bfd3d25793a08f3"></a>
<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurface::operator=</b> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;)=delete</td></tr>
<tr class="separator:gab61c52b981d61a516bfd3d25793a08f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff4ad53a1dd99505b076481d7646926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6ff4ad53a1dd99505b076481d7646926">regina::NormalHypersurface::calculateRealBoundary</a> () const</td></tr>
<tr class="memdesc:ga6ff4ad53a1dd99505b076481d7646926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this hypersurface has any real boundary and stores the result as a property.  <a href="group__hypersurface.html#ga6ff4ad53a1dd99505b076481d7646926">More...</a><br /></td></tr>
<tr class="separator:ga6ff4ad53a1dd99505b076481d7646926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec9e195140fae7cba07e963d6728247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5ec9e195140fae7cba07e963d6728247">regina::NormalHypersurface::calculateFromTriangulation</a> () const</td></tr>
<tr class="memdesc:ga5ec9e195140fae7cba07e963d6728247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and store all properties that we derive from the 3-manifold triangulation of this hypersurface.  <a href="group__hypersurface.html#ga5ec9e195140fae7cba07e963d6728247">More...</a><br /></td></tr>
<tr class="separator:ga5ec9e195140fae7cba07e963d6728247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ab690be412b4d01cb0e45ca667ff3e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga86ab690be412b4d01cb0e45ca667ff3e">regina::NormalHypersurfaces::~NormalHypersurfaces</a> ()</td></tr>
<tr class="memdesc:ga86ab690be412b4d01cb0e45ca667ff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all the hypersurfaces within.  <a href="group__hypersurface.html#ga86ab690be412b4d01cb0e45ca667ff3e">More...</a><br /></td></tr>
<tr class="separator:ga86ab690be412b4d01cb0e45ca667ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e4d8fbac7f933401e084190c468190"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga84e4d8fbac7f933401e084190c468190">regina::NormalHypersurfaces::enumerate</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *owner, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> <a class="el" href="group__hypersurface.html#gadc5c6c7aeab32d4d2d80425c9f8ad108">coords</a>, <a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a> <a class="el" href="group__hypersurface.html#gaebbdf01911361353b206a761af4ffa17">which</a>=<a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c">HS_LIST_DEFAULT</a>, <a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a> algHints=<a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2">HS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:ga84e4d8fbac7f933401e084190c468190"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified routine for enumerating various classes of normal hypersurfaces within a given triangulation.  <a href="group__hypersurface.html#ga84e4d8fbac7f933401e084190c468190">More...</a><br /></td></tr>
<tr class="separator:ga84e4d8fbac7f933401e084190c468190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5c6c7aeab32d4d2d80425c9f8ad108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gadc5c6c7aeab32d4d2d80425c9f8ad108">regina::NormalHypersurfaces::coords</a> () const</td></tr>
<tr class="memdesc:gadc5c6c7aeab32d4d2d80425c9f8ad108"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the hypersurfaces stored in this set.  <a href="group__hypersurface.html#gadc5c6c7aeab32d4d2d80425c9f8ad108">More...</a><br /></td></tr>
<tr class="separator:gadc5c6c7aeab32d4d2d80425c9f8ad108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbdf01911361353b206a761af4ffa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaebbdf01911361353b206a761af4ffa17">regina::NormalHypersurfaces::which</a> () const</td></tr>
<tr class="memdesc:gaebbdf01911361353b206a761af4ffa17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal hypersurfaces this list represents within the underlying triangulation.  <a href="group__hypersurface.html#gaebbdf01911361353b206a761af4ffa17">More...</a><br /></td></tr>
<tr class="separator:gaebbdf01911361353b206a761af4ffa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01cd9910600cf3f0dc578f00faf37c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gae01cd9910600cf3f0dc578f00faf37c2">regina::NormalHypersurfaces::algorithm</a> () const</td></tr>
<tr class="memdesc:gae01cd9910600cf3f0dc578f00faf37c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list.  <a href="group__hypersurface.html#gae01cd9910600cf3f0dc578f00faf37c2">More...</a><br /></td></tr>
<tr class="separator:gae01cd9910600cf3f0dc578f00faf37c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13eb348cfcd3070e215de79d735ddd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gab13eb348cfcd3070e215de79d735ddd0">regina::NormalHypersurfaces::isEmbeddedOnly</a> () const</td></tr>
<tr class="memdesc:gab13eb348cfcd3070e215de79d735ddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this set is known to contain only embedded normal hypersurfaces.  <a href="group__hypersurface.html#gab13eb348cfcd3070e215de79d735ddd0">More...</a><br /></td></tr>
<tr class="separator:gab13eb348cfcd3070e215de79d735ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8994b445d18484526c22635bacb3ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gab8994b445d18484526c22635bacb3ec7">regina::NormalHypersurfaces::triangulation</a> () const</td></tr>
<tr class="memdesc:gab8994b445d18484526c22635bacb3ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal hypersurfaces live.  <a href="group__hypersurface.html#gab8994b445d18484526c22635bacb3ec7">More...</a><br /></td></tr>
<tr class="separator:gab8994b445d18484526c22635bacb3ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b6c5deda3b5f72c5a29567b1812f20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga23b6c5deda3b5f72c5a29567b1812f20">regina::NormalHypersurfaces::size</a> () const</td></tr>
<tr class="memdesc:ga23b6c5deda3b5f72c5a29567b1812f20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of hypersurfaces stored in this list.  <a href="group__hypersurface.html#ga23b6c5deda3b5f72c5a29567b1812f20">More...</a><br /></td></tr>
<tr class="separator:ga23b6c5deda3b5f72c5a29567b1812f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51f4b521a02d12804d77fb765b2293c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad51f4b521a02d12804d77fb765b2293c">regina::NormalHypersurfaces::hypersurface</a> (size_t index) const</td></tr>
<tr class="memdesc:gad51f4b521a02d12804d77fb765b2293c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the hypersurface at the requested index in this list.  <a href="group__hypersurface.html#gad51f4b521a02d12804d77fb765b2293c">More...</a><br /></td></tr>
<tr class="separator:gad51f4b521a02d12804d77fb765b2293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0bf074f42a0da5e565bb79831d6d30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga3f0bf074f42a0da5e565bb79831d6d30">regina::NormalHypersurfaces::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga3f0bf074f42a0da5e565bb79831d6d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__hypersurface.html#ga3f0bf074f42a0da5e565bb79831d6d30">More...</a><br /></td></tr>
<tr class="separator:ga3f0bf074f42a0da5e565bb79831d6d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938dd8acfd2cdab2f6854305bbae4c97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga938dd8acfd2cdab2f6854305bbae4c97">regina::NormalHypersurfaces::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga938dd8acfd2cdab2f6854305bbae4c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__hypersurface.html#ga938dd8acfd2cdab2f6854305bbae4c97">More...</a><br /></td></tr>
<tr class="separator:ga938dd8acfd2cdab2f6854305bbae4c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabfa4d23997c177976c26ade15874d44"><td class="memItemLeft" align="right" valign="top"><a id="gaabfa4d23997c177976c26ade15874d44"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaces::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:gaabfa4d23997c177976c26ade15874d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56057aabcc51c84ea924dd68f2e1326a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga56057aabcc51c84ea924dd68f2e1326a">regina::NormalHypersurfaces::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga56057aabcc51c84ea924dd68f2e1326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__hypersurface.html#ga56057aabcc51c84ea924dd68f2e1326a">More...</a><br /></td></tr>
<tr class="separator:ga56057aabcc51c84ea924dd68f2e1326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf49a8aee54383f5641341b9471a307"><td class="memTemplParams" colspan="2">template&lt;typename Comparison &gt; </td></tr>
<tr class="memitem:ga1bf49a8aee54383f5641341b9471a307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga1bf49a8aee54383f5641341b9471a307">regina::NormalHypersurfaces::sort</a> (Comparison &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga1bf49a8aee54383f5641341b9471a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the hypersurfaces in this list according to the given criterion.  <a href="group__hypersurface.html#ga1bf49a8aee54383f5641341b9471a307">More...</a><br /></td></tr>
<tr class="separator:ga1bf49a8aee54383f5641341b9471a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99880c9b0c8f843af93cf4fefb8ceab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga99880c9b0c8f843af93cf4fefb8ceab0">regina::NormalHypersurfaces::recreateMatchingEquations</a> () const</td></tr>
<tr class="memdesc:ga99880c9b0c8f843af93cf4fefb8ceab0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal hypersurface list.  <a href="group__hypersurface.html#ga99880c9b0c8f843af93cf4fefb8ceab0">More...</a><br /></td></tr>
<tr class="separator:ga99880c9b0c8f843af93cf4fefb8ceab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefed5920d1b387e5d3b0f35b390ebec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gacefed5920d1b387e5d3b0f35b390ebec">regina::NormalHypersurfaces::beginVectors</a> () const</td></tr>
<tr class="memdesc:gacefed5920d1b387e5d3b0f35b390ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for hypersurfaces in this list, pointing to the beginning of this hypersurface list.  <a href="group__hypersurface.html#gacefed5920d1b387e5d3b0f35b390ebec">More...</a><br /></td></tr>
<tr class="separator:gacefed5920d1b387e5d3b0f35b390ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga48d5da33f4ac4f4a2ed4296a4a0395b5">regina::NormalHypersurfaces::endVectors</a> () const</td></tr>
<tr class="memdesc:ga48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for hypersurfaces in this list, pointing past the end of this hypersurface list.  <a href="group__hypersurface.html#ga48d5da33f4ac4f4a2ed4296a4a0395b5">More...</a><br /></td></tr>
<tr class="separator:ga48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a9d0398362ec3ef2135d71f68274d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga84a9d0398362ec3ef2135d71f68274d5">regina::NormalHypersurfaces::VectorIterator::VectorIterator</a> ()</td></tr>
<tr class="memdesc:ga84a9d0398362ec3ef2135d71f68274d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised iterator.  <a href="group__hypersurface.html#ga84a9d0398362ec3ef2135d71f68274d5">More...</a><br /></td></tr>
<tr class="separator:ga84a9d0398362ec3ef2135d71f68274d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab59507b0769b1995ce7db703f3d1252"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaab59507b0769b1995ce7db703f3d1252">regina::NormalHypersurfaces::VectorIterator::VectorIterator</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gaab59507b0769b1995ce7db703f3d1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given iterator.  <a href="group__hypersurface.html#gaab59507b0769b1995ce7db703f3d1252">More...</a><br /></td></tr>
<tr class="separator:gaab59507b0769b1995ce7db703f3d1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dc212ec572efdb2c4b87d2347c0bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga64dc212ec572efdb2c4b87d2347c0bfb">regina::NormalHypersurfaces::VectorIterator::operator=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga64dc212ec572efdb2c4b87d2347c0bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this a copy of the given iterator.  <a href="group__hypersurface.html#ga64dc212ec572efdb2c4b87d2347c0bfb">More...</a><br /></td></tr>
<tr class="separator:ga64dc212ec572efdb2c4b87d2347c0bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97940c8d388390724c76d470d55ece53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga97940c8d388390724c76d470d55ece53">regina::NormalHypersurfaces::VectorIterator::operator==</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ga97940c8d388390724c76d470d55ece53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this with the given operator for equality.  <a href="group__hypersurface.html#ga97940c8d388390724c76d470d55ece53">More...</a><br /></td></tr>
<tr class="separator:ga97940c8d388390724c76d470d55ece53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57c8b07ac47e5eb5005ea4e1f72f47d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad57c8b07ac47e5eb5005ea4e1f72f47d">regina::NormalHypersurfaces::VectorIterator::operator!=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:gad57c8b07ac47e5eb5005ea4e1f72f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this with the given operator for inequality.  <a href="group__hypersurface.html#gad57c8b07ac47e5eb5005ea4e1f72f47d">More...</a><br /></td></tr>
<tr class="separator:gad57c8b07ac47e5eb5005ea4e1f72f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758e1ba025d68f79f41b3daa523e2a2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga758e1ba025d68f79f41b3daa523e2a2c">regina::NormalHypersurfaces::VectorIterator::operator*</a> () const</td></tr>
<tr class="memdesc:ga758e1ba025d68f79f41b3daa523e2a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the raw vector for the normal hypersurface that this iterator is currently pointing to.  <a href="group__hypersurface.html#ga758e1ba025d68f79f41b3daa523e2a2c">More...</a><br /></td></tr>
<tr class="separator:ga758e1ba025d68f79f41b3daa523e2a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032ceddd4eb6422291ea20ffcd23c7ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga032ceddd4eb6422291ea20ffcd23c7ac">regina::NormalHypersurfaces::VectorIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga032ceddd4eb6422291ea20ffcd23c7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preincrement operator.  <a href="group__hypersurface.html#ga032ceddd4eb6422291ea20ffcd23c7ac">More...</a><br /></td></tr>
<tr class="separator:ga032ceddd4eb6422291ea20ffcd23c7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6938dab3a7eb016d6a02b9e06bc8747f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6938dab3a7eb016d6a02b9e06bc8747f">regina::NormalHypersurfaces::VectorIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga6938dab3a7eb016d6a02b9e06bc8747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postincrement operator.  <a href="group__hypersurface.html#ga6938dab3a7eb016d6a02b9e06bc8747f">More...</a><br /></td></tr>
<tr class="separator:ga6938dab3a7eb016d6a02b9e06bc8747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bfed4bcefefa781050a29d4d056572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga81bfed4bcefefa781050a29d4d056572">regina::NormalHypersurfaces::VectorIterator::operator--</a> ()</td></tr>
<tr class="memdesc:ga81bfed4bcefefa781050a29d4d056572"><td class="mdescLeft">&#160;</td><td class="mdescRight">The predecrement operator.  <a href="group__hypersurface.html#ga81bfed4bcefefa781050a29d4d056572">More...</a><br /></td></tr>
<tr class="separator:ga81bfed4bcefefa781050a29d4d056572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac2244b1a32e063c3d7bac0f477b1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaeac2244b1a32e063c3d7bac0f477b1fc">regina::NormalHypersurfaces::VectorIterator::operator--</a> (int)</td></tr>
<tr class="memdesc:gaeac2244b1a32e063c3d7bac0f477b1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postdecrement operator.  <a href="group__hypersurface.html#gaeac2244b1a32e063c3d7bac0f477b1fc">More...</a><br /></td></tr>
<tr class="separator:gaeac2244b1a32e063c3d7bac0f477b1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a29135ae00e910d9a00f2920bc4139"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga53a29135ae00e910d9a00f2920bc4139">regina::NormalHypersurfaces::NormalHypersurfaces</a> (<a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> <a class="el" href="group__hypersurface.html#gadc5c6c7aeab32d4d2d80425c9f8ad108">coords</a>, <a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a> <a class="el" href="group__hypersurface.html#gaebbdf01911361353b206a761af4ffa17">which</a>, <a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a> <a class="el" href="group__hypersurface.html#gae01cd9910600cf3f0dc578f00faf37c2">algorithm</a>)</td></tr>
<tr class="memdesc:ga53a29135ae00e910d9a00f2920bc4139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal hypersurfaces with the given parameters.  <a href="group__hypersurface.html#ga53a29135ae00e910d9a00f2920bc4139">More...</a><br /></td></tr>
<tr class="separator:ga53a29135ae00e910d9a00f2920bc4139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfc6c679ae7ab07f4cd4953ae5c4efe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gafbfc6c679ae7ab07f4cd4953ae5c4efe">regina::NormalHypersurfaces::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gafbfc6c679ae7ab07f4cd4953ae5c4efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__hypersurface.html#gafbfc6c679ae7ab07f4cd4953ae5c4efe">More...</a><br /></td></tr>
<tr class="separator:gafbfc6c679ae7ab07f4cd4953ae5c4efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d6b7be21b48e6ed50652634a85fcac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf3d6b7be21b48e6ed50652634a85fcac">regina::NormalHypersurfaces::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf3d6b7be21b48e6ed50652634a85fcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__hypersurface.html#gaf3d6b7be21b48e6ed50652634a85fcac">More...</a><br /></td></tr>
<tr class="separator:gaf3d6b7be21b48e6ed50652634a85fcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab306ea0e6172fd68400a8d4264113e5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gab306ea0e6172fd68400a8d4264113e5f">regina::NormalHypersurfaces::HypersurfaceInserter::HypersurfaceInserter</a> (<a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;list, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *owner)</td></tr>
<tr class="memdesc:gab306ea0e6172fd68400a8d4264113e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator.  <a href="group__hypersurface.html#gab306ea0e6172fd68400a8d4264113e5f">More...</a><br /></td></tr>
<tr class="separator:gab306ea0e6172fd68400a8d4264113e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8c0af7a8f1225cbafc29f30c2c4516"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga4d8c0af7a8f1225cbafc29f30c2c4516">regina::NormalHypersurfaces::HypersurfaceInserter::HypersurfaceInserter</a> (const <a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga4d8c0af7a8f1225cbafc29f30c2c4516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator that is a clone of the given iterator.  <a href="group__hypersurface.html#ga4d8c0af7a8f1225cbafc29f30c2c4516">More...</a><br /></td></tr>
<tr class="separator:ga4d8c0af7a8f1225cbafc29f30c2c4516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48aab5267a8b085ca4118cb950c17877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga48aab5267a8b085ca4118cb950c17877">regina::NormalHypersurfaces::HypersurfaceInserter::operator=</a> (const <a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga48aab5267a8b085ca4118cb950c17877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this iterator to be a clone of the given output iterator.  <a href="group__hypersurface.html#ga48aab5267a8b085ca4118cb950c17877">More...</a><br /></td></tr>
<tr class="separator:ga48aab5267a8b085ca4118cb950c17877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a48c2586b4f3c292587376b0957cb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6a48c2586b4f3c292587376b0957cb1b">regina::NormalHypersurfaces::HypersurfaceInserter::operator=</a> (<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *<a class="el" href="group__hypersurface.html#gad51f4b521a02d12804d77fb765b2293c">hypersurface</a>)</td></tr>
<tr class="memdesc:ga6a48c2586b4f3c292587376b0957cb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a normal hypersurface to the end of the appropriate surface list.  <a href="group__hypersurface.html#ga6a48c2586b4f3c292587376b0957cb1b">More...</a><br /></td></tr>
<tr class="separator:ga6a48c2586b4f3c292587376b0957cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad83edd71c616f208376bd792e130d9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad83edd71c616f208376bd792e130d9e2">regina::NormalHypersurfaces::HypersurfaceInserter::operator=</a> (<a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *vector)</td></tr>
<tr class="memdesc:gad83edd71c616f208376bd792e130d9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the normal hypersurface corresponding to the given vector to the end of the appropriate hypersurface list.  <a href="group__hypersurface.html#gad83edd71c616f208376bd792e130d9e2">More...</a><br /></td></tr>
<tr class="separator:gad83edd71c616f208376bd792e130d9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65d2067c59a9368bb35297cfb104bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaf65d2067c59a9368bb35297cfb104bbc">regina::NormalHypersurfaces::HypersurfaceInserter::operator*</a> ()</td></tr>
<tr class="memdesc:gaf65d2067c59a9368bb35297cfb104bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__hypersurface.html#gaf65d2067c59a9368bb35297cfb104bbc">More...</a><br /></td></tr>
<tr class="separator:gaf65d2067c59a9368bb35297cfb104bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1708e6be05af78130a480957d39fc62a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga1708e6be05af78130a480957d39fc62a">regina::NormalHypersurfaces::HypersurfaceInserter::operator++</a> ()</td></tr>
<tr class="memdesc:ga1708e6be05af78130a480957d39fc62a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__hypersurface.html#ga1708e6be05af78130a480957d39fc62a">More...</a><br /></td></tr>
<tr class="separator:ga1708e6be05af78130a480957d39fc62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e0934e76f93e2a252f600dccae0f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga71e0934e76f93e2a252f600dccae0f8d">regina::NormalHypersurfaces::HypersurfaceInserter::operator++</a> (int)</td></tr>
<tr class="memdesc:ga71e0934e76f93e2a252f600dccae0f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__hypersurface.html#ga71e0934e76f93e2a252f600dccae0f8d">More...</a><br /></td></tr>
<tr class="separator:ga71e0934e76f93e2a252f600dccae0f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd764c0b44735b99a87dd27e2371361"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5bd764c0b44735b99a87dd27e2371361">regina::NormalHypersurfaces::Enumerator::Enumerator</a> (<a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *list, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang, <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *eqns, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker)</td></tr>
<tr class="memdesc:ga5bd764c0b44735b99a87dd27e2371361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new functor with the given parameters.  <a href="group__hypersurface.html#ga5bd764c0b44735b99a87dd27e2371361">More...</a><br /></td></tr>
<tr class="separator:ga5bd764c0b44735b99a87dd27e2371361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43639fecde3f509f274378e8bd1f02cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga43639fecde3f509f274378e8bd1f02cd">regina::NormalHypersurfaces::Enumerator::Enumerator</a> (Enumerator &amp;&amp;)=default</td></tr>
<tr class="memdesc:ga43639fecde3f509f274378e8bd1f02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <a href="group__hypersurface.html#ga43639fecde3f509f274378e8bd1f02cd">More...</a><br /></td></tr>
<tr class="separator:ga43639fecde3f509f274378e8bd1f02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bd3a147e314ced51594f689f2859eb"><td class="memTemplParams" colspan="2">template&lt;typename Coords &gt; </td></tr>
<tr class="memitem:ga33bd3a147e314ced51594f689f2859eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga33bd3a147e314ced51594f689f2859eb">regina::NormalHypersurfaces::Enumerator::operator()</a> ()</td></tr>
<tr class="memdesc:ga33bd3a147e314ced51594f689f2859eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the real enumeration work, in a setting where the underlying coordinate system is a compile-time constant.  <a href="group__hypersurface.html#ga33bd3a147e314ced51594f689f2859eb">More...</a><br /></td></tr>
<tr class="separator:ga33bd3a147e314ced51594f689f2859eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c1bf121044eaa1d5dfa738975c1be6"><td class="memItemLeft" align="right" valign="top"><a id="ga47c1bf121044eaa1d5dfa738975c1be6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaces::Enumerator::Enumerator</b> (const Enumerator &amp;)=delete</td></tr>
<tr class="separator:ga47c1bf121044eaa1d5dfa738975c1be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26538c6f50214a0dfe2a8f2ce539a481"><td class="memItemLeft" align="right" valign="top"><a id="ga26538c6f50214a0dfe2a8f2ce539a481"></a>
Enumerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaces::Enumerator::operator=</b> (const Enumerator &amp;)=delete</td></tr>
<tr class="separator:ga26538c6f50214a0dfe2a8f2ce539a481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062b6a0fcecd8d05a2193bb98feb8b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29">regina::makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords)</td></tr>
<tr class="memdesc:ga062b6a0fcecd8d05a2193bb98feb8b29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and the given coordinate system.  <a href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29">More...</a><br /></td></tr>
<tr class="separator:ga062b6a0fcecd8d05a2193bb98feb8b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e06572d451bb5cb70b1fa4c165c2f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9">regina::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords)</td></tr>
<tr class="memdesc:ga26e06572d451bb5cb70b1fa4c165c2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal hypersurface matching equations for the given triangulation using the given coordinate system.  <a href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9">More...</a><br /></td></tr>
<tr class="separator:ga26e06572d451bb5cb70b1fa4c165c2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7b9248e89cb91e6aa507a9586ae467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6d7b9248e89cb91e6aa507a9586ae467">regina::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triangulation, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords)</td></tr>
<tr class="memdesc:ga6d7b9248e89cb91e6aa507a9586ae467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded.  <a href="group__hypersurface.html#ga6d7b9248e89cb91e6aa507a9586ae467">More...</a><br /></td></tr>
<tr class="separator:ga6d7b9248e89cb91e6aa507a9586ae467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7201b3eb31aa6f2929d39251a2b96da0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga7201b3eb31aa6f2929d39251a2b96da0">regina::XMLNormalHypersurfaceReader::XMLNormalHypersurfaceReader</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *tri, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coords)</td></tr>
<tr class="memdesc:ga7201b3eb31aa6f2929d39251a2b96da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface reader.  <a href="group__hypersurface.html#ga7201b3eb31aa6f2929d39251a2b96da0">More...</a><br /></td></tr>
<tr class="separator:ga7201b3eb31aa6f2929d39251a2b96da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bc92a93d77a9d308e83c932cfe139e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga63bc92a93d77a9d308e83c932cfe139e">regina::XMLNormalHypersurfaceReader::hypersurface</a> ()</td></tr>
<tr class="memdesc:ga63bc92a93d77a9d308e83c932cfe139e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the normal hypersurface that has been read.  <a href="group__hypersurface.html#ga63bc92a93d77a9d308e83c932cfe139e">More...</a><br /></td></tr>
<tr class="separator:ga63bc92a93d77a9d308e83c932cfe139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e6d5d88264762b313339cf2860d63f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga03e6d5d88264762b313339cf2860d63f">regina::XMLNormalHypersurfaceReader::startElement</a> (const std::string &amp;tagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;tagProps, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *parentReader) override</td></tr>
<tr class="memdesc:ga03e6d5d88264762b313339cf2860d63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__hypersurface.html#ga03e6d5d88264762b313339cf2860d63f">More...</a><br /></td></tr>
<tr class="separator:ga03e6d5d88264762b313339cf2860d63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ada6c4377d58a47a1c514af6c3ded5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga75ada6c4377d58a47a1c514af6c3ded5">regina::XMLNormalHypersurfaceReader::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:ga75ada6c4377d58a47a1c514af6c3ded5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__hypersurface.html#ga75ada6c4377d58a47a1c514af6c3ded5">More...</a><br /></td></tr>
<tr class="separator:ga75ada6c4377d58a47a1c514af6c3ded5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5832475bc2c7c521cb34607a150eb7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga9b5832475bc2c7c521cb34607a150eb7">regina::XMLNormalHypersurfaceReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga9b5832475bc2c7c521cb34607a150eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__hypersurface.html#ga9b5832475bc2c7c521cb34607a150eb7">More...</a><br /></td></tr>
<tr class="separator:ga9b5832475bc2c7c521cb34607a150eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee13ba60fcdcad2f036d7e9faae78c29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gaee13ba60fcdcad2f036d7e9faae78c29">regina::XMLNormalHypersurfacesReader::XMLNormalHypersurfacesReader</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *tri, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:gaee13ba60fcdcad2f036d7e9faae78c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface list reader.  <a href="group__hypersurface.html#gaee13ba60fcdcad2f036d7e9faae78c29">More...</a><br /></td></tr>
<tr class="separator:gaee13ba60fcdcad2f036d7e9faae78c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a4a84abd95fcb6b3dd4f8e168e61a23"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga9a4a84abd95fcb6b3dd4f8e168e61a23">regina::XMLNormalHypersurfacesReader::packet</a> () override</td></tr>
<tr class="memdesc:ga9a4a84abd95fcb6b3dd4f8e168e61a23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__hypersurface.html#ga9a4a84abd95fcb6b3dd4f8e168e61a23">More...</a><br /></td></tr>
<tr class="separator:ga9a4a84abd95fcb6b3dd4f8e168e61a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1426c1a6e47bc103b23974d6fe014e6a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga1426c1a6e47bc103b23974d6fe014e6a">regina::XMLNormalHypersurfacesReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga1426c1a6e47bc103b23974d6fe014e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__hypersurface.html#ga1426c1a6e47bc103b23974d6fe014e6a">More...</a><br /></td></tr>
<tr class="separator:ga1426c1a6e47bc103b23974d6fe014e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621bfbebd403377d6fe78bdb4df2cfa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga621bfbebd403377d6fe78bdb4df2cfa5">regina::XMLNormalHypersurfacesReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga621bfbebd403377d6fe78bdb4df2cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__hypersurface.html#ga621bfbebd403377d6fe78bdb4df2cfa5">More...</a><br /></td></tr>
<tr class="separator:ga621bfbebd403377d6fe78bdb4df2cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga08e1b5afcd3630b9ec7fd7244d53776c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga08e1b5afcd3630b9ec7fd7244d53776c">regina::NormalHypersurfaceVector::coords_</a></td></tr>
<tr class="memdesc:ga08e1b5afcd3630b9ec7fd7244d53776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="group__hypersurface.html#ga08e1b5afcd3630b9ec7fd7244d53776c">More...</a><br /></td></tr>
<tr class="separator:ga08e1b5afcd3630b9ec7fd7244d53776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01107fe9e58d09cc33d78ad93514050a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga01107fe9e58d09cc33d78ad93514050a">regina::NormalHypersurface::vector_</a></td></tr>
<tr class="memdesc:ga01107fe9e58d09cc33d78ad93514050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal hypersurface in whichever space is appropriate.  <a href="group__hypersurface.html#ga01107fe9e58d09cc33d78ad93514050a">More...</a><br /></td></tr>
<tr class="separator:ga01107fe9e58d09cc33d78ad93514050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5966bebd6637e22c5fb8653591de238c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga5966bebd6637e22c5fb8653591de238c">regina::NormalHypersurface::triangulation_</a></td></tr>
<tr class="memdesc:ga5966bebd6637e22c5fb8653591de238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal hypersurface resides.  <a href="group__hypersurface.html#ga5966bebd6637e22c5fb8653591de238c">More...</a><br /></td></tr>
<tr class="separator:ga5966bebd6637e22c5fb8653591de238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935b0370203eda2d9b07e3c751d81e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga935b0370203eda2d9b07e3c751d81e76">regina::NormalHypersurface::name_</a></td></tr>
<tr class="memdesc:ga935b0370203eda2d9b07e3c751d81e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this hypersurface.  <a href="group__hypersurface.html#ga935b0370203eda2d9b07e3c751d81e76">More...</a><br /></td></tr>
<tr class="separator:ga935b0370203eda2d9b07e3c751d81e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad153c38c524603a35d400fb88f291662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad153c38c524603a35d400fb88f291662">regina::NormalHypersurface::orientable_</a></td></tr>
<tr class="memdesc:gad153c38c524603a35d400fb88f291662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface orientable?  <a href="group__hypersurface.html#gad153c38c524603a35d400fb88f291662">More...</a><br /></td></tr>
<tr class="separator:gad153c38c524603a35d400fb88f291662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029a5069b2bfc0c1f9ac64ee9510d995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga029a5069b2bfc0c1f9ac64ee9510d995">regina::NormalHypersurface::twoSided_</a></td></tr>
<tr class="memdesc:ga029a5069b2bfc0c1f9ac64ee9510d995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface two-sided?  <a href="group__hypersurface.html#ga029a5069b2bfc0c1f9ac64ee9510d995">More...</a><br /></td></tr>
<tr class="separator:ga029a5069b2bfc0c1f9ac64ee9510d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12d8548519c825d124d291c1e46db93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gad12d8548519c825d124d291c1e46db93">regina::NormalHypersurface::connected_</a></td></tr>
<tr class="memdesc:gad12d8548519c825d124d291c1e46db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface connected?  <a href="group__hypersurface.html#gad12d8548519c825d124d291c1e46db93">More...</a><br /></td></tr>
<tr class="separator:gad12d8548519c825d124d291c1e46db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga4bf48595823bea5cd7e1c2bd2bf3e0a1">regina::NormalHypersurface::realBoundary_</a></td></tr>
<tr class="memdesc:ga4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this hypersurface have real boundary (i.e.  <a href="group__hypersurface.html#ga4bf48595823bea5cd7e1c2bd2bf3e0a1">More...</a><br /></td></tr>
<tr class="separator:ga4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f5cb305ce9f0254556667efdb9461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga3e6f5cb305ce9f0254556667efdb9461">regina::NormalHypersurface::compact_</a></td></tr>
<tr class="memdesc:ga3e6f5cb305ce9f0254556667efdb9461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface compact (i.e., does it only contain finitely many pieces)?  <a href="group__hypersurface.html#ga3e6f5cb305ce9f0254556667efdb9461">More...</a><br /></td></tr>
<tr class="separator:ga3e6f5cb305ce9f0254556667efdb9461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf666c3a10d4f971c9e01457a0f2cd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#gabf666c3a10d4f971c9e01457a0f2cd60">regina::NormalHypersurface::H1_</a></td></tr>
<tr class="memdesc:gabf666c3a10d4f971c9e01457a0f2cd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">First homology group of the hypersurface.  <a href="group__hypersurface.html#gabf666c3a10d4f971c9e01457a0f2cd60">More...</a><br /></td></tr>
<tr class="separator:gabf666c3a10d4f971c9e01457a0f2cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fd9da4ee4093e95d6f502babf89736"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga44fd9da4ee4093e95d6f502babf89736">regina::NormalHypersurfaces::surfaces_</a></td></tr>
<tr class="memdesc:ga44fd9da4ee4093e95d6f502babf89736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the normal hypersurfaces stored in this packet.  <a href="group__hypersurface.html#ga44fd9da4ee4093e95d6f502babf89736">More...</a><br /></td></tr>
<tr class="separator:ga44fd9da4ee4093e95d6f502babf89736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga6c9ba4d21f39dc2340ea896f9b5e65b1">regina::NormalHypersurfaces::coords_</a></td></tr>
<tr class="memdesc:ga6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores which coordinate system is being used by the normal hypersurfaces in this packet.  <a href="group__hypersurface.html#ga6c9ba4d21f39dc2340ea896f9b5e65b1">More...</a><br /></td></tr>
<tr class="separator:ga6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0441ca3f6753979a988d5f392e2687aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga0441ca3f6753979a988d5f392e2687aa">regina::NormalHypersurfaces::which_</a></td></tr>
<tr class="memdesc:ga0441ca3f6753979a988d5f392e2687aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normal hypersurfaces these represent within the underlying triangulation.  <a href="group__hypersurface.html#ga0441ca3f6753979a988d5f392e2687aa">More...</a><br /></td></tr>
<tr class="separator:ga0441ca3f6753979a988d5f392e2687aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b995dbbf568ef31acb23cb86e512ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga2b995dbbf568ef31acb23cb86e512ea9">regina::NormalHypersurfaces::algorithm_</a></td></tr>
<tr class="memdesc:ga2b995dbbf568ef31acb23cb86e512ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the details of the enumeration algorithm that was used to generate this list.  <a href="group__hypersurface.html#ga2b995dbbf568ef31acb23cb86e512ea9">More...</a><br /></td></tr>
<tr class="separator:ga2b995dbbf568ef31acb23cb86e512ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14526a3ab2de4f6db4e9ee80f29c26ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga14526a3ab2de4f6db4e9ee80f29c26ed">regina::NormalHypersurfaces::HypersurfaceInserter::list_</a></td></tr>
<tr class="memdesc:ga14526a3ab2de4f6db4e9ee80f29c26ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list into which hypersurfaces will be inserted.  <a href="group__hypersurface.html#ga14526a3ab2de4f6db4e9ee80f29c26ed">More...</a><br /></td></tr>
<tr class="separator:ga14526a3ab2de4f6db4e9ee80f29c26ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30459edc14c11806219fa3bfb960d2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hypersurface.html#ga30459edc14c11806219fa3bfb960d2ae">regina::NormalHypersurfaces::HypersurfaceInserter::owner_</a></td></tr>
<tr class="memdesc:ga30459edc14c11806219fa3bfb960d2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which the hypersurfaces to be inserted are contained.  <a href="group__hypersurface.html#ga30459edc14c11806219fa3bfb960d2ae">More...</a><br /></td></tr>
<tr class="separator:ga30459edc14c11806219fa3bfb960d2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gaad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memItemLeft" align="right" valign="top"><a id="gaad51ed54e8b4d8d41dfdfa82496be1ee"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurface::XMLNormalHypersurfaceReader</b></td></tr>
<tr class="separator:gaad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aff27f23f48df39cb2ae7440fdb1d2e"><td class="memItemLeft" align="right" valign="top"><a id="ga6aff27f23f48df39cb2ae7440fdb1d2e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaces::VectorIterator::NormalHypersurfaces</b></td></tr>
<tr class="separator:ga6aff27f23f48df39cb2ae7440fdb1d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82843fd0e0d3899ab41dedd2346a44a1"><td class="memItemLeft" align="right" valign="top"><a id="ga82843fd0e0d3899ab41dedd2346a44a1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalHypersurfaces::XMLNormalHypersurfacesReader</b></td></tr>
<tr class="separator:ga82843fd0e0d3899ab41dedd2346a44a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Normal hypersurfaces in 4-manifold triangulations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7ac059871f52044cf4da2e74081d04f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac059871f52044cf4da2e74081d04f2">&#9670;&nbsp;</a></span>REGINA_NORMAL_HYPERSURFACE_FLAVOUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_NORMAL_HYPERSURFACE_FLAVOUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">superclass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        typedef HyperInfo&lt;id&gt; Info; \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coordsID = id; \</div>
<div class="line">        inline class_(<span class="keyword">const</span> class_&amp; cloneMe) : \</div>
<div class="line">                superclass(cloneMe.coords()) {} \</div>
<div class="line">        inline <span class="keyword">virtual</span> NormalHypersurfaceVector* clone()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return <span class="keyword">new</span> class_(*<span class="keyword">this</span>); \</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__hypersurface_html_ga57526727019e919f8b9c3858318d2350"><div class="ttname"><a href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">regina::HyperCoords</a></div><div class="ttdeci">HyperCoords</div><div class="ttdoc">Represents different coordinate systems that can be used for enumerating and displaying normal hypers...</div><div class="ttdef"><b>Definition:</b> hypercoords.h:60</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of NormalHypersurfaceVector. </p>
<p>Every subclass of NormalHypersurfaceVector <em>must</em> include REGINA_NORMAL_HYPERSURFACE_FLAVOUR at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time enum constant <em>coordsID</em>, which is equal to the corresponding HyperCoords constant;</li>
<li>a typedef <em>Info</em>, which refers to the corresponding specialisation of the HyperInfo&lt;&gt; tempate;</li>
<li>a copy constructor that takes a vector of the same subclass;</li>
<li>declarations and implementations of the virtual function NormalHypersurfaceVector::clone().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this subclass of NormalHypersurfaceVector. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding NNormalCoords constant. </td></tr>
    <tr><td class="paramname">superclass</td><td>the vector class from which <em>class_</em> is derived. This is typically NormalHypersurfaceVector, though in some cases (e.g., prism coordinates) it may be different. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad8c09d9f6738b5a29b8ae4cc46c7d3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">&#9670;&nbsp;</a></span>HyperAlg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a>&gt; <a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">regina::HyperAlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python</dt><dd>This is present, and all values in the HyperAlgFlags enumeration type are treated as members of this HyperAlg class. </dd></dl>

</div>
</div>
<a id="gac49a56378f69241c425c3345b7d6ddf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac49a56378f69241c425c3345b7d6ddf4">&#9670;&nbsp;</a></span>HyperList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a>&gt; <a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">regina::HyperList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal hypersurface lists. </p>
<dl class="section user"><dt>Python</dt><dd>This is present, and all values in the HyperListFlags enumeration type are treated as members of this HyperList class. </dd></dl>

</div>
</div>
<a id="gaf20e731915f0691913bc317c0b73eab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20e731915f0691913bc317c0b73eab8">&#9670;&nbsp;</a></span>MatrixInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>, true &gt; <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">regina::MatrixInt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of arbitrary-precision integers. </p>
<p>This is the most common class used by Regina when running algebraic algorithms over integer matrices. Since the underlying type is Regina's Integer class, calculations will be exact regardless of how large the integers become. </p>

</div>
</div>
<a id="gaa65af5bc46550f786ce94642a658e48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa65af5bc46550f786ce94642a658e48a">&#9670;&nbsp;</a></span>NNormalHypersurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> <a class="el" href="group__hypersurface.html#gaa65af5bc46550f786ce94642a658e48a">regina::NNormalHypersurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>The class NNormalHypersurface has now been renamed to <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a>. </dd></dl>

</div>
</div>
<a id="ga5bfb3415de96221074b6cb26335ed1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bfb3415de96221074b6cb26335ed1af">&#9670;&nbsp;</a></span>NNormalHypersurfaceList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> <a class="el" href="group__hypersurface.html#ga5bfb3415de96221074b6cb26335ed1af">regina::NNormalHypersurfaceList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>The class NNormalHypersurfaceList has now been renamed to <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </dd></dl>

</div>
</div>
<a id="gae344b29cc907891828ec3f065b5deb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae344b29cc907891828ec3f065b5deb40">&#9670;&nbsp;</a></span>NNormalHypersurfaceVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> <a class="el" href="group__hypersurface.html#gae344b29cc907891828ec3f065b5deb40">regina::NNormalHypersurfaceVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>The class NNormalHypersurfaceVector has now been renamed to <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>. </dd></dl>

</div>
</div>
<a id="ga94aeb45ac06210cdb49a8a8ba97b0573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94aeb45ac06210cdb49a8a8ba97b0573">&#9670;&nbsp;</a></span>NNormalHypersurfaceVectorStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HSVectorStandard.html">HSVectorStandard</a> <a class="el" href="group__hypersurface.html#ga94aeb45ac06210cdb49a8a8ba97b0573">regina::NNormalHypersurfaceVectorStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>The class NNormalHypersurfaceVectorStandard has now been renamed to <a class="el" href="classregina_1_1HSVectorStandard.html" title="A normal hypersurface vector using standard tetrahedron-prism coordinates.">HSVectorStandard</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaaecd2a8d25ac496722f2d8d56ceced5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaecd2a8d25ac496722f2d8d56ceced5d">&#9670;&nbsp;</a></span>HyperAlgFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">regina::HyperAlgFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents options and variants of algorithms for enumerating various types of normal hypersurfaces in 4-manifold triangulations. </p>
<p>These options are typically combined in a bitwise fashion using the HyperAlg type, and then passed to enumeration routines such as <a class="el" href="group__hypersurface.html#ga84e4d8fbac7f933401e084190c468190" title="A unified routine for enumerating various classes of normal hypersurfaces within a given triangulatio...">NormalHypersurfaces::enumerate()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>The values in this enumeration type are present, but they are treated by Python as HyperList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2"></a>HS_ALG_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5da436d0542be438b0cfe832d0a0d320fda"></a>HS_VERTEX_DD&#160;</td><td class="fielddoc"><p>When enumerating vertex normal hypersurfaces, this flag indicates that a modified double description method should be used. </p>
<p>This algorithm can suffer from a combinatorial explosion with larger problems, leading to extremely large time and memory footprints. Users should only request this if they have some specialised need.</p>
<p>Having said that: this is the only algorithm that Regina currently supports for 4-dimensional vertex enumeration (unlike the 3-dimensional case, where several alternative algorithms are available). Therefore Regina will use the double description method regardless. Alternative algorithms will be implemented in future versions of Regina.</p>
<p>For details on the modified double description method, see B. A. Burton, "Optimizing the double description method for
normal surface enumeration", Mathematics of Computation 79 (2010), pp. 453-484. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5dacdb7d45eea9f47cd8f70835b8d5a843a"></a>HS_HILBERT_PRIMAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal hypersurfaces, this flag indicates that the primal method should be used for enumerating a Hilbert basis. </p>
<p>The primal method is recommended, and enumeration algorithms will use it if possible unless a different method is explicitly requested. This method uses code from Normaliz for parts of its processing.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with HS_HILBERT_DUAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5dac07e79838db18565d610b06066793700"></a>HS_HILBERT_DUAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal hypersurfaces, this flag indicates that the dual method should be used for enumerating a Hilbert basis. </p>
<p>The dual method is fast (like the primal method), but its performance is highly variable; for this reason the primal method is recommended instead. This method does not make use of Normaliz, and is the recommended method for situations in which Normaliz is not available for some reason.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with HS_HILBERT_PRIMAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5daa40403c71c93f04fc8d6c0ce242188b3"></a>HS_ALG_LEGACY&#160;</td><td class="fielddoc"><p>Indicates that a normal hypersurface list was enumerated using an older prerelease version of the 4-manifolds code (prior to Regina 5.0). </p>
<p>These prerelease versions did not retain details of the algorithm used to build each list, and so in such cases no further algorithmic information is available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaecd2a8d25ac496722f2d8d56ceced5da2c1c6e8b73b7a8087958d04f607d0f39"></a>HS_ALG_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates that a normal hypersurface list was built using a customised algorithm. </p>
<p>In such cases, no further details on the algorithm are available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga57526727019e919f8b9c3858318d2350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57526727019e919f8b9c3858318d2350">&#9670;&nbsp;</a></span>HyperCoords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">regina::HyperCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different coordinate systems that can be used for enumerating and displaying normal hypersurface within 4-manifold triangulations. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own coordinate system, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga57526727019e919f8b9c3858318d2350a0fddbcfd51d4cd1dd59e39c0a93601b8"></a>HS_STANDARD&#160;</td><td class="fielddoc"><p>Represents standard tetrahedron-prism coordinates for normal hypersurfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57526727019e919f8b9c3858318d2350ab9c4a4c7c61f149f7fa0ec0c6b0c7695"></a>HS_PRISM&#160;</td><td class="fielddoc"><p>Represents prism coordinates for normal hypersurfaces. </p>
<p>For now, this coordinate system is for representation only; hypersurface vectors and lists cannot be created in this coordinate system. This will likely change in a future release of Regina, when prism coordinates will be supported for creation as well as viewing. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57526727019e919f8b9c3858318d2350a20231b069d7350f6da4840f48163efe1"></a>HS_EDGE_WEIGHT&#160;</td><td class="fielddoc"><p>Represents edge weight coordinates for normal hypersurfaces. </p>
<p>This coordinate system is for representation only; hypersurface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3504d968f57efcd4379122ce3e37404d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3504d968f57efcd4379122ce3e37404d">&#9670;&nbsp;</a></span>HyperListFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">regina::HyperListFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different lists of normal hypersurfaces that might be constructed for a given 4-manifold triangulation. </p>
<p>The HyperList enumeration refers to the <em>contents</em> of the list, whereas the HyperAlgFlags enumeration refers to the <em>algorithm</em> used to build it.</p>
<dl class="section user"><dt>Python</dt><dd>The values in this enumeration type are present, but they are treated by Python as HyperList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c"></a>HS_LIST_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404da2e89c96e434f11dfdf829b9512af3b5b"></a>HS_EMBEDDED_ONLY&#160;</td><td class="fielddoc"><p>Indicates that this list is restricted to properly embedded hypersurfaces only. </p>
<p>This flag is incompatible with HS_IMMERSED_SINGULAR. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404da052965a4cf0ccdf6cacfe8488e57d0b9"></a>HS_IMMERSED_SINGULAR&#160;</td><td class="fielddoc"><p>Indicates that the scope of this list includes not just properly embedded hypersurfaces, but also immersed and/or branched hypersurfaces. </p>
<p>This is no guarantee that the list <em>contains</em> immersed and/or branched hypersurfaces; it merely states that such hypersurfaces have not been explicitly excluded (in particular, the prism constraints have not been enforced).</p>
<p>This flag is incompatible with HS_EMBEDDED_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404dad37cf8bc509f58f8fe68374dd839f781"></a>HS_VERTEX&#160;</td><td class="fielddoc"><p>Indicates a list of all vertex normal hypersurfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with HS_FUNDAMENTAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404dabc9d522f05ebbb6a772df9bed2894529"></a>HS_FUNDAMENTAL&#160;</td><td class="fielddoc"><p>Indicates a list of all fundamental normal hypersurfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with HS_VERTEX. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404dac6f3050e7490163a92986fc0d7c5161b"></a>HS_LEGACY&#160;</td><td class="fielddoc"><p>Indicates a list that was constructed using an older prerelease version of the 4-manifolds code (prior to Regina 5.0). </p>
<p>These prerelease versions did not retain details of how each list was constructed, beyond whether immersed and/or singular hypersurfaces were included. Therefore no information is available for such lists, other than the presence or absence of the HS_EMBEDDED_ONLY and/or HS_IMMERSED_SINGULAR flags.</p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3504d968f57efcd4379122ce3e37404da8728e78556178e9d4048b5b43667492b"></a>HS_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates some other type of list, typically hand-crafted by the user or built by some customised algorithm. </p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae01cd9910600cf3f0dc578f00faf37c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01cd9910600cf3f0dc578f00faf37c2">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a> regina::NormalHypersurfaces::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list. </p>
<p>These may not be the same HyperAlg flags that were passed to <a class="el" href="group__hypersurface.html#ga84e4d8fbac7f933401e084190c468190" title="A unified routine for enumerating various classes of normal hypersurfaces within a given triangulatio...">enumerate()</a>. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="gacefed5920d1b387e5d3b0f35b390ebec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacefed5920d1b387e5d3b0f35b390ebec">&#9670;&nbsp;</a></span>beginVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::beginVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for hypersurfaces in this list, pointing to the beginning of this hypersurface list. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this hypersurface list. </dd></dl>

</div>
</div>
<a id="ga5ec9e195140fae7cba07e963d6728247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec9e195140fae7cba07e963d6728247">&#9670;&nbsp;</a></span>calculateFromTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::calculateFromTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and store all properties that we derive from the 3-manifold triangulation of this hypersurface. </p>

</div>
</div>
<a id="ga6ff4ad53a1dd99505b076481d7646926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff4ad53a1dd99505b076481d7646926">&#9670;&nbsp;</a></span>calculateRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::calculateRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this hypersurface has any real boundary and stores the result as a property. </p>

</div>
</div>
<a id="ga98fdd9c300f021efe29514d23c2e0179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98fdd9c300f021efe29514d23c2e0179">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>* regina::NormalHypersurface::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this normal hypersurface. </p>
<p>The name of the normal hypersurface will <em>not</em> be copied to the clone; instead the clone will have an empty name.</p>
<dl class="section return"><dt>Returns</dt><dd>a clone of this normal hypersurface. </dd></dl>

</div>
</div>
<a id="ga470f49e212ea52daeb876f0befd5338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470f49e212ea52daeb876f0befd5338a">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::NormalHypersurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="ga2ccc8e495f977c5d2d8ae949ac420673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ccc8e495f977c5d2d8ae949ac420673">&#9670;&nbsp;</a></span>coords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalHypersurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="gadc5c6c7aeab32d4d2d80425c9f8ad108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc5c6c7aeab32d4d2d80425c9f8ad108">&#9670;&nbsp;</a></span>coords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> regina::NormalHypersurfaces::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the hypersurfaces stored in this set. </p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system used. </dd></dl>

</div>
</div>
<a id="ga2ea7b0d48ce30206f27014acbca16a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea7b0d48ce30206f27014acbca16a3f">&#9670;&nbsp;</a></span>countCoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurface::countCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="ga56057aabcc51c84ea924dd68f2e1326a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56057aabcc51c84ea924dd68f2e1326a">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga854c8e7092542bc6f68a77c56aef547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854c8e7092542bc6f68a77c56aef547a">&#9670;&nbsp;</a></span>doubleHypersurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>* regina::NormalHypersurface::doubleHypersurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated hypersurface that is the double of this hypersurface. </p>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal hypersurface. </dd></dl>

</div>
</div>
<a id="gae0661d930754b6c681e6a23595a36476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0661d930754b6c681e6a23595a36476">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;4&gt;::countEdges()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

</div>
</div>
<a id="gaa1957334b91441cd0c21c3da25c105c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1957334b91441cd0c21c3da25c105c8">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurfaceVector::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<p>See <a class="el" href="group__hypersurface.html#gae0661d930754b6c681e6a23595a36476" title="Returns the number of times this normal hypersurface crosses the given edge.">NormalHypersurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;4&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

<p>Implemented in <a class="el" href="group__hypersurface.html#ga8360d22d501c9c135decdd73708c00bd">regina::HSVectorStandard</a>.</p>

</div>
</div>
<a id="ga8360d22d501c9c135decdd73708c00bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8360d22d501c9c135decdd73708c00bd">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<p>See <a class="el" href="group__hypersurface.html#gae0661d930754b6c681e6a23595a36476" title="Returns the number of times this normal hypersurface crosses the given edge.">NormalHypersurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;4&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="group__hypersurface.html#gaa1957334b91441cd0c21c3da25c105c8">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<a id="gafe4f6c59a84e0cd88f91802d0524497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe4f6c59a84e0cd88f91802d0524497b">&#9670;&nbsp;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::embedded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this hypersurface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting prism types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is embedded. </dd></dl>

</div>
</div>
<a id="ga621bfbebd403377d6fe78bdb4df2cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621bfbebd403377d6fe78bdb4df2cfa5">&#9670;&nbsp;</a></span>endContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalHypersurfacesReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__hypersurface.html#ga1426c1a6e47bc103b23974d6fe014e6a" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga48d5da33f4ac4f4a2ed4296a4a0395b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d5da33f4ac4f4a2ed4296a4a0395b5">&#9670;&nbsp;</a></span>endVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::endVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for hypersurfaces in this list, pointing past the end of this hypersurface list. </p>
<p>This iterator is not dereferenceable.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator past the end of this hypersurface list. </dd></dl>

</div>
</div>
<a id="ga84e4d8fbac7f933401e084190c468190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e4d8fbac7f933401e084190c468190">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>* regina::NormalHypersurfaces::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a>&#160;</td>
          <td class="paramname"><em>which</em> = <code><a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c">HS_LIST_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2">HS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified routine for enumerating various classes of normal hypersurfaces within a given triangulation. </p>
<p>The HyperCoords argument allows you to specify an underlying coordinate system.</p>
<p>The HyperList argument is a combination of flags that allows you to specify exactly which normal hypersurfaces you require. This includes (i) whether you want all vertex hypersurfaces or all fundamental hypersurfaces, which defaults to HS_VERTEX if you specify neither or both; and (ii) whether you want only properly embedded surfaces or you also wish to include immersed and/or singular surfaces, which defaults to HS_EMBEDDED_ONLY if you specify neither or both.</p>
<p>The HyperAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default HS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p>The enumerated hypersurfaces will be stored in a new normal hypersurface list, and their representations will be scaled down to use the smallest possible integer coordinates. This normal hypersurface list will be inserted into the packet tree as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this normal hypersurface list, and must not change while this normal hypersurface list remains in existence.</p>
<p>If a progress tracker is passed, the normal hypersurface enumeration will take place in a new thread and this routine will return immediately. If the user cancels the operation from another thread, then the normal surface list will <em>not</em> be inserted into the packet tree (but the caller of this routine will still need to delete it). Regarding progress tracking, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p>If no progress tracker is passed, the enumeration will run in the current thread and this routine will return only when the enumeration is complete. Note that this enumeration can be extremely slow for larger triangulations.</p>
<p>If an error occurs, then this routine will return <code>null</code>, no normal hypersurface list will be created, and the progress tracker (if passed) will be marked as finished. Errors can occur in the following scenarios:</p>
<ul>
<li>Regina could not create the matching equations for the given triangulation in the given coordinate system. This is only possible in certain coordinate systems, and all such coordinate systems are marked as such in the HyperCoords enum documentation.</li>
<li>A progress tracker is passed but a new thread could not be started.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation upon which this list of normal hypersurfaces will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal hypersurfaces should be enumerated. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created normal hypersurface list. Note that if a progress tracker is passed then this list may not be completely filled when this routine returns. If an error occurs (as described above) then this routine will return <code>null</code> instead. </dd></dl>

</div>
</div>
<a id="ga43639fecde3f509f274378e8bd1f02cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43639fecde3f509f274378e8bd1f02cd">&#9670;&nbsp;</a></span>Enumerator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::Enumerator::Enumerator </td>
          <td>(</td>
          <td class="paramtype">Enumerator &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move constructor. </p>

</div>
</div>
<a id="ga5bd764c0b44735b99a87dd27e2371361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bd764c0b44735b99a87dd27e2371361">&#9670;&nbsp;</a></span>Enumerator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::Enumerator::Enumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td>
          <td class="paramname"><em>eqns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new functor with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the hypersurface list to be filled. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which these hypersurfaces lie. </td></tr>
    <tr><td class="paramname">eqns</td><td>the matching equations for the given triangulation in the coordinate system corresponding to <em>list</em>. This object will take ownership of <em>eqns</em>, and the bracket operator will delete it once the enumeration has finished. This pointer <em>must</em> be non-null, i.e., Regina must have been able to construct the matching equations. </td></tr>
    <tr><td class="paramname">tracker</td><td>the progress tracker to use for progress reporting and cancellation polling, or <code>null</code> if these capabilities are not required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd1524fedf86f4155daa0791bfc99971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1524fedf86f4155daa0791bfc99971">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of HyperCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal hypersurfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;HyperInfo&lt;c&gt;&gt;(...)</code> is defined for any valid HyperCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, ...)</code>, this routine will call <code>func.operator()&lt;HyperInfo&lt;coords&gt;&gt;(...)</code> in turn. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em>. (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal hypersurface coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a HyperInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="ga36de7c6e11fe8b3cf37d0ea7f6f90645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36de7c6e11fe8b3cf37d0ea7f6f90645">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of HyperCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal hypersurfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;HyperInfo&lt;c&gt;&gt;(...)</code> is defined for any valid HyperCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;HyperInfo&lt;coords&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal hypersurface coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a HyperInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given coordinate system is invalid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given coordinate system is invalid. </dd></dl>

</div>
</div>
<a id="ga8fd89e9ad52cd1934f435ea1ecfae1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd89e9ad52cd1934f435ea1ecfae1ed">&#9670;&nbsp;</a></span>hasRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface has real boundary. </dd></dl>

</div>
</div>
<a id="gaf5cfddf3340d89bc8e5c8414e3b2d17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cfddf3340d89bc8e5c8414e3b2d17a">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::NormalHypersurface::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this hypersurface. </p>
<p>There is an important caveat regarding invalid 4-manifold triangulations. If the underlying triangulation has edge links that are not spheres, then it is possible that this normal hypersurface is not a compact 3-manifold. In such a case, this routine will compute homology in the same way as <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> - that is, by effectively truncating ideal points of the hypersurface (which may arise where the hypersurface meets an invalid edge).</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a id="gab12ebadec57a732b15f170bd3c4e4d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12ebadec57a732b15f170bd3c4e4d2c">&#9670;&nbsp;</a></span>HSVectorStandard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HSVectorStandard::HSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9335c20b89d0000a3f24b47b7c5e3a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9335c20b89d0000a3f24b47b7c5e3a8b">&#9670;&nbsp;</a></span>HSVectorStandard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HSVectorStandard::HSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63bc92a93d77a9d308e83c932cfe139e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63bc92a93d77a9d308e83c932cfe139e">&#9670;&nbsp;</a></span>hypersurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> * regina::XMLNormalHypersurfaceReader::hypersurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the normal hypersurface that has been read. </p>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated normal hypersurface, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="gad51f4b521a02d12804d77fb765b2293c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad51f4b521a02d12804d77fb765b2293c">&#9670;&nbsp;</a></span>hypersurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> * regina::NormalHypersurfaces::hypersurface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the hypersurface at the requested index in this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested hypersurface in this list; this must be between 0 and <a class="el" href="group__hypersurface.html#ga23b6c5deda3b5f72c5a29567b1812f20" title="Returns the number of hypersurfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal hypersurface at the requested index in this list. </dd></dl>

</div>
</div>
<a id="ga4d8c0af7a8f1225cbafc29f30c2c4516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8c0af7a8f1225cbafc29f30c2c4516">&#9670;&nbsp;</a></span>HypersurfaceInserter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::HypersurfaceInserter::HypersurfaceInserter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator that is a clone of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab306ea0e6172fd68400a8d4264113e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab306ea0e6172fd68400a8d4264113e5f">&#9670;&nbsp;</a></span>HypersurfaceInserter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::HypersurfaceInserter::HypersurfaceInserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator. </p>
<p>The member variables of this iterator will be initialised according to the parameters passed to this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which hypersurfaces will be inserted. </td></tr>
    <tr><td class="paramname">owner</td><td>the triangulation in which the hypersurfaces to be inserted are contained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75ada6c4377d58a47a1c514af6c3ded5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ada6c4377d58a47a1c514af6c3ded5">&#9670;&nbsp;</a></span>initialChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalHypersurfaceReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gafbfc6c679ae7ab07f4cd4953ae5c4efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfc6c679ae7ab07f4cd4953ae5c4efe">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::NormalHypersurfaces::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="ga49bc4b36bd5443133c33aed2b02177e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49bc4b36bd5443133c33aed2b02177e1">&#9670;&nbsp;</a></span>isCompact() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is compact (has finitely many pieces). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal hypersurface is compact. </dd></dl>

</div>
</div>
<a id="ga6ac3e7f7cce9c678b91073859a9395ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac3e7f7cce9c678b91073859a9395ca">&#9670;&nbsp;</a></span>isCompact() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalHypersurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is compact (has finitely many pieces). </p>
<p>The default implementation for this routine simply runs through every piece type until a piece type with infinite piece count is found or all piece types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is compact. </dd></dl>

</div>
</div>
<a id="ga770ee1870e1ceb28a2b577356a4be33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770ee1870e1ceb28a2b577356a4be33d">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is connected. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is connected, or <code>false</code> if this hypersurface is disconnected. </dd></dl>

</div>
</div>
<a id="gab13eb348cfcd3070e215de79d735ddd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab13eb348cfcd3070e215de79d735ddd0">&#9670;&nbsp;</a></span>isEmbeddedOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::isEmbeddedOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this set is known to contain only embedded normal hypersurfaces. </p>
<p>If this returns <code>false</code>, it does not guarantee that immersed and/or singular hypersurfaces are present; it merely indicates that they were not deliberately excluded (for instance, the prism constraints were not enforced).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was constructed to contain only properly embedded hypersurfaces, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae6ac5d0891674f9dd46395d7099dcf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ac5d0891674f9dd46395d7099dcf6a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is empty (has no pieces whatsoever). </p>

</div>
</div>
<a id="ga99506625435eadb56c06968221623935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99506625435eadb56c06968221623935">&#9670;&nbsp;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is orientable. </p>
<p>· This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is orientable, or <code>false</code> if this hypersurface is non-orientable. </dd></dl>

</div>
</div>
<a id="ga8126f6c44dc69ca6e66fd6045313bd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8126f6c44dc69ca6e66fd6045313bd7b">&#9670;&nbsp;</a></span>isThinEdgeLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; * regina::NormalHypersurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this hypersurface is the thin link of a single edge. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by this hypersurface, or 0 if this hypersurface is not a thin edge link. </dd></dl>

</div>
</div>
<a id="ga0b8cefb8b876ef5c98ece1f393313ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8cefb8b876ef5c98ece1f393313ec3">&#9670;&nbsp;</a></span>isThinEdgeLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;4&gt;* regina::NormalHypersurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by this hypersurface, or 0 if this hypersurface is not a thin edge link. </dd></dl>

</div>
</div>
<a id="gaad578abb2b7507a4bdac7cf8427389e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad578abb2b7507a4bdac7cf8427389e0">&#9670;&nbsp;</a></span>isTwoSided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is two-sided. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is two-sided, or <code>false</code> if this hypersurface is one-sided. </dd></dl>

</div>
</div>
<a id="ga54e8a721415302c5101e5064db14b153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e8a721415302c5101e5064db14b153">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; * regina::NormalHypersurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this hypersurface is the link of a single vertex. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this hypersurface, or 0 if this hypersurface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a id="ga6257bfb963173e01255bd29864ca9482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6257bfb963173e01255bd29864ca9482">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;4&gt;* regina::NormalHypersurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this hypersurface, or 0 if this hypersurface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a id="ga842ced3478b08bde5ad883ef77724420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga842ced3478b08bde5ad883ef77724420">&#9670;&nbsp;</a></span>isVertexLinking() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this hypersurface is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is vertex linking. </dd></dl>

</div>
</div>
<a id="gaf38e0ba79fe11756f4a68620fad07f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf38e0ba79fe11756f4a68620fad07f2b">&#9670;&nbsp;</a></span>isVertexLinking() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalHypersurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>The default implementation for this routine simply runs through every non-tetrahedron piece type ensuring that each has no corresponding pieces. Subclasses of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="gaa4a7a0a235aec8da73213bbf1934aa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4a7a0a235aec8da73213bbf1934aa41">&#9670;&nbsp;</a></span>locallyCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface are locally compatible. </p>
<p>Local compatibility means that, within each individual pentachoron of the triangulation, it is possible to arrange the normal discs of both hypersurfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all pentachora <em>simultaneously</em>.</p>
<p>Local compatibility can be formulated in terms of normal piece types. Two normal hypersurfaces are locally compatible if and only if they together use at most two prism piece types per pentachoron; moreover, if there <em>are</em> two prism piece types within a single pentachoron then these prism types are non-intersecting.</p>
<p>If one of the two hypersurfaces breaks the local compatibility constraints on its own (for instance, it contains two conflicting prism types within the same pentachoron), then this routine will return <code>false</code> regardless of what the other hypersurface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface live within the same 4-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other hypersurface to test for local compatibility with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two hypersurfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="ga6e83bf3a6865f7028184027941605f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e83bf3a6865f7028184027941605f0c">&#9670;&nbsp;</a></span>makeEmbeddedConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::NormalHypersurfaceVector::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="ga6d7b9248e89cb91e6aa507a9586ae467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7b9248e89cb91e6aa507a9586ae467">&#9670;&nbsp;</a></span>makeEmbeddedConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the given coordinate system.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used; this must be one of the predefined coordinate system constants in <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="ga139188fcf2aadfc3f3e63405fd5255e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga139188fcf2aadfc3f3e63405fd5255e8">&#9670;&nbsp;</a></span>makeMatchingEquations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalHypersurfaceVector::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of normal hypersurface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a id="ga26e06572d451bb5cb70b1fa4c165c2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e06572d451bb5cb70b1fa4c165c2f9">&#9670;&nbsp;</a></span>makeMatchingEquations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal hypersurface matching equations for the given triangulation using the given coordinate system. </p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>Each equation will be represented as a row of the matrix. Each column of the matrix represents a coordinate in the given coordinate system.</p>
<p>For some coordinate systems, Regina may not be able to create matching equations for all triangulations (any such coordinate systems will be explicitly mentioned as such in the HyperCoords enum documentation). If Regina cannot create the matching equations as requested, this routine will return <code>null</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used; this must be one of the predefined coordinate system constants in <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations, or <code>null</code> if Regina is not able to construct them for the given combination of triangulation and coordinate system. </dd></dl>

</div>
</div>
<a id="ga9766a882b15b01297fcfd3efc9758c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9766a882b15b01297fcfd3efc9758c7b">&#9670;&nbsp;</a></span>makeZeroVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::NormalHypersurfaceVector::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a>. </p>
<p>All elements of the new vector will be initialised to zero.</p>
<p>See <a class="el" href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and th...">makeZeroVector()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ga062b6a0fcecd8d05a2193bb98feb8b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga062b6a0fcecd8d05a2193bb98feb8b29">&#9670;&nbsp;</a></span>makeZeroVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and the given coordinate system. </p>
<p>All elements of this vector will be initialised to zero.</p>
<p>The new vector will be of the subclass of <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> corresponding to the given coordinate system. The caller of this routine is responsible for destroying the new vector.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used; this must be one of the predefined coordinate system constants in <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ga6aca89d84f22f361520c25277521b9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aca89d84f22f361520c25277521b9d9">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalHypersurface::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this hypersurface. </dd></dl>

</div>
</div>
<a id="gabf1687ff1ed99e7a17c2b72e1fa9281f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf1687ff1ed99e7a17c2b72e1fa9281f">&#9670;&nbsp;</a></span>NormalHypersurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coordSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>allCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that creates a new normal hypersurface inside the given triangulation with the given coordinate vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate system is one in which Regina is able to enumerate and store normal hypersurfaces (not a system like <a class="el" href="group__hypersurface.html#gga57526727019e919f8b9c3858318d2350a20231b069d7350f6da4840f48163efe1" title="Represents edge weight coordinates for normal hypersurfaces.">regina::HS_EDGE_WEIGHT</a>, which is for viewing purposes only). </dd>
<dd>
The given coordinate vector represents a normal hypersurface inside the given triangulation (in particular, it satisfies the relevant system of matching equations). This will not be checked, and things <em>will</em> go wrong if you break it.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>Not available; this routine is for Python only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coordSystem</td><td>the coordinate system used by this normal hypersurface. </td></tr>
    <tr><td class="paramname">allCoords</td><td>the corresponding vector of normal coordinates, expressed as a Python list. The list elements will be converted internally to LargeInteger objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79ea52ceb2420115302f014a1fb621e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79ea52ceb2420115302f014a1fb621e8">&#9670;&nbsp;</a></span>NormalHypersurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector. </p>
<p>This normal hypersurface will claim ownership of the given vector (i.e., you should not change or delete the vector yourself afterwards).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector represents a normal hypersurface inside the given triangulation. </dd>
<dd>
The given coordinate vector cannot be the null pointer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface in whichever space is appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53a29135ae00e910d9a00f2920bc4139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53a29135ae00e910d9a00f2920bc4139">&#9670;&nbsp;</a></span>NormalHypersurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal hypersurfaces with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system to be used for filling this list. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal hypersurfaces these will represent within the underlying triangulation. </td></tr>
    <tr><td class="paramname">algorithm</td><td>details of the enumeration algorithm that will be used to fill this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad167e6fba1d9b509ccd8a167cd0a1c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad167e6fba1d9b509ccd8a167cd0a1c42">&#9670;&nbsp;</a></span>NormalHypersurfaceVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaceVector::NormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabeeee38da5e3a901ebb4488cf7274ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeeee38da5e3a901ebb4488cf7274ce4">&#9670;&nbsp;</a></span>NormalHypersurfaceVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaceVector::NormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad57c8b07ac47e5eb5005ea4e1f72f47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad57c8b07ac47e5eb5005ea4e1f72f47d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::VectorIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this with the given operator for inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the iterators point to the same element of the same normal surface list, or <code>true</code> if they do not. </dd></dl>

</div>
</div>
<a id="ga33bd3a147e314ced51594f689f2859eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bd3a147e314ced51594f689f2859eb">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coords &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::Enumerator::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the real enumeration work, in a setting where the underlying coordinate system is a compile-time constant. </p>
<p>We assume here that neither list_-&gt;which_ nor list_-&gt;algorithm_ have been sanity-checked.</p>
<p>This routine fills <em>list_</em> with surfaces, and then once this is finished it inserts <em>list_</em> into the packet tree as a child of <em>triang_</em>.</p>
<p>The matching equation matrix <em>eqns_</em> will be deleted during this routine.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coords</td><td>an instance of the HyperInfo&lt;&gt; template class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf65d2067c59a9368bb35297cfb104bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf65d2067c59a9368bb35297cfb104bbc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">NormalHypersurfaces::HypersurfaceInserter</a> &amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga758e1ba025d68f79f41b3daa523e2a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga758e1ba025d68f79f41b3daa523e2a2c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalHypersurfaces::VectorIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the raw vector for the normal hypersurface that this iterator is currently pointing to. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is dereferenceable (in particular, it is not past-the-end).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding normal hypersurface vector. </dd></dl>

</div>
</div>
<a id="ga032ceddd4eb6422291ea20ffcd23c7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032ceddd4eb6422291ea20ffcd23c7ac">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> &amp; regina::NormalHypersurfaces::VectorIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The preincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator after the increment. </dd></dl>

</div>
</div>
<a id="ga1708e6be05af78130a480957d39fc62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1708e6be05af78130a480957d39fc62a">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">NormalHypersurfaces::HypersurfaceInserter</a> &amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga6938dab3a7eb016d6a02b9e06bc8747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6938dab3a7eb016d6a02b9e06bc8747f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::VectorIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before the increment took place. </dd></dl>

</div>
</div>
<a id="ga71e0934e76f93e2a252f600dccae0f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e0934e76f93e2a252f600dccae0f8d">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">NormalHypersurfaces::HypersurfaceInserter</a> &amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga03282d464e943ec673ae5d04a33533a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03282d464e943ec673ae5d04a33533a2">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal hypersurfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81bfed4bcefefa781050a29d4d056572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bfed4bcefefa781050a29d4d056572">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> &amp; regina::NormalHypersurfaces::VectorIterator::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The predecrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator after the decrement. </dd></dl>

</div>
</div>
<a id="gaeac2244b1a32e063c3d7bac0f477b1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac2244b1a32e063c3d7bac0f477b1fc">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::VectorIterator::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postdecrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before the decrement took place. </dd></dl>

</div>
</div>
<a id="ga48aab5267a8b085ca4118cb950c17877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48aab5267a8b085ca4118cb950c17877">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a>&amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">HypersurfaceInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this iterator to be a clone of the given output iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga64dc212ec572efdb2c4b87d2347c0bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64dc212ec572efdb2c4b87d2347c0bfb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&amp; regina::NormalHypersurfaces::VectorIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this a copy of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the iterator to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga6a48c2586b4f3c292587376b0957cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a48c2586b4f3c292587376b0957cb1b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">NormalHypersurfaces::HypersurfaceInserter</a> &amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td>
          <td class="paramname"><em>hypersurface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a normal hypersurface to the end of the appropriate surface list. </p>
<p>The given hypersurface will be deallocated with the other hypersurfaces in this list when the list is eventually destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hypersurface</td><td>the normal hypersurface to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gad83edd71c616f208376bd792e130d9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad83edd71c616f208376bd792e130d9e2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalHypersurfaces_1_1HypersurfaceInserter.html">NormalHypersurfaces::HypersurfaceInserter</a> &amp; regina::NormalHypersurfaces::HypersurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the normal hypersurface corresponding to the given vector to the end of the appropriate hypersurface list. </p>
<p>The given vector will be owned by the newly created normal hypersurface and will be deallocated with the other hypersurfaces in this list when the list is eventually destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector of the normal hypersurface to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga97940c8d388390724c76d470d55ece53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97940c8d388390724c76d470d55ece53">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::VectorIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this with the given operator for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the iterators point to the same element of the same normal surface list, or <code>false</code> if they do not. </dd></dl>

</div>
</div>
<a id="ga4ff88752783b70349710da6368de3ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ff88752783b70349710da6368de3ba7">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalHypersurfaceVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="group__hypersurface.html#gaeafcf1b859ef233f5193551626a5c30b" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="ga535cafb0be3e098c5d28ed3835073b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535cafb0be3e098c5d28ed3835073b2e">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gaaecd2a8d25ac496722f2d8d56ceced5d">HyperAlgFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga5dcd474e2d14be1d8379e2392607e031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dcd474e2d14be1d8379e2392607e031">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga3504d968f57efcd4379122ce3e37404d">HyperListFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga9a4a84abd95fcb6b3dd4f8e168e61a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a4a84abd95fcb6b3dd4f8e168e61a23">&#9670;&nbsp;</a></span>packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLNormalHypersurfacesReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga34268af846d03f4016a3a6134e6f65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34268af846d03f4016a3a6134e6f65d5">&#9670;&nbsp;</a></span>prisms() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>A prism piece type is identified by specifying a pentachoron and an edge of that pentachoron; prisms of this type will then separate edge <em>i</em> of the pentachoron from triangle <em>i</em> of the pentachoron.</p>
<p>If you are using a coordinate system that adorns pieces with additional information (such as orientation), this routine returns the <em>total</em> number of prisms in the given pentachoron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prisms reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

</div>
</div>
<a id="ga0d96a0eb204333f4deff8f7cacefdb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d96a0eb204333f4deff8f7cacefdb00">&#9670;&nbsp;</a></span>prisms() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurfaceVector::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="group__hypersurface.html#ga34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurface::prisms()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prism pieces reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

<p>Implemented in <a class="el" href="group__hypersurface.html#ga1a8a380fc2a185f6e045c9707f1d5983">regina::HSVectorStandard</a>.</p>

</div>
</div>
<a id="ga1a8a380fc2a185f6e045c9707f1d5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8a380fc2a185f6e045c9707f1d5983">&#9670;&nbsp;</a></span>prisms() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="group__hypersurface.html#ga34268af846d03f4016a3a6134e6f65d5" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurface::prisms()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prism pieces reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

<p>Implements <a class="el" href="group__hypersurface.html#ga0d96a0eb204333f4deff8f7cacefdb00">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<a id="ga449322a000b093f813f8693cbb248f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449322a000b093f813f8693cbb248f92">&#9670;&nbsp;</a></span>rawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalHypersurface::rawVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the raw vector that sits beneath this normal hypersurface. </p>
<p>Generally users should not need this function. However, it is provided here in case the need should arise (e.g., for reasons of efficiency).</p>
<dl class="section warning"><dt>Warning</dt><dd>An <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> does not know what underlying coordinate system its raw vector uses. Unless you already know the coordinate system in advance (i.e., you created the hypersurface yourself), it is best to keep to the coordinate-system-agnostic access functions such as <a class="el" href="group__hypersurface.html#gabcecbbd6ed6b1c905604345e755e9a23" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NormalHypersurfaceVector::tetrahedra()</a> and <a class="el" href="group__hypersurface.html#ga0d96a0eb204333f4deff8f7cacefdb00" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurfaceVector::prisms()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying raw vector. </dd></dl>

</div>
</div>
<a id="ga99880c9b0c8f843af93cf4fefb8ceab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99880c9b0c8f843af93cf4fefb8ceab0">&#9670;&nbsp;</a></span>recreateMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> * regina::NormalHypersurfaces::recreateMatchingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal hypersurface list. </p>
<p>The destruction of this matrix is the responsibility of the caller of this routine. Multiple calls to this routine will result in the construction of multiple matrices. This routine in fact merely calls <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> with the appropriate parameters.</p>
<p>The format of the matrix is identical to that returned by <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a>.</p>
<p>Note that there are situations in which <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> returns <code>null</code> (because the triangulation is not supported by the chosen coordinate system). However, this routine should never return <code>null</code>, because if <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> had returned <code>null</code> then this normal hypersurface list would not have been created in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching equations used to create this normal hypersurface list. </dd></dl>

</div>
</div>
<a id="gaf912cc475e68845a8b28e906d692d806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf912cc475e68845a8b28e906d692d806">&#9670;&nbsp;</a></span>sameSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::sameSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface in fact represent the same normal hypersurface. </p>
<p>Specifically, this routine examines (or computes) the number of normal pieces of each type, and returns <code>true</code> if and only if these counts are the same for both hypersurfaces.</p>
<p>It does not matter what coordinate systems the two hypersurfaces use. In particular, it does not matter if this and the given hypersurface use different coordinate systems.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface live within the same 4-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the hypersurface to be compared with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both hypersurfaces represent the same normal hypersurface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga242996a39b1ab9b3198610b2f4d2e7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242996a39b1ab9b3198610b2f4d2e7a4">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

</div>
</div>
<a id="ga9a8c275dac12626724b3c4f87eb99cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8c275dac12626724b3c4f87eb99cd7">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaceVector::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must e between 0 and <a class="el" href="group__hypersurface.html#gaeafcf1b859ef233f5193551626a5c30b" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cdf3ef9c9407d10c5eabc69671207f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cdf3ef9c9407d10c5eabc69671207f5">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name to associate with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeafcf1b859ef233f5193551626a5c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeafcf1b859ef233f5193551626a5c30b">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="ga23b6c5deda3b5f72c5a29567b1812f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b6c5deda3b5f72c5a29567b1812f20">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurfaces::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of hypersurfaces stored in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of hypersurfaces. </dd></dl>

</div>
</div>
<a id="ga1bf49a8aee54383f5641341b9471a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf49a8aee54383f5641341b9471a307">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the hypersurfaces in this list according to the given criterion. </p>
<p>This sort is stable, i.e., hypersurfaces that are equivalent under the given criterion will remain in the same relative order.</p>
<p>The implementation of this routine uses std::stable_sort.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>a binary function (or function object) that accepts two const HyperSurface pointers, and returns <code>true</code> if and only if the first hypersurface should appear before the second in the sorted list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1426c1a6e47bc103b23974d6fe014e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1426c1a6e47bc103b23974d6fe014e6a">&#9670;&nbsp;</a></span>startContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLNormalHypersurfacesReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga03e6d5d88264762b313339cf2860d63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03e6d5d88264762b313339cf2860d63f">&#9670;&nbsp;</a></span>startElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalHypersurfaceReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__hypersurface.html#ga9b5832475bc2c7c521cb34607a150eb7" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga9b5832475bc2c7c521cb34607a150eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5832475bc2c7c521cb34607a150eb7">&#9670;&nbsp;</a></span>startSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLNormalHypersurfaceReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga5e571077474b0899732e60f6c3c393df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e571077474b0899732e60f6c3c393df">&#9670;&nbsp;</a></span>tetrahedra() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>A tetrahedron piece type is identified by specifying a pentachoron and a vertex of that pentachoron that the tetrahedron surrounds.</p>
<p>If you are using a coordinate system that adorns pieces with additional information (such as orientation), this routine returns the <em>total</em> number of tetrahedra in the given pentachoron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested pieces reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested pieces lie; this should be between 0 and 4 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

</div>
</div>
<a id="gabcecbbd6ed6b1c905604345e755e9a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcecbbd6ed6b1c905604345e755e9a23">&#9670;&nbsp;</a></span>tetrahedra() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurfaceVector::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="group__hypersurface.html#ga5e571077474b0899732e60f6c3c393df" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NormalHypersurface::tetrahedra()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested tetrahedron pieces reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested tetrahedron pieces lie; this should be between 0 and 4 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

<p>Implemented in <a class="el" href="group__hypersurface.html#ga3034b9229803e759b39cc4f9cc3bb093">regina::HSVectorStandard</a>.</p>

</div>
</div>
<a id="ga3034b9229803e759b39cc4f9cc3bb093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3034b9229803e759b39cc4f9cc3bb093">&#9670;&nbsp;</a></span>tetrahedra() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::HSVectorStandard::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="group__hypersurface.html#ga5e571077474b0899732e60f6c3c393df" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NormalHypersurface::tetrahedra()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested tetrahedron pieces reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested tetrahedron pieces lie; this should be between 0 and 4 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

<p>Implements <a class="el" href="group__hypersurface.html#gabcecbbd6ed6b1c905604345e755e9a23">regina::NormalHypersurfaceVector</a>.</p>

</div>
</div>
<a id="ga10612a9cb4e27aa9162b2c8e05d082fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10612a9cb4e27aa9162b2c8e05d082fa">&#9670;&nbsp;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalHypersurface::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 3-manifold triangulation describing this normal hypersurface. </p>
<p>The triangulation will be simplified via <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">Triangulation&lt;3&gt;::intelligentSimplify()</a>, which means that the tetrahedra of the final triangulation are not likely to correspond to any particular tetrahedron/prism pieces of this normal hypersurface.</p>
<p>The 3-manifold triangulation will be newly allocated, and destroying it is the responsibility of the caller of this routine.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd><em>Bug:</em> Check for absurdly large numbers of pieces and return 0 accordingly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this normal hypersurface. </dd></dl>

</div>
</div>
<a id="ga5204ff2db3586315cccada33614e5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5204ff2db3586315cccada33614e5fab">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * regina::NormalHypersurface::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal hypersurface resides. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="gab8994b445d18484526c22635bacb3ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8994b445d18484526c22635bacb3ec7">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* regina::NormalHypersurfaces::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal hypersurfaces live. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation in which these hypersurfaces live. </dd></dl>

</div>
</div>
<a id="ga84a9d0398362ec3ef2135d71f68274d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84a9d0398362ec3ef2135d71f68274d5">&#9670;&nbsp;</a></span>VectorIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::VectorIterator::VectorIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised iterator. </p>

</div>
</div>
<a id="gaab59507b0769b1995ce7db703f3d1252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab59507b0769b1995ce7db703f3d1252">&#9670;&nbsp;</a></span>VectorIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::VectorIterator::VectorIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the iterator to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebbdf01911361353b206a761af4ffa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebbdf01911361353b206a761af4ffa17">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a> regina::NormalHypersurfaces::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal hypersurfaces this list represents within the underlying triangulation. </p>
<p>This may not be the same HyperList that was passed to <a class="el" href="group__hypersurface.html#ga84e4d8fbac7f933401e084190c468190" title="A unified routine for enumerating various classes of normal hypersurfaces within a given triangulatio...">enumerate()</a>. In particular, default values will have been explicitly filled in (such as HS_VERTEX and/or HS_EMBEDDED_ONLY), and invalid and/or redundant values will have been removed.</p>
<dl class="section return"><dt>Returns</dt><dd>details of what this list represents. </dd></dl>

</div>
</div>
<a id="ga77471d238bd9223eee6e581e2b046dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77471d238bd9223eee6e581e2b046dd7">&#9670;&nbsp;</a></span>writeRawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeRawVector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the underlying coordinate vector to the given output stream in text format. </p>
<p>No indication will be given as to which coordinate system is being used or what each coordinate means. No newline will be written.</p>
<dl class="section user"><dt>Python</dt><dd>The paramater <em>out</em> does not exist, and is taken to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga938dd8acfd2cdab2f6854305bbae4c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938dd8acfd2cdab2f6854305bbae4c97">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalHypersurfaces::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="gac169d0bb98e129d7437ca45b97054b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac169d0bb98e129d7437ca45b97054b47">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f0bf074f42a0da5e565bb79831d6d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0bf074f42a0da5e565bb79831d6d30">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalHypersurfaces::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="ga3d013a7283675341079a93aaaba902ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d013a7283675341079a93aaaba902ad">&#9670;&nbsp;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal hypersurface and all of its properties. </p>
<p>This routine will be called from within <a class="el" href="group__hypersurface.html#gaf3d6b7be21b48e6ed50652634a85fcac" title="Writes a chunk of XML containing the data for this packet only.">NormalHypersurfaces::writeXMLPacketData()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3d6b7be21b48e6ed50652634a85fcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3d6b7be21b48e6ed50652634a85fcac">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalHypersurfaces::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="ga7201b3eb31aa6f2929d39251a2b96da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7201b3eb31aa6f2929d39251a2b96da0">&#9670;&nbsp;</a></span>XMLNormalHypersurfaceReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLNormalHypersurfaceReader::XMLNormalHypersurfaceReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system used by this normal hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee13ba60fcdcad2f036d7e9faae78c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee13ba60fcdcad2f036d7e9faae78c29">&#9670;&nbsp;</a></span>XMLNormalHypersurfacesReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLNormalHypersurfacesReader::XMLNormalHypersurfacesReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface list reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which these normal hypersurfaces live. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab30dbb81eda08334962f4e5328dded7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30dbb81eda08334962f4e5328dded7f">&#9670;&nbsp;</a></span>~NormalHypersurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::~NormalHypersurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this normal hypersurface. </p>
<p>The underlying vector of coordinates will also be deallocated. </p>

</div>
</div>
<a id="ga86ab690be412b4d01cb0e45ca667ff3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ab690be412b4d01cb0e45ca667ff3e">&#9670;&nbsp;</a></span>~NormalHypersurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::~NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all the hypersurfaces within. </p>

</div>
</div>
<a id="ga061be85305688ec1eaa9c3f3e0d526df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061be85305688ec1eaa9c3f3e0d526df">&#9670;&nbsp;</a></span>~NormalHypersurfaceVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaceVector::~NormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual destructor. </p>
<p>This is required because here we introduce virtual functions into the <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> hierarchy. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga2b995dbbf568ef31acb23cb86e512ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b995dbbf568ef31acb23cb86e512ea9">&#9670;&nbsp;</a></span>algorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gad8c09d9f6738b5a29b8ae4cc46c7d3e9">HyperAlg</a> regina::NormalHypersurfaces::algorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the details of the enumeration algorithm that was used to generate this list. </p>
<p>This might not be the same as the <em>algorithmHints</em> flag passed to the corresponding enumeration routine (e.g., if invalid or inappropriate flags were passed). </p>

</div>
</div>
<a id="ga3e6f5cb305ce9f0254556667efdb9461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6f5cb305ce9f0254556667efdb9461">&#9670;&nbsp;</a></span>compact_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::compact_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface compact (i.e., does it only contain finitely many pieces)? </p>

</div>
</div>
<a id="gad12d8548519c825d124d291c1e46db93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12d8548519c825d124d291c1e46db93">&#9670;&nbsp;</a></span>connected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::connected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface connected? </p>

</div>
</div>
<a id="ga08e1b5afcd3630b9ec7fd7244d53776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e1b5afcd3630b9ec7fd7244d53776c">&#9670;&nbsp;</a></span>coords_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalHypersurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<a id="ga6c9ba4d21f39dc2340ea896f9b5e65b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9ba4d21f39dc2340ea896f9b5e65b1">&#9670;&nbsp;</a></span>coords_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> regina::NormalHypersurfaces::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores which coordinate system is being used by the normal hypersurfaces in this packet. </p>

</div>
</div>
<a id="gabf666c3a10d4f971c9e01457a0f2cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf666c3a10d4f971c9e01457a0f2cd60">&#9670;&nbsp;</a></span>H1_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&gt; regina::NormalHypersurface::H1_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First homology group of the hypersurface. </p>

</div>
</div>
<a id="ga14526a3ab2de4f6db4e9ee80f29c26ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14526a3ab2de4f6db4e9ee80f29c26ed">&#9670;&nbsp;</a></span>list_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>* regina::NormalHypersurfaces::HypersurfaceInserter::list_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list into which hypersurfaces will be inserted. </p>

</div>
</div>
<a id="ga935b0370203eda2d9b07e3c751d81e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935b0370203eda2d9b07e3c751d81e76">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalHypersurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this hypersurface. </p>

</div>
</div>
<a id="gad153c38c524603a35d400fb88f291662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad153c38c524603a35d400fb88f291662">&#9670;&nbsp;</a></span>orientable_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface orientable? </p>

</div>
</div>
<a id="ga30459edc14c11806219fa3bfb960d2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30459edc14c11806219fa3bfb960d2ae">&#9670;&nbsp;</a></span>owner_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* regina::NormalHypersurfaces::HypersurfaceInserter::owner_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulation in which the hypersurfaces to be inserted are contained. </p>

</div>
</div>
<a id="ga4bf48595823bea5cd7e1c2bd2bf3e0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf48595823bea5cd7e1c2bd2bf3e0a1">&#9670;&nbsp;</a></span>realBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::realBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this hypersurface have real boundary (i.e. </p>
<p>does it meet any boundary facets)? </p>

</div>
</div>
<a id="ga44fd9da4ee4093e95d6f502babf89736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44fd9da4ee4093e95d6f502babf89736">&#9670;&nbsp;</a></span>surfaces_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>*&gt; regina::NormalHypersurfaces::surfaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the normal hypersurfaces stored in this packet. </p>

</div>
</div>
<a id="ga5966bebd6637e22c5fb8653591de238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5966bebd6637e22c5fb8653591de238c">&#9670;&nbsp;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* regina::NormalHypersurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal hypersurface resides. </p>

</div>
</div>
<a id="ga029a5069b2bfc0c1f9ac64ee9510d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029a5069b2bfc0c1f9ac64ee9510d995">&#9670;&nbsp;</a></span>twoSided_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::twoSided_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface two-sided? </p>

</div>
</div>
<a id="ga01107fe9e58d09cc33d78ad93514050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01107fe9e58d09cc33d78ad93514050a">&#9670;&nbsp;</a></span>vector_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::NormalHypersurface::vector_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal hypersurface in whichever space is appropriate. </p>

</div>
</div>
<a id="ga0441ca3f6753979a988d5f392e2687aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0441ca3f6753979a988d5f392e2687aa">&#9670;&nbsp;</a></span>which_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gac49a56378f69241c425c3345b7d6ddf4">HyperList</a> regina::NormalHypersurfaces::which_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which normal hypersurfaces these represent within the underlying triangulation. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
