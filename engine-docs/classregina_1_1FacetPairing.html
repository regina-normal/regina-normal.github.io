<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::FacetPairing&lt; int &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1FacetPairing-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::FacetPairing&lt; int &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__generic.html">Generic code</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the dual graph of a <em>dim</em>-manifold triangulation; that is, the pairwise matching of facets of <em>dim</em>-dimensional simplices.  
 <a href="classregina_1_1FacetPairing.html#details">More...</a></p>

<p><code>#include &lt;generic/facetpairing.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::FacetPairing&lt; int &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1FacetPairing.png" usemap="#regina::FacetPairing&lt; int &gt;_map" alt=""/>
  <map id="regina::FacetPairing&lt; int &gt;_map" name="regina::FacetPairing&lt; int &gt;_map">
<area href="classregina_1_1detail_1_1FacetPairingBase.html" title="Provides core functionality for facet pairings (that is, dual graphs) of dim-dimensional triangulatio..." alt="regina::detail::FacetPairingBase&lt; dim &gt;" shape="rect" coords="152,112,446,136"/>
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; FacetPairingBase&lt; dim &gt; &gt;" shape="rect" coords="0,56,294,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; FacetPairingBase&lt; dim &gt;, false &gt;" shape="rect" coords="0,0,294,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a29c1d0f565e50aa76cfca68714347533"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a><br class="typebreak"/>
&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a></td></tr>
<tr class="memdesc:a29c1d0f565e50aa76cfca68714347533"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of isomorphisms on facet pairings.  <a href="#a29c1d0f565e50aa76cfca68714347533">More...</a><br/></td></tr>
<tr class="separator:a29c1d0f565e50aa76cfca68714347533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509cb0fc50dd293792e8e13f155b241e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a509cb0fc50dd293792e8e13f155b241e">Use</a> )(const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> *, void *)</td></tr>
<tr class="memdesc:a509cb0fc50dd293792e8e13f155b241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a facet pairing and its automorphisms.  <a href="#a509cb0fc50dd293792e8e13f155b241e">More...</a><br/></td></tr>
<tr class="separator:a509cb0fc50dd293792e8e13f155b241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af7ada43db9509aaaf5ddf77f1d3783ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing.html#af7ada43db9509aaaf5ddf77f1d3783ef">FacetPairing</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:af7ada43db9509aaaf5ddf77f1d3783ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new clone of the given facet pairing.  <a href="#af7ada43db9509aaaf5ddf77f1d3783ef">More...</a><br/></td></tr>
<tr class="separator:af7ada43db9509aaaf5ddf77f1d3783ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0110635d7a625de5871392f0ae5915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing.html#aef0110635d7a625de5871392f0ae5915">FacetPairing</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri)</td></tr>
<tr class="memdesc:aef0110635d7a625de5871392f0ae5915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the dual graph of the given triangulation.  <a href="#aef0110635d7a625de5871392f0ae5915">More...</a><br/></td></tr>
<tr class="separator:aef0110635d7a625de5871392f0ae5915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#afb6c9df60a4ebe89115cd80eb683cf58">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afb6c9df60a4ebe89115cd80eb683cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#afb6c9df60a4ebe89115cd80eb683cf58">More...</a><br/></td></tr>
<tr class="separator:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ab182c97fe654b8929d1fe41dc564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#aea0ab182c97fe654b8929d1fe41dc564">toString</a> () const</td></tr>
<tr class="memdesc:aea0ab182c97fe654b8929d1fe41dc564"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for str().  <a href="#aea0ab182c97fe654b8929d1fe41dc564">More...</a><br/></td></tr>
<tr class="separator:aea0ab182c97fe654b8929d1fe41dc564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f5abced4d1365c34980741b564765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#af32f5abced4d1365c34980741b564765">toStringLong</a> () const</td></tr>
<tr class="memdesc:af32f5abced4d1365c34980741b564765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for detail().  <a href="#af32f5abced4d1365c34980741b564765">More...</a><br/></td></tr>
<tr class="separator:af32f5abced4d1365c34980741b564765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Queries</div></td></tr>
<tr class="memitem:af212a34f7e105b07a5b93ecf99051fbb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af212a34f7e105b07a5b93ecf99051fbb">size</a> () const </td></tr>
<tr class="memdesc:af212a34f7e105b07a5b93ecf99051fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices whose facets are described by this facet pairing.  <a href="#af212a34f7e105b07a5b93ecf99051fbb">More...</a><br/></td></tr>
<tr class="separator:af212a34f7e105b07a5b93ecf99051fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3ef2bebfa649c25ae3d797cd89af65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a5b3ef2bebfa649c25ae3d797cd89af65">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:a5b3ef2bebfa649c25ae3d797cd89af65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#a5b3ef2bebfa649c25ae3d797cd89af65">More...</a><br/></td></tr>
<tr class="separator:a5b3ef2bebfa649c25ae3d797cd89af65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdb4ace8220622e51cb325d36847fee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aebdb4ace8220622e51cb325d36847fee">dest</a> (size_t simp, unsigned facet) const </td></tr>
<tr class="memdesc:aebdb4ace8220622e51cb325d36847fee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#aebdb4ace8220622e51cb325d36847fee">More...</a><br/></td></tr>
<tr class="separator:aebdb4ace8220622e51cb325d36847fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80189c4568695da0032f58012725905"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ae80189c4568695da0032f58012725905">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:ae80189c4568695da0032f58012725905"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#ae80189c4568695da0032f58012725905">More...</a><br/></td></tr>
<tr class="separator:ae80189c4568695da0032f58012725905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107184d8b18fb844180f70bc84bbb00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a107184d8b18fb844180f70bc84bbb00e">isUnmatched</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:a107184d8b18fb844180f70bc84bbb00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="#a107184d8b18fb844180f70bc84bbb00e">More...</a><br/></td></tr>
<tr class="separator:a107184d8b18fb844180f70bc84bbb00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ce9acbaf6677a419576b8076617c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a4c4ce9acbaf6677a419576b8076617c8">isUnmatched</a> (size_t simp, unsigned facet) const </td></tr>
<tr class="memdesc:a4c4ce9acbaf6677a419576b8076617c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="#a4c4ce9acbaf6677a419576b8076617c8">More...</a><br/></td></tr>
<tr class="separator:a4c4ce9acbaf6677a419576b8076617c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d1dc68732bfe750b5aab29967f883a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a85d1dc68732bfe750b5aab29967f883a">isClosed</a> () const </td></tr>
<tr class="memdesc:a85d1dc68732bfe750b5aab29967f883a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is closed.  <a href="#a85d1dc68732bfe750b5aab29967f883a">More...</a><br/></td></tr>
<tr class="separator:a85d1dc68732bfe750b5aab29967f883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphic Representations</div></td></tr>
<tr class="memitem:a49fd05547a2a2d5424ec6a02416cb525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525">isCanonical</a> () const </td></tr>
<tr class="memdesc:a49fd05547a2a2d5424ec6a02416cb525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class.  <a href="#a49fd05547a2a2d5424ec6a02416cb525">More...</a><br/></td></tr>
<tr class="separator:a49fd05547a2a2d5424ec6a02416cb525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b629a573b6278ae961befb0a7becf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a301b629a573b6278ae961befb0a7becf">findAutomorphisms</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;list) const </td></tr>
<tr class="memdesc:a301b629a573b6278ae961befb0a7becf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given list with the set of all combinatorial automorphisms of this facet pairing.  <a href="#a301b629a573b6278ae961befb0a7becf">More...</a><br/></td></tr>
<tr class="separator:a301b629a573b6278ae961befb0a7becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and Output</div></td></tr>
<tr class="memitem:ae0315b056047cc623776246f9997e122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ae0315b056047cc623776246f9997e122">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ae0315b056047cc623776246f9997e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable representation of this facet pairing to the given output stream.  <a href="#ae0315b056047cc623776246f9997e122">More...</a><br/></td></tr>
<tr class="separator:ae0315b056047cc623776246f9997e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e973ce73b7f5079d3a29cfee45c38b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e973ce73b7f5079d3a29cfee45c38b6">toTextRep</a> () const </td></tr>
<tr class="memdesc:a7e973ce73b7f5079d3a29cfee45c38b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text-based representation of this facet pairing that can be used to reconstruct the facet pairing.  <a href="#a7e973ce73b7f5079d3a29cfee45c38b6">More...</a><br/></td></tr>
<tr class="separator:a7e973ce73b7f5079d3a29cfee45c38b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579cbd2caa5f36620665b31866331a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d">writeDot</a> (std::ostream &amp;out, const char *prefix=0, bool subgraph=false, bool labels=false) const </td></tr>
<tr class="memdesc:a579cbd2caa5f36620665b31866331a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graph corresponding to this facet pairing in the Graphviz DOT language.  <a href="#a579cbd2caa5f36620665b31866331a8d">More...</a><br/></td></tr>
<tr class="separator:a579cbd2caa5f36620665b31866331a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab298a686ae299d208448a32c64aea9ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab298a686ae299d208448a32c64aea9ba">dot</a> (const char *prefix=0, bool subgraph=false, bool labels=false) const </td></tr>
<tr class="memdesc:ab298a686ae299d208448a32c64aea9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of the graph that describes this facet pairing.  <a href="#ab298a686ae299d208448a32c64aea9ba">More...</a><br/></td></tr>
<tr class="separator:ab298a686ae299d208448a32c64aea9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3241a34885f4b644773edccf65225ac4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a3241a34885f4b644773edccf65225ac4">fromTextRep</a> (const std::string &amp;rep)</td></tr>
<tr class="memdesc:a3241a34885f4b644773edccf65225ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a facet pairing from a text-based representation.  <a href="#a3241a34885f4b644773edccf65225ac4">More...</a><br/></td></tr>
<tr class="separator:a3241a34885f4b644773edccf65225ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e368406092dd1c1c349dd07958f6145"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145">writeDotHeader</a> (std::ostream &amp;out, const char *graphName=0)</td></tr>
<tr class="memdesc:a7e368406092dd1c1c349dd07958f6145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="#a7e368406092dd1c1c349dd07958f6145">More...</a><br/></td></tr>
<tr class="separator:a7e368406092dd1c1c349dd07958f6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1e9a32a2820fc0215afd89a6566c32"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#adf1e9a32a2820fc0215afd89a6566c32">dotHeader</a> (const char *graphName=0)</td></tr>
<tr class="memdesc:adf1e9a32a2820fc0215afd89a6566c32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="#adf1e9a32a2820fc0215afd89a6566c32">More...</a><br/></td></tr>
<tr class="separator:adf1e9a32a2820fc0215afd89a6566c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772451072af1e4e27c39115688d79ced"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced">findAllPairings</a> (size_t nSimplices, <a class="el" href="classregina_1_1NBoolSet.html">NBoolSet</a> boundary, int nBdryFacets, <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a509cb0fc50dd293792e8e13f155b241e">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a772451072af1e4e27c39115688d79ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible facet pairings satisfying the given constraints.  <a href="#a772451072af1e4e27c39115688d79ced">More...</a><br/></td></tr>
<tr class="separator:a772451072af1e4e27c39115688d79ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6beef317a48670f0a4b015b6a9677c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a6beef317a48670f0a4b015b6a9677c62"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#a6beef317a48670f0a4b015b6a9677c62">More...</a><br/></td></tr>
<tr class="separator:a6beef317a48670f0a4b015b6a9677c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0426cec394e5b98ec2134c12dcaed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aec0426cec394e5b98ec2134c12dcaed9">dest</a> (size_t simp, unsigned facet)</td></tr>
<tr class="memdesc:aec0426cec394e5b98ec2134c12dcaed9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#aec0426cec394e5b98ec2134c12dcaed9">More...</a><br/></td></tr>
<tr class="separator:aec0426cec394e5b98ec2134c12dcaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74fc68b1801eae6f8a62220accb4c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab74fc68b1801eae6f8a62220accb4c72">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:ab74fc68b1801eae6f8a62220accb4c72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="#ab74fc68b1801eae6f8a62220accb4c72">More...</a><br/></td></tr>
<tr class="separator:ab74fc68b1801eae6f8a62220accb4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd74a82a53a6ac6b3d6008b1422d866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a4dd74a82a53a6ac6b3d6008b1422d866">noDest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:a4dd74a82a53a6ac6b3d6008b1422d866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="#a4dd74a82a53a6ac6b3d6008b1422d866">More...</a><br/></td></tr>
<tr class="separator:a4dd74a82a53a6ac6b3d6008b1422d866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aa582a0b2feca47a17fa4fabc0b16d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a20aa582a0b2feca47a17fa4fabc0b16d">noDest</a> (size_t simp, unsigned facet) const </td></tr>
<tr class="memdesc:a20aa582a0b2feca47a17fa4fabc0b16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="#a20aa582a0b2feca47a17fa4fabc0b16d">More...</a><br/></td></tr>
<tr class="separator:a20aa582a0b2feca47a17fa4fabc0b16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d3bf5d71404f8c82dc54d14876521b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af2d3bf5d71404f8c82dc54d14876521b">isCanonicalInternal</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;list) const </td></tr>
<tr class="memdesc:af2d3bf5d71404f8c82dc54d14876521b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions.  <a href="#af2d3bf5d71404f8c82dc54d14876521b">More...</a><br/></td></tr>
<tr class="separator:af2d3bf5d71404f8c82dc54d14876521b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a663cb963d4d177f69ec39c7f7409d278"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a663cb963d4d177f69ec39c7f7409d278">size_</a></td></tr>
<tr class="memdesc:a663cb963d4d177f69ec39c7f7409d278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices under consideration.  <a href="#a663cb963d4d177f69ec39c7f7409d278">More...</a><br/></td></tr>
<tr class="separator:a663cb963d4d177f69ec39c7f7409d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aee05ce55cfad3b49aae171e5baa4a5e0">pairs_</a></td></tr>
<tr class="memdesc:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The other facet to which each simplex facet is paired.  <a href="#aee05ce55cfad3b49aae171e5baa4a5e0">More...</a><br/></td></tr>
<tr class="separator:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa07233fd7ef05238df04eaf81fbd3105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa07233fd7ef05238df04eaf81fbd3105"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::FacetPairingBase&lt; dim &gt;</b></td></tr>
<tr class="separator:aa07233fd7ef05238df04eaf81fbd3105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int&gt;<br/>
class regina::FacetPairing&lt; int &gt;</h3>

<p>Represents the dual graph of a <em>dim</em>-manifold triangulation; that is, the pairwise matching of facets of <em>dim</em>-dimensional simplices. </p>
<p>Given a fixed number of <em>dim</em>-dimensional simplices, each facet of each simplex is either paired with some other simplex facet (which is in turn paired with it) or remains unmatched. A simplex facet cannot be paired with itself.</p>
<p>Such a matching models part of the structure of a <em>dim</em>-manifold triangulation, in which each simplex facet is either glued to some other simplex facet (which is in turn glued to it) or is an unglued boundary facet.</p>
<p>Note that if this pairing is used to construct an actual triangulation, the individual gluing permutations will still need to be specified; they are not a part of this structure.</p>
<p>For Regina's <a class="el" href="stddim.html">standard dimensions</a>, this template is specialised and offers more functionality. In order to use these specialised classes, you will need to include the corresponding headers (e.g., <a class="el" href="dim2_2dim2edgepairing_8h.html" title="Deals with dual graphs of 2-manifold triangulations.">dim2/dim2edgepairing.h</a> for <em>dim</em> = 2, or <a class="el" href="triangulation_2nfacepairing_8h.html" title="Deals with dual graphs of 3-manifold triangulations.">triangulation/nfacepairing.h</a> for <em>dim</em> = 3). For convenience, there are typedefs available for these specialised classes (such as Dim2EdgePairing and NFacePairing respectively).</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., FacetPairing2 and FacetPairing3 for dimensions 2 and 3). The typedefs mentioned above for standard dimensions (e.g., Dim2EdgePairing and NFacePairing) are also available.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a29c1d0f565e50aa76cfca68714347533"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt;*&gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of isomorphisms on facet pairings. </p>
<p>Such an isomorphism can be used to convert one facet pairing into another.</p>
<p>This type is used to store all <em>automorphisms</em> of a facet pairing; that is, all isomorphisms that map the facet pairing to itself. </p>

</div>
</div>
<a class="anchor" id="a509cb0fc50dd293792e8e13f155b241e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::Use)(const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> *, void *)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a facet pairing and its automorphisms. </p>
<p>Such routines are used to process pairings that are found when running <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">findAllPairings()</a>.</p>
<p>The first parameter passed should be a facet pairing (this should not be deallocated by this routine). The second parameter should be a list of all automorphisms of this pairing (this should not be deallocated either). The third parameter may contain arbitrary data as passed to <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">findAllPairings()</a>.</p>
<p>It may be assumed that the pairing is of the appropriate dimension-specific subclass (such as NFacePairing for dimension three, or Dim2EdgePairing for dimension two).</p>
<p>Note that the first two parameters passed might be <code>null</code> to signal that facet pairing generation has finished. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7ada43db9509aaaf5ddf77f1d3783ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new clone of the given facet pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the facet pairing to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef0110635d7a625de5871392f0ae5915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the dual graph of the given triangulation. </p>
<p>This is the facet pairing that describes how the facets of simplices in the given triangulation are joined together, as described in the class notes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is not empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose facet pairing should be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b3ef2bebfa649c25ae3d797cd89af65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="aebdb4ace8220622e51cb325d36847fee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="a6beef317a48670f0a4b015b6a9677c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="aec0426cec394e5b98ec2134c12dcaed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ab298a686ae299d208448a32c64aea9ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of the graph that describes this facet pairing. </p>
<p>This routine simply returns the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p>All arguments are the same as for <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>; see the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a class="anchor" id="adf1e9a32a2820fc0215afd89a6566c32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dotHeader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>This routine simply returns the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> as a string, instead of dumping it to an output stream.</p>
<p>All arguments are the same as for <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>; see the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, as outlined above. </dd></dl>

</div>
</div>
<a class="anchor" id="a772451072af1e4e27c39115688d79ced"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAllPairings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NBoolSet.html">NBoolSet</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBdryFacets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a509cb0fc50dd293792e8e13f155b241e">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible facet pairings satisfying the given constraints. </p>
<p>Only connected facet pairings (pairings in which each simplex can be reached from each other via a series of individual matched facets) will be produced.</p>
<p>Each facet pairing will be produced precisely once up to isomorphism. Facet pairings are considered isomorphic if they are related by a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex. Each facet pairing that is generated will be a lexicographically minimal representative of its isomorphism class, i.e., will be in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</p>
<p>For each facet pairing that is generated, routine <em>use</em> (as passed to this function) will be called with that pairing and its automorphisms as arguments. Each pairing will be of the appropriate dimension-specific subclass (for instance, NFacePairing for dimension three, or Dim2EdgePairing for dimension two).</p>
<p>Once the generation of facet pairings has finished, routine <em>use</em> will be called once more, this time with <code>null</code> as its first two arguments (for the facet pairing and its automorphisms).</p>
<p>Because this class cannot represent an empty facet pairing, if the argument <em>nSimplices</em> is zero then no facet pairings will be generated at all.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation.</p>
</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present, even in the dimension-specific subclasses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices whose facets should be (potentially) matched. </td></tr>
    <tr><td class="paramname">boundary</td><td>determines whether any facets may be left unmatched. This set should contain <code>true</code> if pairings with at least one unmatched facet are to be generated, and should contain <code>false</code> if pairings with no unmatched facets are to be generated. </td></tr>
    <tr><td class="paramname">nBdryFacets</td><td>specifies the precise number of facets that should be left unmatched. If this parameter is negative, it is ignored and no additional restriction is imposed. If parameter <em>boundary</em> does not contain <code>true</code>, this parameter is likewise ignored. If parameter <em>boundary</em> does contain true and this parameter is non-negative, only pairings with precisely this many unmatched facets will be generated. In particular, if this parameter is positive then pairings with no unmatched facets will not be produced irrespective of whether <code>false</code> is contained in parameter <em>boundary</em>. Note that, in order to produce any pairings at all, this parameter must be of the same parity as <code>nSimplices * (dim+1)</code>, and can be at most <code>(dim-1) * nSimplices + 2</code>. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each facet pairing that is found. The first parameter passed to this function will be a facet pairing. The second parameter will be a list of all its automorphisms (relabellings of simplices and individual simplex facets that produce the exact same pairing). The third parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each pairing found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a301b629a573b6278ae961befb0a7becf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAutomorphisms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given list with the set of all combinatorial automorphisms of this facet pairing. </p>
<p>An automorphism is a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex resulting in precisely the same facet pairing.</p>
<p>This routine uses optimisations that can cause unpredictable breakages if this facet pairing is not in canonical form.</p>
<p>The automorphisms placed in the given list will be newly created; it is the responsibility of the caller of this routine to deallocate them.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty. </dd>
<dd>
This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
This facet pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present, even in the dimension-specific subclasses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which the newly created automorphisms will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3241a34885f4b644773edccf65225ac4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::fromTextRep </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a facet pairing from a text-based representation. </p>
<p>This text-based representation must be in the format produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e973ce73b7f5079d3a29cfee45c38b6" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>.</p>
<p>The facet pairing returned will be newly constructed; it is the responsibility of the caller of this routine to deallocate it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The facet pairing to be reconstructed involves at least one simplex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>a text-based representation of a facet pairing, as produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e973ce73b7f5079d3a29cfee45c38b6" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding newly constructed facet pairing, or <code>null</code> if the given text-based representation was invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a49fd05547a2a2d5424ec6a02416cb525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class. </p>
<p>Isomorphisms of facet pairings correspond to relabellings of simplices and relabellings of the (<em>dim</em> + 1) facets within each simplex.</p>
<p>Facet pairings are ordered by lexicographical comparison of <code>dest(0,0)</code>, <code>dest(0,1)</code>, ..., <code>dest(<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af212a34f7e105b07a5b93ecf99051fbb" title="Returns the number of simplices whose facets are described by this facet pairing.">size()</a>-1,<em>dim</em>)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a class="anchor" id="af2d3bf5d71404f8c82dc54d14876521b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonicalInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions. </p>
<p>If this facet pairing is in canonical form, the given list will be filled with the set of all combinatorial automorphisms of this facet pairing. If not, the given list will be left empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty. </dd>
<dd>
For each simplex <em>t</em>, the only case in which <code>dest(t,i)</code> is greater than <code>dest(t,i+1)</code> is where facets <code>(t,i)</code> and <code>(t,i+1)</code> are paired together. </dd>
<dd>
For each simplex <em>t</em> &gt; 0, it is true that <code>dest(t,0).simp &lt; t</code>. </dd>
<dd>
The sequence <code>dest(1,0)</code>, <code>dest(2,0)</code>, ..., <code>dest(n-1,0)</code> is strictly increasing, where <em>n</em> is the total number of simplices under investigation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which automorphisms will be placed if appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a class="anchor" id="a85d1dc68732bfe750b5aab29967f883a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is closed. </p>
<p>A closed facet pairing has no unmatched facets. </p>

</div>
</div>
<a class="anchor" id="a107184d8b18fb844180f70bc84bbb00e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c4ce9acbaf6677a419576b8076617c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dd74a82a53a6ac6b3d6008b1422d866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a20aa582a0b2feca47a17fa4fabc0b16d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae80189c4568695da0032f58012725905"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="ab74fc68b1801eae6f8a62220accb4c72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a class="anchor" id="af212a34f7e105b07a5b93ecf99051fbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices whose facets are described by this facet pairing. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0ab182c97fe654b8929d1fe41dc564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , supportsUtf8 &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for str(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000253">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type str() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="af32f5abced4d1365c34980741b564765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , supportsUtf8 &gt;::toStringLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for detail(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000254">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type detail() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a long text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e973ce73b7f5079d3a29cfee45c38b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::toTextRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text-based representation of this facet pairing that can be used to reconstruct the facet pairing. </p>
<p>This reconstruction is done through routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a3241a34885f4b644773edccf65225ac4" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>.</p>
<p>The text produced is not particularly readable; for a human-readable text representation, see routine <a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49" title="Returns a short text representation of this object.">str()</a> instead.</p>
<p>The string returned will contain no newlines.</p>
<dl class="section return"><dt>Returns</dt><dd>a text-based representation of this facet pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a579cbd2caa5f36620665b31866331a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the graph corresponding to this facet pairing in the Graphviz DOT language. </p>
<p>Every vertex of this graph represents a simplex, and every edge represents a pair of simplex facets that are joined together. Note that for a closed triangulation this graph will be entirely (<em>dim</em> + 1)-valent; for triangulations with boundary facets, some graph vertices will have degree <em>dim</em> or less.</p>
<p>The graph can either be written as a complete DOT graph, or as a clustered subgraph within some larger DOT graph (according to whether the argument <em>subgraph</em> is passed as <code>false</code> or <code>true</code>).</p>
<p>If a complete DOT graph is being written, the output may be used as a standalone DOT file ready for use with Graphviz.</p>
<p>If a subgraph is being written, the output will contain a single <code>subgraph</code> section that should be inserted into some larger DOT file. Note that the output generated by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, followed by one or more subgraphs and then a closing curly brace will suffice. The subgraph name will begin with the string <code>pairing_</code>.</p>
<p>The argument <em>prefix</em> will be prepended to the name of each graph vertex, and will also be used in the name of the graph or subgraph. Using unique prefixes becomes important if you are calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> several times to generate several subgraphs for use in a single DOT file. If the <em>prefix</em> argument is null or empty then a default prefix will be used.</p>
<p>Note that this routine generates undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python:</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string to prepend to the name of each graph vertex, and to include in the graph or subgraph name; see above for details. </td></tr>
    <tr><td class="paramname">subgraph</td><td><code>false</code> if a complete standalone DOT graph should be output, or <code>true</code> if a clustered subgraph should be output for use in some larger DOT file. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. This feature is currently experimental, and the default is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e368406092dd1c1c349dd07958f6145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDotHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>See the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> documentation for further information on such graphs.</p>
<p>The output will be in the Graphviz DOT language, and will include appropriate display settings for graphs, edges and nodes. The opening brace for a <code>graph</code> section of the DOT file is included.</p>
<p>This routine may be used with <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> to generate a single DOT file containing the graphs for several different facet pairings. A complete DOT file can be produced by calling this routine, then calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in subgraph mode for each facet pairing, then outputting a final closing curly brace.</p>
<p>Note that if you require a DOT file containing the graph for only a single facet pairing, this routine is unnecessary; you may simply call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a579cbd2caa5f36620665b31866331a8d" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in full graph mode instead.</p>
<p>This routine is suitable for generating undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python:</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">graphName</td><td>the name of the graph in the DOT file. If this is null or empty then a default graph name will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb6c9df60a4ebe89115cd80eb683cf58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a03ab9eda74347bfa8ad909e9d6ecf0bd">FacetPairingBase</a>&lt; dim &gt; , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0315b056047cc623776246f9997e122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a human-readable representation of this facet pairing to the given output stream. </p>
<p>The string returned will contain no newlines.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aee05ce55cfad3b49aae171e5baa4a5e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::pairs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The other facet to which each simplex facet is paired. </p>
<p>If a simplex facet is left unmatched, the corresponding element of this array will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#ae2c4571c7718ae37a7b34fca42d3a800" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>). If the destination for a particular facet has not yet been decided, the facet will be paired to itself. </p>

</div>
</div>
<a class="anchor" id="a663cb963d4d177f69ec39c7f7409d278"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices under consideration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>census/<a class="el" href="ngenericgluingperms_8h.html">ngenericgluingperms.h</a></li>
<li>generic/<a class="el" href="facetpairing_8h.html">facetpairing.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
