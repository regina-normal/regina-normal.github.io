<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NTreeTraversal.html">NTreeTraversal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NTreeTraversal-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A base class for searches that employ the tree traversal algorithm for enumerating and locating vertex normal surfaces and taut angle structures.  
 <a href="classregina_1_1NTreeTraversal.html#details">More...</a></p>

<p><code>#include &lt;enumerate/ntreetraversal.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NTreeTraversal.png" usemap="#regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt;_map" alt=""/>
  <map id="regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt;_map" name="regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt;_map">
<area href="classregina_1_1NTautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m..." alt="regina::NTautEnumeration&lt; LPConstraint, BanConstraint, Integer &gt;" shape="rect" coords="0,112,391,136"/>
<area href="classregina_1_1NTreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal..." alt="regina::NTreeEnumeration&lt; LPConstraint, BanConstraint, Integer &gt;" shape="rect" coords="401,112,792,136"/>
<area href="classregina_1_1NTreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm..." alt="regina::NTreeSingleSoln&lt; LPConstraint, BanConstraint, Integer &gt;" shape="rect" coords="802,112,1193,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51524015f75033c7888dcc3201421250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a51524015f75033c7888dcc3201421250">constraintsBroken</a> () const </td></tr>
<tr class="memdesc:a51524015f75033c7888dcc3201421250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully to the infrastructure for the search tree.  <a href="#a51524015f75033c7888dcc3201421250">More...</a><br/></td></tr>
<tr class="separator:a51524015f75033c7888dcc3201421250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabef77a7271fa34dacf2690fe6e5a266"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#aabef77a7271fa34dacf2690fe6e5a266">nVisited</a> () const </td></tr>
<tr class="memdesc:aabef77a7271fa34dacf2690fe6e5a266"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of nodes in the search tree that we have visited thus far in the tree traversal.  <a href="#aabef77a7271fa34dacf2690fe6e5a266">More...</a><br/></td></tr>
<tr class="separator:aabef77a7271fa34dacf2690fe6e5a266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f263c61b52bf21d5c5e1d87ee1572d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#ac0f263c61b52bf21d5c5e1d87ee1572d">dumpTypes</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac0f263c61b52bf21d5c5e1d87ee1572d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current type vector to the given output stream.  <a href="#ac0f263c61b52bf21d5c5e1d87ee1572d">More...</a><br/></td></tr>
<tr class="separator:ac0f263c61b52bf21d5c5e1d87ee1572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5697f5972055c268b3672967fc6cc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NNormalSurface.html">NNormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#af5697f5972055c268b3672967fc6cc11">buildSurface</a> () const </td></tr>
<tr class="memdesc:af5697f5972055c268b3672967fc6cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full normal surface that is represented by the type vector at the current stage of the search.  <a href="#af5697f5972055c268b3672967fc6cc11">More...</a><br/></td></tr>
<tr class="separator:af5697f5972055c268b3672967fc6cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef539e88811767ef9fcf63ceb22375f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NAngleStructure.html">NAngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a0ef539e88811767ef9fcf63ceb22375f">buildStructure</a> () const </td></tr>
<tr class="memdesc:a0ef539e88811767ef9fcf63ceb22375f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search.  <a href="#a0ef539e88811767ef9fcf63ceb22375f">More...</a><br/></td></tr>
<tr class="separator:a0ef539e88811767ef9fcf63ceb22375f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d505fd11c2b2cfdc850591878c89ea5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a8d505fd11c2b2cfdc850591878c89ea5">verify</a> (const <a class="el" href="classregina_1_1NNormalSurface.html">NNormalSurface</a> *s, const <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *matchingEqns=0) const </td></tr>
<tr class="memdesc:a8d505fd11c2b2cfdc850591878c89ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given normal or almost normal surface satisfies the matching equations, as well as any additional constraints from the template parameter LPConstraint.  <a href="#a8d505fd11c2b2cfdc850591878c89ea5">More...</a><br/></td></tr>
<tr class="separator:a8d505fd11c2b2cfdc850591878c89ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad820dc7b5955ea5eb76e6e37afe243a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#ad820dc7b5955ea5eb76e6e37afe243a8">verify</a> (const <a class="el" href="classregina_1_1NAngleStructure.html">NAngleStructure</a> *s, const <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *angleEqns=0) const </td></tr>
<tr class="memdesc:ad820dc7b5955ea5eb76e6e37afe243a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given angle structure satisfies the angle equations, as well as any additional constraints from the template parameter LPConstraint.  <a href="#ad820dc7b5955ea5eb76e6e37afe243a8">More...</a><br/></td></tr>
<tr class="separator:ad820dc7b5955ea5eb76e6e37afe243a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a324ebfbacffada22c1f2fca8ce4c0c14"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a324ebfbacffada22c1f2fca8ce4c0c14">supported</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:a324ebfbacffada22c1f2fca8ce4c0c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the given coordinate system is supported by this tree traversal infrastructure.  <a href="#a324ebfbacffada22c1f2fca8ce4c0c14">More...</a><br/></td></tr>
<tr class="separator:a324ebfbacffada22c1f2fca8ce4c0c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a97eb307fd3cbaabea41935db1ae4a674"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a97eb307fd3cbaabea41935db1ae4a674">NTreeTraversal</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *tri, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, int branchesPerQuad, int branchesPerTri, bool enumeration)</td></tr>
<tr class="memdesc:a97eb307fd3cbaabea41935db1ae4a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new base object for running the tree traversal algorithm.  <a href="#a97eb307fd3cbaabea41935db1ae4a674">More...</a><br/></td></tr>
<tr class="separator:a97eb307fd3cbaabea41935db1ae4a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271491c3048180c69f02909d407392fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a271491c3048180c69f02909d407392fb">~NTreeTraversal</a> ()</td></tr>
<tr class="memdesc:a271491c3048180c69f02909d407392fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object.  <a href="#a271491c3048180c69f02909d407392fb">More...</a><br/></td></tr>
<tr class="separator:a271491c3048180c69f02909d407392fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac630db8509b0dee69adc2d7052ab0037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#ac630db8509b0dee69adc2d7052ab0037">setNext</a> (int nextType)</td></tr>
<tr class="memdesc:ac630db8509b0dee69adc2d7052ab0037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges the search tree so that <em>nextType</em> becomes the next type that we process.  <a href="#ac630db8509b0dee69adc2d7052ab0037">More...</a><br/></td></tr>
<tr class="separator:ac630db8509b0dee69adc2d7052ab0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a7ce11bb8c1bb6d50b5c90c986c6e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a89a7ce11bb8c1bb6d50b5c90c986c6e2">nextUnmarkedTriangleType</a> (int startFrom)</td></tr>
<tr class="memdesc:a89a7ce11bb8c1bb6d50b5c90c986c6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next unmarked triangle type from a given starting point.  <a href="#a89a7ce11bb8c1bb6d50b5c90c986c6e2">More...</a><br/></td></tr>
<tr class="separator:a89a7ce11bb8c1bb6d50b5c90c986c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fb41f24688fc2367812c6ae67c35d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#aa0fb41f24688fc2367812c6ae67c35d0">feasibleBranches</a> (int quadType)</td></tr>
<tr class="memdesc:aa0fb41f24688fc2367812c6ae67c35d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system.  <a href="#aa0fb41f24688fc2367812c6ae67c35d0">More...</a><br/></td></tr>
<tr class="separator:aa0fb41f24688fc2367812c6ae67c35d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d23b2ac041415908e82eff3e4825f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a3a6d23b2ac041415908e82eff3e4825f">percent</a> () const </td></tr>
<tr class="memdesc:a3a6d23b2ac041415908e82eff3e4825f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree.  <a href="#a3a6d23b2ac041415908e82eff3e4825f">More...</a><br/></td></tr>
<tr class="separator:a3a6d23b2ac041415908e82eff3e4825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:addf50ccfd44b496cf86bb73bed1467d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a><br class="typebreak"/>
&lt; LPConstraint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#addf50ccfd44b496cf86bb73bed1467d3">origTableaux_</a></td></tr>
<tr class="memdesc:addf50ccfd44b496cf86bb73bed1467d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins.  <a href="#addf50ccfd44b496cf86bb73bed1467d3">More...</a><br/></td></tr>
<tr class="separator:addf50ccfd44b496cf86bb73bed1467d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e9d1a953b482fdf72ca353759fd7c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a35e9d1a953b482fdf72ca353759fd7c0">coords_</a></td></tr>
<tr class="memdesc:a35e9d1a953b482fdf72ca353759fd7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate system in which we are enumerating or searching for normal surfaces, almost normal surfaces, or taut angle structures.  <a href="#a35e9d1a953b482fdf72ca353759fd7c0">More...</a><br/></td></tr>
<tr class="separator:a35e9d1a953b482fdf72ca353759fd7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a58c8a4bf02411b13607936bc93b5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a926a58c8a4bf02411b13607936bc93b5">nTets_</a></td></tr>
<tr class="memdesc:a926a58c8a4bf02411b13607936bc93b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tetrahedra in the underlying triangulation.  <a href="#a926a58c8a4bf02411b13607936bc93b5">More...</a><br/></td></tr>
<tr class="separator:a926a58c8a4bf02411b13607936bc93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6392dcdeb79ed170600ba34804c6947b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a6392dcdeb79ed170600ba34804c6947b">nTypes_</a></td></tr>
<tr class="memdesc:a6392dcdeb79ed170600ba34804c6947b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total length of a type vector.  <a href="#a6392dcdeb79ed170600ba34804c6947b">More...</a><br/></td></tr>
<tr class="separator:a6392dcdeb79ed170600ba34804c6947b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd706c4f0fb975f41f90acd2b12ec97"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a6cd706c4f0fb975f41f90acd2b12ec97">nTableaux_</a></td></tr>
<tr class="memdesc:a6cd706c4f0fb975f41f90acd2b12ec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search.  <a href="#a6cd706c4f0fb975f41f90acd2b12ec97">More...</a><br/></td></tr>
<tr class="separator:a6cd706c4f0fb975f41f90acd2b12ec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a713ce66641fe89993410eb8920a5b5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a9a713ce66641fe89993410eb8920a5b5">type_</a></td></tr>
<tr class="memdesc:a9a713ce66641fe89993410eb8920a5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current working type vector.  <a href="#a9a713ce66641fe89993410eb8920a5b5">More...</a><br/></td></tr>
<tr class="separator:a9a713ce66641fe89993410eb8920a5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535b2b029b0383a20940fa75f3f4f5f6"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a535b2b029b0383a20940fa75f3f4f5f6">typeOrder_</a></td></tr>
<tr class="memdesc:a535b2b029b0383a20940fa75f3f4f5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]].  <a href="#a535b2b029b0383a20940fa75f3f4f5f6">More...</a><br/></td></tr>
<tr class="separator:a535b2b029b0383a20940fa75f3f4f5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c5be14e90013faf35b2a3153060dca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a76c5be14e90013faf35b2a3153060dca">level_</a></td></tr>
<tr class="memdesc:a76c5be14e90013faf35b2a3153060dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current level in the search tree.  <a href="#a76c5be14e90013faf35b2a3153060dca">More...</a><br/></td></tr>
<tr class="separator:a76c5be14e90013faf35b2a3153060dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa736bb922dc618dd74942a94fe01f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#af8aa736bb922dc618dd74942a94fe01f">octLevel_</a></td></tr>
<tr class="memdesc:af8aa736bb922dc618dd74942a94fe01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level at which we are enforcing an octagon type (with a strictly positive number of octagons).  <a href="#af8aa736bb922dc618dd74942a94fe01f">More...</a><br/></td></tr>
<tr class="separator:af8aa736bb922dc618dd74942a94fe01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8917fcfd50205a3927ace7fba6c8dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, Integer &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a5d8917fcfd50205a3927ace7fba6c8dc">lp_</a></td></tr>
<tr class="memdesc:a5d8917fcfd50205a3927ace7fba6c8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores tableaux for linear programming at various nodes in the search tree.  <a href="#a5d8917fcfd50205a3927ace7fba6c8dc">More...</a><br/></td></tr>
<tr class="separator:a5d8917fcfd50205a3927ace7fba6c8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1d1d88e2352c530b1bf5e460b9a374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, Integer &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a7e1d1d88e2352c530b1bf5e460b9a374">lpSlot_</a></td></tr>
<tr class="memdesc:a7e1d1d88e2352c530b1bf5e460b9a374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors.  <a href="#a7e1d1d88e2352c530b1bf5e460b9a374">More...</a><br/></td></tr>
<tr class="separator:a7e1d1d88e2352c530b1bf5e460b9a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, Integer &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb">nextSlot_</a></td></tr>
<tr class="memdesc:a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the next available tableaux in lp_ that is free to use at each level of the search tree.  <a href="#a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb">More...</a><br/></td></tr>
<tr class="separator:a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec5bf166bb3911465e735f7d0b0800"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#a16ec5bf166bb3911465e735f7d0b0800">nVisited_</a></td></tr>
<tr class="memdesc:a16ec5bf166bb3911465e735f7d0b0800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the total number of nodes in the search tree that we have visited thus far.  <a href="#a16ec5bf166bb3911465e735f7d0b0800">More...</a><br/></td></tr>
<tr class="separator:a16ec5bf166bb3911465e735f7d0b0800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71a4f97e49ccda99b03e6a1598fd9b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, Integer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NTreeTraversal.html#ab71a4f97e49ccda99b03e6a1598fd9b3">tmpLP_</a> [4]</td></tr>
<tr class="memdesc:ab71a4f97e49ccda99b03e6a1598fd9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary tableaux used by the function <a class="el" href="classregina_1_1NTreeTraversal.html#aa0fb41f24688fc2367812c6ae67c35d0" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree.  <a href="#ab71a4f97e49ccda99b03e6a1598fd9b3">More...</a><br/></td></tr>
<tr class="separator:ab71a4f97e49ccda99b03e6a1598fd9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class LPConstraint, typename BanConstraint, typename Integer&gt;<br/>
class regina::NTreeTraversal&lt; LPConstraint, BanConstraint, Integer &gt;</h3>

<p>A base class for searches that employ the tree traversal algorithm for enumerating and locating vertex normal surfaces and taut angle structures. </p>
<p>Users should not use this base class directly; instead use one of the subclasses <a class="el" href="classregina_1_1NTreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">NTreeEnumeration</a> (for enumerating all vertex normal surfaces), <a class="el" href="classregina_1_1NTautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">NTautEnumeration</a> (for enumerating all taut angle structures), or <a class="el" href="classregina_1_1NTreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">NTreeSingleSoln</a> (for locating a single non-trivial solution under additional constraints, such as positive Euler characteristic).</p>
<p>For normal surfaces, the full algorithms are described respectively in "A tree traversal algorithm for decision problems in knot theory and
3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079.</p>
<p>This base class provides the infrastructure for the search tree, and the subclasses handle the mechanics of the moving through the tree according to the backtracking search. The domination test is handled separately by the class <a class="el" href="classregina_1_1NTypeTrie.html" title="A trie that stores a set of type vectors of a fixed length.">NTypeTrie</a>, and the feasibility test is handled separately by the class <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a>.</p>
<p>This class holds the particular state of the tree traversal at any point in time, as described by the current <em>level</em> (indicating our current depth in the search tree) and <em>type vector</em> (indicating which branches of the search tree we have followed). For details on these concepts, see the Algorithmica paper cited above. The key details are summarised below; throughout this discussion <em>n</em> represents the number of tetrahedra in the underlying triangulation.</p>
<ul>
<li>In quadrilateral coordinates, the type vector is a sequence of <em>n</em> integers, each equal to 0, 1, 2 or 3, where the <em>i</em>th integer describes the choice of quadrilateral location in the <em>i</em>th tetrahedron.</li>
</ul>
<ul>
<li>In standard coordinates, the type vector begins with the <em>n</em> quadrilateral choices outlined above. This is then followed by an additional 4<em>n</em> integers, each equal to 0 or 1; these correspond to the 4<em>n</em> triangle coordinates, and indicate whether each coordinate is zero or non-zero.</li>
</ul>
<ul>
<li>In angle structure coordinates, this class identifies taut angle structures only. Here the type vector is a sequence of <em>n</em> integers, each equal to 1, 2 or 3, where the <em>i</em>th integer describes the location of the two &pi; angles in the <em>i</em>th tetrahedron.</li>
</ul>
<p>In the original Algorithmica paper, we choose types in the order type_[0], type_[1] and so on, working from the root of the tree down to the leaves. Here we support a more flexible system: there is an internal permutation <em>typeOrder_</em>, and we choose types in the order type_[typeOrder_[0]], type_[typeOrder_[1]] and so on. This permutation may mix quadrilateral and triangle processing, and may even change as the algorithm runs.</p>
<p>This class can also support octagon types in almost normal surfaces. However, we still do our linear programming in standard or quadrilateral coordinates, where we represent an octagon using two conflicting quadrilaterals in the same tetrahedron (which meet the tetrahedron boundary in the same set of arcs as a single octagon would). As with the almost normal coordinate systems in <a class="el" href="classregina_1_1NNormalSurfaceList.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NNormalSurfaceList</a>, we allow multiple octagons of the same type, but only one octagon type in the entire tetrahedron. In the type vector, octagons are indicated by setting a quadrilateral type to 4, 5 or 6.</p>
<p>There is optional support for adding extra linear constraints (such as a constraint on Euler characteristic), supplied by the template parameter <em>LPConstraint</em>. If there are no additional constraints, simply use the template parameter <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>.</p>
<p>Also, there is optional support for banning coordinates (i.e., insisting that certain coordinates must be set to zero), and/or marking coordinates (for normal and almost normal surfaces this affects what is meant by a "non-trivial" surface for the <a class="el" href="classregina_1_1NTreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">NTreeSingleSoln</a> algorithm; the concept of marking may be expanded further in future versions of Regina). These options are supplied by the template parameter <em>BanConstraint</em>. If there are no coordinates to ban or mark, simply use the template parameter <em><a class="el" href="classregina_1_1BanNone.html" title="A do-nothing class that bans no coordinates and marks no coordinates.">BanNone</a></em>.</p>
<p>In some cases, it is impossible to add the extra linear constraints that we would like (for instance, if they require additional preconditions on the underlying triangulation). If this is a possibility in your setting, you should call <a class="el" href="classregina_1_1NTreeTraversal.html#a51524015f75033c7888dcc3201421250" title="Indicates whether or not the extra constraints from the template parameter LPConstraints were added s...">constraintsBroken()</a> to test for this once the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> object has been constructed.</p>
<p>The template argument <em>Integer</em> indicates the integer type that will be used throughout the underlying linear programming machinery. Unless you have a good reason to do otherwise, you should use the arbitrary-precision NInteger class (in which integers can grow arbitrarily large, and overflow can never occur).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The parameters LPConstraint and BanConstraint must be subclasses of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> and <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> respectively. See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> and <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes for further details.</dd>
<dd>
The default constructor for the template class Integer must intialise each new integer to zero. The classes NInteger and <a class="el" href="classregina_1_1NNativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NNativeInteger</a>, for instance, have this property.</dd></dl>
<dl class="section user"><dt>Headers:</dt><dd>Parts of this template class are implemented in a separate header (ntreetraversal-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97eb307fd3cbaabea41935db1ae4a674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::<a class="el" href="classregina_1_1NTreeTraversal.html">NTreeTraversal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchesPerQuad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchesPerTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enumeration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises a new base object for running the tree traversal algorithm. </p>
<p>This routine may only be called by subclass constructors; for more information on how to create and run a tree traversal, see subclasses such as <a class="el" href="classregina_1_1NTreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">NTreeEnumeration</a>, <a class="el" href="classregina_1_1NTautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">NTautEnumeration</a> or <a class="el" href="classregina_1_1NTreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">NTreeSingleSoln</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to search for normal surfaces or taut angle structures. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system in which wish to search for normal surfaces or taut angle structures. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, NS_AN_STANDARD, or NS_ANGLE. </td></tr>
    <tr><td class="paramname">branchesPerQuad</td><td>the maximum number of branches we spawn in the search tree for each quadrilateral or angle type (e.g., 4 for a vanilla normal surface tree traversal algorithm, or 3 for enumerating taut angle structures). </td></tr>
    <tr><td class="paramname">branchesPerTri</td><td>the maximum number of branches we spawn in the search tree for each triangle type (e.g., 2 for a vanilla normal surface tree traversal algorithm). If the underlying coordinate system does not support triangles then this argument will be ignored. </td></tr>
    <tr><td class="paramname">enumeration</td><td><code>true</code> if we should optimise the tableaux for a full enumeration of vertex surfaces or taut angle structures, or <code>false</code> if we should optimise the tableaux for an existence test (such as searching for a non-trivial normal disc or sphere). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a271491c3048180c69f02909d407392fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::~<a class="el" href="classregina_1_1NTreeTraversal.html">NTreeTraversal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0ef539e88811767ef9fcf63ceb22375f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NAngleStructure.html">NAngleStructure</a>* <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::buildStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search. </p>
<p>This routine is for use only with taut angle structures, not normal or almost normal surfaces.</p>
<p>The angle structure that is returned will be newly constructed, and it is the caller's responsibility to destroy it when it is no longer required.</p>
<p>There will always be a unique taut angle structure corresponding to this type vector (this follows from the preconditions below).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a taut angle structure. This condition is always true after <a class="el" href="classregina_1_1NTautEnumeration.html#ad4f59b5230aac79ad765bc3aa7096a8e" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution...">NTautEnumeration::next()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1NTautEnumeration.html#aa038cf029e8ac7ea28f0cc65f70fe613" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">NTautEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with angle structure coordinates; that is, the coordinate system passed to the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> constructor was NS_ANGLE.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the taut angle structure that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a class="anchor" id="af5697f5972055c268b3672967fc6cc11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NNormalSurface.html">NNormalSurface</a>* <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::buildSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the full normal surface that is represented by the type vector at the current stage of the search. </p>
<p>This routine is for use only with normal (or almost normal) surfaces, not taut angle structures.</p>
<p>The surface that is returned will be newly constructed, and it is the caller's responsibility to destroy it when it is no longer required.</p>
<p>If the current type vector does not represent a <em>vertex</em> normal surface (which may be the case when calling <a class="el" href="classregina_1_1NTreeSingleSoln.html#ab769e7a0e5ee062c2fe307070b370e28" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">NTreeSingleSoln::find()</a>), then there may be many normal surfaces all represented by the same type vector; in this case there are no further guarantees about <em>which</em> of these normal surfaces you will get.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a normal surface (though this need not be a vertex surface). This condition is always true after <a class="el" href="classregina_1_1NTreeEnumeration.html#a50f5b3548b81f4e445da493d99db7413" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">NTreeEnumeration::next()</a> or <a class="el" href="classregina_1_1NTreeSingleSoln.html#ab769e7a0e5ee062c2fe307070b370e28" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">NTreeSingleSoln::find()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1NTreeEnumeration.html#acb95eb8aa7af1c9f1e9c7142aa189fa1" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces...">NTreeEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with normal or almost normal surfaces. That is, the coordinate system passed to the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> constructor was not NS_ANGLE.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a normal surface that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a class="anchor" id="a51524015f75033c7888dcc3201421250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::constraintsBroken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully to the infrastructure for the search tree. </p>
<p>This query function is important because some constraints require additional preconditions on the underlying triangulation, and so these constraints cannot be added in some circumstances. If it is possible that the constraints might not be added successfully, this function should be tested as soon as the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> object has been created.</p>
<p>If the extra constraints were not added successfully, the search tree will be left in a consistent state but will give incorrect results (specifically, the extra constraints will be treated as zero functions).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the constraints were <em>not</em> added successfully, or <code>false</code> if the constraints were added successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f263c61b52bf21d5c5e1d87ee1572d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::dumpTypes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current type vector to the given output stream. </p>
<p>There will be no spaces between the types, and there will be no final newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0fb41f24688fc2367812c6ae67c35d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::feasibleBranches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system. </p>
<p>This will involve solving three or four linear programs, all based on the current state of the tableaux at the current level of the search tree. These assign 0, 1, 2 and 3 to the given quadrilateral or angle type in turn (here 0 is not used for angle types), and then enforce the corresponding constraints. For quadrilateral types, we count types 0 and 1 separately as in <a class="el" href="classregina_1_1NTreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">NTreeEnumeration</a>, not merged together as in <a class="el" href="classregina_1_1NTreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">NTreeSingleSoln</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given quadrilateral or angle type has not yet been processed in the search tree (i.e., it has not had an explicit value selected).</dd>
<dd>
When using angle structure coordinates, the final scaling coordinate has already been enforced as positive. (This is because, for angle structures, this routine does nothing to eliminate the zero solution.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadType</td><td>the quadrilateral or angle type to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of type values 0, 1, 2 or 3 that yield a feasible system; this will be between 0 and 4 inclusive for quadrilateral types, or between 0 and 3 inclusive for angle types. </dd></dl>

</div>
</div>
<a class="anchor" id="a89a7ce11bb8c1bb6d50b5c90c986c6e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nextUnmarkedTriangleType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next unmarked triangle type from a given starting point. </p>
<p>Specifically, this routine returns the first unmarked triangle type whose type number is greater than or equal to <em>startFrom</em>. For more information on marking, see the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes.</p>
<p>This routine simply searches through types by increasing index into the type vector; in particular, it does <em>not</em> make any use of the reordering defined by the <em>typeOrder_</em> array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>We are working in standard normal or almost normal coordinates. That is, the coordinate system passed to the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> constructor was one of NS_STANDARD or NS_AN_STANDARD.</dd>
<dd>
The argument <em>startFrom</em> is at least <em>nTets_</em> (i.e., it is at least as large as the index of the first triangle type).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startFrom</td><td>the index into the type vector of the triangle type from which we begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into the type vector of the next unmarked triangle type from <em>startFrom</em> onwards, or -1 if there are no more remaining. </dd></dl>

</div>
</div>
<a class="anchor" id="aabef77a7271fa34dacf2690fe6e5a266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nVisited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of nodes in the search tree that we have visited thus far in the tree traversal. </p>
<p>This figure might grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree.</p>
<p>This counts all nodes that we visit, including those that fail any or all of the domination, feasibility and zero tests. The precise way that this number is calculated is subject to change in future versions of Regina.</p>
<p>If you called an "all at once" routine such as <a class="el" href="classregina_1_1NTreeEnumeration.html#acb95eb8aa7af1c9f1e9c7142aa189fa1" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces...">NTreeEnumeration::run()</a> or <a class="el" href="classregina_1_1NTreeSingleSoln.html#ab769e7a0e5ee062c2fe307070b370e28" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">NTreeSingleSoln::find()</a>, then this will be the total number of nodes that were visited in the entire tree traversal. If you are calling an "incremental" routine such as <a class="el" href="classregina_1_1NTreeEnumeration.html#a50f5b3548b81f4e445da493d99db7413" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">NTreeEnumeration::next()</a> (i.e., you are generating one solution at time), then this will be the partial count of how many nodes have been visited so far.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes visited so far. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a6d23b2ac041415908e82eff3e4825f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::percent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree. </p>
<p>This is useful for progress tracking.</p>
<p>This routine only attemps to determine the percentage within a reasonable range of error (at the time of writing, 0.01%). This allows it to be more efficient (in particular, by only examining the branches closest to the root of the search tree).</p>
<dl class="section return"><dt>Returns</dt><dd>the percentage, as a number between 0 and 100 inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="ac630db8509b0dee69adc2d7052ab0037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::setNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges the search tree so that <em>nextType</em> becomes the next type that we process. </p>
<p>Specifically, this routine will set typeOrder_[level_ + 1] to <em>nextType_</em>, and will move other elements of typeOrder_ back by one position to make space as required.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>nextType</em> is in the range 0,...,<em>nTypes-1</em> inclusive. </dd>
<dd>
<em>nextType</em> is still waiting to be processed; that is, <em>nextType</em> does not appear in the list typeOrder_[0,...,level_].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextType</td><td>the next type to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a324ebfbacffada22c1f2fca8ce4c0c14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the given coordinate system is supported by this tree traversal infrastructure. </p>
<p>Currently this is true only for NS_STANDARD and NS_QUAD (for normal surfaces), NS_AN_STANDARD and NS_AN_QUAD_OCT (for almost normal surfaces), and NS_ANGLE (for taut angle structures). Any additional restrictions imposed by LPConstraint and BanConstraint will also be taken into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this coordinate system is supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d505fd11c2b2cfdc850591878c89ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NNormalSurface.html">NNormalSurface</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *&#160;</td>
          <td class="paramname"><em>matchingEqns</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that the given normal or almost normal surface satisfies the matching equations, as well as any additional constraints from the template parameter LPConstraint. </p>
<p>This routine is for use only with normal (or almost normal) surfaces, not angle structures.</p>
<p>This routine is provided for diagnostic, debugging and verification purposes.</p>
<p>Instead of using the initial tableaux to verify the matching equations, this routine goes back to the original matching equations matrix as constructed by <a class="el" href="group__hypersurface.html#ga839ed1e933b800f2622b465387a8b0e5" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a>. This ensures that the test is independent of any potential problems with the tableaux. You are not required to pass your own matching equations (if you don't, they will be temporarily reconstructed for you); however, you may pass your own if you wish to use a non-standard matching equation matrix, and/or reuse the same matrix to avoid the overhead of reconstructing it every time this routine is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The normal or almost normal surface <em>s</em> uses the same coordinate system as was passed to the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> constructor. Moreover, this coordinate system is in fact a normal or almost normal coordinate system (i.e., not NS_ANGLE).</dd>
<dd>
If <em>matchingEqns</em> is non-null, then the number of columns in <em>matchingEqns</em> is equal to the number of coordinates in the underlying normal or almost normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the normal surface to verify. </td></tr>
    <tr><td class="paramname">matchingEqns</td><td>the matching equations to check against the given surface; this may be 0, in which case the matching equations will be temporarily reconstructed for you using <a class="el" href="group__hypersurface.html#ga839ed1e933b800f2622b465387a8b0e5" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given surface passes all of the tests described above, or <code>false</code> if it fails one or more tests (indicating a problem or error). </dd></dl>

</div>
</div>
<a class="anchor" id="ad820dc7b5955ea5eb76e6e37afe243a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NAngleStructure.html">NAngleStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *&#160;</td>
          <td class="paramname"><em>angleEqns</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that the given angle structure satisfies the angle equations, as well as any additional constraints from the template parameter LPConstraint. </p>
<p>This routine is for use only with angle structures, not normal (or almost normal) surfaces.</p>
<p>This routine is provided for diagnostic, debugging and verification purposes.</p>
<p>Instead of using the initial tableaux to verify the angle equations, this routine goes back to the original angle equations matrix as constructed by <a class="el" href="classregina_1_1NAngleStructureVector.html#a31de94231554ab498cde04390b09f60e" title="Creates a new set of angle structure equations for the given triangulation.">NAngleStructureVector::makeAngleEquations()</a>. This ensures that the test is independent of any potential problems with the tableaux. You are not required to pass your own angle equations (if you don't, they will be temporarily reconstructed for you); however, you may pass your own if you wish to use a non-standard angle equation matrix, and/or reuse the same matrix to avoid the overhead of reconstructing it every time this routine is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coordinate system passed to the <a class="el" href="classregina_1_1NTreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">NTreeTraversal</a> constructor was NS_ANGLE.</dd>
<dd>
If <em>angleEqns</em> is non-null, then the number of columns in <em>angleEqns</em> is equal to the number of coordinates in the underlying angle structure coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the angle structure to verify. </td></tr>
    <tr><td class="paramname">angleEqns</td><td>the angle equations to check against the given angle structure; this may be 0, in which case the angle equations will be temporarily reconstructed for you using <a class="el" href="group__hypersurface.html#ga839ed1e933b800f2622b465387a8b0e5" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">NAngleStructureVector::makeMatchingEquations()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given angle structure passes all of the tests described above, or <code>false</code> if it fails one or more tests (indicating a problem or error). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a35e9d1a953b482fdf72ca353759fd7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coordinate system in which we are enumerating or searching for normal surfaces, almost normal surfaces, or taut angle structures. </p>
<p>This must be one of NS_QUAD or NS_STANDARD if we are only supporting normal surfaces, one of NS_AN_QUAD_OCT or NS_AN_STANDARD if we are allowing octagons in almost normal surfaces, or NS_ANGLE if we are searching for taut angle structures. </p>

</div>
</div>
<a class="anchor" id="a76c5be14e90013faf35b2a3153060dca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current level in the search tree. </p>
<p>As the search runs, this holds the index into typeOrder_ corresponding to the last type that we chose. </p>

</div>
</div>
<a class="anchor" id="a5d8917fcfd50205a3927ace7fba6c8dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, Integer&gt;* <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::lp_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores tableaux for linear programming at various nodes in the search tree. </p>
<p>We only store a limited number of tableaux at any given time, and as the search progresses we overwrite old tableaux with new tableaux.</p>
<p>More precisely, we store a linear number of tableaux, essentially corresponding to the current node in the search tree and all of its ancestores, all the way up to the root node. In addition to these tableaux, we also store other immediate children of these ancestores that we have pre-prepared for future processing. See the documentation within routines such as <a class="el" href="classregina_1_1NTreeEnumeration.html#a50f5b3548b81f4e445da493d99db7413" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">NTreeEnumeration::next()</a> for details of when and how these tableaux are constructed. </p>

</div>
</div>
<a class="anchor" id="a7e1d1d88e2352c530b1bf5e460b9a374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, Integer&gt;** <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::lpSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors. </p>
<p>This means we have one tableaux for the root node, as well as additional tableaux at each level 0,1,...,<em>level_</em>.</p>
<p>The array lpSlot_ indicates which element of the array <em>lp_</em> holds each of these tableaux. Specifically: lpSlot_[0] points to the tableaux for the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding tableaux is *lpSlot_[i+1]. Again, see the documentation within routines such as <a class="el" href="classregina_1_1NTreeEnumeration.html#a50f5b3548b81f4e445da493d99db7413" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">NTreeEnumeration::next()</a> for details of when and how these tableaux are constructed and later overwritten. </p>

</div>
</div>
<a class="anchor" id="a8b1ce5b7d0b1aeeb0de2fc1674f8b3cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, Integer&gt;** <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nextSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points to the next available tableaux in lp_ that is free to use at each level of the search tree. </p>
<p>Specifically: nextSlot_[0] points to the next free tableaux at the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding next free tableaux is *nextSlot_[i+1].</p>
<p>The precise layout of the nextSlot_ array depends on the order in which we process quadrilateral, triangle and/or angle types. </p>

</div>
</div>
<a class="anchor" id="a6cd706c4f0fb975f41f90acd2b12ec97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search. </p>

</div>
</div>
<a class="anchor" id="a926a58c8a4bf02411b13607936bc93b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nTets_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of tetrahedra in the underlying triangulation. </p>

</div>
</div>
<a class="anchor" id="a6392dcdeb79ed170600ba34804c6947b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nTypes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total length of a type vector. </p>

</div>
</div>
<a class="anchor" id="a16ec5bf166bb3911465e735f7d0b0800"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::nVisited_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the total number of nodes in the search tree that we have visited thus far. </p>
<p>This may grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree. </p>

</div>
</div>
<a class="anchor" id="af8aa736bb922dc618dd74942a94fe01f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::octLevel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level at which we are enforcing an octagon type (with a strictly positive number of octagons). </p>
<p>If we are working with angle structures or normal surfaces only (and so we do not allow octagons at all), then <em>octLevel_</em> = <em>nTypes_</em>. If we are allowing almost normal surfaces but we have not yet chosen an octagon type, then <em>octLevel_</em> = -1. </p>

</div>
</div>
<a class="anchor" id="addf50ccfd44b496cf86bb73bed1467d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt;LPConstraint&gt; <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::origTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins. </p>

</div>
</div>
<a class="anchor" id="ab71a4f97e49ccda99b03e6a1598fd9b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, Integer&gt; <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::tmpLP_[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary tableaux used by the function <a class="el" href="classregina_1_1NTreeTraversal.html#aa0fb41f24688fc2367812c6ae67c35d0" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree. </p>
<p>Other routines are welcome to use these temporary tableaux also (as "scratch space"); however, be aware that any call to <a class="el" href="classregina_1_1NTreeTraversal.html#aa0fb41f24688fc2367812c6ae67c35d0" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> will overwrite them. </p>

</div>
</div>
<a class="anchor" id="a9a713ce66641fe89993410eb8920a5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current working type vector. </p>
<p>As the search runs, we modify this type vector in-place. Any types beyond the current level in the search tree will always be set to zero. </p>

</div>
</div>
<a class="anchor" id="a535b2b029b0383a20940fa75f3f4f5f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1NTreeTraversal.html">regina::NTreeTraversal</a>&lt; LPConstraint, BanConstraint, Integer &gt;::typeOrder_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]]. </p>
<p>This permutation is allowed to change as the algorithm runs (though of course you can only change sections of the permutation that correspond to types not yet selected). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>enumerate/<a class="el" href="ntreetraversal_8h.html">ntreetraversal.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
