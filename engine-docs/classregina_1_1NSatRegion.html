<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NSatRegion Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1NSatRegion-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NSatRegion Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A large saturated region in a Seifert fibred space formed by joining together saturated blocks.  
 <a href="classregina_1_1NSatRegion.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/nsatregion.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NSatRegion:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NSatRegion.png" usemap="#regina::NSatRegion_map" alt=""/>
  <map id="regina::NSatRegion_map" name="regina::NSatRegion_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NSatRegion &gt;" shape="rect" coords="0,0,181,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab780b2a2fe3463d46329628e24cf44da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#ab780b2a2fe3463d46329628e24cf44da">NSatRegion</a> (<a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *starter)</td></tr>
<tr class="memdesc:ab780b2a2fe3463d46329628e24cf44da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new region containing just the given block.  <a href="#ab780b2a2fe3463d46329628e24cf44da">More...</a><br/></td></tr>
<tr class="separator:ab780b2a2fe3463d46329628e24cf44da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad106fc344c307ce7bc054f89dd607d52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#ad106fc344c307ce7bc054f89dd607d52">~NSatRegion</a> ()</td></tr>
<tr class="memdesc:ad106fc344c307ce7bc054f89dd607d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and all of its internal data, including the individual blocks that make up this region.  <a href="#ad106fc344c307ce7bc054f89dd607d52">More...</a><br/></td></tr>
<tr class="separator:ad106fc344c307ce7bc054f89dd607d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b21aa2f89baa9b20a890e57995442c0"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a3b21aa2f89baa9b20a890e57995442c0">numberOfBlocks</a> () const </td></tr>
<tr class="memdesc:a3b21aa2f89baa9b20a890e57995442c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated blocks that come together to form this saturated region.  <a href="#a3b21aa2f89baa9b20a890e57995442c0">More...</a><br/></td></tr>
<tr class="separator:a3b21aa2f89baa9b20a890e57995442c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e73378885456dd36494d41b544ff67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1NSatBlockSpec.html">NSatBlockSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a72e73378885456dd36494d41b544ff67">block</a> (unsigned long which) const </td></tr>
<tr class="memdesc:a72e73378885456dd36494d41b544ff67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested saturated block within this region.  <a href="#a72e73378885456dd36494d41b544ff67">More...</a><br/></td></tr>
<tr class="separator:a72e73378885456dd36494d41b544ff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b9209618e10199d7456fd59ac1226"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#acd7b9209618e10199d7456fd59ac1226">blockIndex</a> (const <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *<a class="el" href="classregina_1_1NSatRegion.html#a72e73378885456dd36494d41b544ff67">block</a>) const </td></tr>
<tr class="memdesc:acd7b9209618e10199d7456fd59ac1226"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the given block within this region.  <a href="#acd7b9209618e10199d7456fd59ac1226">More...</a><br/></td></tr>
<tr class="separator:acd7b9209618e10199d7456fd59ac1226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103998e954cce7b6ef98f0c691aec9e4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a103998e954cce7b6ef98f0c691aec9e4">numberOfBoundaryAnnuli</a> () const </td></tr>
<tr class="memdesc:a103998e954cce7b6ef98f0c691aec9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated annuli that together form the boundary components of this region.  <a href="#a103998e954cce7b6ef98f0c691aec9e4">More...</a><br/></td></tr>
<tr class="separator:a103998e954cce7b6ef98f0c691aec9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4319370c60d6a4b3b2543e45e7d53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a59a4319370c60d6a4b3b2543e45e7d53">boundaryAnnulus</a> (unsigned long which, bool &amp;blockRefVert, bool &amp;blockRefHoriz) const </td></tr>
<tr class="memdesc:a59a4319370c60d6a4b3b2543e45e7d53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested saturated annulus on the boundary of this region.  <a href="#a59a4319370c60d6a4b3b2543e45e7d53">More...</a><br/></td></tr>
<tr class="separator:a59a4319370c60d6a4b3b2543e45e7d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0e311ad3e522c48d576093f99f0f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a87c0e311ad3e522c48d576093f99f0f6">boundaryAnnulus</a> (unsigned long which, <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&amp;<a class="el" href="classregina_1_1NSatRegion.html#a72e73378885456dd36494d41b544ff67">block</a>, unsigned &amp;annulus, bool &amp;blockRefVert, bool &amp;blockRefHoriz) const </td></tr>
<tr class="memdesc:a87c0e311ad3e522c48d576093f99f0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> fine details of the requested saturated annulus on the boundary of this region.  <a href="#a87c0e311ad3e522c48d576093f99f0f6">More...</a><br/></td></tr>
<tr class="separator:a87c0e311ad3e522c48d576093f99f0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc45e63bd2ce67e9e82b2a3ee5dba35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a3dc45e63bd2ce67e9e82b2a3ee5dba35">createSFS</a> (bool reflect) const </td></tr>
<tr class="memdesc:a3dc45e63bd2ce67e9e82b2a3ee5dba35"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the Seifert fibred space represented by this region.  <a href="#a3dc45e63bd2ce67e9e82b2a3ee5dba35">More...</a><br/></td></tr>
<tr class="separator:a3dc45e63bd2ce67e9e82b2a3ee5dba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d179e094c9a86a76408f7f51c2e381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#af2d179e094c9a86a76408f7f51c2e381">createSFS</a> (long, bool reflect) const </td></tr>
<tr class="memdesc:af2d179e094c9a86a76408f7f51c2e381"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated version of the routine that returns details of the Seifert fibred space represented by this region.  <a href="#af2d179e094c9a86a76408f7f51c2e381">More...</a><br/></td></tr>
<tr class="separator:af2d179e094c9a86a76408f7f51c2e381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b77a4aa2a717190da0cfd99144901"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a269b77a4aa2a717190da0cfd99144901">expand</a> (<a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">NSatBlock::TetList</a> &amp;avoidTets, bool stopIfIncomplete=false)</td></tr>
<tr class="memdesc:a269b77a4aa2a717190da0cfd99144901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands this region as far as possible within the overall triangulation.  <a href="#a269b77a4aa2a717190da0cfd99144901">More...</a><br/></td></tr>
<tr class="separator:a269b77a4aa2a717190da0cfd99144901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9719960e7cec8da269c5f33014f8f628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a9719960e7cec8da269c5f33014f8f628">writeBlockAbbrs</a> (std::ostream &amp;out, bool tex=false) const </td></tr>
<tr class="memdesc:a9719960e7cec8da269c5f33014f8f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated list of blocks within this region to the given output stream.  <a href="#a9719960e7cec8da269c5f33014f8f628">More...</a><br/></td></tr>
<tr class="separator:a9719960e7cec8da269c5f33014f8f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ecdee2e8210bb40d294972095e3209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a54ecdee2e8210bb40d294972095e3209">writeDetail</a> (std::ostream &amp;out, const std::string &amp;title) const </td></tr>
<tr class="memdesc:a54ecdee2e8210bb40d294972095e3209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the composition of this region to the given output stream.  <a href="#a54ecdee2e8210bb40d294972095e3209">More...</a><br/></td></tr>
<tr class="separator:a54ecdee2e8210bb40d294972095e3209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed84dc3aa4ad665a6ae21c8a15b2d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a1ed84dc3aa4ad665a6ae21c8a15b2d5b">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1ed84dc3aa4ad665a6ae21c8a15b2d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a1ed84dc3aa4ad665a6ae21c8a15b2d5b">More...</a><br/></td></tr>
<tr class="separator:a1ed84dc3aa4ad665a6ae21c8a15b2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f699ab560220966fde8713a9cee4418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatRegion.html#a1f699ab560220966fde8713a9cee4418">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1f699ab560220966fde8713a9cee4418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a1f699ab560220966fde8713a9cee4418">More...</a><br/></td></tr>
<tr class="separator:a1f699ab560220966fde8713a9cee4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ab182c97fe654b8929d1fe41dc564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#aea0ab182c97fe654b8929d1fe41dc564">toString</a> () const</td></tr>
<tr class="memdesc:aea0ab182c97fe654b8929d1fe41dc564"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for str().  <a href="#aea0ab182c97fe654b8929d1fe41dc564">More...</a><br/></td></tr>
<tr class="separator:aea0ab182c97fe654b8929d1fe41dc564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f5abced4d1365c34980741b564765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#af32f5abced4d1365c34980741b564765">toStringLong</a> () const</td></tr>
<tr class="memdesc:af32f5abced4d1365c34980741b564765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for detail().  <a href="#af32f5abced4d1365c34980741b564765">More...</a><br/></td></tr>
<tr class="separator:af32f5abced4d1365c34980741b564765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A large saturated region in a Seifert fibred space formed by joining together saturated blocks. </p>
<p>Like a saturated block (described in the class <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a>), a saturated region is a connected set of tetrahedra built from a subset of fibres. Unlike a saturated block however, a saturated region has no constraints on its boundary - it may have several boundary components or it may have none. For instance, a saturated region might be an entire closed Seifert fibred space, or it might describe a Seifert fibred component of a JSJ decomposition.</p>
<p>A saturated region is formed from a collection of saturated blocks by joining the boundary annuli of these blocks together in pairs. The joins must be made so that the fibres are consistent, though it is allowable to reverse the directions of the fibres. There is no problem with joining two boundary annuli from the same block to each other.</p>
<p>Any boundary annulus of a block that is not joined to some other boundary annulus of a block becomes a boundary annulus of the entire region. In this way, each boundary component of the region (if there are any at all) is formed from a ring of boundary annuli, in the same way that the boundary of a block is. Note that the routine <a class="el" href="classregina_1_1NSatBlock.html#a9363cbf843199d800945b92828731a4b" title="Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part ...">NSatBlock::nextBoundaryAnnulus()</a> can be used to trace around a region boundary. Like block boundaries, the boundary of a saturated region need not be part of the boundary of the larger triangulation (i.e., there may be adjacent tetrahedra that are not recognised as part of this saturated structure).</p>
<p>The <a class="el" href="classregina_1_1NSatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks...">NSatRegion</a> class stores a list of its constituent blocks, but it does not directly store which block boundary annuli are joined to which. This adjacency information is stored within the blocks themselves; see the notes regarding adjacency in the <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> class description.</p>
<p>Blocks cannot be added to a region by hand. The way a region is constructed is by locating some initial block within a triangulation and passing this to the <a class="el" href="classregina_1_1NSatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks...">NSatRegion</a> constructor, and then by calling <a class="el" href="classregina_1_1NSatRegion.html#a269b77a4aa2a717190da0cfd99144901" title="Expands this region as far as possible within the overall triangulation.">expand()</a> to locate adjacent blocks and expand the region as far as possible. For locating initial blocks, the class <a class="el" href="classregina_1_1NSatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">NSatBlockStarterSearcher</a> may be of use.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is crucial that the adjacency information stored in the blocks is consistent with the region containing them. All this requires is that the blocks are not manipulated externally (e.g., <a class="el" href="classregina_1_1NSatBlock.html#a1faecdf3a0e5968c4a188cac242e894c" title="Lists the given saturated block as being adjacent to the given boundary annulus of this block...">NSatBlock::setAdjacent()</a> is not called on any of the blocks), but instead all adjacency information is managed by this class. Routines such as <a class="el" href="classregina_1_1NSatRegion.html#a269b77a4aa2a717190da0cfd99144901" title="Expands this region as far as possible within the overall triangulation.">expand()</a> which may add more blocks to the region will update the block adjacencies accordingly.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><em>Feature:</em> Have this class track the boundary components properly, with annuli grouped and oriented according to the region boundaries (as opposed to individual block boundaries). </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab780b2a2fe3463d46329628e24cf44da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSatRegion::NSatRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td>
          <td class="paramname"><em>starter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new region containing just the given block. </p>
<p>All boundary annuli of the given block will become boundary annuli of this region. It is guaranteed that this block will be stored in the region without any kind of reflection (see <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> for details).</p>
<p>Typically a region is initialised using this constructor, and then grown using the <a class="el" href="classregina_1_1NSatRegion.html#a269b77a4aa2a717190da0cfd99144901" title="Expands this region as far as possible within the overall triangulation.">expand()</a> routine. For help in finding an initial starter block, see the <a class="el" href="classregina_1_1NSatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">NSatBlockStarterSearcher</a> class.</p>
<p>This region will claim ownership of the given block, and upon destruction it will destroy this block also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given block has no adjacencies listed. That is, for every boundary annulus of the given block, <a class="el" href="classregina_1_1NSatBlock.html#abc1a892c758412c511e5f6fb62a68d18" title="Returns whether there is another saturated block listed as being adjacent to the given boundary annul...">NSatBlock::hasAdjacentBlock()</a> returns <code>false</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starter</td><td>the single block that this region will describe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad106fc344c307ce7bc054f89dd607d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSatRegion::~NSatRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and all of its internal data, including the individual blocks that make up this region. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a72e73378885456dd36494d41b544ff67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1NSatBlockSpec.html">NSatBlockSpec</a> &amp; regina::NSatRegion::block </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested saturated block within this region. </p>
<p>The information will returned will include structural information for the block, along with details of how the block is aligned (e.g., reflected vertically or horizontally) within the larger region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the constituent blocks should be returned; this must be between 0 and <a class="el" href="classregina_1_1NSatRegion.html#a3b21aa2f89baa9b20a890e57995442c0" title="Returns the number of saturated blocks that come together to form this saturated region.">numberOfBlocks()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested saturated block. </dd></dl>

</div>
</div>
<a class="anchor" id="acd7b9209618e10199d7456fd59ac1226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::NSatRegion::blockIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the given block within this region. </p>
<p>This index corresponds to the integer parameter that is passed to the routine <a class="el" href="classregina_1_1NSatRegion.html#a72e73378885456dd36494d41b544ff67" title="Returns details of the requested saturated block within this region.">block()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, since it simply scans through the blocks in this region one by one until the given block is found (or until all blocks are exhausted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given block (as an integer between 0 and <a class="el" href="classregina_1_1NSatRegion.html#a3b21aa2f89baa9b20a890e57995442c0" title="Returns the number of saturated blocks that come together to form this saturated region.">numberOfBlocks()</a>-1 inclusive), or -1 if the block is not part of this region. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a4319370c60d6a4b3b2543e45e7d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a>&amp; regina::NSatRegion::boundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested saturated annulus on the boundary of this region. </p>
<p>The saturated annuli that together form the boundary components of this region are numbered from 0 to <a class="el" href="classregina_1_1NSatRegion.html#a103998e954cce7b6ef98f0c691aec9e4" title="Returns the number of saturated annuli that together form the boundary components of this region...">numberOfBoundaryAnnuli()</a>-1 inclusive. The argument <em>which</em> specifies which one of these annuli should be returned.</p>
<p>Currently the annuli are numbered lexicographically by block and then by annulus number within the block, although this ordering is subject to change in future versions of Regina. In particular, the annuli are <em>not</em> necessarily numbered in order around the region boundaries, and each region boundary component might not even be given a consecutive range of numbers.</p>
<p>It is guaranteed however that, if the starter block passed to the <a class="el" href="classregina_1_1NSatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks...">NSatRegion</a> constructor provides any boundary annuli for the overall region, then the first such annulus in the starter block will be numbered 0 here.</p>
<p>The structure returned will be the annulus precisely as it appears within its particular saturated block. As discussed in the <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> class notes, the block might be reflected horizontally and/or vertically within the overall region, which will affect how the annulus is positioned as part of the overall region boundary (e.g., the annulus might be positioned upside-down in the overall region boundary, or it might be positioned with its second triangle appearing before its first triangle as one walks around the boundary). To account for this, the two boolean arguments <em>blockRefVert</em> and <em>blockRefHoriz</em> will be modified to indicate if and how the block is reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is quite slow, since it currently scans through every annulus of every saturated block. Use it sparingly!</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Both variants of <a class="el" href="classregina_1_1NSatRegion.html#a59a4319370c60d6a4b3b2543e45e7d53" title="Returns the requested saturated annulus on the boundary of this region.">boundaryAnnulus()</a> are combined into a single routine, which takes the integer <em>which</em> as its only argument and returns its results as a tuple. See the alternate version of <a class="el" href="classregina_1_1NSatRegion.html#a59a4319370c60d6a4b3b2543e45e7d53" title="Returns the requested saturated annulus on the boundary of this region.">boundaryAnnulus()</a> for details on how the return tuple is structured.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which boundary annulus of this region to return; this must be between 0 and <a class="el" href="classregina_1_1NSatRegion.html#a103998e954cce7b6ef98f0c691aec9e4" title="Returns the number of saturated annuli that together form the boundary components of this region...">numberOfBoundaryAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">blockRefVert</td><td>used to return whether the block containing the requested annulus is vertically reflected within this region (see <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> for details). This will be set to <code>true</code> if the block is vertically reflected, or <code>false</code> if not. </td></tr>
    <tr><td class="paramname">blockRefHoriz</td><td>used to return whether the block containing the requested annulus is horizontally reflected within this region (see <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> for details). This will be set to <code>true</code> if the block is horizontally reflected, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested boundary annulus, precisely as it appears within its particular saturated block. </dd></dl>

</div>
</div>
<a class="anchor" id="a87c0e311ad3e522c48d576093f99f0f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatRegion::boundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> fine details of the requested saturated annulus on the boundary of this region. </p>
<p>The argument <em>which</em> specifies which one of these annuli should be returned. See the boundaryAnnulus(unsigned long, bool&amp;, bool&amp;) documentation for details on how the boundary annuli are numbered.</p>
<p>Various details of the requested boundary annulus are returned in the various arguments, as described below.</p>
<p>Be aware that the block containing the requested annulus might be reflected horizontally and/or vertically within the overall region, as discussed in the <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> class notes. This will affect how the annulus is positioned as part of the overall region boundary (e.g., the annulus might be positioned upside-down in the overall region boundary, or it might be positioned with its second triangle appearing before its first triangle as one walks around the boundary). The two boolean arguments <em>blockRefVert</em> and <em>blockRefHoriz</em> will be modified to indicate if and how the block is reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is quite slow, since it currently scans through every annulus of every saturated block. Use it sparingly!</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This routine only takes a single argument (the integer <em>which</em>). The return value is a tuple of four values: the block returned in <em>block</em>, the integer returned in <em>annulus</em>, the boolean returned in <em>blockRefVert</em>, and the boolean returned in <em>blockRefHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which boundary annulus of this region to return; this must be between 0 and <a class="el" href="classregina_1_1NSatRegion.html#a103998e954cce7b6ef98f0c691aec9e4" title="Returns the number of saturated annuli that together form the boundary components of this region...">numberOfBoundaryAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">block</td><td>used to return the particular saturated block containing the requested annulus. </td></tr>
    <tr><td class="paramname">annulus</td><td>used to return which annulus number in the returned block is the requested annulus; this will be between 0 and block-&gt;nAnnuli() inclusive. </td></tr>
    <tr><td class="paramname">blockRefVert</td><td>used to return whether the block containing the requested annulus is vertically reflected within this region (see <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> for details). This will be set to <code>true</code> if the block is vertically reflected, or <code>false</code> if not. </td></tr>
    <tr><td class="paramname">blockRefHoriz</td><td>used to return whether the block containing the requested annulus is horizontally reflected within this region (see <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> for details). This will be set to <code>true</code> if the block is horizontally reflected, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dc45e63bd2ce67e9e82b2a3ee5dba35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a>* regina::NSatRegion::createSFS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the Seifert fibred space represented by this region. </p>
<p>Each boundary component of this region will be formed from a ring of saturated annuli, which together form a torus or a Klein bottle. For torus boundary components, the oriented curves representing the fibres and base orbifold on the boundary (see <a class="el" href="sfsnotation.html">Notation for Seifert fibred spaces</a>) will be as follows.</p>
<ul>
<li>Consider the 0/1/2 markings on the first and second triangles of each saturated annulus, as described in the <a class="el" href="structregina_1_1NSatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">NSatAnnulus</a> class notes.</li>
<li>The fibres are represented by the oriented edge joining markings 1 and 0 on the first triangle (or 0 and 1 on the second triangle). This is reversed if the block containing the boundary annulus is vertically reflected.</li>
<li>The curve representing the base orbifold run along the oriented edge joining markings 0 and 2 on the first triangle (or 2 and 0 on the second triangle). This is reversed if the block containing the boundary annulus is horizontally reflected.</li>
<li>See the <a class="el" href="structregina_1_1NSatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">NSatBlockSpec</a> overview for descriptions of horizontal and vertical reflection.</li>
</ul>
<p>If the argument <em>reflect</em> is <code>true</code>, the Seifert fibred space will be created as though the entire region had been reflected. In particular, each twist or exceptional fibre will be negated before being added to the Seifert structure.</p>
<p>For Klein bottle boundary components, these curves must (for now) be analysed by hand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflect</td><td><code>true</code> if this region is to be reflected as the Seifert fibred space is created, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created structure of the underlying Seifert fibred space. </dd></dl>

</div>
</div>
<a class="anchor" id="af2d179e094c9a86a76408f7f51c2e381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a> * regina::NSatRegion::createSFS </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated version of the routine that returns details of the Seifert fibred space represented by this region. </p>
<p>This is an old and now-deprecated version of <a class="el" href="classregina_1_1NSatRegion.html#a3dc45e63bd2ce67e9e82b2a3ee5dba35" title="Returns details of the Seifert fibred space represented by this region.">createSFS()</a>, which imposed additional preconditions (all boundary components had to be tori), and required the user to pass the number of boundary components as the first argument. This first argument is now ignored, and the preconditions have been relaxed to allow Klein bottle boundary components also.</p>
<p>See createSFS(bool), the new version of this routine, for further details.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000331">Deprecated:</a></b></dt><dd>This routine simply ignores the first argument, and passes the second argument through to createSFS(bool). Code should be changed to call createSFS(bool) directly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflect</td><td><code>true</code> if this region is to be reflected as the Seifert fibred space is created, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created structure of the underlying Seifert fibred space. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a269b77a4aa2a717190da0cfd99144901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatRegion::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">NSatBlock::TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopIfIncomplete</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands this region as far as possible within the overall triangulation. </p>
<p>This routine will hunt for new saturated blocks, and will also hunt for new adjacencies between existing blocks.</p>
<p>The first argument to this routine is the tetrahedron list <em>avoidTets</em>. This is a list of tetrahedra that will not be considered when examining potential new blocks. This list will be modified by this routine; in particular, it will be expanded to include all tetrahedra for any new blocks that are found. Before calling this routine it should contain tetrahedra for blocks already in this region, as discussed in the preconditions below.</p>
<p>It may be that you are searching for a region that fills an entire triangulation component (i.e., every boundary annulus of the region in fact forms part of the boundary of the triangulation). In this case you may pass the optional argument <em>stopIfIncomplete</em> as <code>true</code>. This means that if this routine ever discovers an annulus that is not part of the triangulation boundary and that it cannot match with some adjacent block, it will exit immediately and return <code>false</code>. Note that the region structure will be incomplete and/or inconsistent if this happens; in this case the unfinished region should be destroyed completely and never used.</p>
<p>For internal purposes, it should be noted that any new blocks that are discovered will be added to the end of the internal block list (thus the indices of existing blocks will not change).</p>
<dl class="section warning"><dt>Warning</dt><dd>When joining blocks together, it is possible to create invalid edges (e.g., by joining a one-annulus untwisted boundary to a one-annulus twisted boundary). This routine does <em>not</em> check for such conditions. It is recommended that you run <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4602a09cb4e9babf8d9bfd33031c6dc5" title="Determines if this triangulation is valid.">NTriangulation::isValid()</a> before calling this routine.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If any blocks already belonging to this region have adjacencies listed in their <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> structures, then these adjacent blocks belong to this region also. This precondition is easily satisfied if you let the <a class="el" href="classregina_1_1NSatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks...">NSatRegion</a> constructor and <a class="el" href="classregina_1_1NSatRegion.html#a269b77a4aa2a717190da0cfd99144901" title="Expands this region as far as possible within the overall triangulation.">expand()</a> do all of the adjacency handling, as described in the class notes. </dd>
<dd>
The list <em>avoidTets</em> includes all tetrahedra on the boundaries of any blocks already contained in this region.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The first argument <em>avoidTets</em> is not present. An empty list will be passed instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avoidTets</td><td>a list of tetrahedra that should not be considered for new blocks, as discussed above. Note that this list may be modified by this routine. </td></tr>
    <tr><td class="paramname">stopIfIncomplete</td><td><code>true</code> if you are filling an entire triangulation component with this region and you wish this routine to exit early if this is not possible, or <code>false</code> (the default) if you simply wish to expand this region as far as you can. See above for further discussion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the optional argument <em>stopIfIncomplete</em> was passed as <code>true</code> but expansion did not fill the entire triangulation component as described above, or <code>true</code> in all other cases. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b21aa2f89baa9b20a890e57995442c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NSatRegion::numberOfBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated blocks that come together to form this saturated region. </p>

</div>
</div>
<a class="anchor" id="a103998e954cce7b6ef98f0c691aec9e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NSatRegion::numberOfBoundaryAnnuli </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated annuli that together form the boundary components of this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0ab182c97fe654b8929d1fe41dc564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a> , false  &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for str(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000253">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type str() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="af32f5abced4d1365c34980741b564765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a> , false  &gt;::toStringLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for detail(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000254">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type detail() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a long text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatRegion.html">NSatRegion</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a9719960e7cec8da269c5f33014f8f628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatRegion::writeBlockAbbrs </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an abbreviated list of blocks within this region to the given output stream. </p>
<p>Blocks will be written using their abbreviated names, and these names will be separated by commas. See <a class="el" href="classregina_1_1NSatBlock.html#acd62b6809915e181af60b96f263957a2" title="Writes an abbreviated name or symbol for this block to the given output stream.">NSatBlock::writeAbbr()</a> for further details.</p>
<p>The blocks within this region will be sorted before their abbreviated names are output. The particular method of sorting is an arbitrary aesthetic decision on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54ecdee2e8210bb40d294972095e3209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatRegion::writeDetail </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes details of the composition of this region to the given output stream. </p>
<p>The output will consist of several lines. The first line will contain the title string (passed as a separate argument to this routine), followed by a colon. Following this will be a number of lines describing the individual blocks that make up this region and the various adjacencies between them.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">title</td><td>the name of this region, to be written on the first line of output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f699ab560220966fde8713a9cee4418"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatRegion::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ed84dc3aa4ad665a6ae21c8a15b2d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatRegion::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="nsatregion_8h.html">nsatregion.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
