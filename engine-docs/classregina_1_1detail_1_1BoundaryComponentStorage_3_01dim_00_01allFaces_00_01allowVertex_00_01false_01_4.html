<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="namespaceregina_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4.html">BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__detail.html">Implementation details</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class that manages all data storage for a boundary component of a <em>dim</em>-dimensional triangulation.  
 <a href="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4.html#details">More...</a></p>

<p><code>#include &lt;triangulation/detail/boundarycomponent.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4.png" usemap="#regina::detail::BoundaryComponentStorage_3C_20dim_2C_20allFaces_2C_20allowVertex_2C_20false_20_3E_map" alt=""/>
  <map id="regina::detail::BoundaryComponentStorage_3C_20dim_2C_20allFaces_2C_20allowVertex_2C_20false_20_3E_map" name="regina::detail::BoundaryComponentStorage_3C_20dim_2C_20allFaces_2C_20allowVertex_2C_20false_20_3E_map">
<area href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html" alt="regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex &gt;" shape="rect" coords="535,168,1060,192"/>
<area href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html" alt="regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces &gt;" shape="rect" coords="535,112,1060,136"/>
<area href="classregina_1_1detail_1_1WeakFaceListSuite.html" alt="regina::detail::WeakFaceListSuite&lt; dim, dim - 1 &gt;" shape="rect" coords="0,56,525,80"/>
<area href="classregina_1_1alias_1_1FacesOfTriangulation.html" alt="regina::alias::FacesOfTriangulation&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, dim &gt;" shape="rect" coords="535,56,1060,80"/>
<area href="classregina_1_1alias_1_1FaceOfTriangulation.html" alt="regina::alias::FaceOfTriangulation&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, dim &gt;" shape="rect" coords="1070,56,1595,80"/>
<area href="classregina_1_1detail_1_1WeakFaceList.html" title="Internal class that stores all subdim-faces in a component or boundary component of a dim-dimensional..." alt="regina::detail::WeakFaceList&lt; dim, subdim &gt;" shape="rect" coords="0,0,525,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga61771dae69054fc0c9bb42a5966916de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga61771dae69054fc0c9bb42a5966916de">isReal</a> () const</td></tr>
<tr class="memdesc:ga61771dae69054fc0c9bb42a5966916de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is real.  <a href="group__detail.html#ga61771dae69054fc0c9bb42a5966916de">More...</a><br /></td></tr>
<tr class="separator:ga61771dae69054fc0c9bb42a5966916de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbc78362654ae62c31e3a2707d131e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9">isIdeal</a> () const</td></tr>
<tr class="memdesc:gaabbc78362654ae62c31e3a2707d131e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is ideal.  <a href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9">More...</a><br /></td></tr>
<tr class="separator:gaabbc78362654ae62c31e3a2707d131e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d">isInvalidVertex</a> () const</td></tr>
<tr class="memdesc:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component consists of a single invalid vertex and nothing else.  <a href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d">More...</a><br /></td></tr>
<tr class="separator:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68da49bd858b8b7f9016b7824bd7489f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga68da49bd858b8b7f9016b7824bd7489f">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga68da49bd858b8b7f9016b7824bd7489f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#ga68da49bd858b8b7f9016b7824bd7489f">More...</a><br /></td></tr>
<tr class="separator:ga68da49bd858b8b7f9016b7824bd7489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56261b6f8f242d925a03de69db78f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf56261b6f8f242d925a03de69db78f35">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf56261b6f8f242d925a03de69db78f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#gaf56261b6f8f242d925a03de69db78f35">More...</a><br /></td></tr>
<tr class="separator:gaf56261b6f8f242d925a03de69db78f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483ae78a8682ebace035a95c4e1eac12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12">size</a> () const</td></tr>
<tr class="memdesc:ga483ae78a8682ebace035a95c4e1eac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12">More...</a><br /></td></tr>
<tr class="separator:ga483ae78a8682ebace035a95c4e1eac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaaa1b9175365dfc003ea3ef238ec1fb5a">countRidges</a> () const</td></tr>
<tr class="memdesc:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of (<em>dim</em>-2)-faces in this boundary component.  <a href="group__detail.html#gaaa1b9175365dfc003ea3ef238ec1fb5a">More...</a><br /></td></tr>
<tr class="separator:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9">countFaces</a> () const</td></tr>
<tr class="memdesc:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this boundary component.  <a href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9">More...</a><br /></td></tr>
<tr class="separator:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133608401c59bc96e1bbc7e2785ed72d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga133608401c59bc96e1bbc7e2785ed72d">facets</a> () const</td></tr>
<tr class="memdesc:ga133608401c59bc96e1bbc7e2785ed72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#ga133608401c59bc96e1bbc7e2785ed72d">More...</a><br /></td></tr>
<tr class="separator:ga133608401c59bc96e1bbc7e2785ed72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1ed8ba830f6428fba6cd71b4e9e8f58d">faces</a> () const</td></tr>
<tr class="memdesc:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all <em>subdim</em>-faces in this boundary component.  <a href="group__detail.html#ga1ed8ba830f6428fba6cd71b4e9e8f58d">More...</a><br /></td></tr>
<tr class="separator:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf700895bba89bdb331ae7f0a0958d947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf700895bba89bdb331ae7f0a0958d947">facet</a> (size_t index) const</td></tr>
<tr class="memdesc:gaf700895bba89bdb331ae7f0a0958d947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested (<em>dim</em>-1)-face in this boundary component.  <a href="group__detail.html#gaf700895bba89bdb331ae7f0a0958d947">More...</a><br /></td></tr>
<tr class="separator:gaf700895bba89bdb331ae7f0a0958d947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">face</a> (size_t index) const</td></tr>
<tr class="memdesc:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face in this boundary component.  <a href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">More...</a><br /></td></tr>
<tr class="separator:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5035b1f08320755fa39468231aaab0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf5035b1f08320755fa39468231aaab0f">triangulation</a> () const</td></tr>
<tr class="memdesc:gaf5035b1f08320755fa39468231aaab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation to which this boundary component belongs.  <a href="group__detail.html#gaf5035b1f08320755fa39468231aaab0f">More...</a><br /></td></tr>
<tr class="separator:gaf5035b1f08320755fa39468231aaab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002ba14e514d4bfc13d110bb03a8855a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga002ba14e514d4bfc13d110bb03a8855a">component</a> () const</td></tr>
<tr class="memdesc:ga002ba14e514d4bfc13d110bb03a8855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component of the triangulation to which this boundary component belongs.  <a href="group__detail.html#ga002ba14e514d4bfc13d110bb03a8855a">More...</a><br /></td></tr>
<tr class="separator:ga002ba14e514d4bfc13d110bb03a8855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga2f4309f2e7b617da85e6585e198dab58"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2f4309f2e7b617da85e6585e198dab58">canBuild</a> = false</td></tr>
<tr class="memdesc:ga2f4309f2e7b617da85e6585e198dab58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class supports triangulating boundary components.  <a href="group__detail.html#ga2f4309f2e7b617da85e6585e198dab58">More...</a><br /></td></tr>
<tr class="separator:ga2f4309f2e7b617da85e6585e198dab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2259be5e070ee6a88808f21026a8e2e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a></td></tr>
<tr class="memdesc:gae2259be5e070ee6a88808f21026a8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class.  <a href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">More...</a><br /></td></tr>
<tr class="separator:gae2259be5e070ee6a88808f21026a8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695616fda7f4a0360ce6b94458a879c8"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a></td></tr>
<tr class="memdesc:ga695616fda7f4a0360ce6b94458a879c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>).  <a href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">More...</a><br /></td></tr>
<tr class="separator:ga695616fda7f4a0360ce6b94458a879c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8d3a55fb04716f4fdb002e4bdf5ae88f">buildVertexLink</a> () const</td></tr>
<tr class="memdesc:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates the vertex link for an ideal or invalid vertex boundary component.  <a href="group__detail.html#ga8d3a55fb04716f4fdb002e4bdf5ae88f">More...</a><br /></td></tr>
<tr class="separator:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga433519f91dc8bb5feab3fae9ba1d7f9c">push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *<a class="el" href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">face</a>)</td></tr>
<tr class="memdesc:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component.  <a href="group__detail.html#ga433519f91dc8bb5feab3fae9ba1d7f9c">More...</a><br /></td></tr>
<tr class="separator:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95037dfb38a8f7488908cfa84649111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae95037dfb38a8f7488908cfa84649111">reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *tri) const</td></tr>
<tr class="memdesc:gae95037dfb38a8f7488908cfa84649111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way.  <a href="group__detail.html#gae95037dfb38a8f7488908cfa84649111">More...</a><br /></td></tr>
<tr class="separator:gae95037dfb38a8f7488908cfa84649111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73becf4d57e83b9199775bc9b1378fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga73becf4d57e83b9199775bc9b1378fae">reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *tri, const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;tridimFaces) const</td></tr>
<tr class="memdesc:ga73becf4d57e83b9199775bc9b1378fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way.  <a href="group__detail.html#ga73becf4d57e83b9199775bc9b1378fae">More...</a><br /></td></tr>
<tr class="separator:ga73becf4d57e83b9199775bc9b1378fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ga7a9e624f86239df884711385ff208eb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7a9e624f86239df884711385ff208eb2">faces_</a></td></tr>
<tr class="memdesc:ga7a9e624f86239df884711385ff208eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of faces.  <a href="group__detail.html#ga7a9e624f86239df884711385ff208eb2">More...</a><br /></td></tr>
<tr class="separator:ga7a9e624f86239df884711385ff208eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, bool allFaces, bool allowVertex&gt;<br />
class regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt;</h3>

<p>Helper class that manages all data storage for a boundary component of a <em>dim</em>-dimensional triangulation. </p>
<p>See the general <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html" title="Helper class that manages all data storage for a boundary component of a dim-dimensional triangulatio...">BoundaryComponentStorage</a> template notes for further details.</p>
<p>This specialisation is used for dimensions in which you cannot triangulate boundary components (i.e., dimension 2). It therefore removes the member functions that work with boundary component triangulations. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ga8d3a55fb04716f4fdb002e4bdf5ae88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3a55fb04716f4fdb002e4bdf5ae88f">&#9670;&nbsp;</a></span>buildVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::buildVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates the vertex link for an ideal or invalid vertex boundary component. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulated vertex link. </dd></dl>

</div>
</div>
<a id="ga002ba14e514d4bfc13d110bb03a8855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002ba14e514d4bfc13d110bb03a8855a">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this boundary component. </dd></dl>

</div>
</div>
<a id="ga8cf61d217e99a5ae34d7b5d4f7c427e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cf61d217e99a5ae34d7b5d4f7c427e9">&#9670;&nbsp;</a></span>countFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this boundary component. </p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="gaaa1b9175365dfc003ea3ef238ec1fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1b9175365dfc003ea3ef238ec1fb5a">&#9670;&nbsp;</a></span>countRidges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::countRidges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-2)-faces in this boundary component. </p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-2)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="ga7eeb9248ad6e7c14665825dba89e57e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eeb9248ad6e7c14665825dba89e57e5">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face in this boundary component. </p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each <em>subdim</em>-face in this boundary component will match the index of the corresponding <em>subdim</em>-face in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9" title="Returns the number of subdim-faces in this boundary component.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ga1ed8ba830f6428fba6cd71b4e9e8f58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed8ba830f6428fba6cd71b4e9e8f58d">&#9670;&nbsp;</a></span>faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all <em>subdim</em>-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the boundary component. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="gaf700895bba89bdb331ae7f0a0958d947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf700895bba89bdb331ae7f0a0958d947">&#9670;&nbsp;</a></span>facet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::facet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested (<em>dim</em>-1)-face in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each (<em>dim</em>-1)-face in this boundary component will match the index of the corresponding top-dimensional simplex in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12" title="Returns the number of (dim-1)-faces in this boundary component.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ga133608401c59bc96e1bbc7e2785ed72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133608401c59bc96e1bbc7e2785ed72d">&#9670;&nbsp;</a></span>facets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all (<em>dim</em>-1)-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all (<em>dim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="gaabbc78362654ae62c31e3a2707d131e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbc78362654ae62c31e3a2707d131e9">&#9670;&nbsp;</a></span>isIdeal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is ideal. </p>
<p>This is the case if and only if it consists of a single ideal vertex and no faces of any other dimensions.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of ideal boundary components, which can only occur in dimensions &ge; 3, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>Note that a boundary component formed from a single <em>invalid</em> vertex is <em>not</em> considered to be ideal. This means that, if a boundary component contains no faces of positive dimension, then one and only one of <a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9" title="Determines if this boundary component is ideal.">isIdeal()</a> and <a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d" title="Determines if this boundary component consists of a single invalid vertex and nothing else.">isInvalidVertex()</a> will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is ideal. </dd></dl>

</div>
</div>
<a id="gab697465cdf1282c9ae1e4ed54b9d359d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab697465cdf1282c9ae1e4ed54b9d359d">&#9670;&nbsp;</a></span>isInvalidVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isInvalidVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component consists of a single invalid vertex and nothing else. </p>
<p>In particular, such a boundary component must contain no faces of any positive dimension.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of invalid vertex boundary components, which can only occur in dimensions &ge; 4, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>An invalid vertex is only placed in its own boundary component if it does not already belong to some larger boundary component (for instance, if its link is an ideal (<em>dim</em>-1)-manifold triangulation). This means that, for a boundary component consisting of one or more (<em>dim</em>-1)-faces, this routine will return <code>false</code> even if the boundary component also includes one or more invalid vertices.</p>
<p>Note that, if a boundary component contains no faces of positive dimension, then one and only one of <a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9" title="Determines if this boundary component is ideal.">isIdeal()</a> and <a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d" title="Determines if this boundary component consists of a single invalid vertex and nothing else.">isInvalidVertex()</a> will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component consists of a single invalid vertex and nothing else. </dd></dl>

</div>
</div>
<a id="ga61771dae69054fc0c9bb42a5966916de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61771dae69054fc0c9bb42a5966916de">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is real. </p>
<p>This is the case if and only if it is formed from one or more (dim-1)-faces.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of real, ideal, and invalid vertex boundary components.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. (In other dimensions, real boundary components are the only types of boundary component that Regina will recognise.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is real. </dd></dl>

</div>
</div>
<a id="ga433519f91dc8bb5feab3fae9ba1d7f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433519f91dc8bb5feab3fae9ba1d7f9c">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component. </p>
<p>This class does not take ownership of the given face.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to append. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the face to append to the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae95037dfb38a8f7488908cfa84649111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95037dfb38a8f7488908cfa84649111">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way. </p>
<p>This affects all faces of dimensions 0,...,(<em>dim</em>-2).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a real boundary component. </dd>
<dd>
<em>tri</em> is a triangulation of this boundary component. </dd>
<dd>
For each <em>i</em>, the <em>i</em>th top-dimensional simplex of <em>tri</em> corresponds to the <em>i</em>th (<em>dim</em>-1)-face of this boundary component, and has its vertices 0,...,(<em>dim</em>-1) labelled in the same way.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a triangulation of this boundary component, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73becf4d57e83b9199775bc9b1378fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73becf4d57e83b9199775bc9b1378fae">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1WeakFaceListSuite.html">regina::detail::WeakFaceListSuite</a>&lt; dim, subdim &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tridimFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way. </p>
<dl class="section pre"><dt>Precondition</dt><dd>For each dimension <em>k</em> = 0,...,<em>subdim</em>, the <em>k</em>-faces of the given triangulation <em>tri</em> are in one-to-one correspondence with the <em>k</em>-faces in this suite, though not necessarily in the same order. Moreover, for each <em>i</em> and <em>j</em>, this correspondence maps the <em>i</em>th <em>k</em>-face of <code>tri-&gt;simplex(j)</code> to the <em>i</em>th <em>k</em>-face of <code>tridimFaces[j]</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tridim</td><td>the dimension of the given triangulation. This must be strictly larger than <em>subdim</em>, but it need not be equal to <em>dim</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a <em>tridim</em>-dimensional triangulation, as described above. </td></tr>
    <tr><td class="paramname">tridimFaces</td><td>a list of <em>tridim</em>-faces that together contain all of the faces in this suite, and that are in an <em>ordered</em> one-to-one correspondence with the top-dimensional simplices of <em>tri</em> as described in the precondition above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga483ae78a8682ebace035a95c4e1eac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483ae78a8682ebace035a95c4e1eac12">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-1)-faces in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-1)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="gaf5035b1f08320755fa39468231aaab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5035b1f08320755fa39468231aaab0f">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this boundary component. </dd></dl>

</div>
</div>
<a id="gaf56261b6f8f242d925a03de69db78f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56261b6f8f242d925a03de69db78f35">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68da49bd858b8b7f9016b7824bd7489f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68da49bd858b8b7f9016b7824bd7489f">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ga695616fda7f4a0360ce6b94458a879c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695616fda7f4a0360ce6b94458a879c8">&#9670;&nbsp;</a></span>allFaces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::allFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>). </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="gae2259be5e070ee6a88808f21026a8e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2259be5e070ee6a88808f21026a8e2e">&#9670;&nbsp;</a></span>allowVertex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::allowVertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/detail/<a class="el" href="triangulation_2detail_2boundarycomponent_8h.html">boundarycomponent.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
