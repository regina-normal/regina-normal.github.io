<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::GluingPerms&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1GluingPerms-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::GluingPerms&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a specific set of gluing permutations to complement a particular pairwise matching of simplex facets.  
 <a href="classregina_1_1GluingPerms.html#details">More...</a></p>

<p><code>#include &lt;census/gluingperms.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66b25211be46c5f7f46f4a2fb0750e21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a66b25211be46c5f7f46f4a2fb0750e21">GluingPerms</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a66b25211be46c5f7f46f4a2fb0750e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of gluing permutations that is a clone of the given permutation set.  <a href="#a66b25211be46c5f7f46f4a2fb0750e21">More...</a><br/></td></tr>
<tr class="separator:a66b25211be46c5f7f46f4a2fb0750e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb274fddfacdad1fbe870fa0dba57a51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#acb274fddfacdad1fbe870fa0dba57a51">GluingPerms</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:acb274fddfacdad1fbe870fa0dba57a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new set of gluing permutations from the given input stream.  <a href="#acb274fddfacdad1fbe870fa0dba57a51">More...</a><br/></td></tr>
<tr class="separator:acb274fddfacdad1fbe870fa0dba57a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d584bf4ffb32f2227db4310fd12997e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a5d584bf4ffb32f2227db4310fd12997e">~GluingPerms</a> ()</td></tr>
<tr class="memdesc:a5d584bf4ffb32f2227db4310fd12997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any memory used by this structure.  <a href="#a5d584bf4ffb32f2227db4310fd12997e">More...</a><br/></td></tr>
<tr class="separator:a5d584bf4ffb32f2227db4310fd12997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bbad418f06f4822634038eb2a7de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#ab5bbad418f06f4822634038eb2a7de95">inputError</a> () const </td></tr>
<tr class="memdesc:ab5bbad418f06f4822634038eb2a7de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="#ab5bbad418f06f4822634038eb2a7de95">More...</a><br/></td></tr>
<tr class="separator:ab5bbad418f06f4822634038eb2a7de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a6a2bb95b2c9ea1c28e2f4091dcbceb66">size</a> () const </td></tr>
<tr class="memdesc:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of simplices under consideration.  <a href="#a6a2bb95b2c9ea1c28e2f4091dcbceb66">More...</a><br/></td></tr>
<tr class="separator:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb120711ed73fb165bbe248a34301d46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#acb120711ed73fb165bbe248a34301d46">facetPairing</a> () const </td></tr>
<tr class="memdesc:acb120711ed73fb165bbe248a34301d46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#acb120711ed73fb165bbe248a34301d46">More...</a><br/></td></tr>
<tr class="separator:acb120711ed73fb165bbe248a34301d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca21023c088994b0c1caeb968f995f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e">gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:aca21023c088994b0c1caeb968f995f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet.  <a href="#aca21023c088994b0c1caeb968f995f4e">More...</a><br/></td></tr>
<tr class="separator:aca21023c088994b0c1caeb968f995f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34072afb49329d499c028cf843579bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a34072afb49329d499c028cf843579bea">gluingPerm</a> (unsigned simp, unsigned facet) const </td></tr>
<tr class="memdesc:a34072afb49329d499c028cf843579bea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet.  <a href="#a34072afb49329d499c028cf843579bea">More...</a><br/></td></tr>
<tr class="separator:a34072afb49329d499c028cf843579bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#adc5cc3bc26c026b9ab9a82a44ded003c">triangulate</a> () const </td></tr>
<tr class="memdesc:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="#adc5cc3bc26c026b9ab9a82a44ded003c">More...</a><br/></td></tr>
<tr class="separator:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029524ff940df5de09e02f3ee77e6ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#ac029524ff940df5de09e02f3ee77e6ca">dumpData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac029524ff940df5de09e02f3ee77e6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="#ac029524ff940df5de09e02f3ee77e6ca">More...</a><br/></td></tr>
<tr class="separator:ac029524ff940df5de09e02f3ee77e6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a747d7a252a077b329e1411c137d220d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a747d7a252a077b329e1411c137d220d6">GluingPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *pairing)</td></tr>
<tr class="memdesc:a747d7a252a077b329e1411c137d220d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new permutation set.  <a href="#a747d7a252a077b329e1411c137d220d6">More...</a><br/></td></tr>
<tr class="separator:a747d7a252a077b329e1411c137d220d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f6711eb803742af936b68a0680888f"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a28f6711eb803742af936b68a0680888f">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a28f6711eb803742af936b68a0680888f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a28f6711eb803742af936b68a0680888f">More...</a><br/></td></tr>
<tr class="separator:a28f6711eb803742af936b68a0680888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aa1eb17b2d09a1fc64176b5eda1e057e4">permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#aa1eb17b2d09a1fc64176b5eda1e057e4">More...</a><br/></td></tr>
<tr class="separator:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#abaa4fd5a9fa072efe8318ebe6fef632f">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const </td></tr>
<tr class="memdesc:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#abaa4fd5a9fa072efe8318ebe6fef632f">More...</a><br/></td></tr>
<tr class="separator:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae534308e45fc5d77400f393646b93c"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a1ae534308e45fc5d77400f393646b93c">permIndex</a> (unsigned simp, unsigned facet) const </td></tr>
<tr class="memdesc:a1ae534308e45fc5d77400f393646b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a1ae534308e45fc5d77400f393646b93c">More...</a><br/></td></tr>
<tr class="separator:a1ae534308e45fc5d77400f393646b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638cd32d383ca0c0517331eb3536f0db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a638cd32d383ca0c0517331eb3536f0db">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const </td></tr>
<tr class="memdesc:a638cd32d383ca0c0517331eb3536f0db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a638cd32d383ca0c0517331eb3536f0db">More...</a><br/></td></tr>
<tr class="separator:a638cd32d383ca0c0517331eb3536f0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7826914d40eab7cbb40c92f64dc84869"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a7826914d40eab7cbb40c92f64dc84869">gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const </td></tr>
<tr class="memdesc:a7826914d40eab7cbb40c92f64dc84869"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a7826914d40eab7cbb40c92f64dc84869">More...</a><br/></td></tr>
<tr class="separator:a7826914d40eab7cbb40c92f64dc84869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0b9eff3280d05b7bb1be971f3b202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#abec0b9eff3280d05b7bb1be971f3b202">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, int index) const </td></tr>
<tr class="memdesc:abec0b9eff3280d05b7bb1be971f3b202"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1.  <a href="#abec0b9eff3280d05b7bb1be971f3b202">More...</a><br/></td></tr>
<tr class="separator:abec0b9eff3280d05b7bb1be971f3b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd48b741abeb1822f9c5a172dbcf1594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#acd48b741abeb1822f9c5a172dbcf1594">indexToGluing</a> (unsigned simp, unsigned facet, int index) const </td></tr>
<tr class="memdesc:acd48b741abeb1822f9c5a172dbcf1594"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1.  <a href="#acd48b741abeb1822f9c5a172dbcf1594">More...</a><br/></td></tr>
<tr class="separator:acd48b741abeb1822f9c5a172dbcf1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad9fb5bb6ec20f8822927d49c100738e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#ad9fb5bb6ec20f8822927d49c100738e5">pairing_</a></td></tr>
<tr class="memdesc:ad9fb5bb6ec20f8822927d49c100738e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="#ad9fb5bb6ec20f8822927d49c100738e5">More...</a><br/></td></tr>
<tr class="separator:ad9fb5bb6ec20f8822927d49c100738e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae038d32acaf9c1fc1f086dc8a344417"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aae038d32acaf9c1fc1f086dc8a344417">permIndices_</a></td></tr>
<tr class="memdesc:aae038d32acaf9c1fc1f086dc8a344417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="#aae038d32acaf9c1fc1f086dc8a344417">More...</a><br/></td></tr>
<tr class="separator:aae038d32acaf9c1fc1f086dc8a344417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a4df91f50200ff5d6e76ede8c123e8ce6">inputError_</a></td></tr>
<tr class="memdesc:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="#a4df91f50200ff5d6e76ede8c123e8ce6">More...</a><br/></td></tr>
<tr class="separator:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br/>
class regina::GluingPerms&lt; dim &gt;</h3>

<p>Represents a specific set of gluing permutations to complement a particular pairwise matching of simplex facets. </p>
<p>Given a pairwise matching of facets (as described by class <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing&lt;dim&gt;</a>), each facet that is matched with some other facet will have an associated permutation of (<em>dim</em> + 1) elements.</p>
<p>If a facet is matched with some other facet, the two associated permutations in this set will be inverses. If a facet is left deliberately unmatched, it will have no associated permutation in this set.</p>
<p>Such a set of permutations models part of the structure of a triangulation, in which each simplex facet that is glued to another facet has a corresponding gluing permutation (and the matched facet has the inverse gluing permutation).</p>
<dl class="section user"><dt>Headers:</dt><dd>Parts of this template class are implemented in a separate header (gluingperms-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not available.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation that is being modelled. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a66b25211be46c5f7f46f4a2fb0750e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of gluing permutations that is a clone of the given permutation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the gluing permutations to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb274fddfacdad1fbe870fa0dba57a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a new set of gluing permutations from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="classregina_1_1GluingPerms.html#ac029524ff940df5de09e02f3ee77e6ca" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="classregina_1_1GluingPerms.html#ab5bbad418f06f4822634038eb2a7de95" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d584bf4ffb32f2227db4310fd12997e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates any memory used by this structure. </p>

</div>
</div>
<a class="anchor" id="a747d7a252a077b329e1411c137d220d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new permutation set. </p>
<p>All internal arrays will be allocated but not initialised.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of simplex facets that this permutation set will complement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac029524ff940df5de09e02f3ee77e6ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#a668660f0451a7a878f848aebd6aa7994">regina::HyperbolicMinSearcher</a>, <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html#af2705d6cc7353a67b2ea0778824e3665">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1CompactSearcher.html#abc1389bf509ca49fa54b05fa9f144f31">regina::CompactSearcher</a>, <a class="el" href="classregina_1_1EulerSearcher.html#aeee0fc2f765084aa0a57723ea97e5c9e">regina::EulerSearcher</a>, <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html#af0c56c08309b8cff169874f6a0fae344">regina::GluingPermSearcher&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#acdadca6d757abea29b35eac4b3e59133">regina::GluingPermSearcher&lt; 3 &gt;</a>, and <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a4b9f9dee5c22c5137f1ac8aeb9a61d6f">regina::GluingPermSearcher&lt; 2 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acb120711ed73fb165bbe248a34301d46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; * <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::facetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="aca21023c088994b0c1caeb968f995f4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="classregina_1_1GluingPerms.html#acb120711ed73fb165bbe248a34301d46" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements...">facetPairing()</a>). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a34072afb49329d499c028cf843579bea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="classregina_1_1GluingPerms.html#acb120711ed73fb165bbe248a34301d46" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements...">facetPairing()</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a638cd32d383ca0c0517331eb3536f0db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a7826914d40eab7cbb40c92f64dc84869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="abec0b9eff3280d05b7bb1be971f3b202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="acd48b741abeb1822f9c5a172dbcf1594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bbad418f06f4822634038eb2a7de95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a28f6711eb803742af936b68a0680888f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1eb17b2d09a1fc64176b5eda1e057e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa4fd5a9fa072efe8318ebe6fef632f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae534308e45fc5d77400f393646b93c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a2bb95b2c9ea1c28e2f4091dcbceb66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5cc3bc26c026b9ab9a82a44ded003c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4df91f50200ff5d6e76ede8c123e8ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a class="anchor" id="ad9fb5bb6ec20f8822927d49c100738e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a class="anchor" id="aae038d32acaf9c1fc1f086dc8a344417"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines <a class="el" href="classregina_1_1GluingPerms.html#a638cd32d383ca0c0517331eb3536f0db" title="Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the...">gluingToIndex()</a> and <a class="el" href="classregina_1_1GluingPerms.html#abec0b9eff3280d05b7bb1be971f3b202" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingperms_8h.html">gluingperms.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
