<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::BoundaryComponent&lt; int &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1BoundaryComponent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::BoundaryComponent&lt; int &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__triangulation.html">Triangulations</a> &#124; <a class="el" href="group__generic.html">Generic triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A component of the boundary of a <em>dim</em>-manifold triangulation.  
 <a href="classregina_1_1BoundaryComponent.html#details">More...</a></p>

<p><code>#include &lt;triangulation/generic.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::BoundaryComponent&lt; int &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1BoundaryComponent.png" usemap="#regina::BoundaryComponent&lt; int &gt;_map" alt=""/>
  <map id="regina::BoundaryComponent&lt; int &gt;_map" name="regina::BoundaryComponent&lt; int &gt;_map">
<area href="classregina_1_1detail_1_1BoundaryComponentBase.html" title="Helper class that provides core functionality for a boundary component of a dim-dimensional triangula..." alt="regina::detail::BoundaryComponentBase&lt; dim &gt;" shape="rect" coords="954,280,1580,304"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; BoundaryComponentBase&lt; dim &gt; &gt;" shape="rect" coords="0,224,626,248"/>
<area href="classregina_1_1detail_1_1BoundaryComponentStorage.html" alt="regina::detail::BoundaryComponentStorage&lt; dim, standardDim(dim),(standardDim(dim)&amp;&amp;dim &gt; 2),(dim &gt; 2) &gt;" shape="rect" coords="636,224,1262,248"/>
<area href="classregina_1_1MarkedElement.html" title="A base class for elements of MarkedVector." alt="regina::MarkedElement" shape="rect" coords="1908,224,2534,248"/>
<area href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html" alt="regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex &gt;" shape="rect" coords="636,168,1262,192"/>
<area href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html" alt="regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces &gt;" shape="rect" coords="636,112,1262,136"/>
<area href="classregina_1_1detail_1_1WeakFaceListSuite.html" alt="regina::detail::WeakFaceListSuite&lt; dim, dim-1 &gt;" shape="rect" coords="0,56,626,80"/>
<area href="classregina_1_1alias_1_1FacesOfTriangulation.html" alt="regina::alias::FacesOfTriangulation&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, dim &gt;" shape="rect" coords="636,56,1262,80"/>
<area href="classregina_1_1alias_1_1FaceOfTriangulation.html" alt="regina::alias::FaceOfTriangulation&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, dim &gt;" shape="rect" coords="1272,56,1898,80"/>
<area href="classregina_1_1detail_1_1WeakFaceList.html" title="Internal class that stores all subdim-faces in a component or boundary component of a dim-dimensional..." alt="regina::detail::WeakFaceList&lt; dim, subdim &gt;" shape="rect" coords="0,0,626,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada6c3ec37e11607d8713376de622250d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#ada6c3ec37e11607d8713376de622250d">index</a> () const </td></tr>
<tr class="memdesc:ada6c3ec37e11607d8713376de622250d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this boundary component in the underlying triangulation.  <a href="#ada6c3ec37e11607d8713376de622250d">More...</a><br/></td></tr>
<tr class="separator:ada6c3ec37e11607d8713376de622250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b6cc5a0d8ed67f99c3bc34b7b0360"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#aca0b6cc5a0d8ed67f99c3bc34b7b0360">isOrientable</a> () const </td></tr>
<tr class="memdesc:aca0b6cc5a0d8ed67f99c3bc34b7b0360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is orientable.  <a href="#aca0b6cc5a0d8ed67f99c3bc34b7b0360">More...</a><br/></td></tr>
<tr class="separator:aca0b6cc5a0d8ed67f99c3bc34b7b0360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975681139470461682969e245311e5b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html#a975681139470461682969e245311e5b8">build</a> () const</td></tr>
<tr class="memdesc:a975681139470461682969e245311e5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full (<em>dim</em>-1)-dimensional triangulation of this boundary component.  <a href="#a975681139470461682969e245311e5b8">More...</a><br/></td></tr>
<tr class="separator:a975681139470461682969e245311e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac700fa8d3e07f5646d58f21f6dc48ea6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ac700fa8d3e07f5646d58f21f6dc48ea6">isReal</a> () const</td></tr>
<tr class="memdesc:ac700fa8d3e07f5646d58f21f6dc48ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is real.  <a href="#ac700fa8d3e07f5646d58f21f6dc48ea6">More...</a><br/></td></tr>
<tr class="separator:ac700fa8d3e07f5646d58f21f6dc48ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf60847ab2531753ce700399b0879a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ad4bf60847ab2531753ce700399b0879a">isIdeal</a> () const</td></tr>
<tr class="memdesc:ad4bf60847ab2531753ce700399b0879a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is ideal.  <a href="#ad4bf60847ab2531753ce700399b0879a">More...</a><br/></td></tr>
<tr class="separator:ad4bf60847ab2531753ce700399b0879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636443fd222bec548d0463d4dfbf2351"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#a636443fd222bec548d0463d4dfbf2351">isInvalidVertex</a> () const</td></tr>
<tr class="memdesc:a636443fd222bec548d0463d4dfbf2351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component consists of a single invalid vertex and nothing else.  <a href="#a636443fd222bec548d0463d4dfbf2351">More...</a><br/></td></tr>
<tr class="separator:a636443fd222bec548d0463d4dfbf2351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a86f31c8d03b88f318b30153958f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#a962a86f31c8d03b88f318b30153958f4">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a962a86f31c8d03b88f318b30153958f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a962a86f31c8d03b88f318b30153958f4">More...</a><br/></td></tr>
<tr class="separator:a962a86f31c8d03b88f318b30153958f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3653c2408c9125b9a69d9e9f87fb01e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#a3653c2408c9125b9a69d9e9f87fb01e4">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a3653c2408c9125b9a69d9e9f87fb01e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a3653c2408c9125b9a69d9e9f87fb01e4">More...</a><br/></td></tr>
<tr class="separator:a3653c2408c9125b9a69d9e9f87fb01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc90cc433c841f566b5cd614a3ebdb88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#adc90cc433c841f566b5cd614a3ebdb88">size</a> () const</td></tr>
<tr class="memdesc:adc90cc433c841f566b5cd614a3ebdb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of (<em>dim</em>-1)-faces in this boundary component.  <a href="#adc90cc433c841f566b5cd614a3ebdb88">More...</a><br/></td></tr>
<tr class="separator:adc90cc433c841f566b5cd614a3ebdb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49afeb7d35ad5ffa110e0e97f25ed62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#af49afeb7d35ad5ffa110e0e97f25ed62">countRidges</a> () const</td></tr>
<tr class="memdesc:af49afeb7d35ad5ffa110e0e97f25ed62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of (<em>dim</em>-2)-faces in this boundary component.  <a href="#af49afeb7d35ad5ffa110e0e97f25ed62">More...</a><br/></td></tr>
<tr class="separator:af49afeb7d35ad5ffa110e0e97f25ed62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9900942c76f94f6a289ad98e1895ea1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#ab9900942c76f94f6a289ad98e1895ea1">countFaces</a> () const</td></tr>
<tr class="memdesc:ab9900942c76f94f6a289ad98e1895ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this boundary component.  <a href="#ab9900942c76f94f6a289ad98e1895ea1">More...</a><br/></td></tr>
<tr class="separator:ab9900942c76f94f6a289ad98e1895ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfe6bb0f9b75ea2be812c669e1a29dc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, <br class="typebreak"/>
dim-1 &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a2bfe6bb0f9b75ea2be812c669e1a29dc">facets</a> () const</td></tr>
<tr class="memdesc:a2bfe6bb0f9b75ea2be812c669e1a29dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all (<em>dim</em>-1)-faces in this boundary component.  <a href="#a2bfe6bb0f9b75ea2be812c669e1a29dc">More...</a><br/></td></tr>
<tr class="separator:a2bfe6bb0f9b75ea2be812c669e1a29dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b68a68a6d929a132f5576b10f8ec97a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, <br class="typebreak"/>
subdim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a0b68a68a6d929a132f5576b10f8ec97a">faces</a> () const</td></tr>
<tr class="memdesc:a0b68a68a6d929a132f5576b10f8ec97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all <em>subdim</em>-faces in this boundary component.  <a href="#a0b68a68a6d929a132f5576b10f8ec97a">More...</a><br/></td></tr>
<tr class="separator:a0b68a68a6d929a132f5576b10f8ec97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfbc6b5a9df83ab866a28f25a040206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a7bfbc6b5a9df83ab866a28f25a040206">facet</a> (size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#ada6c3ec37e11607d8713376de622250d">index</a>) const</td></tr>
<tr class="memdesc:a7bfbc6b5a9df83ab866a28f25a040206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested (<em>dim</em>-1)-face in this boundary component.  <a href="#a7bfbc6b5a9df83ab866a28f25a040206">More...</a><br/></td></tr>
<tr class="separator:a7bfbc6b5a9df83ab866a28f25a040206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486dc6df8899d88cc33aca822f80bc29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a486dc6df8899d88cc33aca822f80bc29">face</a> (size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#ada6c3ec37e11607d8713376de622250d">index</a>) const</td></tr>
<tr class="memdesc:a486dc6df8899d88cc33aca822f80bc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face in this boundary component.  <a href="#a486dc6df8899d88cc33aca822f80bc29">More...</a><br/></td></tr>
<tr class="separator:a486dc6df8899d88cc33aca822f80bc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a900f9b73c180c4957e58de76fc6b35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a1a900f9b73c180c4957e58de76fc6b35">triangulation</a> () const</td></tr>
<tr class="memdesc:a1a900f9b73c180c4957e58de76fc6b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation to which this boundary component belongs.  <a href="#a1a900f9b73c180c4957e58de76fc6b35">More...</a><br/></td></tr>
<tr class="separator:a1a900f9b73c180c4957e58de76fc6b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1adec6d5701124aa053b6336d56430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#aeb1adec6d5701124aa053b6336d56430">component</a> () const</td></tr>
<tr class="memdesc:aeb1adec6d5701124aa053b6336d56430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component of the triangulation to which this boundary component belongs.  <a href="#aeb1adec6d5701124aa053b6336d56430">More...</a><br/></td></tr>
<tr class="separator:aeb1adec6d5701124aa053b6336d56430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29dbd59ab567de78a4cf083988a0e8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html#abf29dbd59ab567de78a4cf083988a0e8">markedIndex</a> () const </td></tr>
<tr class="memdesc:abf29dbd59ab567de78a4cf083988a0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="#abf29dbd59ab567de78a4cf083988a0e8">More...</a><br/></td></tr>
<tr class="separator:abf29dbd59ab567de78a4cf083988a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a743fcbbe87613ad86f844f5fbe07e2e3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html#a743fcbbe87613ad86f844f5fbe07e2e3">canBuild</a></td></tr>
<tr class="memdesc:a743fcbbe87613ad86f844f5fbe07e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class supports triangulating boundary components.  <a href="#a743fcbbe87613ad86f844f5fbe07e2e3">More...</a><br/></td></tr>
<tr class="separator:a743fcbbe87613ad86f844f5fbe07e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2259be5e070ee6a88808f21026a8e2e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ae2259be5e070ee6a88808f21026a8e2e">allowVertex</a></td></tr>
<tr class="memdesc:ae2259be5e070ee6a88808f21026a8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class.  <a href="#ae2259be5e070ee6a88808f21026a8e2e">More...</a><br/></td></tr>
<tr class="separator:ae2259be5e070ee6a88808f21026a8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf79ecd4d510560c38e544eda0ec39b"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a></td></tr>
<tr class="memdesc:abbf79ecd4d510560c38e544eda0ec39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>).  <a href="#abbf79ecd4d510560c38e544eda0ec39b">More...</a><br/></td></tr>
<tr class="separator:abbf79ecd4d510560c38e544eda0ec39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7d4df801d1970f874ad191dd75aaae9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ac7d4df801d1970f874ad191dd75aaae9">buildVertexLink</a> () const</td></tr>
<tr class="memdesc:ac7d4df801d1970f874ad191dd75aaae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates the vertex link for an ideal or invalid vertex boundary component.  <a href="#ac7d4df801d1970f874ad191dd75aaae9">More...</a><br/></td></tr>
<tr class="separator:ac7d4df801d1970f874ad191dd75aaae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd7478fc8ee8fe3c6615b326ebc49b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#adbd7478fc8ee8fe3c6615b326ebc49b0">push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *<a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#a486dc6df8899d88cc33aca822f80bc29">face</a>)</td></tr>
<tr class="memdesc:adbd7478fc8ee8fe3c6615b326ebc49b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component.  <a href="#adbd7478fc8ee8fe3c6615b326ebc49b0">More...</a><br/></td></tr>
<tr class="separator:adbd7478fc8ee8fe3c6615b326ebc49b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8181ea205265113dddce18d3b3a315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#ada8181ea205265113dddce18d3b3a315">reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *tri) const</td></tr>
<tr class="memdesc:ada8181ea205265113dddce18d3b3a315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way.  <a href="#ada8181ea205265113dddce18d3b3a315">More...</a><br/></td></tr>
<tr class="separator:ada8181ea205265113dddce18d3b3a315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15c90c1eec10c664fb6d3ac559bdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1WeakFaceListSuite.html#aef15c90c1eec10c664fb6d3ac559bdcc">reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *tri, const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;tridimFaces) const</td></tr>
<tr class="memdesc:aef15c90c1eec10c664fb6d3ac559bdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way.  <a href="#aef15c90c1eec10c664fb6d3ac559bdcc">More...</a><br/></td></tr>
<tr class="separator:aef15c90c1eec10c664fb6d3ac559bdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa836bb693c00ec5ceed9f9fa8b1404e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#aa836bb693c00ec5ceed9f9fa8b1404e1">orientable_</a></td></tr>
<tr class="memdesc:aa836bb693c00ec5ceed9f9fa8b1404e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this boundary component orientable?  <a href="#aa836bb693c00ec5ceed9f9fa8b1404e1">More...</a><br/></td></tr>
<tr class="separator:aa836bb693c00ec5ceed9f9fa8b1404e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba41612ae02ea47c1953758ec2e604d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html#a7ba41612ae02ea47c1953758ec2e604d">boundary_</a></td></tr>
<tr class="memdesc:a7ba41612ae02ea47c1953758ec2e604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A full triangulation of the boundary component.  <a href="#a7ba41612ae02ea47c1953758ec2e604d">More...</a><br/></td></tr>
<tr class="separator:a7ba41612ae02ea47c1953758ec2e604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e624f86239df884711385ff208eb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html#a7a9e624f86239df884711385ff208eb2">faces_</a></td></tr>
<tr class="memdesc:a7a9e624f86239df884711385ff208eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of faces.  <a href="#a7a9e624f86239df884711385ff208eb2">More...</a><br/></td></tr>
<tr class="separator:a7a9e624f86239df884711385ff208eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac4dded60d8f6ec4e40d49ca37e9057"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Triangulation&lt; dim &gt;</b></td></tr>
<tr class="separator:a4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a4659674b1612d92dcbec5bc0cb17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1a4659674b1612d92dcbec5bc0cb17"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::TriangulationBase&lt; dim &gt;</b></td></tr>
<tr class="separator:a1f1a4659674b1612d92dcbec5bc0cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int&gt;<br/>
class regina::BoundaryComponent&lt; int &gt;</h3>

<p>A component of the boundary of a <em>dim</em>-manifold triangulation. </p>
<p>Regina recognises three types of boundary components:</p>
<ul>
<li>A <em>real boundary component</em> is formed from unglued facets of top-dimensional simplices of the triangulation. For example, a real boundary component of a 3-manifold triangulation is formed from boundary triangles in the 2-skeleton.</li>
</ul>
<ul>
<li>An <em>ideal boundary component</em> consists of a single ideal vertex; that is, a vertex whose link is a closed (<em>dim</em>-1)-manifold but not a sphere. This is only possible for dimensions <em>dim</em> &ge; 3.</li>
</ul>
<ul>
<li>An <em>invalid vertex boundary component</em> consists of a single invalid invalid vertex that does not belong to a real boundary component. This means the vertex link must be an ideal (<em>dim</em>-1)-manifold, or an invalid (<em>dim</em>-1)-manifold with no real boundary. Invalid vertex boundary components are only possible for dimensions <em>dim</em> &ge; 4.</li>
</ul>
<p>Ideal and invalid vertex boundary components are <em>only</em> recognised when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. This is because, in higher dimensions, the relevant conditions rely on undecidable problems.</p>
<p>Regina stores different skeletal information for different types of boundary components:</p>
<ul>
<li>For real boundary components in <a class="el" href="stddim.html">standard dimensions</a>, Regina stores all boundary faces of all dimensions 0,1,...,<em>dim</em>-1.</li>
</ul>
<ul>
<li>For real boundary components in higher (non-standard) dimensions, Regina only stores the boundary (<em>dim</em>-1)-faces (i.e., the unglued facets of top-dimensional simplices that make up the boundary component). This is simply to avoid excessive memory usage.</li>
</ul>
<ul>
<li>For ideal and invalid vertex boundary components, Regina stores the relevant vertex. Such boundary components do not contain any faces of any dimension greater than zero.</li>
</ul>
<p>We can encounter some interesting cases with invalid triangulations. Consider some face whose link has more than one boundary component (which makes the face invalid). This means that different parts of the (<em>dim</em>)-manifold boundary are effectively "pinched" together. If this happens, the different parts of the boundary that are pinched might or might not be listed as part of the same boundary component; if not then the offending face will be included in <em>all</em> of these boundary components. Nevertheless, only one of these can be considered the "official" boundary component of the face as returned by <a class="el" href="classregina_1_1detail_1_1FaceBase.html#aa34356247cebdc4002c479c6e6bd9674" title="Returns the boundary component of the triangulation to which this face belongs.">Face::boundaryComponent()</a>. This is all a bit of a mess, but then again the entire triangulation is invalid and so you almost certainly have bigger problems to deal with.</p>
<p>Boundary components are highly temporary: whenever a triangulation changes, all of its boundary component objects will be deleted and new ones will be created in their place.</p>
<p>Boundary component objects are all created, managed and destroyed by the class <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a>. See the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> notes for further information on working with <em>dim</em>-dimensional triangulations.</p>
<p>For dimension <em>dim</em> = 3, this template is specialised and offers more functionality. In order to use this specialised class, you will need to include the corresponding header <a class="el" href="dim3_8h.html" title="Includes all headers for working with 3-dimensional triangulations. This includes headers for the mai...">triangulation/dim3.h</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., BoundaryComponent2 and BoundaryComponent3 for dimensions 2 and 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a975681139470461682969e245311e5b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full (<em>dim</em>-1)-dimensional triangulation of this boundary component. </p>
<p>Note that this triangulation is read-only (though of course you can clone it and then operate upon the clone).</p>
<p>If this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the triangulation of this boundary component is as follows:</p>
<ul>
<li>Let <em>i</em> lie between 0 and size()-1 inclusive. Then simplex <em>i</em> of the returned (<em>dim</em>-1)-dimensional triangulation is a copy of <code>facet(i)</code> of this boundary component, and its vertices 0,...,<em>dim</em>-1 are numbered in the same way. To relate these (<em>dim</em>-1)-face vertex numbers to the vertex numbers of top-dimensional simplices in the overall <em>dim</em>-dimensional triangulation, see Simplex&lt;dim&gt;::faceMapping&lt;dim-1&gt;().</li>
</ul>
<ul>
<li>If this boundary component stores lower-dimensional faces (i.e., if the template argument <em>allFaces</em> is <code>true</code>), then a similar correspondence holds for these lower-dimensional faces also: for each <em>i</em>, <em>k</em>-face <em>i</em> of the returned triangulation is a copy of <code>face&lt;k&gt;(i)</code> of this boundary component, and its vertices are numbered in the same way.</li>
</ul>
<p>If this boundary component consists only of a single vertex (i.e., this is an ideal or invalid vertex boundary component), then this routine returns the triangulation of the corresponding vertex link. See Vertex::link() for details.</p>
<p>This routine is fast, since it caches the boundary triangulation. Moreover, it is guaranteed that the full skeleton of this (<em>dim</em>-1)-dimensional triangulation will have been generated already.</p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation of this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7d4df801d1970f874ad191dd75aaae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::buildVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates the vertex link for an ideal or invalid vertex boundary component. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulated vertex link. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb1adec6d5701124aa053b6336d56430"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connected component of the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9900942c76f94f6a289ad98e1895ea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this boundary component. </p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="af49afeb7d35ad5ffa110e0e97f25ed62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::countRidges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of (<em>dim</em>-2)-faces in this boundary component. </p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-2)-faces in this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#a8fd5cf5e44180624e63eaba4caceace5">BoundaryComponentBase</a>&lt; dim &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a486dc6df8899d88cc33aca822f80bc29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face in this boundary component. </p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each <em>subdim</em>-face in this boundary component will match the index of the corresponding <em>subdim</em>-face in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to countFaces&lt;subdim&gt;()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b68a68a6d929a132f5576b10f8ec97a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all <em>subdim</em>-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python:</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the boundary component. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bfbc6b5a9df83ab866a28f25a040206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::facet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested (<em>dim</em>-1)-face in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each (<em>dim</em>-1)-face in this boundary component will match the index of the corresponding top-dimensional simplex in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfe6bb0f9b75ea2be812c669e1a29dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all (<em>dim</em>-1)-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all (<em>dim</em>-1)-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="ada6c3ec37e11607d8713376de622250d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this boundary component in the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4bf60847ab2531753ce700399b0879a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is ideal. </p>
<p>This is the case if and only if it consists of a single ideal vertex and no faces of any other dimensions.</p>
<p>See the BoundaryComponent class notes for an overview of ideal boundary components, which can only occur in dimensions &ge; 3, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>Note that a boundary component formed from a single <em>invalid</em> vertex is <em>not</em> considered to be ideal. This means that, if a boundary component contains no faces of positive dimension, then one and only one of isIdeal() and isInvalidVertex() will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is ideal. </dd></dl>

</div>
</div>
<a class="anchor" id="a636443fd222bec548d0463d4dfbf2351"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::isInvalidVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component consists of a single invalid vertex and nothing else. </p>
<p>In particular, such a boundary component must contain no faces of any positive dimension.</p>
<p>See the BoundaryComponent class notes for an overview of invalid vertex boundary components, which can only occur in dimensions &ge; 4, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>An invalid vertex is only placed in its own boundary component if it does not already belong to some larger boundary component (for instance, if its link is an ideal (<em>dim</em>-1)-manifold triangulation). This means that, for a boundary component consisting of one or more (<em>dim</em>-1)-faces, this routine will return <code>false</code> even if the boundary component also includes one or more invalid vertices.</p>
<p>Note that, if a boundary component contains no faces of positive dimension, then one and only one of isIdeal() and isInvalidVertex() will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component consists of a single invalid vertex and nothing else. </dd></dl>

</div>
</div>
<a class="anchor" id="aca0b6cc5a0d8ed67f99c3bc34b7b0360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is orientable. </p>
<p>If this is an ideal or invalid vertex boundary component, then the orientability of the corresponding vertex link is returned.</p>
<p>This routine is fast; in particular, it is pre-computed and does not build a full triangulation of the boundary component.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac700fa8d3e07f5646d58f21f6dc48ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::isReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is real. </p>
<p>This is the case if and only if it is formed from one or more (dim-1)-faces.</p>
<p>See the BoundaryComponent class notes for an overview of real, ideal, and invalid vertex boundary components.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. (In other dimensions, real boundary components are the only types of boundary component that Regina will recognise.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is real. </dd></dl>

</div>
</div>
<a class="anchor" id="abf29dbd59ab567de78a4cf083988a0e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedElement::markedIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>. </p>
<p>If this object does not belong to an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>, the return value is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the index at which this object is stored. </dd></dl>

</div>
</div>
<a class="anchor" id="adbd7478fc8ee8fe3c6615b326ebc49b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component. </p>
<p>This class does not take ownership of the given face.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to append. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the face to append to the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef15c90c1eec10c664fb6d3ac559bdcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1WeakFaceListSuite.html">regina::detail::WeakFaceListSuite</a>&lt; dim, subdim &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tridimFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way. </p>
<dl class="section pre"><dt>Precondition</dt><dd>For each dimension <em>k</em> = 0,...,<em>subdim</em>, the <em>k</em>-faces of the given triangulation <em>tri</em> are in one-to-one correspondence with the <em>k</em>-faces in this suite, though not necessarily in the same order. Moreover, for each <em>i</em> and <em>j</em>, this correspondence maps the <em>i</em>th <em>k</em>-face of <code>tri-&gt;simplex(j)</code> to the <em>i</em>th <em>k</em>-face of <code>tridimFaces[j]</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tridim</td><td>the dimension of the given triangulation. This must be strictly larger than <em>subdim</em>, but it need not be equal to <em>dim</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a <em>tridim</em>-dimensional triangulation, as described above. </td></tr>
    <tr><td class="paramname">tridimFaces</td><td>a list of <em>tridim</em>-faces that together contain all of the faces in this suite, and that are in an <em>ordered</em> one-to-one correspondence with the top-dimensional simplices of <em>tri</em> as described in the precondition above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada8181ea205265113dddce18d3b3a315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way. </p>
<p>This affects all faces of dimensions 0,...,(<em>dim</em>-2).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a real boundary component. </dd>
<dd>
<em>tri</em> is a triangulation of this boundary component. </dd>
<dd>
For each <em>i</em>, the <em>i</em>th top-dimensional simplex of <em>tri</em> corresponds to the <em>i</em>th (<em>dim</em>-1)-face of this boundary component, and has its vertices 0,...,(<em>dim</em>-1) labelled in the same way.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a triangulation of this boundary component, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc90cc433c841f566b5cd614a3ebdb88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of (<em>dim</em>-1)-faces in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-1)-faces in this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#a8fd5cf5e44180624e63eaba4caceace5">BoundaryComponentBase</a>&lt; dim &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a900f9b73c180c4957e58de76fc6b35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html#a8fd5cf5e44180624e63eaba4caceace5">BoundaryComponentBase</a>&lt; dim &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a3653c2408c9125b9a69d9e9f87fb01e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a962a86f31c8d03b88f318b30153958f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abbf79ecd4d510560c38e544eda0ec39b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; int, bool &gt;::allFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>). </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2259be5e070ee6a88808f21026a8e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, allowVertex_ &gt;::allowVertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba41612ae02ea47c1953758ec2e604d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::boundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A full triangulation of the boundary component. </p>
<p>This may be pre-computed when the triangulation skeleton is constructed, or it may be <code>null</code> in which case it will be built on demand. For ideal or invalid vertices, this is always <code>null</code> since the triangulation is cached by the vertex class instead. </p>

</div>
</div>
<a class="anchor" id="a743fcbbe87613ad86f844f5fbe07e2e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#abbf79ecd4d510560c38e544eda0ec39b">allFaces</a>, <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#ae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::canBuild</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class supports triangulating boundary components. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a9e624f86239df884711385ff208eb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt; <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::faces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of faces. </p>

</div>
</div>
<a class="anchor" id="aa836bb693c00ec5ceed9f9fa8b1404e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this boundary component orientable? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>triangulation/<a class="el" href="forward_8h.html">forward.h</a></li>
<li>triangulation/generic/<a class="el" href="triangulation_2generic_2boundarycomponent_8h.html">boundarycomponent.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
