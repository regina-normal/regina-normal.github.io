<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::TriSolidTorus Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1TriSolidTorus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::TriSolidTorus Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a three-tetrahedron triangular solid torus in a triangulation.  
 <a href="classregina_1_1TriSolidTorus.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/trisolidtorus.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TriSolidTorus:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TriSolidTorus.png" usemap="#regina::TriSolidTorus_map" alt=""/>
  <map id="regina::TriSolidTorus_map" name="regina::TriSolidTorus_map">
<area href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood." alt="regina::StandardTriangulation" shape="rect" coords="0,56,239,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; StandardTriangulation &gt;" shape="rect" coords="0,0,239,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70b53a3215c260f91b3f0b8c51688f02"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a70b53a3215c260f91b3f0b8c51688f02">~TriSolidTorus</a> ()</td></tr>
<tr class="memdesc:a70b53a3215c260f91b3f0b8c51688f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this solid torus.  <a href="#a70b53a3215c260f91b3f0b8c51688f02">More...</a><br /></td></tr>
<tr class="separator:a70b53a3215c260f91b3f0b8c51688f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3db9c62e7aae094162936494a2b6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a3f3db9c62e7aae094162936494a2b6ed">clone</a> () const</td></tr>
<tr class="memdesc:a3f3db9c62e7aae094162936494a2b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="#a3f3db9c62e7aae094162936494a2b6ed">More...</a><br /></td></tr>
<tr class="separator:a3f3db9c62e7aae094162936494a2b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6309e86d2d4d03d34cc5d750bd1fc393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a6309e86d2d4d03d34cc5d750bd1fc393">tetrahedron</a> (int index) const</td></tr>
<tr class="memdesc:a6309e86d2d4d03d34cc5d750bd1fc393"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this solid torus.  <a href="#a6309e86d2d4d03d34cc5d750bd1fc393">More...</a><br /></td></tr>
<tr class="separator:a6309e86d2d4d03d34cc5d750bd1fc393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a73c2957fd960d42c0b493726f7f994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a7a73c2957fd960d42c0b493726f7f994">vertexRoles</a> (int index) const</td></tr>
<tr class="memdesc:a7a73c2957fd960d42c0b493726f7f994"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus.  <a href="#a7a73c2957fd960d42c0b493726f7f994">More...</a><br /></td></tr>
<tr class="separator:a7a73c2957fd960d42c0b493726f7f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a6ad5bd5c7d85cb3b617d5a8c3572d1a5">isAnnulusSelfIdentified</a> (int index, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; *roleMap) const</td></tr>
<tr class="memdesc:a6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two triangles of the requested annulus are glued to each other.  <a href="#a6ad5bd5c7d85cb3b617d5a8c3572d1a5">More...</a><br /></td></tr>
<tr class="separator:a6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646e2a25cdee5230abff81fe108b54ed"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a646e2a25cdee5230abff81fe108b54ed">areAnnuliLinkedMajor</a> (int otherAnnulus) const</td></tr>
<tr class="memdesc:a646e2a25cdee5230abff81fe108b54ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given annuli are linked in a particular fashion by a layered chain.  <a href="#a646e2a25cdee5230abff81fe108b54ed">More...</a><br /></td></tr>
<tr class="separator:a646e2a25cdee5230abff81fe108b54ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3126bafc3f63fb842e54a0bf9aa814dd"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a3126bafc3f63fb842e54a0bf9aa814dd">areAnnuliLinkedAxis</a> (int otherAnnulus) const</td></tr>
<tr class="memdesc:a3126bafc3f63fb842e54a0bf9aa814dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given annuli are linked in a particular fashion by a layered chain.  <a href="#a3126bafc3f63fb842e54a0bf9aa814dd">More...</a><br /></td></tr>
<tr class="separator:a3126bafc3f63fb842e54a0bf9aa814dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3acbf6ce44a7908fe2c00e706c59ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#ac3acbf6ce44a7908fe2c00e706c59ba0">manifold</a> () const override</td></tr>
<tr class="memdesc:ac3acbf6ce44a7908fe2c00e706c59ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="#ac3acbf6ce44a7908fe2c00e706c59ba0">More...</a><br /></td></tr>
<tr class="separator:ac3acbf6ce44a7908fe2c00e706c59ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6561d6eeb5f18705335ad19b10530942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a6561d6eeb5f18705335ad19b10530942">homology</a> () const override</td></tr>
<tr class="memdesc:a6561d6eeb5f18705335ad19b10530942"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="#a6561d6eeb5f18705335ad19b10530942">More...</a><br /></td></tr>
<tr class="separator:a6561d6eeb5f18705335ad19b10530942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45703ff36060192b4d248e30d9eb20cb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a45703ff36060192b4d248e30d9eb20cb">writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a45703ff36060192b4d248e30d9eb20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="#a45703ff36060192b4d248e30d9eb20cb">More...</a><br /></td></tr>
<tr class="separator:a45703ff36060192b4d248e30d9eb20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42be4348d68170c65a146398cc246eb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#af42be4348d68170c65a146398cc246eb">writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:af42be4348d68170c65a146398cc246eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="#af42be4348d68170c65a146398cc246eb">More...</a><br /></td></tr>
<tr class="separator:af42be4348d68170c65a146398cc246eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460017e67a7ddfc3a9af80b3a5a9df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#a0460017e67a7ddfc3a9af80b3a5a9df2">writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a0460017e67a7ddfc3a9af80b3a5a9df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a0460017e67a7ddfc3a9af80b3a5a9df2">More...</a><br /></td></tr>
<tr class="separator:a0460017e67a7ddfc3a9af80b3a5a9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f318c415f2ec73916cc6c3aa669d8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a62f318c415f2ec73916cc6c3aa669d8a">name</a> () const</td></tr>
<tr class="memdesc:a62f318c415f2ec73916cc6c3aa669d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation as a human-readable string.  <a href="#a62f318c415f2ec73916cc6c3aa669d8a">More...</a><br /></td></tr>
<tr class="separator:a62f318c415f2ec73916cc6c3aa669d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad060bab2f08b1e5881d25b2291d8e09c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#ad060bab2f08b1e5881d25b2291d8e09c">TeXName</a> () const</td></tr>
<tr class="memdesc:ad060bab2f08b1e5881d25b2291d8e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation in TeX format.  <a href="#ad060bab2f08b1e5881d25b2291d8e09c">More...</a><br /></td></tr>
<tr class="separator:ad060bab2f08b1e5881d25b2291d8e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd1c110caa1deb5e1ce0e58665bb573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#acbd1c110caa1deb5e1ce0e58665bb573">homologyH1</a> () const</td></tr>
<tr class="memdesc:acbd1c110caa1deb5e1ce0e58665bb573"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="#acbd1c110caa1deb5e1ce0e58665bb573">More...</a><br /></td></tr>
<tr class="separator:acbd1c110caa1deb5e1ce0e58665bb573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da317c33469df8b5518cecb60b2109"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a11da317c33469df8b5518cecb60b2109">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a11da317c33469df8b5518cecb60b2109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a11da317c33469df8b5518cecb60b2109">More...</a><br /></td></tr>
<tr class="separator:a11da317c33469df8b5518cecb60b2109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afcbf6dc2a01ca7ac4375f281201a8b7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html#afcbf6dc2a01ca7ac4375f281201a8b7e">formsTriSolidTorus</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; useVertexRoles)</td></tr>
<tr class="memdesc:afcbf6dc2a01ca7ac4375f281201a8b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms part of a three-tetrahedron triangular solid torus with its vertices playing the given roles in the solid torus.  <a href="#afcbf6dc2a01ca7ac4375f281201a8b7e">More...</a><br /></td></tr>
<tr class="separator:afcbf6dc2a01ca7ac4375f281201a8b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c589e3471255c2cf81a9da2ab6e214a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a1c589e3471255c2cf81a9da2ab6e214a">isStandardTriangulation</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *component)</td></tr>
<tr class="memdesc:a1c589e3471255c2cf81a9da2ab6e214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given component represents one of the standard triangulations understood by Regina.  <a href="#a1c589e3471255c2cf81a9da2ab6e214a">More...</a><br /></td></tr>
<tr class="separator:a1c589e3471255c2cf81a9da2ab6e214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e665c2d5ba2cb29947962c2e176bfd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a08e665c2d5ba2cb29947962c2e176bfd">isStandardTriangulation</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:a08e665c2d5ba2cb29947962c2e176bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given triangulation represents one of the standard triangulations understood by Regina.  <a href="#a08e665c2d5ba2cb29947962c2e176bfd">More...</a><br /></td></tr>
<tr class="separator:a08e665c2d5ba2cb29947962c2e176bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a three-tetrahedron triangular solid torus in a triangulation. </p>
<p>A three-tetrahedron triangular solid torus is a three-tetrahedron triangular prism with its two ends identified.</p>
<p>The resulting triangular solid torus will have all edges as boundary edges. Three of these will be <em>axis edges</em> (parallel to the axis of the solid torus). Between the axis edges will be three annuli, each with two internal edges. One of these internal edges will meet all three tetrahedra (the <em>major</em> edge) and one of these internal edges will only meet two of the tetrahedra (the <em>minor</em> edge).</p>
<p>Assume the axis of the layered solid torus is oriented. The three major edges together form a loop on the boundary torus. This loop can be oriented to run around the solid torus in the same direction as the axis; this then induces an orientation on the boundary of a meridinal disc. Thus, using an axis edge as longitude, the three major edges will together form a (1,1) curve on the boundary torus.</p>
<p>We can now orient the minor edges so they also run around the solid torus in the same direction as the axis, together forming a (2, -1) curve on the boundary torus.</p>
<p>Finally, the three tetrahedra can be numbered 0, 1 and 2 in an order that follows the axis, and the annuli can be numbered 0, 1 and 2 in an order that follows the meridinal disc boundary so that annulus <em>i</em> does not use any faces from tetrahedron <em>i</em>.</p>
<p>Note that all three tetrahedra in the triangular solid torus must be distinct.</p>
<p>All optional <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> routines are implemented for this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a70b53a3215c260f91b3f0b8c51688f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b53a3215c260f91b3f0b8c51688f02">&#9670;&nbsp;</a></span>~TriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TriSolidTorus::~TriSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this solid torus. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3126bafc3f63fb842e54a0bf9aa814dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3126bafc3f63fb842e54a0bf9aa814dd">&#9670;&nbsp;</a></span>areAnnuliLinkedAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TriSolidTorus::areAnnuliLinkedAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>otherAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given annuli are linked in a particular fashion by a layered chain. </p>
<p>In this scenario, one of the given annuli meets both faces of the top tetrahedron and the other annulus meets both faces of the bottom tetrahedron of the layered chain.</p>
<p>To be identified by this routine, the layered chain (described by <a class="el" href="classregina_1_1LayeredChain.html" title="Represents a layered chain in a triangulation.">LayeredChain</a>) must be attached as follows. We shall refer to the two hinge edges of the layered chain as <em>first</em> and <em>second</em>.</p>
<p>The two diagonals of the layered chain (between the two top faces and between the two bottom faces) should correspond to the two directed major edges of the two annuli, with the major edges both pointing from top hinge edge to bottom hinge edge. The other boundary edges of the layered chain that are not hinge edges should correspond to the two directed minor edges of the two annuli, with the minor edges both pointing from bottom hinge edge to top hinge edge. The hinge edges themselves should correspond to the axis edges of the triangular solid torus (this correspondence is determined by the previous identifications; the axis edge between the two annuli will be identified to both of the others in reverse).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherAnnulus</td><td>the annulus on the solid torus boundary <em>not</em> to be examined; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra in the layered chain if the two annuli are linked as described, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="a646e2a25cdee5230abff81fe108b54ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646e2a25cdee5230abff81fe108b54ed">&#9670;&nbsp;</a></span>areAnnuliLinkedMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TriSolidTorus::areAnnuliLinkedMajor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>otherAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given annuli are linked in a particular fashion by a layered chain. </p>
<p>In this scenario, both of the given annuli meet one face of the top tetrahedron and one face of the bottom tetrahedron of the layered chain.</p>
<p>To be identified by this routine, the layered chain (described by <a class="el" href="classregina_1_1LayeredChain.html" title="Represents a layered chain in a triangulation.">LayeredChain</a>) must be attached as follows. The two directed major edges of the two annuli should correspond to the two hinge edges of the layered chain (with both hinge edges pointing in the same direction around the solid torus formed by the layered chain). The two directed diagonals of the layered chain (between the two top faces and between the two bottom faces, each pointing in the opposite direction to the hinge edges around the solid torus formed by the layered chain) should be identified and must correspond to the (identified) two directed minor edges of the two annuli. The remaining boundary edges of the layered chain should correspond to the axis edges of the triangular solid torus (this correspondence is determined by the previous identifications).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherAnnulus</td><td>the annulus on the solid torus boundary <em>not</em> to be examined; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra in the layered chain if the two annuli are linked as described, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="a3f3db9c62e7aae094162936494a2b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3db9c62e7aae094162936494a2b6ed">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a>* regina::TriSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="afcbf6dc2a01ca7ac4375f281201a8b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbf6dc2a01ca7ac4375f281201a8b7e">&#9670;&nbsp;</a></span>formsTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a>* regina::TriSolidTorus::formsTriSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>useVertexRoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms part of a three-tetrahedron triangular solid torus with its vertices playing the given roles in the solid torus. </p>
<p>Note that the six boundary triangles of the triangular solid torus need not be boundary triangles within the overall triangulation, i.e., they may be identified with each other or with faces of other tetrahedra.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine. </td></tr>
    <tr><td class="paramname">useVertexRoles</td><td>a permutation describing the role each tetrahedron vertex must play in the solid torus; this must be in the same format as the permutation returned by <a class="el" href="classregina_1_1TriSolidTorus.html#a7a73c2957fd960d42c0b493726f7f994" title="Returns a permutation represeting the role that each vertex of the requested tetrahedron plays in the...">vertexRoles()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the solid torus with the given tetrahedron as tetrahedron 0, or <code>null</code> if the given tetrahedron is not part of a triangular solid torus with the given vertex roles. </dd></dl>

</div>
</div>
<a id="a6561d6eeb5f18705335ad19b10530942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6561d6eeb5f18705335ad19b10530942">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::TriSolidTorus::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="classregina_1_1StandardTriangulation.html#acbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#aca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="acbd1c110caa1deb5e1ce0e58665bb573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd1c110caa1deb5e1ce0e58665bb573">&#9670;&nbsp;</a></span>homologyH1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::StandardTriangulation::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="classregina_1_1TriSolidTorus.html#a6561d6eeb5f18705335ad19b10530942" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a> (a name that is less specific, but a little easier to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

</div>
</div>
<a id="a6ad5bd5c7d85cb3b617d5a8c3572d1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad5bd5c7d85cb3b617d5a8c3572d1a5">&#9670;&nbsp;</a></span>isAnnulusSelfIdentified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TriSolidTorus::isAnnulusSelfIdentified </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>roleMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two triangles of the requested annulus are glued to each other. </p>
<p>If the two triangles are glued, parameter <em>roleMap</em> will be modified to return a permutation describing how the vertex roles are glued to each other. This will describe directly how axis edges, major edges and minor edges map to each other without having to worry about the specific assignment of tetrahedron vertex numbers. For a discussion of vertex roles, see <a class="el" href="classregina_1_1TriSolidTorus.html#a7a73c2957fd960d42c0b493726f7f994" title="Returns a permutation represeting the role that each vertex of the requested tetrahedron plays in the...">vertexRoles()</a>.</p>
<p>Note that annulus <code>index</code> uses faces from tetrahedra <code>index+1</code> and <code>index+2</code>. The gluing permutation that maps vertices of tetrahedron <code>index+1</code> to vertices of tetrahedron <code>index+2</code> will be <code>vertexRoles(index+2) * roleMap * vertexRoles(index+1).inverse()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which annulus on the solid torus boundary to examine; this must be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">roleMap</td><td>a pointer to a permutation that, if this routine returns <code>true</code>, will be modified to describe the gluing of vertex roles. This parameter may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangles of the requested annulus are glued together. </dd></dl>

</div>
</div>
<a id="a1c589e3471255c2cf81a9da2ab6e214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c589e3471255c2cf81a9da2ab6e214a">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a>* regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given component represents one of the standard triangulations understood by Regina. </p>
<p>The list of recognised triangulations is expected to grow between releases.</p>
<p>If the standard triangulation returned has boundary triangles then the given component must have the same corresponding boundary triangles, i.e., the component cannot have any further identifications of these boundary triangles with each other.</p>
<p>Note that the triangulation-based routine <a class="el" href="classregina_1_1StandardTriangulation.html#a08e665c2d5ba2cb29947962c2e176bfd" title="Determines whether the given triangulation represents one of the standard triangulations understood b...">isStandardTriangulation(Triangulation&lt;3&gt;*)</a> may recognise more triangulations than this routine, since passing an entire triangulation allows access to more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>the triangulation component under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the details of the standard triangulation if the given component is recognised, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="a08e665c2d5ba2cb29947962c2e176bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e665c2d5ba2cb29947962c2e176bfd">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a>* regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given triangulation represents one of the standard triangulations understood by Regina. </p>
<p>The list of recognised triangulations is expected to grow between releases.</p>
<p>If the standard triangulation returned has boundary triangles then the given triangulation must have the same corresponding boundary triangles, i.e., the triangulation cannot have any further identifications of these boundary triangles with each other.</p>
<p>This routine may recognise more triangulations than the component-based <a class="el" href="classregina_1_1StandardTriangulation.html#a1c589e3471255c2cf81a9da2ab6e214a" title="Determines whether the given component represents one of the standard triangulations understood by Re...">isStandardTriangulation(Component&lt;3&gt;*)</a>, since passing an entire triangulation allows access to more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the details of the standard triangualation if the given triangulation is recognised, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="ac3acbf6ce44a7908fe2c00e706c59ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3acbf6ce44a7908fe2c00e706c59ba0">&#9670;&nbsp;</a></span>manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::TriSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#ac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a62f318c415f2ec73916cc6c3aa669d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f318c415f2ec73916cc6c3aa669d8a">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python</dt><dd>In addition to <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a6309e86d2d4d03d34cc5d750bd1fc393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6309e86d2d4d03d34cc5d750bd1fc393">&#9670;&nbsp;</a></span>tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::TriSolidTorus::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this solid torus. </p>
<p>See the general class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron in the solid torus to return; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="ad060bab2f08b1e5881d25b2291d8e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad060bab2f08b1e5881d25b2291d8e09c">&#9670;&nbsp;</a></span>TeXName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation in TeX format. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation in TeX format. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a7a73c2957fd960d42c0b493726f7f994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a73c2957fd960d42c0b493726f7f994">&#9670;&nbsp;</a></span>vertexRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::TriSolidTorus::vertexRoles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus. </p>
<p>The permutation returned (call this <code>p</code>) maps 0, 1, 2 and 3 to the four vertices of tetrahedron <em>index</em> so that the edge from <code>p[0]</code> to <code>p[3]</code> is an oriented axis edge, and the path from vertices <code>p[0]</code> to <code>p[1]</code> to <code>p[2]</code> to <code>p[3]</code> follows the three oriented major edges. In particular, the major edge for annulus <em>index</em> will run from vertices <code>p[1]</code> to <code>p[2]</code>. Edges <code>p[0]</code> to <code>p[2]</code> and <code>p[1]</code> to <code>p[3]</code> will both be oriented minor edges.</p>
<p>Note that annulus <code>index+1</code> uses face <code>p[1]</code> of the requested tetrahedron and annulus <code>index+2</code> uses face <code>p[2]</code> of the requested tetrahedron. Both annuli use the axis edge <code>p[0]</code> to <code>p[3]</code>, and each annulus uses one other major edge and one other minor edge so that (according to homology) the axis edge equals the major edge plus the minor edge.</p>
<p>See the general class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron in the solid torus to examine; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation representing the roles of the vertices of the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="a45703ff36060192b4d248e30d9eb20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45703ff36060192b4d248e30d9eb20cb">&#9670;&nbsp;</a></span>writeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TriSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1StandardTriangulation.html#a4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="af42be4348d68170c65a146398cc246eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42be4348d68170c65a146398cc246eb">&#9670;&nbsp;</a></span>writeTeXName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TriSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1StandardTriangulation.html#a7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a0460017e67a7ddfc3a9af80b3a5a9df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0460017e67a7ddfc3a9af80b3a5a9df2">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TriSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="classregina_1_1TriSolidTorus.html#a45703ff36060192b4d248e30d9eb20cb" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#a1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a11da317c33469df8b5518cecb60b2109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11da317c33469df8b5518cecb60b2109">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::StandardTriangulation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="classregina_1_1TriSolidTorus.html#a45703ff36060192b4d248e30d9eb20cb" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="trisolidtorus_8h.html">trisolidtorus.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
