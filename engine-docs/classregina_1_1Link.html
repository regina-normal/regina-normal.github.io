<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::Link Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Link.html">Link</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Link-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Link Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a directed knot or link in the 3-sphere.  
 <a href="classregina_1_1Link.html#details">More...</a></p>

<p><code>#include &lt;link/link.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Link:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Link.png" usemap="#regina::Link_map" alt=""/>
  <map id="regina::Link_map" name="regina::Link_map">
<area href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::Packet" shape="rect" coords="111,56,323,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Packet &gt;" shape="rect" coords="0,0,212,24"/>
<area href="classregina_1_1SafePointeeBase.html" alt="regina::SafePointeeBase&lt; Packet &gt;" shape="rect" coords="222,0,434,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td></tr>
<tr class="memdesc:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="#a2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br /></td></tr>
<tr class="separator:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">hasOwner</a> () const</td></tr>
<tr class="memdesc:gac85ba39c124eda4ce631b653d6bb0a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">More...</a><br /></td></tr>
<tr class="separator:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#aa724448326c5e5b0ba727fe6ce6d1233">hasSafePtr</a> () const</td></tr>
<tr class="memdesc:aa724448326c5e5b0ba727fe6ce6d1233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there one or more SafePtr currently pointing to this object?  <a href="#aa724448326c5e5b0ba727fe6ce6d1233">More...</a><br /></td></tr>
<tr class="separator:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:aff4dc84be20b66314534c2dcc7466324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aff4dc84be20b66314534c2dcc7466324">Link</a> ()</td></tr>
<tr class="memdesc:aff4dc84be20b66314534c2dcc7466324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty link.  <a href="#aff4dc84be20b66314534c2dcc7466324">More...</a><br /></td></tr>
<tr class="separator:aff4dc84be20b66314534c2dcc7466324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b717f99561f93f6b09118cdf770803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa6b717f99561f93f6b09118cdf770803">Link</a> (size_t unknots)</td></tr>
<tr class="memdesc:aa6b717f99561f93f6b09118cdf770803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the unlink with the given number of components.  <a href="#aa6b717f99561f93f6b09118cdf770803">More...</a><br /></td></tr>
<tr class="separator:aa6b717f99561f93f6b09118cdf770803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359918be5fb86081d1122cc2f2260a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a359918be5fb86081d1122cc2f2260a5f">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy)</td></tr>
<tr class="memdesc:a359918be5fb86081d1122cc2f2260a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link.  <a href="#a359918be5fb86081d1122cc2f2260a5f">More...</a><br /></td></tr>
<tr class="separator:a359918be5fb86081d1122cc2f2260a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aaef22c9d7355dc008bfc0282c1f99e4b">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also.  <a href="#aaef22c9d7355dc008bfc0282c1f99e4b">More...</a><br /></td></tr>
<tr class="separator:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b233fb32a24925705b616b5dc23b219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9b233fb32a24925705b616b5dc23b219">Link</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a9b233fb32a24925705b616b5dc23b219"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a link.  <a href="#a9b233fb32a24925705b616b5dc23b219">More...</a><br /></td></tr>
<tr class="separator:a9b233fb32a24925705b616b5dc23b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93be82c5a263db9e3dc28a928fb4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aca93be82c5a263db9e3dc28a928fb4ba">~Link</a> ()</td></tr>
<tr class="memdesc:aca93be82c5a263db9e3dc28a928fb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this link.  <a href="#aca93be82c5a263db9e3dc28a928fb4ba">More...</a><br /></td></tr>
<tr class="separator:aca93be82c5a263db9e3dc28a928fb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Crossings and Components</div></td></tr>
<tr class="memitem:ad12a7e69700971494486e299bbc39c57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad12a7e69700971494486e299bbc39c57">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad12a7e69700971494486e299bbc39c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link is empty.  <a href="#ad12a7e69700971494486e299bbc39c57">More...</a><br /></td></tr>
<tr class="separator:ad12a7e69700971494486e299bbc39c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c6f34794cc62574fcfca388f3f66d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9">size</a> () const</td></tr>
<tr class="memdesc:a32c6f34794cc62574fcfca388f3f66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this link.  <a href="#a32c6f34794cc62574fcfca388f3f66d9">More...</a><br /></td></tr>
<tr class="separator:a32c6f34794cc62574fcfca388f3f66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60">countComponents</a> () const</td></tr>
<tr class="memdesc:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of components in this link.  <a href="#ab4fb9a0932d786dfca9eef2f6e45ec60">More...</a><br /></td></tr>
<tr class="separator:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47712bc419c15659a634ae6ea97b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:a2b47712bc419c15659a634ae6ea97b91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this link.  <a href="#a2b47712bc419c15659a634ae6ea97b91">More...</a><br /></td></tr>
<tr class="separator:a2b47712bc419c15659a634ae6ea97b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3425a2a6994fbc87baf890e9b429ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3425a2a6994fbc87baf890e9b429ef6f">component</a> (size_t index) const</td></tr>
<tr class="memdesc:a3425a2a6994fbc87baf890e9b429ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a strand in the given component of this link.  <a href="#a3425a2a6994fbc87baf890e9b429ef6f">More...</a><br /></td></tr>
<tr class="separator:a3425a2a6994fbc87baf890e9b429ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f710b2b7a73d1999cf0ea44cc7a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a411f710b2b7a73d1999cf0ea44cc7a4a">strand</a> (int id) const</td></tr>
<tr class="memdesc:a411f710b2b7a73d1999cf0ea44cc7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the strand in the link with the given integer ID.  <a href="#a411f710b2b7a73d1999cf0ea44cc7a4a">More...</a><br /></td></tr>
<tr class="separator:a411f710b2b7a73d1999cf0ea44cc7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa4d5e4637efe2ed81e2c9588aaa76591">translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference for some other link into the corresponding strand reference for this link.  <a href="#aa4d5e4637efe2ed81e2c9588aaa76591">More...</a><br /></td></tr>
<tr class="separator:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc783777826fcf17af86d21a343118d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#abc783777826fcf17af86d21a343118d5">connected</a> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *a, const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *b) const</td></tr>
<tr class="memdesc:abc783777826fcf17af86d21a343118d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram.  <a href="#abc783777826fcf17af86d21a343118d5">More...</a><br /></td></tr>
<tr class="separator:abc783777826fcf17af86d21a343118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Editing</div></td></tr>
<tr class="memitem:a15ae448f3fa16932d01d4c5a165e408c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a15ae448f3fa16932d01d4c5a165e408c">swapContents</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:a15ae448f3fa16932d01d4c5a165e408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given link.  <a href="#a15ae448f3fa16932d01d4c5a165e408c">More...</a><br /></td></tr>
<tr class="separator:a15ae448f3fa16932d01d4c5a165e408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d386bea941e436ae6548aa8663a005b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0d386bea941e436ae6548aa8663a005b">change</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a0d386bea941e436ae6548aa8663a005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of the given crossing.  <a href="#a0d386bea941e436ae6548aa8663a005b">More...</a><br /></td></tr>
<tr class="separator:a0d386bea941e436ae6548aa8663a005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0546dc7f2bde7b63c31f3e057a8c04db">changeAll</a> ()</td></tr>
<tr class="memdesc:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the diagram.  <a href="#a0546dc7f2bde7b63c31f3e057a8c04db">More...</a><br /></td></tr>
<tr class="separator:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da54fa7f3352392989e34629c314a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6da54fa7f3352392989e34629c314a91">resolve</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a6da54fa7f3352392989e34629c314a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the given crossing.  <a href="#a6da54fa7f3352392989e34629c314a91">More...</a><br /></td></tr>
<tr class="separator:a6da54fa7f3352392989e34629c314a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8b4396c9fcb99dbb3bb4ba7176b859c4">reflect</a> ()</td></tr>
<tr class="memdesc:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this link into its reflection.  <a href="#a8b4396c9fcb99dbb3bb4ba7176b859c4">More...</a><br /></td></tr>
<tr class="separator:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b8f0dd10461df6f5b535fb3991bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a078b8f0dd10461df6f5b535fb3991bce">rotate</a> ()</td></tr>
<tr class="memdesc:a078b8f0dd10461df6f5b535fb3991bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this link diagram, converting it into a different diagram of the same link.  <a href="#a078b8f0dd10461df6f5b535fb3991bce">More...</a><br /></td></tr>
<tr class="separator:a078b8f0dd10461df6f5b535fb3991bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326a4e30a7cfb373020c4c6084775fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9326a4e30a7cfb373020c4c6084775fc">reverse</a> ()</td></tr>
<tr class="memdesc:a9326a4e30a7cfb373020c4c6084775fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of every component of this link.  <a href="#a9326a4e30a7cfb373020c4c6084775fc">More...</a><br /></td></tr>
<tr class="separator:a9326a4e30a7cfb373020c4c6084775fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a23a70af4f63bbd4f7dea13a04a3b984a">r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to remove a crossing.  <a href="#a23a70af4f63bbd4f7dea13a04a3b984a">More...</a><br /></td></tr>
<tr class="separator:a23a70af4f63bbd4f7dea13a04a3b984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9535918349c0ada298fcabeac5638ec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a9535918349c0ada298fcabeac5638ec8">r1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a9535918349c0ada298fcabeac5638ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to add a new crossing.  <a href="#a9535918349c0ada298fcabeac5638ec8">More...</a><br /></td></tr>
<tr class="separator:a9535918349c0ada298fcabeac5638ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf3e0d6eaa504eba071e3950a939028"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#afaf3e0d6eaa504eba071e3950a939028">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:afaf3e0d6eaa504eba071e3950a939028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="#afaf3e0d6eaa504eba071e3950a939028">More...</a><br /></td></tr>
<tr class="separator:afaf3e0d6eaa504eba071e3950a939028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050794f44093f3ec4740eb6b2653d40e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a050794f44093f3ec4740eb6b2653d40e">r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a050794f44093f3ec4740eb6b2653d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="#a050794f44093f3ec4740eb6b2653d40e">More...</a><br /></td></tr>
<tr class="separator:a050794f44093f3ec4740eb6b2653d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a92d15fe6c6ad9a04ae0e05c9fea67cea">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to add two new crossings.  <a href="#a92d15fe6c6ad9a04ae0e05c9fea67cea">More...</a><br /></td></tr>
<tr class="separator:a92d15fe6c6ad9a04ae0e05c9fea67cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29467a23ac123cbab680b1e406e34bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad29467a23ac123cbab680b1e406e34bc">r3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ad29467a23ac123cbab680b1e406e34bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="#ad29467a23ac123cbab680b1e406e34bc">More...</a><br /></td></tr>
<tr class="separator:ad29467a23ac123cbab680b1e406e34bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ba90169324b005d88587e4597ad129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae0ba90169324b005d88587e4597ad129">r3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Link.html#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ae0ba90169324b005d88587e4597ad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type III Reidemeister move.  <a href="#ae0ba90169324b005d88587e4597ad129">More...</a><br /></td></tr>
<tr class="separator:ae0ba90169324b005d88587e4597ad129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6293eb60b5477b5cac84363c43286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#acb6293eb60b5477b5cac84363c43286a">hasReducingPass</a> () const</td></tr>
<tr class="memdesc:acb6293eb60b5477b5cac84363c43286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this knot has a pass move that will reduce the number of crossings.  <a href="#acb6293eb60b5477b5cac84363c43286a">More...</a><br /></td></tr>
<tr class="separator:acb6293eb60b5477b5cac84363c43286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc961ba707da75f2b71d3585c994cc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:a5fc961ba707da75f2b71d3585c994cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the link diagram using fast and greedy heuristics.  <a href="#a5fc961ba707da75f2b71d3585c994cc9">More...</a><br /></td></tr>
<tr class="separator:a5fc961ba707da75f2b71d3585c994cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf6c87c3dc80de018d659e686b48ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a3adf6c87c3dc80de018d659e686b48ef">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:a3adf6c87c3dc80de018d659e686b48ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings.  <a href="#a3adf6c87c3dc80de018d659e686b48ef">More...</a><br /></td></tr>
<tr class="separator:a3adf6c87c3dc80de018d659e686b48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7701e3dd1fdbe8d8106363d118ec887d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7701e3dd1fdbe8d8106363d118ec887d">simplifyExhaustive</a> (int height=1, unsigned nThreads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a7701e3dd1fdbe8d8106363d118ec887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph.  <a href="#a7701e3dd1fdbe8d8106363d118ec887d">More...</a><br /></td></tr>
<tr class="separator:a7701e3dd1fdbe8d8106363d118ec887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc3ba80f5f033f8b306a718b06566c"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:aeadc3ba80f5f033f8b306a718b06566c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aeadc3ba80f5f033f8b306a718b06566c">rewrite</a> (int height, unsigned nThreads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:aeadc3ba80f5f033f8b306a718b06566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings.  <a href="#aeadc3ba80f5f033f8b306a718b06566c">More...</a><br /></td></tr>
<tr class="separator:aeadc3ba80f5f033f8b306a718b06566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a28355f40d08c312c5f2e6cceb68bc1b4">composeWith</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the composition of this with the given link.  <a href="#a28355f40d08c312c5f2e6cceb68bc1b4">More...</a><br /></td></tr>
<tr class="separator:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Invariants and Related Properties</div></td></tr>
<tr class="memitem:a821a3c1d060bdc5f3807ee1a64064775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a821a3c1d060bdc5f3807ee1a64064775">isAlternating</a> () const</td></tr>
<tr class="memdesc:a821a3c1d060bdc5f3807ee1a64064775"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this knot diagram is alternating.  <a href="#a821a3c1d060bdc5f3807ee1a64064775">More...</a><br /></td></tr>
<tr class="separator:a821a3c1d060bdc5f3807ee1a64064775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdacd0939c10de129dcf4c9a72f209c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8cdacd0939c10de129dcf4c9a72f209c">linking</a> () const</td></tr>
<tr class="memdesc:a8cdacd0939c10de129dcf4c9a72f209c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the linking number of this link.  <a href="#a8cdacd0939c10de129dcf4c9a72f209c">More...</a><br /></td></tr>
<tr class="separator:a8cdacd0939c10de129dcf4c9a72f209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e5a318a8fdab39ebea49912074d19"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aed6e5a318a8fdab39ebea49912074d19">writhe</a> () const</td></tr>
<tr class="memdesc:aed6e5a318a8fdab39ebea49912074d19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the writhe of this link diagram.  <a href="#aed6e5a318a8fdab39ebea49912074d19">More...</a><br /></td></tr>
<tr class="separator:aed6e5a318a8fdab39ebea49912074d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b02a5c5a55f174df916132eb1b74d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2b02a5c5a55f174df916132eb1b74d54">complement</a> (bool simplify=true) const</td></tr>
<tr class="memdesc:a2b02a5c5a55f174df916132eb1b74d54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an ideal triangulation of the complement of this link in the 3-sphere.  <a href="#a2b02a5c5a55f174df916132eb1b74d54">More...</a><br /></td></tr>
<tr class="separator:a2b02a5c5a55f174df916132eb1b74d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9da32820ca345fb6056f0cc149c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2d9da32820ca345fb6056f0cc149c872">parallel</a> (int k, <a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a> framing=<a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a>) const</td></tr>
<tr class="memdesc:a2d9da32820ca345fb6056f0cc149c872"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <em>k</em> cables of this link, all parallel to each other using the given framing.  <a href="#a2d9da32820ca345fb6056f0cc149c872">More...</a><br /></td></tr>
<tr class="separator:a2d9da32820ca345fb6056f0cc149c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd286c4c3d5512b2d9de53e57a57055a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a">bracket</a> (<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:afd286c4c3d5512b2d9de53e57a57055a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Kauffman bracket polynomial of this link diagram.  <a href="#afd286c4c3d5512b2d9de53e57a57055a">More...</a><br /></td></tr>
<tr class="separator:afd286c4c3d5512b2d9de53e57a57055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a432a4f3024e537920770c0eb60d2e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6a432a4f3024e537920770c0eb60d2e2">knowsBracket</a> () const</td></tr>
<tr class="memdesc:a6a432a4f3024e537920770c0eb60d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details.  <a href="#a6a432a4f3024e537920770c0eb60d2e2">More...</a><br /></td></tr>
<tr class="separator:a6a432a4f3024e537920770c0eb60d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74edbfadfccb443efa6a6f1852ab9b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5">jones</a> (<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ad74edbfadfccb443efa6a6f1852ab9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Jones polynomial of this link, but with all exponents doubled.  <a href="#ad74edbfadfccb443efa6a6f1852ab9b5">More...</a><br /></td></tr>
<tr class="separator:ad74edbfadfccb443efa6a6f1852ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2acb5efa330841a89e91d28e5d64a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a13a2acb5efa330841a89e91d28e5d64a">knowsJones</a> () const</td></tr>
<tr class="memdesc:a13a2acb5efa330841a89e91d28e5d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Jones polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details.  <a href="#a13a2acb5efa330841a89e91d28e5d64a">More...</a><br /></td></tr>
<tr class="separator:a13a2acb5efa330841a89e91d28e5d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173ba85ab3f36b64631816894ff4809f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f">homflyAZ</a> (<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a173ba85ab3f36b64631816894ff4809f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="#a173ba85ab3f36b64631816894ff4809f">More...</a><br /></td></tr>
<tr class="separator:a173ba85ab3f36b64631816894ff4809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8165708806e390b41b33655bdbb40af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5">homflyLM</a> (<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a8165708806e390b41b33655bdbb40af5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>.  <a href="#a8165708806e390b41b33655bdbb40af5">More...</a><br /></td></tr>
<tr class="separator:a8165708806e390b41b33655bdbb40af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cdae63725a633c32868737d44cb7c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7">homfly</a> (<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:aa3cdae63725a633c32868737d44cb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>.  <a href="#aa3cdae63725a633c32868737d44cb7c7">More...</a><br /></td></tr>
<tr class="separator:aa3cdae63725a633c32868737d44cb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae7100ef279d1f9a4ed7a739e76d5c5d4">knowsHomfly</a> () const</td></tr>
<tr class="memdesc:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details.  <a href="#ae7100ef279d1f9a4ed7a739e76d5c5d4">More...</a><br /></td></tr>
<tr class="separator:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9867163e5b6defa9aa85d9bd8d9963"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#adf9867163e5b6defa9aa85d9bd8d9963">niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:adf9867163e5b6defa9aa85d9bd8d9963"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.  <a href="#adf9867163e5b6defa9aa85d9bd8d9963">More...</a><br /></td></tr>
<tr class="separator:adf9867163e5b6defa9aa85d9bd8d9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b845088fe7d44ab3da72b9fa9abddc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7b845088fe7d44ab3da72b9fa9abddc0">useTreeDecomposition</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;td)</td></tr>
<tr class="memdesc:a7b845088fe7d44ab3da72b9fa9abddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link.  <a href="#a7b845088fe7d44ab3da72b9fa9abddc0">More...</a><br /></td></tr>
<tr class="separator:a7b845088fe7d44ab3da72b9fa9abddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Administration</div></td></tr>
<tr class="memitem:a645147f6f603066ea0eb85a8d0978578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a645147f6f603066ea0eb85a8d0978578">writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a645147f6f603066ea0eb85a8d0978578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a645147f6f603066ea0eb85a8d0978578">More...</a><br /></td></tr>
<tr class="separator:a645147f6f603066ea0eb85a8d0978578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58309b754fc2392ea83ee63c77a961b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a58309b754fc2392ea83ee63c77a961b8">writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a58309b754fc2392ea83ee63c77a961b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a58309b754fc2392ea83ee63c77a961b8">More...</a><br /></td></tr>
<tr class="separator:a58309b754fc2392ea83ee63c77a961b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34359ae0aeda30012164cd24256dd29d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a34359ae0aeda30012164cd24256dd29d">dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:a34359ae0aeda30012164cd24256dd29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#a34359ae0aeda30012164cd24256dd29d">More...</a><br /></td></tr>
<tr class="separator:a34359ae0aeda30012164cd24256dd29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Links</div></td></tr>
<tr class="memitem:a805821d3da773fdd9a69f75916dbd90e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a805821d3da773fdd9a69f75916dbd90e">brief</a> () const</td></tr>
<tr class="memdesc:a805821d3da773fdd9a69f75916dbd90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this link in Regina's own brief format.  <a href="#a805821d3da773fdd9a69f75916dbd90e">More...</a><br /></td></tr>
<tr class="separator:a805821d3da773fdd9a69f75916dbd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05b65401950517d86be107268233b09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09">gauss</a> () const</td></tr>
<tr class="memdesc:ac05b65401950517d86be107268233b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a classical Gauss code for this knot.  <a href="#ac05b65401950517d86be107268233b09">More...</a><br /></td></tr>
<tr class="separator:ac05b65401950517d86be107268233b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8c0d2be78044e3fc4108e092d086a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a5d8c0d2be78044e3fc4108e092d086a5">gauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5d8c0d2be78044e3fc4108e092d086a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a classical Gauss code for this knot to the given output stream.  <a href="#a5d8c0d2be78044e3fc4108e092d086a5">More...</a><br /></td></tr>
<tr class="separator:a5d8c0d2be78044e3fc4108e092d086a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d81af83901af217da0bee17b6bf120"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120">orientedGauss</a> () const</td></tr>
<tr class="memdesc:ab8d81af83901af217da0bee17b6bf120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an oriented Gauss code for this knot.  <a href="#ab8d81af83901af217da0bee17b6bf120">More...</a><br /></td></tr>
<tr class="separator:ab8d81af83901af217da0bee17b6bf120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a21eaa9351a071dc7ddcf8e4d1101d584">orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this knot to the given output stream.  <a href="#a21eaa9351a071dc7ddcf8e4d1101d584">More...</a><br /></td></tr>
<tr class="separator:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8">jenkins</a> () const</td></tr>
<tr class="memdesc:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link as a string using the text representation described by Bob Jenkins.  <a href="#a194f84f5ad2fb28ab1a0da34aa69d8a8">More...</a><br /></td></tr>
<tr class="separator:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6509ca2eaf2920bf4dc7e69eb5f5f499">jenkins</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link to the given output stream using the text representation described by Bob Jenkins.  <a href="#a6509ca2eaf2920bf4dc7e69eb5f5f499">More...</a><br /></td></tr>
<tr class="separator:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478">dt</a> (bool alpha=false) const</td></tr>
<tr class="memdesc:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this knot using Dowker-Thistlethwaite notation.  <a href="#a7394cd7aa9cb8d14cb4d7d39f9d96478">More...</a><br /></td></tr>
<tr class="separator:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6e48b3891b1ec16cff1190f781e3ebd0">dt</a> (std::ostream &amp;out, bool alpha=false) const</td></tr>
<tr class="memdesc:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this knot to the given output stream using Dowker-Thistlethwaite notation.  <a href="#a6e48b3891b1ec16cff1190f781e3ebd0">More...</a><br /></td></tr>
<tr class="separator:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92">writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the underlying planar 4-valent multigraph using the PACE text format.  <a href="#a8f682deb7aeb5c9e3b06c8db4aec3b92">More...</a><br /></td></tr>
<tr class="separator:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b21aaa8020908478576e1f9325d4f91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a6b21aaa8020908478576e1f9325d4f91">pace</a> () const</td></tr>
<tr class="memdesc:a6b21aaa8020908478576e1f9325d4f91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of the underlying planar 4-valent multigraph, using the PACE text format.  <a href="#a6b21aaa8020908478576e1f9325d4f91">More...</a><br /></td></tr>
<tr class="separator:a6b21aaa8020908478576e1f9325d4f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718258433d47de780e6905585a00bd29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a718258433d47de780e6905585a00bd29">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:a718258433d47de780e6905585a00bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used to reconstruct this link.  <a href="#a718258433d47de780e6905585a00bd29">More...</a><br /></td></tr>
<tr class="separator:a718258433d47de780e6905585a00bd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e305e2721276730a7783e84bc0bc04"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04">knotSig</a> (bool useReflection=true, bool useReversal=true) const</td></tr>
<tr class="memdesc:a96e305e2721276730a7783e84bc0bc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <em>signature</em> for this knot diagram.  <a href="#a96e305e2721276730a7783e84bc0bc04">More...</a><br /></td></tr>
<tr class="separator:a96e305e2721276730a7783e84bc0bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:ga11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a> () const =0</td></tr>
<tr class="memdesc:ga11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:ga11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">typeName</a> () const =0</td></tr>
<tr class="memdesc:ga787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:ga787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a> () const</td></tr>
<tr class="memdesc:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">humanLabel</a> () const</td></tr>
<tr class="memdesc:gadfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:gadfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfd869991cbf664891629f21a5432b02">setLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:gadfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="group__packet.html#gadfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:gadfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">fullName</a> () const</td></tr>
<tr class="memdesc:ga29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:ga29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaf4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">hasTags</a> () const</td></tr>
<tr class="memdesc:ga4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:ga4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">removeAllTags</a> ()</td></tr>
<tr class="memdesc:gaee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">tags</a> () const</td></tr>
<tr class="memdesc:ga06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:ga06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:gaa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gaa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:gaa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:gae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> () const</td></tr>
<tr class="memdesc:gab80d6d7bc86d4600980f0c9555bb6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">More...</a><br /></td></tr>
<tr class="separator:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">firstChild</a> () const</td></tr>
<tr class="memdesc:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">More...</a><br /></td></tr>
<tr class="separator:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">lastChild</a> () const</td></tr>
<tr class="memdesc:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">More...</a><br /></td></tr>
<tr class="separator:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">nextSibling</a> () const</td></tr>
<tr class="memdesc:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">More...</a><br /></td></tr>
<tr class="separator:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84decda10642eccee55a109e70e10076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84decda10642eccee55a109e70e10076">prevSibling</a> () const</td></tr>
<tr class="memdesc:ga84decda10642eccee55a109e70e10076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="group__packet.html#ga84decda10642eccee55a109e70e10076">More...</a><br /></td></tr>
<tr class="separator:ga84decda10642eccee55a109e70e10076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">root</a> () const</td></tr>
<tr class="memdesc:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">More...</a><br /></td></tr>
<tr class="separator:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">More...</a><br /></td></tr>
<tr class="separator:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const</td></tr>
<tr class="memdesc:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">More...</a><br /></td></tr>
<tr class="separator:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">More...</a><br /></td></tr>
<tr class="separator:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">countChildren</a> () const</td></tr>
<tr class="memdesc:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">countDescendants</a> () const</td></tr>
<tr class="memdesc:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet.  <a href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">totalTreeSize</a> () const</td></tr>
<tr class="memdesc:gae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:gae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">More...</a><br /></td></tr>
<tr class="separator:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">More...</a><br /></td></tr>
<tr class="separator:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:gad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">More...</a><br /></td></tr>
<tr class="separator:gad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">makeOrphan</a> ()</td></tr>
<tr class="memdesc:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ga219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">More...</a><br /></td></tr>
<tr class="separator:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:ga27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">More...</a><br /></td></tr>
<tr class="separator:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga765186c1742fe402922433b77e5f439a">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:ga765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="group__packet.html#ga765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:ga765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ga59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="group__packet.html#ga59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:ga59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">moveToFirst</a> ()</td></tr>
<tr class="memdesc:gab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:gab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">moveToLast</a> ()</td></tr>
<tr class="memdesc:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">sortChildren</a> ()</td></tr>
<tr class="memdesc:gaf91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:gaf91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a> ()</td></tr>
<tr class="memdesc:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">More...</a><br /></td></tr>
<tr class="separator:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941baf3f572331538ec82154fd3dc997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a> ()</td></tr>
<tr class="memdesc:ga941baf3f572331538ec82154fd3dc997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">More...</a><br /></td></tr>
<tr class="separator:ga941baf3f572331538ec82154fd3dc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">descendants</a> () const</td></tr>
<tr class="memdesc:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">More...</a><br /></td></tr>
<tr class="separator:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17dd27f603463f226e64ccb65211060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">children</a> () const</td></tr>
<tr class="memdesc:gaf17dd27f603463f226e64ccb65211060"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet.  <a href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">More...</a><br /></td></tr>
<tr class="separator:gaf17dd27f603463f226e64ccb65211060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br /></td></tr>
<tr class="separator:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">nextTreePacket</a> () const</td></tr>
<tr class="memdesc:gaeaff341860febcb3daadd1b9b4216c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">More...</a><br /></td></tr>
<tr class="separator:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">More...</a><br /></td></tr>
<tr class="separator:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74345507fd3326dc1b22a284b90da5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga74345507fd3326dc1b22a284b90da5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">More...</a><br /></td></tr>
<tr class="separator:ga74345507fd3326dc1b22a284b90da5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">More...</a><br /></td></tr>
<tr class="separator:ga12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">More...</a><br /></td></tr>
<tr class="separator:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br /></td></tr>
<tr class="separator:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7855ea352221d498d1ca38a34d85af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:gac7855ea352221d498d1ca38a34d85af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">More...</a><br /></td></tr>
<tr class="separator:gac7855ea352221d498d1ca38a34d85af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Dependencies</div></td></tr>
<tr class="memitem:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">isPacketEditable</a> () const</td></tr>
<tr class="memdesc:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">More...</a><br /></td></tr>
<tr class="separator:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>=true) const</td></tr>
<tr class="memdesc:ga73c411ef1237a06ad6b634d3db67f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">More...</a><br /></td></tr>
<tr class="separator:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File I/O</div></td></tr>
<tr class="memitem:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">save</a> (const char *filename, bool compressed=true) const</td></tr>
<tr class="memdesc:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">More...</a><br /></td></tr>
<tr class="separator:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">save</a> (std::ostream &amp;s, bool compressed=true) const</td></tr>
<tr class="memdesc:ga898ec49e8d39c46cd965ad506493f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">More...</a><br /></td></tr>
<tr class="separator:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">writeXMLFile</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0bf681a968d890cd848f1277ea22ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">More...</a><br /></td></tr>
<tr class="separator:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">internalID</a> () const</td></tr>
<tr class="memdesc:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6c4c3e3e4fa822eebebef10246a5469f"><td class="memItemLeft" align="right" valign="top"><a id="a6c4c3e3e4fa822eebebef10246a5469f"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:a6c4c3e3e4fa822eebebef10246a5469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">safeDelete</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it.  <a href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">More...</a><br /></td></tr>
<tr class="separator:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7063f2022a096350cb8e25cd937a94cc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7063f2022a096350cb8e25cd937a94cc">jonesVar</a></td></tr>
<tr class="memdesc:a7063f2022a096350cb8e25cd937a94cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Jones polynomial, as returned by <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>.  <a href="#a7063f2022a096350cb8e25cd937a94cc">More...</a><br /></td></tr>
<tr class="separator:a7063f2022a096350cb8e25cd937a94cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2ca40f892a2375f27159cf11314ac"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#af6b2ca40f892a2375f27159cf11314ac">homflyAZVarX</a></td></tr>
<tr class="memdesc:af6b2ca40f892a2375f27159cf11314ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="#af6b2ca40f892a2375f27159cf11314ac">More...</a><br /></td></tr>
<tr class="separator:af6b2ca40f892a2375f27159cf11314ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3c7bb6dae63c7e28696f33f79ac6db"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a0a3c7bb6dae63c7e28696f33f79ac6db">homflyAZVarY</a></td></tr>
<tr class="memdesc:a0a3c7bb6dae63c7e28696f33f79ac6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>.  <a href="#a0a3c7bb6dae63c7e28696f33f79ac6db">More...</a><br /></td></tr>
<tr class="separator:a0a3c7bb6dae63c7e28696f33f79ac6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4891884482d63762104e45c064375c"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#abf4891884482d63762104e45c064375c">homflyLMVarX</a></td></tr>
<tr class="memdesc:abf4891884482d63762104e45c064375c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="#abf4891884482d63762104e45c064375c">More...</a><br /></td></tr>
<tr class="separator:abf4891884482d63762104e45c064375c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ace9dcc4b15180a96d0d2c8d0cbb157ab">homflyLMVarY</a></td></tr>
<tr class="memdesc:ace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>.  <a href="#ace9dcc4b15180a96d0d2c8d0cbb157ab">More...</a><br /></td></tr>
<tr class="separator:ace9dcc4b15180a96d0d2c8d0cbb157ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65375567e9a939248cef8a464e1ea0c7"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a65375567e9a939248cef8a464e1ea0c7">homflyVarX</a></td></tr>
<tr class="memdesc:a65375567e9a939248cef8a464e1ea0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="#a65375567e9a939248cef8a464e1ea0c7">More...</a><br /></td></tr>
<tr class="separator:a65375567e9a939248cef8a464e1ea0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b39da1b23893a682ff22b388041fdc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a79b39da1b23893a682ff22b388041fdc">homflyVarY</a></td></tr>
<tr class="memdesc:a79b39da1b23893a682ff22b388041fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>.  <a href="#a79b39da1b23893a682ff22b388041fdc">More...</a><br /></td></tr>
<tr class="separator:a79b39da1b23893a682ff22b388041fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa36d8a4b0c964cafb2cbac86b0d5e272"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa36d8a4b0c964cafb2cbac86b0d5e272">internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:aa36d8a4b0c964cafb2cbac86b0d5e272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#aa36d8a4b0c964cafb2cbac86b0d5e272">More...</a><br /></td></tr>
<tr class="separator:aa36d8a4b0c964cafb2cbac86b0d5e272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df95452d2c6fdd8ec754c5adbaf9505"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a4df95452d2c6fdd8ec754c5adbaf9505">writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a4df95452d2c6fdd8ec754c5adbaf9505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#a4df95452d2c6fdd8ec754c5adbaf9505">More...</a><br /></td></tr>
<tr class="separator:a4df95452d2c6fdd8ec754c5adbaf9505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">writeXMLPacketTree</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">More...</a><br /></td></tr>
<tr class="separator:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="a152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ModelLinkGraph</b></td></tr>
<tr class="separator:a152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="a5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Tangle</b></td></tr>
<tr class="separator:a5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memItemLeft" align="right" valign="top"><a id="ac427ed4036a7fdf0f108da0bbf1ca863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkCrossingsReader</b></td></tr>
<tr class="separator:ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3f892e9d18731f9bee8f2a197e904"><td class="memItemLeft" align="right" valign="top"><a id="acab3f892e9d18731f9bee8f2a197e904"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkComponentsReader</b></td></tr>
<tr class="separator:acab3f892e9d18731f9bee8f2a197e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Building Links</h2></td></tr>
<tr class="memitem:aa11d6d31315c7b000cb653901a0a711c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#aa11d6d31315c7b000cb653901a0a711c">insertTorusLink</a> (int p, int q, bool positive=true)</td></tr>
<tr class="memdesc:aa11d6d31315c7b000cb653901a0a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new (<em>p</em>, <em>q</em>) torus link into this link.  <a href="#aa11d6d31315c7b000cb653901a0a711c">More...</a><br /></td></tr>
<tr class="separator:aa11d6d31315c7b000cb653901a0a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080cbca4af7eadcab1aea5aec456d2ba"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a080cbca4af7eadcab1aea5aec456d2ba"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a080cbca4af7eadcab1aea5aec456d2ba">fromData</a> (std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... components)</td></tr>
<tr class="memdesc:a080cbca4af7eadcab1aea5aec456d2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new link from hard-coded information about its crossings and components.  <a href="#a080cbca4af7eadcab1aea5aec456d2ba">More...</a><br /></td></tr>
<tr class="separator:a080cbca4af7eadcab1aea5aec456d2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa67a9f8642ba7682baeade317ded53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2fa67a9f8642ba7682baeade317ded53">fromKnotSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:a2fa67a9f8642ba7682baeade317ded53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a knot diagram from its signature.  <a href="#a2fa67a9f8642ba7682baeade317ded53">More...</a><br /></td></tr>
<tr class="separator:a2fa67a9f8642ba7682baeade317ded53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24bafb845a51157cecfdbdd66f6f30c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ad24bafb845a51157cecfdbdd66f6f30c">fromGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ad24bafb845a51157cecfdbdd66f6f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code.  <a href="#ad24bafb845a51157cecfdbdd66f6f30c">More...</a><br /></td></tr>
<tr class="separator:ad24bafb845a51157cecfdbdd66f6f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552933848162ccc80e1ee0b4399f9866"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a552933848162ccc80e1ee0b4399f9866"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a552933848162ccc80e1ee0b4399f9866">fromGauss</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:a552933848162ccc80e1ee0b4399f9866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from a classical Gauss code.  <a href="#a552933848162ccc80e1ee0b4399f9866">More...</a><br /></td></tr>
<tr class="separator:a552933848162ccc80e1ee0b4399f9866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23add46272acfdedb83be5fd5f7d3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c">fromOrientedGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a7f23add46272acfdedb83be5fd5f7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code.  <a href="#a7f23add46272acfdedb83be5fd5f7d3c">More...</a><br /></td></tr>
<tr class="separator:a7f23add46272acfdedb83be5fd5f7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9ccfdf468272086377417cf8a3df27"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a2d9ccfdf468272086377417cf8a3df27"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a2d9ccfdf468272086377417cf8a3df27">fromOrientedGauss</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:a2d9ccfdf468272086377417cf8a3df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an "oriented" variant of the Gauss code.  <a href="#a2d9ccfdf468272086377417cf8a3df27">More...</a><br /></td></tr>
<tr class="separator:a2d9ccfdf468272086377417cf8a3df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac206f9e3697de7472ee9ec151c106df0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ac206f9e3697de7472ee9ec151c106df0">fromJenkins</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ac206f9e3697de7472ee9ec151c106df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a link from the text representation described by Bob Jenkins.  <a href="#ac206f9e3697de7472ee9ec151c106df0">More...</a><br /></td></tr>
<tr class="separator:ac206f9e3697de7472ee9ec151c106df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02aeec8648b7d97f889a3cb231ae226"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#ae02aeec8648b7d97f889a3cb231ae226">fromJenkins</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ae02aeec8648b7d97f889a3cb231ae226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a link from the text representation described by Bob Jenkins.  <a href="#ae02aeec8648b7d97f889a3cb231ae226">More...</a><br /></td></tr>
<tr class="separator:ae02aeec8648b7d97f889a3cb231ae226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d838c4975af256e7c8b40842d370dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a34d838c4975af256e7c8b40842d370dc">fromDT</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a34d838c4975af256e7c8b40842d370dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.  <a href="#a34d838c4975af256e7c8b40842d370dc">More...</a><br /></td></tr>
<tr class="separator:a34d838c4975af256e7c8b40842d370dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8e6024307a59835117f2910eac5a99"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a7b8e6024307a59835117f2910eac5a99"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Link.html#a7b8e6024307a59835117f2910eac5a99">fromDT</a> (Iterator <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a>, Iterator <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>)</td></tr>
<tr class="memdesc:a7b8e6024307a59835117f2910eac5a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new knot from an integer sequence using the numerical variant of Dowker-Thistlethwaite notation.  <a href="#a7b8e6024307a59835117f2910eac5a99">More...</a><br /></td></tr>
<tr class="separator:a7b8e6024307a59835117f2910eac5a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a directed knot or link in the 3-sphere. </p>
<p>This class supports links with any number of components (including zero), and it also supports components with no crossings (which form additional unknot components of the overall link). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e4bacf91fc79a12ae3a02f4339ed034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4bacf91fc79a12ae3a02f4339ed034">&#9670;&nbsp;</a></span>SafePointeeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>  <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff4dc84be20b66314534c2dcc7466324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4dc84be20b66314534c2dcc7466324">&#9670;&nbsp;</a></span>Link() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty link. </p>
<p>This will have zero components. </p>

</div>
</div>
<a id="aa6b717f99561f93f6b09118cdf770803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b717f99561f93f6b09118cdf770803">&#9670;&nbsp;</a></span>Link() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unknots</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the unlink with the given number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unknots</td><td>the number of (unknotted) components in the new unlink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359918be5fb86081d1122cc2f2260a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359918be5fb86081d1122cc2f2260a5f">&#9670;&nbsp;</a></span>Link() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link. </p>
<p>The packet tree structure and packet label are <em>not</em> copied.</p>
<p>This will clone any computed properties (such as Jones polynomial and so on) of the given link also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef22c9d7355dc008bfc0282c1f99e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef22c9d7355dc008bfc0282c1f99e4b">&#9670;&nbsp;</a></span>Link() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given link (such as Jones polynomial and so on), or <code>false</code> if the new link should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b233fb32a24925705b616b5dc23b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b233fb32a24925705b616b5dc23b219">&#9670;&nbsp;</a></span>Link() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a link. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>knot signatures, as used by <a class="el" href="classregina_1_1Link.html#a2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a>;</li>
<li>oriented Gauss codes, as used by <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>;</li>
<li>classical Gauss codes, as used by <a class="el" href="classregina_1_1Link.html#ad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss()</a>;</li>
<li>numeric or alphabetical Dowker-Thistlethwaite strings, as used by <a class="el" href="classregina_1_1Link.html#a34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT()</a>.</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<p>Regina will also set the packet label accordingly.</p>
<p>If Regina cannot interpret the given string, this will be left as the empty link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a knot or link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca93be82c5a263db9e3dc28a928fb4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca93be82c5a263db9e3dc28a928fb4ba">&#9670;&nbsp;</a></span>~Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::~Link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this link. </p>
<p>The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this link will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afd286c4c3d5512b2d9de53e57a57055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd286c4c3d5512b2d9de53e57a57055a">&#9670;&nbsp;</a></span>bracket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::bracket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Kauffman bracket polynomial of this link diagram. </p>
<p>Note that the bracket polynomial is not an invariant - it is preserved under Reidemeister moves II and III, but not I.</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> should be called again; this will be instantaneous if the bracket polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the requested invariant has already been computed, then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently less than the number of bits in a long, which on a typical machine is 64). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bracket polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="a805821d3da773fdd9a69f75916dbd90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805821d3da773fdd9a69f75916dbd90e">&#9670;&nbsp;</a></span>brief()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::brief </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this link in Regina's own brief format. </p>
<p>This format is concise, but contains enough information to reconstruct the link.</p>
<p>This format cannot (yet) be used to read links back into Regina, and so it is not good for external storage, or for passing links between different programs (or even different instances of Regina). It was originally designed for use with the test suite, where it was used to ensure that links with being created and/or manipulated correctly.</p>
<p>The output will contains the following elements, separated by single spaces:</p>
<ul>
<li>a sequence of signs (<code>+</code> or <code>-</code>), concatenated together, giving the signs of the crossings in order from crossing 0 to crossing <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1;</li>
<li>a description of each component of the link, in order from component 0 to component <a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1. Each component will be written in the form <code>( a b c ... )</code>, indicating the crossings that are encountered as we follow the component in the forward direction from its starting strand. Each element <em>a</em>, <em>b</em>, <em>c</em> and so on will be written in the format used by the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> class: either <code>^n</code> when passing over crossing <em>n</em>, or <code>_n</code> when passing under crossing <em>n</em>.</li>
</ul>
<p>For example, the Whitehead link as returned by <a class="el" href="classregina_1_1ExampleLink.html#a66bec3dc74f7d1fc1ef2ce9cde5508ae" title="Returns a five-crossing diagram of the Whitehead link.">ExampleLink.whitehead()</a> will give the following brief output:</p>
<pre class="fragment">--++- ( ^0 _1 ^4 _3 ^2 _4 ) ( _0 ^1 _2 ^3 )
</pre><p>As a special case, if the link contains no crossings, then the format will not begin with a space; instead it will simply be a sequence of the form <code>( ) ( ) ... ( )</code>.</p>
<p>The string will not end in a newline.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link in Regina's brief format. </dd></dl>

</div>
</div>
<a id="a0d386bea941e436ae6548aa8663a005b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d386bea941e436ae6548aa8663a005b">&#9670;&nbsp;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of the given crossing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0546dc7f2bde7b63c31f3e057a8c04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546dc7f2bde7b63c31f3e057a8c04db">&#9670;&nbsp;</a></span>changeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::changeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the diagram. </p>
<p>This operation corresponds to reflecting the link diagram through the plane on which it is drawn. </p>

</div>
</div>
<a id="a2b02a5c5a55f174df916132eb1b74d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b02a5c5a55f174df916132eb1b74d54">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::Link::complement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an ideal triangulation of the complement of this link in the 3-sphere. </p>
<p>The triangulation will have one ideal vertex for each link component. Assuming you pass <em>simplify</em> as <code>true</code> (the default), there will typically be no internal vertices; however, this is not guaranteed.</p>
<p>Initially, the triangulation will be oriented. In particular, each tetrahedron will be oriented according to a right-hand rule: the thumb of the right hand points from vertices 0 to 1, and the fingers curl around to point from vertices 2 to 3.</p>
<p>What happens next depends upon the argument <em>simplify:</em> </p>
<ul>
<li>If you pass <em>simplify</em> as <code>true</code>, then Regina will attempt to simplify the triangulation to as few tetrahedra as possible. As a result, the orientation described above will be lost.</li>
<li>If you pass <em>simplify</em> as <code>false</code>, then Regina will leave the triangulation as is. This will preserve the orientation, but it means that the triangulation will contain both ideal and internal vertices (and, in general, far more tetrahedra than are necessary).</li>
</ul>
<p>The triangulation will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if and only if the triangulation of the complement should be simplified (thereby losing information about the orientation), as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complement of this link, as a newly-created object. </dd></dl>

</div>
</div>
<a id="a3425a2a6994fbc87baf890e9b429ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3425a2a6994fbc87baf890e9b429ef6f">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a strand in the given component of this link. </p>
<p>For each component of the link, this routine returns a "starting strand". You can traverse the entire component by beginning at this starting strand and repeatedly incrementing it through a routine such as <a class="el" href="classregina_1_1StrandRef.html#aca9f21431143267c5f4d7142f604559f" title="Moves this reference forward along the direction of the link until it reaches the next crossing.">StrandRef::operator++</a> or <a class="el" href="classregina_1_1StrandRef.html#a0f3ce62d47997b0e320735c7e32fd54a" title="Returns the crossing reference that comes immediately after this when walking forward along the direc...">StrandRef::next()</a>.</p>
<p>If a component has no crossings (which means it must be a separate unknot component), then this routine will return a null reference (i.e., <a class="el" href="classregina_1_1StrandRef.html#abe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">StrandRef::crossing()</a> will return <code>null</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="classregina_1_1Link.html#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a "starting strand" for traversing the component at the given index, or a null reference if the requested component has no crossings. </dd></dl>

</div>
</div>
<a id="a28355f40d08c312c5f2e6cceb68bc1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28355f40d08c312c5f2e6cceb68bc1b4">&#9670;&nbsp;</a></span>composeWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::composeWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the composition of this with the given link. </p>
<p>This link will be altered directly.</p>
<p>Specifically, the first component of the given link will be grafted into the first component of this link, in a way that preserves orientations and crossing signs. If the given link has any additional components, then they will be copied into this link directly with no modification.</p>
<p>This routine may be expanded in future versions of Regina to allow more flexibility (in particular, to allow you to choose which components of the two links to graft together, and/or at which strands to graft them).</p>
<p>If either link is empty (i.e., contains no components at all), then the result will simply be a clone of the other link (with no composition operation performed).</p>
<p>It is allowed to pass this link as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link with which this should be composed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc783777826fcf17af86d21a343118d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc783777826fcf17af86d21a343118d5">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given crossings are connected in the underlying 4-valent graph of the link diagram. </p>
<p>Here "the underlying 4-valent graph" means the multigraph whose vertices are the crossings and whose edges are the arcs between crossings. In particular</p>
<ul>
<li>two crossings may be connected even if they involve entirely different components of the link;</li>
<li>if two crossings are not connected then the underlying link must be splittable (though this need not happen in the other direction: one can have a diagram of a splittable link in which all crossings are connected with each other).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow (linear time), since it may need to perform a depth-first search through the graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first of the two crossings to examine. </td></tr>
    <tr><td class="paramname">b</td><td>the second of the two crossings to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two given crossings are connected. </dd></dl>

</div>
</div>
<a id="ab4fb9a0932d786dfca9eef2f6e45ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb9a0932d786dfca9eef2f6e45ec60">&#9670;&nbsp;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of components in this link. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="a2b47712bc419c15659a634ae6ea97b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47712bc419c15659a634ae6ea97b91">&#9670;&nbsp;</a></span>crossing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Link::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the crossing at the given index within this link. </p>
<p>For a link with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="a34359ae0aeda30012164cd24256dd29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34359ae0aeda30012164cd24256dd29d">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7394cd7aa9cb8d14cb4d7d39f9d96478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7394cd7aa9cb8d14cb4d7d39f9d96478">&#9670;&nbsp;</a></span>dt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this knot using Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, Regina supports two variants of this notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will return the empty string if the alphabetical variant is requested.</li>
</ul>
<p>In general, Dowker-Thistlethwaite notation does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same sequence of integers; moreover, for composite knots, the same Dowker-Thistlethwaite notation can describe inequivalent knots (even when allowing for reflections). If you need notation that specifies the knot uniquely, consider using the oriented Gauss code instead, as output by <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>.</p>
<p>Currently Regina only supports Dowker-Thistlethwaite notation for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Dowker-Thistlethwaite notation for this knot diagram. This routine will return the empty string if this link has zero or multiple components, or if <em>alpha</em> is <code>true</code> and the knot has more than 26 crossings. </dd></dl>

</div>
</div>
<a id="a6e48b3891b1ec16cff1190f781e3ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e48b3891b1ec16cff1190f781e3ebd0">&#9670;&nbsp;</a></span>dt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this knot to the given output stream using Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, Regina supports two variants of this notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will output nothing at all if the alphabetical variant is requested.</li>
</ul>
<p>In general, Dowker-Thistlethwaite notation does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same sequence of integers; moreover, for composite knots, the same Dowker-Thistlethwaite notation can describe inequivalent knots (even when allowing for reflections). If you need notation that specifies the knot uniquely, consider using the oriented Gauss code instead, as output by <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>.</p>
<p>Currently Regina only supports Dowker-Thistlethwaite notation for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python:\n This routine is not available in Python. Instead,</dt><dd>Python users can use the variant <a class="el" href="classregina_1_1Link.html#a7394cd7aa9cb8d14cb4d7d39f9d96478" title="Outputs this knot using Dowker-Thistlethwaite notation.">dt()</a>, which takes just the optional <em>alpha</em> argument and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a718258433d47de780e6905585a00bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718258433d47de780e6905585a00bd29">&#9670;&nbsp;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used to reconstruct this link. </p>
<p>This code will use the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> constructor that takes a series of hard-coded C++11 initialiser lists.</p>
<p>The main purpose of this routine is to generate these hard-coded initialiser lists, which can be tedious and error-prone to write by hand.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="a080cbca4af7eadcab1aea5aec456d2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080cbca4af7eadcab1aea5aec456d2ba">&#9670;&nbsp;</a></span>fromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>crossingSigns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Args &gt;...&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new link from hard-coded information about its crossings and components. </p>
<p>This constructor takes a series of C++11 initialiser lists (each a list of integers), which makes it useful for creating hard-coded examples directly in C++ code.</p>
<p>For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The lists that you must pass to this routine are as follows:</p>
<ul>
<li>The first list contains the signs of crossings 1, ..., <em>n</em> in order, where each sign is either +1 or -1.</li>
<li>Each subsequent list describes a single component of the link. The list identifies which crossings you visit in order when traversing the component; a positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>. Empty lists are allowed (these denote separate unknot components).</li>
<li>If a component has no crossings, then you should pass the list { 0 }, not the empty list. (This is because the C++ compiler cannot deduce the type of an empty list.)</li>
</ul>
<p>Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the left-hand trefoil and the Hopf link as follows:</p>
<dl class="section pre"><dt>Precondition</dt><dd>trefoil = <a class="el" href="classregina_1_1Link.html#a080cbca4af7eadcab1aea5aec456d2ba" title="Creates a new link from hard-coded information about its crossings and components.">Link::fromData</a>({ -1, -1, -1 }, { 1, -2, 3, -1, 2, -3 }); hopf = <a class="el" href="classregina_1_1Link.html#a080cbca4af7eadcab1aea5aec456d2ba" title="Creates a new link from hard-coded information about its crossings and components.">Link::fromData</a>({ +1, +1 }, { 1, -2 }, { -1, 2 }); \endpre</dd></dl>
<p>The topology of the link is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a link diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you have an existing link that you would like to hard-code, the routine <a class="el" href="classregina_1_1Link.html#a718258433d47de780e6905585a00bd29" title="Returns C++ code that can be used to reconstruct this link.">dumpConstruction()</a> will output C++ code that can reconstruct the link by calling this constructor.</dd></dl>
<dl class="section user"><dt>Python:\n Not available.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossingSigns</td><td>a list containing the signs of the crossings; each sign must be either +1 or -1. </td></tr>
    <tr><td class="paramname">components</td><td>one list for each link component that describes the crossings that are visited along that component, as described in the detailed notes above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="a34d838c4975af256e7c8b40842d370dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d838c4975af256e7c8b40842d370dc">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, the input may be in one of two forms:</p>
<ul>
<li><em>numerical</em> Dowker-Thistlethwaite notation, which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li><em>alphabetical</em> Dowker-Thistlethwaite notation, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used to describe knots with 26 crossings or fewer.</li>
</ul>
<p>Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing Dowker-Thistlethwaite notation is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm. These issues are resolved using oriented Gauss codes, as used by the routines <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a> and <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>.</p>
<p>As an example, you can construct the trefoil using either of the following variants of Dowker-Thistlethwaite notation:</p>
<pre class="fragment">4 6 2
bca
</pre><p>There are two variants of this routine. This variant takes a single string, which is either the alphabetical notation (in which any whitespace within the string will be ignored), or the numerical notation where the integers have been combined together and separated by whitespace. The other variant of this routine is only for the numerical variant, and it takes a sequence of integers defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>either the alphabetical or numerical Dowker-Thistlethwaite notation for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="a7b8e6024307a59835117f2910eac5a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8e6024307a59835117f2910eac5a99">&#9670;&nbsp;</a></span>fromDT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an integer sequence using the numerical variant of Dowker-Thistlethwaite notation. </p>
<p>For an <em>n</em>-crossing knot, this must be a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p>See <a class="el" href="classregina_1_1Link.html#a34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>Regina can also reconstruct a knot from <em>alphabetical</em> Dowker-Thistlethwaite notation, but for this you must use the other version of this routine that takes a single string argument.</p>
<p>For numerical Dowker-Thistlethwaite notation, there are two variants of this routine that you can use. The other variant (<a class="el" href="classregina_1_1Link.html#a34d838c4975af256e7c8b40842d370dc" title="Creates a new knot from either alphabetical or numerical Dowker-Thistlethwaite notation.">fromDT(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the integers have been combined together and separated by whitespace. This variant takes a sequence of integers, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces an integer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python:\n Instead of a pair of begin and past-the-end</dt><dd>iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Much of the code for this routine is based on the Dowker-Thistlethwaite implementation in the SnapPea/SnapPy kernel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for the Dowker-Thistlethwaite notation for a knot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ad24bafb845a51157cecfdbdd66f6f30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24bafb845a51157cecfdbdd66f6f30c">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing a Gauss code is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm. These issues are resolved using <em>oriented</em> Gauss codes, as used by the routines <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a> and <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss()</a>.</p>
<p>The Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers, representing strands that pass over and under crossings respectively. Regina's implementation of Gauss codes comes with the following restrictions:</p>
<ul>
<li>It can only be used for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot have be arbitrary natural numbers).</li>
</ul>
<p>The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. Whenever you pass crossing <em>k</em>, write the integer <code><em>k</em></code> if you pass over the crossing, or <code>-<em>k</em></code> if you pass under the crossing.</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p>There are two variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variant takes a sequence of integers, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a classical Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="a552933848162ccc80e1ee0b4399f9866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552933848162ccc80e1ee0b4399f9866">&#9670;&nbsp;</a></span>fromGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from a classical Gauss code. </p>
<p>See <a class="el" href="classregina_1_1Link.html#ad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>There are two variants of this routine. The other variant (<a class="el" href="classregina_1_1Link.html#ad24bafb845a51157cecfdbdd66f6f30c" title="Creates a new knot from a classical Gauss code.">fromGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the integers have been combined together and separated by whitespace. This variant takes a sequence of integers, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces an integer.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd>
<dd>
While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python:\n Instead of a pair of begin and past-the-end</dt><dd>iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for a classical Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for a classical Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ac206f9e3697de7472ee9ec151c106df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac206f9e3697de7472ee9ec151c106df0">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a link from the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>In this format, a link is described by a sequence of integers separated by whitespace - the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of this sequence is also allowed.</p>
<p>We assume that there are <em>n</em> crossings in the link, labelled arbitrarily as 0, 1, ..., <em>n</em>-1. The sequence of integers must contain, in order:</p>
<ul>
<li>the number of components in the link;</li>
<li>for each link component:<ul>
<li>the number of times you pass a crossing when traversing the component (i.e., the length of the component);</li>
<li>two integers for each crossing that you pass in such a traversal: the crossing label, and then either +1 or -1 according to whether you pass over or under the crossing respectively;</li>
</ul>
</li>
<li>for each crossing:<ul>
<li>the crossing label;</li>
<li>the sign of the crossing (either +1 or -1).</li>
</ul>
</li>
</ul>
<p>As an example, you could construct the left-hand trefoil using the following sequence:</p>
<pre class="fragment">1
6   0 1   1 -1   2 1   0 -1   1 1   2 -1
0 -1   1 -1   2 -1
</pre><p>Another example is the Hopf link, which you could construct using the following sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p>The topology of the knot is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<p>There are two variants of this routine. This variant takes a single string containing the integer sequence. The other variant takes an input stream, from which the sequence of integers will be read.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can export an existing link in Jenkins' format by calling the routine <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link as a string using the text representation described by Bob Jenkins.">jenkins()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string containing a sequence of integers separated by whitespace that describes a link, as detailed above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ae02aeec8648b7d97f889a3cb231ae226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02aeec8648b7d97f889a3cb231ae226">&#9670;&nbsp;</a></span>fromJenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a link from the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>See <a class="el" href="classregina_1_1Link.html#ac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins(const std::string&amp;)</a> for a detailed description of this format.</p>
<p>There are two variants of this routine. The other variant takes a single string containing the integer sequence. This variant takes an input stream, from which the sequence of integers will be read.</p>
<p>In this variant, this routine reads the integers that describe the link and then leaves the remainder of the input stream untouched (in particular, the stream may contain additional material, which can be read by the user after this routine has finished).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that begins with a sequence of integers separated by whitespace that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="a2fa67a9f8642ba7682baeade317ded53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa67a9f8642ba7682baeade317ded53">&#9670;&nbsp;</a></span>fromKnotSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromKnotSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a knot diagram from its signature. </p>
<p>See <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> for more information on knot signatures.</p>
<p>The knot that is returned will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<p>Calling <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a> followed by <a class="el" href="classregina_1_1Link.html#a2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> is not guaranteed to produce an <em>identical</em> knot diagram to the original, but it is guaranteed to produce one that is related by relabelling, rotation, and optionally (according to the arguments that were passed to <a class="el" href="classregina_1_1Link.html#a96e305e2721276730a7783e84bc0bc04" title="Constructs the signature for this knot diagram.">knotSig()</a>) reflection and/or reversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the knot diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated knot if the reconstruction was successful, or <code>null</code> if the given string was not a valid knot signature. </dd></dl>

</div>
</div>
<a id="a7f23add46272acfdedb83be5fd5f7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f23add46272acfdedb83be5fd5f7d3c">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be ambiguity in the orientation of the diagram, and (for composite knots) even the topology of the knot itself. Furthermore, parsing a Gauss code is complex since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</p>
<p>Andreeva et al. describe a variant of the Gauss code that includes extra information about the embedding, so as to remove both the ambiguity and the complexity in the conversion procedure. With this extra information, the knot and its orientation are well-defined (but the diagram is still ambiguous - see the note below).</p>
<p>This "oriented" format is described at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>. Regina adds two additional restrictions on this format:</p>
<ul>
<li>It can only be used for knots (i.e., links with exactly one component).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> (i.e., they cannot have be arbitrary natural numbers).</li>
</ul>
<p>The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. At every crossing that you pass, write a token of the form <code>+&lt;<em>k</em></code>, <code>-&lt;<em>k</em></code>, <code>+&gt;<em>k</em></code> or <code>-&gt;<em>k</em></code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right.</li>
</ul>
</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the left-hand trefoil using the following code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p>The topology of the knot is defined precisely by this data, but the precise embedding of the diagram in the plane remains ambiguous. To be exact: the embedding of the diagram in the <em>2-sphere</em> is defined precisely, but there remains a choice of which 2-cell of this embedding will contain the point at infinity (i.e., which 2-cell becomes the exterior cell of the diagram in the plane).</p>
<p>There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an "oriented" Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="a2d9ccfdf468272086377417cf8a3df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9ccfdf468272086377417cf8a3df27">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new knot from an "oriented" variant of the Gauss code. </p>
<p>This format is described by Andreeva et al. at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>, though Regina limits its use to knots (i.e., one-component links), and insists that the crossings be numbered 1, ..., <em>n</em> (not arbitrary natural numbers).</p>
<p>See <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p>There are two variants of this routine. The other variant (<a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the tokens have been combined together and separated by whitespace. This variant takes a sequence of tokens, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces either a C-style string (which can be cast to <code>const char*</code>) or a C++-style string (which can be cast to <code>const std::string&amp;</code>).</dd>
<dd>
The tokens in the input sequence do not contain any whitespace.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, it does <em>not</em> test for planarity of the diagram. That is, if the input describes a knot diagram that must be drawn on some higher-genus surface as opposed to the plane, this will not be detected. Of course such inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="section user"><dt>Python:\n Instead of a pair of begin and past-the-end</dt><dd>iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an "oriented" Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an "oriented" Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed link, or <code>null</code> if the input was found to be invalid. </dd></dl>

</div>
</div>
<a id="ac05b65401950517d86be107268233b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05b65401950517d86be107268233b09">&#9670;&nbsp;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::gauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a classical Gauss code for this knot. </p>
<p>In general, the classical Gauss code does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same Gauss code; moreover, for composite knots, the Gauss code can describe inequivalent knots (even when allowing for reflections). If you need a code that specifies the knot uniquely, consider using the <em>oriented</em> Gauss code instead.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code for this knot, or the empty string if this is a link with zero or multiple components. </dd></dl>

</div>
</div>
<a id="a5d8c0d2be78044e3fc4108e092d086a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8c0d2be78044e3fc4108e092d086a5">&#9670;&nbsp;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::gauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a classical Gauss code for this knot to the given output stream. </p>
<p>In general, the classical Gauss code does not carry enough information to uniquely reconstruct the knot. For instance, both a knot and its reflection can be described by the same Gauss code; moreover, for composite knots, the Gauss code can describe inequivalent knots (even when allowing for reflections). If you need a code that specifies the knot uniquely, consider using the <em>oriented</em> Gauss code instead.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python:\n This routine is not available in Python. Instead,</dt><dd>Python users can use the variant <a class="el" href="classregina_1_1Link.html#ac05b65401950517d86be107268233b09" title="Outputs a classical Gauss code for this knot.">gauss()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb6293eb60b5477b5cac84363c43286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6293eb60b5477b5cac84363c43286a">&#9670;&nbsp;</a></span>hasReducingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasReducingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether this knot has a pass move that will reduce the number of crossings. </p>
<p>Currently this routine is only available for knots, not multiple-component links.</p>
<p>A <em>pass</em> move involves taking a section of the knot that involves only over-crossings (or only under-crossings), and then lifting that section above (or beneath respectively) the diagram and placing it back again in a different location. In particular, this routine searches for a different location that will involve fewer crossings than the original location.</p>
<p>This routine does not actually <em>perform</em> the pass move; it simply determines whether one exists.</p>
<p>The running time is cubic in the number of crossings.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link is actually a knot (i.e., it contains exactly one component).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is a pass move that reduces the number of crossings. </dd></dl>

</div>
</div>
<a id="aa724448326c5e5b0ba727fe6ce6d1233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa724448326c5e5b0ba727fe6ce6d1233">&#9670;&nbsp;</a></span>hasSafePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::hasSafePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is there one or more <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> currently pointing to this object? </p>

</div>
</div>
<a id="aa3cdae63725a633c32868737d44cb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cdae63725a633c32868737d44cb7c7">&#9670;&nbsp;</a></span>homfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp; regina::Link::homfly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>This routine is simply an alias for <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. See the documentation for <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> for further details.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyVarX, Link::homflyVarY)</code>.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="a173ba85ab3f36b64631816894ff4809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173ba85ab3f36b64631816894ff4809f">&#9670;&nbsp;</a></span>homflyAZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::homflyAZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>This variant of the HOMFLY polynomial is described (amongst other places) in G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>alpha</em> and <em>z</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p>If the HOMFLY polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="a8165708806e390b41b33655bdbb40af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8165708806e390b41b33655bdbb40af5">&#9670;&nbsp;</a></span>homflyLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::homflyLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the HOMFLY polynomial of this link, as a polynomial in <em>l</em> and <em>m</em>. </p>
<p>This variant of the HOMFLY polynomial is described (amongst other places) in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>l</em> and <em>m</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> should be called again; this will be instantaneous if the HOMFLY polynomial has already been calculated.</p>
<p>If the HOMFLY polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the HOMFLY polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_BACKTRACK will use Kauffman's skein-template algorithm, and ALG_TREEWIDTH will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="aa11d6d31315c7b000cb653901a0a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d6d31315c7b000cb653901a0a711c">&#9670;&nbsp;</a></span>insertTorusLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertTorusLink </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new (<em>p</em>, <em>q</em>) torus link into this link. </p>
<p>The parameters <em>p</em> and <em>q</em> must be non-negative, but they do not need to be coprime.</p>
<p>All of the crossings in the new torus link component(s) will be positive if the argument <em>positive</em> is <code>true</code>, or negative otherwise.</p>
<p>The new crossings and components will be inserted at the end of the respective lists in this link.</p>
<p>If your aim is to create a new torus link (as opposed to inserting one into an existing link), it is simpler to just call <a class="el" href="classregina_1_1ExampleLink.html#a96f37e1919de78b6d37143a4e5b634c4" title="Returns the (p,q) torus link.">ExampleLink::torus()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the first parameter of the new torus link; this must be non-negative. </td></tr>
    <tr><td class="paramname">q</td><td>the second parameter of the new torus link; this must also be non-negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc961ba707da75f2b71d3585c994cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc961ba707da75f2b71d3585c994cc9">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the link diagram using fast and greedy heuristics. </p>
<p>Specifically, this routine tries combinations of Reidemeister moves with the aim of reducing the number of crossings.</p>
<p>Currently this routine uses <a class="el" href="classregina_1_1Link.html#a3adf6c87c3dc80de018d659e686b48ef" title="Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number o...">simplifyToLocalMinimum()</a> in combination with random type III Reidemeister moves.</p>
<p>Although <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> often works well, it can sometimes get stuck. If this link is a knot (i.e., it has precisely one component), then in such cases you can try the more powerful but (much) slower <a class="el" href="classregina_1_1Link.html#a7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same link may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina. </dd></dl>

</div>
</div>
<a id="aa36d8a4b0c964cafb2cbac86b0d5e272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36d8a4b0c964cafb2cbac86b0d5e272">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Link::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="a821a3c1d060bdc5f3807ee1a64064775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821a3c1d060bdc5f3807ee1a64064775">&#9670;&nbsp;</a></span>isAlternating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isAlternating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this knot diagram is alternating. </p>
<p>Note that this routine cannot tell whether the <em>knot</em> is alternating (i.e., whether there <em>exists</em> an alternating diagram). Instead, it simply returns whether this specific diagram is alternating or not.</p>
<p>The empty diagram and any zero-crossing unknot components will be considered alternating.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an alternating diagram, or <code>false</code> if this is a non-alternating diagram. </dd></dl>

</div>
</div>
<a id="ad12a7e69700971494486e299bbc39c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12a7e69700971494486e299bbc39c57">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link is empty. </p>
<p>An empty link is one with no components at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link is empty. </dd></dl>

</div>
</div>
<a id="a194f84f5ad2fb28ab1a0da34aa69d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f84f5ad2fb28ab1a0da34aa69d8a8">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link as a string using the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>Jenkins' text format uses a sequence of integers separated by whitespace. For details of this format, see the documentation for <a class="el" href="classregina_1_1Link.html#ac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The string will contain multiple lines, and will end in a newline.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' text format. </dd></dl>

</div>
</div>
<a id="a6509ca2eaf2920bf4dc7e69eb5f5f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6509ca2eaf2920bf4dc7e69eb5f5f499">&#9670;&nbsp;</a></span>jenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link to the given output stream using the text representation described by Bob Jenkins. </p>
<p>Jenkins uses this representation in his HOMFLY polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>.</p>
<p>Jenkins' text format uses a sequence of integers separated by whitespace. For details of this format, see the documentation from <a class="el" href="classregina_1_1Link.html#ac206f9e3697de7472ee9ec151c106df0" title="Builds a link from the text representation described by Bob Jenkins.">fromJenkins()</a>, which imports links using this format.</p>
<p>The output will contain multiple lines, and will end in a newline.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python:\n This routine is not available in Python. Instead,</dt><dd>Python users can use the variant <a class="el" href="classregina_1_1Link.html#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link as a string using the text representation described by Bob Jenkins.">jenkins()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad74edbfadfccb443efa6a6f1852ab9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74edbfadfccb443efa6a6f1852ab9b5">&#9670;&nbsp;</a></span>jones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt;&amp; regina::Link::jones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="namespaceregina.html#ae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Jones polynomial of this link, but with all exponents doubled. </p>
<p>By "all exponents doubled", we are indicating that the Jones polynomial is in fact a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>. So, for example:</p>
<ul>
<li>The right-hand trefoil has Jones polynomial <code>1/t + 1/t^3 - 1/t^4</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>x^-2 + x^-6 - x^-8</code>.</li>
<li>The Hopf link has Jones polynomial <code>-1/sqrt(x) - 1/sqrt(x^5)</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>-x^-1 - x^-5</code>.</li>
</ul>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Regina follows the conventions described in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994. If you wish to convert to the conventions used by Khovanov as described in Dror Bar-Natan, "On Khovanov's categorifiction of the Jones
polynomial", Algebraic &amp; Geometric Topology 2 (2002), 337-370, you can simply take the polynomial returned by this routine and replace the variable <em>x</em> (which represents the square root of <em>t</em>) with the expression -q.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>.</p>
<p>Bear in mind that each time the link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> should be called again; this will be instantaneous if the Jones polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the polynomial has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> again to retrieve the polynomial.</li>
<li>If no progress tracker is passed and the polynomial has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the requested invariant has already been computed, then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently less than the number of bits in a long, which on a typical machine is 64). If you pass ALG_NAIVE and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (ALG_DEFAULT) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: ALG_NAIVE is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and ALG_TREEWIDTH uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jones polynomial. If a progress tracker was passed then this return value must be ignored, and you should call <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> again once the tracker is marked as finished. </dd></dl>

</div>
</div>
<a id="a96e305e2721276730a7783e84bc0bc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e305e2721276730a7783e84bc0bc04">&#9670;&nbsp;</a></span>knotSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::knotSig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReflection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReversal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <em>signature</em> for this knot diagram. </p>
<p>A <em>signature</em> is a compact text representation of a knot diagram that unique determines the knot up to relabelling, rotation, and (optionally) reflection and/or reversal.</p>
<p>Currently signatures are only implemented for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will return the empty string.</p>
<p>The signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of crossings.</p>
<p>The routine <a class="el" href="classregina_1_1Link.html#a2fa67a9f8642ba7682baeade317ded53" title="Recovers a knot diagram from its signature.">fromKnotSig()</a> can be used to recover a knot from its signature. The resulting knot might not be identical to the original, but it will be related by zero or more applications of relabelling, rotation, and/or (according to the arguments) reflection and reversal.</p>
<p>This routine runs in quadratic time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useReflection</td><td><code>true</code> if the reflection of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reflection). </td></tr>
    <tr><td class="paramname">useReversal</td><td><code>true</code> if the reversal of a knot diagram should have the same signature as the original, or <code>false</code> if these should be distinct (assuming the diagram is not symmetric under reversal). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature for this knot diagram. </dd></dl>

</div>
</div>
<a id="a6a432a4f3024e537920770c0eb60d2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a432a4f3024e537920770c0eb60d2e2">&#9670;&nbsp;</a></span>knowsBracket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsBracket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#afd286c4c3d5512b2d9de53e57a57055a" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="ae7100ef279d1f9a4ed7a739e76d5c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7100ef279d1f9a4ed7a739e76d5c5d4">&#9670;&nbsp;</a></span>knowsHomfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsHomfly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the HOMFLY polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>, <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> will all be very fast (simply returning the precalculated values).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a13a2acb5efa330841a89e91d28e5d64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a2acb5efa330841a89e91d28e5d64a">&#9670;&nbsp;</a></span>knowsJones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsJones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Jones polynomial of this link diagram already known? See <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a8cdacd0939c10de129dcf4c9a72f209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdacd0939c10de129dcf4c9a72f209c">&#9670;&nbsp;</a></span>linking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::linking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the linking number of this link. </p>
<p>This is an invariant of the link, computed as half the sum of the signs of all crossings that involve different link components.</p>
<p>The algorithm to compute linking number is linear time.</p>
<dl class="section return"><dt>Returns</dt><dd>the linking number. </dd></dl>

</div>
</div>
<a id="adf9867163e5b6defa9aa85d9bd8d9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9867163e5b6defa9aa85d9bd8d9963">&#9670;&nbsp;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::Link::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram. </p>
<p>This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of this graph.</p>
<p>See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="classregina_1_1TreeDecomposition.html#ae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p>This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p>The tree decomposition will be cached, so that if this routine is called a second time (and the underlying link has not been changed) then the same tree decomposition will be returned immediately.</p>
<p>If you wish to supply your own tree decomposition (as opposed to relying on the greedy heuristics that Regina implements), then you can supply it by calling <a class="el" href="classregina_1_1Link.html#a7b845088fe7d44ab3da72b9fa9abddc0" title="Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree d...">useTreeDecomposition()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of this link diagram. </dd></dl>

</div>
</div>
<a id="ab8d81af83901af217da0bee17b6bf120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d81af83901af217da0bee17b6bf120">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an oriented Gauss code for this knot. </p>
<p>The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. For details of this format, see the documentation for <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The key advantage of using the oriented Gauss code (as opposed to the classical Gauss code) is that an oriented Gauss code always describes a unique knot, and moreover (for knots that are not equivalent to their reflections) it describes a unique reflection of that knot.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then the empty string will be returned.</p>
<p>The string will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this knot, or the empty string if this is a link with zero or multiple components. </dd></dl>

</div>
</div>
<a id="a21eaa9351a071dc7ddcf8e4d1101d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eaa9351a071dc7ddcf8e4d1101d584">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this knot to the given output stream. </p>
<p>The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. For details of this format, see the documentation for <a class="el" href="classregina_1_1Link.html#a7f23add46272acfdedb83be5fd5f7d3c" title="Creates a new knot from an &quot;oriented&quot; variant of the Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports links in this format.</p>
<p>The key advantage of using the oriented Gauss code (as opposed to the classical Gauss code) is that an oriented Gauss code always describes a unique knot, and moreover (for knots that are not equivalent to their reflections) it describes a unique reflection of that knot.</p>
<p>Currently Regina only supports Gauss codes for knots, not multiple-component links. If this link does not have precisely one component then nothing will be output at all.</p>
<p>The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python:\n This routine is not available in Python. Instead,</dt><dd>Python users can use the variant <a class="el" href="classregina_1_1Link.html#ab8d81af83901af217da0bee17b6bf120" title="Outputs an oriented Gauss code for this knot.">orientedGauss()</a>, which takes no arguments and returns the output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b21aaa8020908478576e1f9325d4f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b21aaa8020908478576e1f9325d4f91">&#9670;&nbsp;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of the underlying planar 4-valent multigraph, using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a>.</p>
<p>This routine simply returns the output of <a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a> as a string, instead of writing it to an output stream.</p>
<p>See the <a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1Link.html#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying planar 4-valent multigraph using the PACE text format.">writePACE()</a>, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a2d9da32820ca345fb6056f0cc149c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9da32820ca345fb6056f0cc149c872">&#9670;&nbsp;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a>* regina::Link::parallel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a>&#160;</td>
          <td class="paramname"><em>framing</em> = <code><a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa049e88d698accae1190644ad2804d96f">FRAMING_SEIFERT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> <em>k</em> cables of this link, all parallel to each other using the given framing. </p>
<p>This routine creates a new link by:</p>
<ul>
<li>treating each component of this link as a ribbon, using the given framing;</li>
<li>creating <em>k</em> parallel copies of the original link, following each other side-by-side along these ribbons.</li>
</ul>
<p>This link will not be modified.</p>
<p>The result will returned as a new link, and it is the responsibility of the caller of this routine to destroy it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of parallel copies to create. This must be non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>k</em> parallel copies of this link, as a newly-created object. </dd></dl>

</div>
</div>
<a id="a23a70af4f63bbd4f7dea13a04a3b984a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a70af4f63bbd4f7dea13a04a3b984a">&#9670;&nbsp;</a></span>r1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to remove a crossing. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>crossing</em>, which indicates the crossing that will be removed. Specifically, this move involves undoing a trivial twist at the given crossing.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because one crossing is being removed, the other crossings in the link may be reindexed. However, no crossings other than the one involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a9535918349c0ada298fcabeac5638ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9535918349c0ada298fcabeac5638ec8">&#9670;&nbsp;</a></span>r1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to add a new crossing. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves adding a trivial twist to the given arc; the arguments <em>side</em> and <em>sign</em> indicate on which side of the arc and with which orientation the new twist will be made. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If <em>arc</em> is a null reference, then the new twist will be added to a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If <em>arc</em> is null but there is no zero-crossing component then the move cannot be performed, and if <em>arc</em> is null but there are multiple zero-crossing components then the first such component will be used.</p>
<p>This move is almost always able to be performed: the only situation in which it <em>cannot</em> be performed is if <em>arc</em> is a null reference but this link contains no zero-crossing components, as discussed above.</p>
<p>The existing crossings in this link will keep the same indices, and the new crossing will be given the next index that is available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="afaf3e0d6eaa504eba071e3950a939028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf3e0d6eaa504eba071e3950a939028">&#9670;&nbsp;</a></span>r2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves pulling apart two arcs of the link that surround a bigon; the given arc must be one of these two arcs. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a050794f44093f3ec4740eb6b2653d40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050794f44093f3ec4740eb6b2653d40e">&#9670;&nbsp;</a></span>r2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the argument <em>crossing</em>, Specifically, this move involves pulling apart two arcs of the link (one upper, one lower) that both run between the same pair of crossings. The given crossing should be the start point of the upper arc; that is, when following the upper arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. Note that <em>crossing</em> is one of the two crossings that will be removed by this move.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a92d15fe6c6ad9a04ae0e05c9fea67cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d15fe6c6ad9a04ae0e05c9fea67cea">&#9670;&nbsp;</a></span>r2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>upperArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upperSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>lowerArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to add two new crossings. </p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>upperArc</em>, <em>upperSide</em>, <em>lowerArc</em> and <em>lowerSide</em>. Specifically, this move involves taking the arc <em>upperArc</em> and pushing it over <em>lowerArc</em> so that the two arcs overlap. The arguments <em>upperSide</em> and <em>lowerSide</em> indicate on which side of each arc the overlap takes place. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If either <em>upperArc</em> or <em>lowerArc</em> is a null reference, then the move will be performed upon a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If one of these arguments is a null reference but there is no zero-crossing component then the move cannot be performed, and if there are multiple zero-crossing components then the first such component will be used.</p>
<p>Likewise, if <em>both</em> arcs are null references, then the move will be performed upon two <em>different</em> zero-crossing unknot components. In this case, if there are fewer than two such components then the move cannot be performed, and otherwise <em>upperArc</em> will be the first such component and <em>lowerArc</em> will be the second.</p>
<p>Currently, Regina cannot perform the move when <em>upperArc</em> and <em>lowerArc</em> represent the same arc (or the same zero-crossing unknot component). In this case there is a workaround: you can achieve the same effect by performing two type I Reidemeister moves (i.e., by adding two twists).</p>
<p>The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for this move is expensive (linear time), since it includes testing whether both sides-of-arcs belong to the same 2-cell of the knot diagram.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies the arc of the link which will be passed over the other, as described above. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies the arc of the link which will be passed beneath the other, as described above. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ad29467a23ac123cbab680b1e406e34bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29467a23ac123cbab680b1e406e34bc">&#9670;&nbsp;</a></span>r3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>arc</em> and <em>side</em>. Specifically, this move takes place around a triangle; the given arc must form one of the three edges of this triangle. The argument <em>side</em> indicates on which side of the arc the third crossing is located. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae0ba90169324b005d88587e4597ad129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ba90169324b005d88587e4597ad129">&#9670;&nbsp;</a></span>r3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type III Reidemeister move. </p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>There are two boolean arguments that control the behaviour of this routine: <em>check</em> and <em>perform</em>.</p>
<ul>
<li>If <em>check</em> and <em>perform</em> are both <code>true</code> (the default), then this routine will first check whether this move can be performed at the given location. If so, it will perform the move and return <code>true</code>. If not, it will do nothing and return <code>false</code>.</li>
<li>If <em>check</em> is <code>true</code> but <em>perform</em> is <code>false</code>, then this routine will simply check whether this move can be performed at the given location and return <code>true</code> or <code>false</code> accordingly.</li>
<li>If <em>check</em> is <code>false</code> but <em>perform</em> is <code>true</code>, then this routine will perform the move without any prior checks, and will always return <code>true</code>. In this case, it must be known in advance that the move can be performed at the given location.</li>
<li>If <em>check</em> and <em>perform</em> are both <code>false</code>, then this routine does nothing and just returns <code>true</code>. (There is no reason to use this combination of arguments.)</li>
</ul>
<p>The location of this move is specified by the arguments <em>crossing</em> and <em>side</em>. Specifically, this move takes place around a triangle, and one of the arcs of this triangle is <em>uppermost</em> (in that it passes above the other two arcs). The given crossing should be the start point of this uppermost arc; that is, when following the arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. The additional argument <em>side</em> indicates on which side of the uppermost arc the third crossing is located.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means (i) <em>check</em> must be <code>true</code>, and therefore (ii) this routine will do nothing and return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a8b4396c9fcb99dbb3bb4ba7176b859c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4396c9fcb99dbb3bb4ba7176b859c4">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this link into its reflection. </p>
<p>This routine changes the sign of every crossing, but leaves the upper and lower strands the same. This operation corresponds to reflecting the link diagram about some axis in the plane. </p>

</div>
</div>
<a id="a6da54fa7f3352392989e34629c314a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da54fa7f3352392989e34629c314a91">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves the given crossing. </p>
<p>The two incoming strands will switch connections with the two outgoing strands, with the result that the given crossing is removed entirely.</p>
<dl class="section note"><dt>Note</dt><dd>The number of components in the link <em>will</em> change as a result of this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to resolve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9326a4e30a7cfb373020c4c6084775fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9326a4e30a7cfb373020c4c6084775fc">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of every component of this link. </p>
<p>This routine preserves both the sign and the upper/lower positions at every crossing, but switches all incoming strands with outgoing strands and vice versa (so next() becomes prev(), and prev() becomes next()). </p>

</div>
</div>
<a id="aeadc3ba80f5f033f8b306a718b06566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadc3ba80f5f033f8b306a718b06566c">&#9670;&nbsp;</a></span>rewrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::rewrite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a given number of additional crossings. </p>
<p>This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will return immediately (as described below).</p>
<p>This routine iterates through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number.</p>
<p>For every such knot diagram (including this starting diagram), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take at least one argument. The first argument will be of type <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>&amp;, and will reference the knot diagram that has been found. If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more knot diagrams will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this knot (i.e., the original knot upon which <a class="el" href="classregina_1_1Link.html#aeadc3ba80f5f033f8b306a718b06566c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a> was called). This will not affect the search: all knot diagrams that this routine visits will be obtained via Reidemeister moves from the original knot diagram, before any subsequent changes (if any) were made.</li>
<li><em>action</em> may, if it chooses, make changes to the knot that is passed in its argument (though it must not delete it). This will likewise not affect the search, since the knot diagram that is passed to <em>action</em> will be destroyed immediately after <em>action</em> is called.</li>
<li><em>action</em> will only be called once for each knot diagram (including this starting diagram). In other words, no knot diagram will be revisited a second time in a single call to <a class="el" href="classregina_1_1Link.html#aeadc3ba80f5f033f8b306a718b06566c" title="Explores all knot diagrams that can be reached from this via Reidemeister moves, without exceeding a ...">rewrite()</a>.</li>
</ul>
<p>This routine can be very slow and very memory-intensive, since the number of knot diagrams it visits may be exponential in the number of crossings, and it records every knot diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some knot diagram that is passed to it.</p>
<p>If a progress tracker is passed, then the exploration of knot diagrams will take place in a new thread and this routine will return immediately.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time).</p>
<p>If this link does not have precisely one component, then this routine will do nothing. If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="section warning"><dt>Warning</dt><dd>By default, the arguments <em>args</em> will be copied (or moved) when they are passed to <em>action</em>. If you need to pass some argument(s) by reference, you must wrap them in std::ref or std::cref.</dd>
<dd>
The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this knot diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call upon each knot diagram that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial knot argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="a078b8f0dd10461df6f5b535fb3991bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078b8f0dd10461df6f5b535fb3991bce">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::rotate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this link diagram, converting it into a different diagram of the same link. </p>
<p>This routine keeps the sign of each crossing fixed, but switches the upper and lower strands. This operation corresponds to a 3-dimensional rotation about some axis in the plane. </p>

</div>
</div>
<a id="a7701e3dd1fdbe8d8106363d118ec887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7701e3dd1fdbe8d8106363d118ec887d">&#9670;&nbsp;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister graph. </p>
<p>This routine is more powerful but much slower than <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p>This routine is only available for knots at the present time. If this link has multiple (or zero) components, then this routine will return immediately (as described below).</p>
<p>This routine will iterate through all knot diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number.</p>
<p>If at any stage it finds a diagram with <em>fewer</em> crossings than the original, then this routine will call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> to simplify the diagram further if possible and will then return <code>true</code>. If it cannot find a diagram with fewer crossings then it will leave this knot diagram unchanged and return <code>false</code>.</p>
<p>This routine can be very slow and very memory-intensive: the number of knot diagrams it visits may be exponential in the number of crossings, and it records every diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will not terminate until a simpler diagram is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p>If you want a <em>fast</em> simplification routine, you should call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> instead. The benefit of <a class="el" href="classregina_1_1Link.html#a7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is that, for very stubborn knot diagrams where <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> finds itself stuck at a local minimum, <a class="el" href="classregina_1_1Link.html#a7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p>If a progress tracker is passed, then the exhaustive simplification will take place in a new thread and this routine will return immediately. In this case, you will need to use some other means to determine whether the knot diagram was eventually simplified (e.g., by examining <a class="el" href="classregina_1_1Link.html#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a> after the tracker indicates that the operation has finished).</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either the diagram was simplified or the search was exhausted).</p>
<p>If this routine is unable to simplify the knot diagram, then this knot diagram will not be changed.</p>
<p>If this link does not have precisely one component, then this routine will do nothing. If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if and only if this diagram was successfully simplified to fewer crossings. </dd></dl>

</div>
</div>
<a id="a3adf6c87c3dc80de018d659e686b48ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adf6c87c3dc80de018d659e686b48ef">&#9670;&nbsp;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings. </p>
<p>End users will probably not want to call this routine. You should call <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a> if you want a fast (and usually effective) means of simplifying a link. If this link is a knot (i.e., it has precisely one component), then you can also call <a class="el" href="classregina_1_1Link.html#a7701e3dd1fdbe8d8106363d118ec887d" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p>Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine. Such moves do however feature in <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="a32c6f34794cc62574fcfca388f3f66d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c6f34794cc62574fcfca388f3f66d9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of crossings in this link. </p>
<p>Note that a link can have more components than crossings (since it may contain additional zero-crossing unknot components).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:\n In addition to str(), this is also used as the</dt><dd>Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a411f710b2b7a73d1999cf0ea44cc7a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f710b2b7a73d1999cf0ea44cc7a4a">&#9670;&nbsp;</a></span>strand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::strand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the strand in the link with the given integer ID. </p>
<p>Each strand ID is of the form 2<em>c</em>+<em>s</em>, where <em>c</em> is the index of the crossing, and <em>s</em> is 0 or 1 for the lower or upper strand respectively. A null strand reference (as used to indicate 0-crossing unknot components) has an ID of -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an integer between -1 and 2*size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the strand of this link with the corresponding ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1StrandRef.html#add61713b60a4536a94461656e93298b2" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> </dd></dl>

</div>
</div>
<a id="a15ae448f3fa16932d01d4c5a165e408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ae448f3fa16932d01d4c5a165e408c">&#9670;&nbsp;</a></span>swapContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given link. </p>
<p>All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link. Likewise, all cached properties (e.g., tree decompositions) will be swapped.</p>
<p>In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d5e4637efe2ed81e2c9588aaa76591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e4637efe2ed81e2c9588aaa76591">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference for some other link into the corresponding strand reference for this link. </p>
<p>Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other link, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this link.</p>
<p>This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this link. </dd></dl>

</div>
</div>
<a id="a7b845088fe7d44ab3da72b9fa9abddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b845088fe7d44ab3da72b9fa9abddc0">&#9670;&nbsp;</a></span>useTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::useTreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td>
          <td class="paramname"><em>td</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link. </p>
<p>For some link routines, including <a class="el" href="classregina_1_1Link.html#adf9867163e5b6defa9aa85d9bd8d9963" title="Returns a nice tree decomposition of the planar 4-valent multigraph formed by this link diagram.">niceTreeDecomposition()</a> as well as computations such as <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> that support the option ALG_TREEWIDTH, Regina needs a tree decomposition of the planar 4-valent multigraph formed by this link diagram.</p>
<p>By default, Regina will compute (and then cache) such a tree decomposition itself, using in-built greedy heuristics. This routine allows you to supply your <em>own</em> tree decomposition (which, for example, might be a smaller-width tree decomposition that you found using third-party software). By supplying your own tree decomposition <em>td</em> through this routine, Regina will throw away any pre-computed tree decomposition that it has cached, and will instead cache <em>td</em> for future use instead.</p>
<p>Regina will not claim ownership of <em>td</em>, and will not edit it in any way. Instead, it will make a deep copy of <em>td</em> and then modify this copy for its purposes.</p>
<p>In particular, <em>td</em> does not need to be a <em>nice</em> tree decomposition (indeed, it does not need to have any special properties beyond the definition of a tree decomposition). Regina will automatically create a nice tree decomposition from it if <em>td</em> is not nice already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">td</td><td>a tree decomposition of the planar 4-valent multigraph formed by this link diagram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a8f682deb7aeb5c9e3b06c8db4aec3b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f682deb7aeb5c9e3b06c8db4aec3b92">&#9670;&nbsp;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the underlying planar 4-valent multigraph using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>In summary, the output will consist of several lines of text:</p>
<ul>
<li>If this link has a packet label, then the output will begin with a descriptive comment line of the form <code>c <em>label</em></code>. Otherwise this initial comment line will be omitted.</li>
<li>Next will be a line of the form <code>p&#160;tw&#160;<em>num_vertices</em>&#160;<em>num_edges</em></code>. Note that, since the underlying graph comes from a link diagram, we will always have <em>num_edges</em> equal to twice <em>num_vertices</em>.</li>
<li>Following this will be <em>num_edges</em> lines, one for each edge, each of the form <code><em>u&#160;v</em></code>, indicating an edge from vertex number <em>u</em> to vertex number <em>v</em>. In this format, vertices are numbered 1,2,...,<em>num_vertices</em>.</li>
</ul>
<p>An example of this text format is as follows:</p>
<pre class="fragment">c Figure eight knot
p tw 4 8
1 2
1 4
1 2
2 3
3 4
1 3
3 4
2 4
</pre><dl class="section user"><dt>Python:\n The <em>out</em> argument is not present; instead</dt><dd>standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a58309b754fc2392ea83ee63c77a961b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58309b754fc2392ea83ee63c77a961b8">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="a645147f6f603066ea0eb85a8d0978578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645147f6f603066ea0eb85a8d0978578">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="a4df95452d2c6fdd8ec754c5adbaf9505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df95452d2c6fdd8ec754c5adbaf9505">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Link::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="aed6e5a318a8fdab39ebea49912074d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e5a318a8fdab39ebea49912074d19">&#9670;&nbsp;</a></span>writhe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writhe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the writhe of this link diagram. </p>
<p>This is <em>not</em> an invariant of the link; instead it depends on the particular link diagram. It is computed as the sum of the signs of all crossings. It is preserved under Reidemeister moves II and III, but not I.</p>
<dl class="section return"><dt>Returns</dt><dd>the writhe. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af6b2ca40f892a2375f27159cf11314ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b2ca40f892a2375f27159cf11314ac">&#9670;&nbsp;</a></span>homflyAZVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the mathematical symbol <em>alpha</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="a0a3c7bb6dae63c7e28696f33f79ac6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3c7bb6dae63c7e28696f33f79ac6db">&#9670;&nbsp;</a></span>homflyAZVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="classregina_1_1Link.html#a173ba85ab3f36b64631816894ff4809f" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the single character <em>z</em>.</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="abf4891884482d63762104e45c064375c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4891884482d63762104e45c064375c">&#9670;&nbsp;</a></span>homflyLMVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the mathematical script symbol for <em>l</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="ace9dcc4b15180a96d0d2c8d0cbb157ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9dcc4b15180a96d0d2c8d0cbb157ab">&#9670;&nbsp;</a></span>homflyLMVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY polynomials for human consumption.</p>
<p>Since <a class="el" href="classregina_1_1Link.html#a8165708806e390b41b33655bdbb40af5" title="Returns the HOMFLY polynomial of this link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the single character <em>m</em>.</p>
<p>To pretty-print this HOMFLY polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="a65375567e9a939248cef8a464e1ea0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65375567e9a939248cef8a464e1ea0c7">&#9670;&nbsp;</a></span>homflyVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarX. See the documentation for homflyAZVarX for further details. </p>

</div>
</div>
<a id="a79b39da1b23893a682ff22b388041fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b39da1b23893a682ff22b388041fdc">&#9670;&nbsp;</a></span>homflyVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY polynomial as returned by <a class="el" href="classregina_1_1Link.html#aa3cdae63725a633c32868737d44cb7c7" title="Returns the HOMFLY polynomial of this link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarY. See the documentation for homflyAZVarY for further details. </p>

</div>
</div>
<a id="a7063f2022a096350cb8e25cd937a94cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7063f2022a096350cb8e25cd937a94cc">&#9670;&nbsp;</a></span>jonesVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::jonesVar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Jones polynomial, as returned by <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>. </p>
<p>This is provided to help with pretty-printing Jones polynomials for human consumption.</p>
<p>Since <a class="el" href="classregina_1_1Link.html#ad74edbfadfccb443efa6a6f1852ab9b5" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>, this string is just a human-readable representation of the square root of <em>t</em> (encoded in UTF-8).</p>
<p>To pretty-print the Jones polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
