<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NGroupPresentation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NGroupPresentation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NGroupPresentation Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a finite presentation of a group.  
 <a href="classregina_1_1NGroupPresentation.html#details">More...</a></p>

<p><code>#include &lt;algebra/ngrouppresentation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NGroupPresentation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NGroupPresentation.png" usemap="#regina::NGroupPresentation_map" alt=""/>
  <map id="regina::NGroupPresentation_map" name="regina::NGroupPresentation_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NGroupPresentation &gt;" shape="rect" coords="0,0,229,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1bd70f21444f4db13bd9df3e0ba0b5c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a1bd70f21444f4db13bd9df3e0ba0b5c0">NGroupPresentation</a> ()</td></tr>
<tr class="memdesc:a1bd70f21444f4db13bd9df3e0ba0b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new presentation with no generators and no relations.  <a href="#a1bd70f21444f4db13bd9df3e0ba0b5c0">More...</a><br/></td></tr>
<tr class="separator:a1bd70f21444f4db13bd9df3e0ba0b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d481aa0fe4ea8b0144620e3127c319d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a3d481aa0fe4ea8b0144620e3127c319d">NGroupPresentation</a> (const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a3d481aa0fe4ea8b0144620e3127c319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group presentation.  <a href="#a3d481aa0fe4ea8b0144620e3127c319d">More...</a><br/></td></tr>
<tr class="separator:a3d481aa0fe4ea8b0144620e3127c319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f19fa64867a83a6ddc0201ae36bd31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ad9f19fa64867a83a6ddc0201ae36bd31">NGroupPresentation</a> (unsigned long nGens, const std::vector&lt; std::string &gt; &amp;rels)</td></tr>
<tr class="memdesc:ad9f19fa64867a83a6ddc0201ae36bd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to directly pass an arbitrary number of relators in string format.  <a href="#ad9f19fa64867a83a6ddc0201ae36bd31">More...</a><br/></td></tr>
<tr class="separator:ad9f19fa64867a83a6ddc0201ae36bd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986de1e84adec2b3e046ed9438f1625"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a6986de1e84adec2b3e046ed9438f1625">~NGroupPresentation</a> ()</td></tr>
<tr class="memdesc:a6986de1e84adec2b3e046ed9438f1625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the group presentation.  <a href="#a6986de1e84adec2b3e046ed9438f1625">More...</a><br/></td></tr>
<tr class="separator:a6986de1e84adec2b3e046ed9438f1625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a6e1551739dbbfa7e8fa24bea16b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a56a6e1551739dbbfa7e8fa24bea16b61">operator=</a> (const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a56a6e1551739dbbfa7e8fa24bea16b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a56a6e1551739dbbfa7e8fa24bea16b61">More...</a><br/></td></tr>
<tr class="separator:a56a6e1551739dbbfa7e8fa24bea16b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b9a6dd0a9266a3304c9ed2bf5bbe0"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aa87b9a6dd0a9266a3304c9ed2bf5bbe0">addGenerator</a> (unsigned long numToAdd=1)</td></tr>
<tr class="memdesc:aa87b9a6dd0a9266a3304c9ed2bf5bbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more generators to the group presentation.  <a href="#aa87b9a6dd0a9266a3304c9ed2bf5bbe0">More...</a><br/></td></tr>
<tr class="separator:aa87b9a6dd0a9266a3304c9ed2bf5bbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9780575405b68ebfaa8ab221cba71500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a9780575405b68ebfaa8ab221cba71500">addRelation</a> (<a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> *rel)</td></tr>
<tr class="memdesc:a9780575405b68ebfaa8ab221cba71500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given relation to the group presentation.  <a href="#a9780575405b68ebfaa8ab221cba71500">More...</a><br/></td></tr>
<tr class="separator:a9780575405b68ebfaa8ab221cba71500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb324b63105930dc0bc38752a6a9c326"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326">countGenerators</a> () const </td></tr>
<tr class="memdesc:afb324b63105930dc0bc38752a6a9c326"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators in this group presentation.  <a href="#afb324b63105930dc0bc38752a6a9c326">More...</a><br/></td></tr>
<tr class="separator:afb324b63105930dc0bc38752a6a9c326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c0d7ec67f1234fef21958aecb66bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a16c0d7ec67f1234fef21958aecb66bbc">getNumberOfGenerators</a> () const </td></tr>
<tr class="memdesc:a16c0d7ec67f1234fef21958aecb66bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of generators in this group presentation.  <a href="#a16c0d7ec67f1234fef21958aecb66bbc">More...</a><br/></td></tr>
<tr class="separator:a16c0d7ec67f1234fef21958aecb66bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04147dca433c6b2ed95ecb0c30d518d0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a04147dca433c6b2ed95ecb0c30d518d0">countRelations</a> () const </td></tr>
<tr class="memdesc:a04147dca433c6b2ed95ecb0c30d518d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of relations in this group presentation.  <a href="#a04147dca433c6b2ed95ecb0c30d518d0">More...</a><br/></td></tr>
<tr class="separator:a04147dca433c6b2ed95ecb0c30d518d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a73fdb2cb59230adc55d0776c1a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a4b1a73fdb2cb59230adc55d0776c1a7f">getNumberOfRelations</a> () const </td></tr>
<tr class="memdesc:a4b1a73fdb2cb59230adc55d0776c1a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of relations in this group presentation.  <a href="#a4b1a73fdb2cb59230adc55d0776c1a7f">More...</a><br/></td></tr>
<tr class="separator:a4b1a73fdb2cb59230adc55d0776c1a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005bf46cda0d29469ec4ab71a62baa6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a005bf46cda0d29469ec4ab71a62baa6f">relation</a> (size_t index) const </td></tr>
<tr class="memdesc:a005bf46cda0d29469ec4ab71a62baa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relation at the given index in this group presentation.  <a href="#a005bf46cda0d29469ec4ab71a62baa6f">More...</a><br/></td></tr>
<tr class="separator:a005bf46cda0d29469ec4ab71a62baa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64155c74cbb60dbbc9db76b2b1e5f699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a64155c74cbb60dbbc9db76b2b1e5f699">getRelation</a> (size_t index) const </td></tr>
<tr class="memdesc:a64155c74cbb60dbbc9db76b2b1e5f699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the relation at the given index in this group presentation.  <a href="#a64155c74cbb60dbbc9db76b2b1e5f699">More...</a><br/></td></tr>
<tr class="separator:a64155c74cbb60dbbc9db76b2b1e5f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b274d0033f233ca74df2fa7a9b6d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a23b274d0033f233ca74df2fa7a9b6d74">isValid</a> () const </td></tr>
<tr class="memdesc:a23b274d0033f233ca74df2fa7a9b6d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether all of the relations for the group are indeed words in the generators.  <a href="#a23b274d0033f233ca74df2fa7a9b6d74">More...</a><br/></td></tr>
<tr class="separator:a23b274d0033f233ca74df2fa7a9b6d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad198d9fddaf1b93c94fe5f98e1b331"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a0ad198d9fddaf1b93c94fe5f98e1b331">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:a0ad198d9fddaf1b93c94fe5f98e1b331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation as intelligently as possible without further input.  <a href="#a0ad198d9fddaf1b93c94fe5f98e1b331">More...</a><br/></td></tr>
<tr class="separator:a0ad198d9fddaf1b93c94fe5f98e1b331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13c31d85521542b72dbceca5b7fae71"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ad13c31d85521542b72dbceca5b7fae71">intelligentSimplifyDetail</a> ()</td></tr>
<tr class="memdesc:ad13c31d85521542b72dbceca5b7fae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation as intelligently as possible without further input.  <a href="#ad13c31d85521542b72dbceca5b7fae71">More...</a><br/></td></tr>
<tr class="separator:ad13c31d85521542b72dbceca5b7fae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2959d98bcfe915ffe7cfe3699f0f76d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a2959d98bcfe915ffe7cfe3699f0f76d0">smallCancellation</a> ()</td></tr>
<tr class="memdesc:a2959d98bcfe915ffe7cfe3699f0f76d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation using only small cancellation theory.  <a href="#a2959d98bcfe915ffe7cfe3699f0f76d0">More...</a><br/></td></tr>
<tr class="separator:a2959d98bcfe915ffe7cfe3699f0f76d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05088ef75d599f680894cd1cbd67520"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aa05088ef75d599f680894cd1cbd67520">smallCancellationDetail</a> ()</td></tr>
<tr class="memdesc:aa05088ef75d599f680894cd1cbd67520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation using small cancellation theory.  <a href="#aa05088ef75d599f680894cd1cbd67520">More...</a><br/></td></tr>
<tr class="separator:aa05088ef75d599f680894cd1cbd67520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7695b6e7b7e700ec0326a6129b36802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#af7695b6e7b7e700ec0326a6129b36802">simplifyWord</a> (<a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp;input) const </td></tr>
<tr class="memdesc:af7695b6e7b7e700ec0326a6129b36802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses small cancellation theory to reduce the input word, using the current presentation of the group.  <a href="#af7695b6e7b7e700ec0326a6129b36802">More...</a><br/></td></tr>
<tr class="separator:af7695b6e7b7e700ec0326a6129b36802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f57990eebf3f93f6181b6eee8284ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a2f57990eebf3f93f6181b6eee8284ed8">proliferateRelators</a> (unsigned long depth=1)</td></tr>
<tr class="memdesc:a2f57990eebf3f93f6181b6eee8284ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators.  <a href="#a2f57990eebf3f93f6181b6eee8284ed8">More...</a><br/></td></tr>
<tr class="separator:a2f57990eebf3f93f6181b6eee8284ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd470a4000d01766581a865cf2bfcdf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a8bd470a4000d01766581a865cf2bfcdf">recogniseGroup</a> (bool moreUtf8=false) const </td></tr>
<tr class="memdesc:a8bd470a4000d01766581a865cf2bfcdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to recognise the group corresponding to this presentation.  <a href="#a8bd470a4000d01766581a865cf2bfcdf">More...</a><br/></td></tr>
<tr class="separator:a8bd470a4000d01766581a865cf2bfcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10db344f73965ffc6cf9266439229958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a10db344f73965ffc6cf9266439229958">writeXMLData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a10db344f73965ffc6cf9266439229958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this group presentation.  <a href="#a10db344f73965ffc6cf9266439229958">More...</a><br/></td></tr>
<tr class="separator:a10db344f73965ffc6cf9266439229958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6f957fc2cc4578731f3fda3e706c4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aee6f957fc2cc4578731f3fda3e706c4c">relatorLength</a> () const </td></tr>
<tr class="memdesc:aee6f957fc2cc4578731f3fda3e706c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of the word lengths of the relators.  <a href="#aee6f957fc2cc4578731f3fda3e706c4c">More...</a><br/></td></tr>
<tr class="separator:aee6f957fc2cc4578731f3fda3e706c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6821ded1f6df26493f3bf641b5a1c879"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1NAbelianGroup.html">NAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a6821ded1f6df26493f3bf641b5a1c879">abelianisation</a> () const </td></tr>
<tr class="memdesc:a6821ded1f6df26493f3bf641b5a1c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <a href="#a6821ded1f6df26493f3bf641b5a1c879">More...</a><br/></td></tr>
<tr class="separator:a6821ded1f6df26493f3bf641b5a1c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b6f1cb98febb418d239069bd93db36"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NMarkedAbelianGroup.html">NMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aa5b6f1cb98febb418d239069bd93db36">markedAbelianisation</a> () const </td></tr>
<tr class="memdesc:aa5b6f1cb98febb418d239069bd93db36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <a href="#aa5b6f1cb98febb418d239069bd93db36">More...</a><br/></td></tr>
<tr class="separator:aa5b6f1cb98febb418d239069bd93db36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab592a8eb9838e6f3143feab22a659650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ab592a8eb9838e6f3143feab22a659650">identifyAbelian</a> () const </td></tr>
<tr class="memdesc:ab592a8eb9838e6f3143feab22a659650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine if the group is abelian.  <a href="#ab592a8eb9838e6f3143feab22a659650">More...</a><br/></td></tr>
<tr class="separator:ab592a8eb9838e6f3143feab22a659650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b96f4bacc325834fce35f7d1d83a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aa8b96f4bacc325834fce35f7d1d83a7f">nielsenTransposition</a> (unsigned long i, unsigned long j)</td></tr>
<tr class="memdesc:aa8b96f4bacc325834fce35f7d1d83a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation.  <a href="#aa8b96f4bacc325834fce35f7d1d83a7f">More...</a><br/></td></tr>
<tr class="separator:aa8b96f4bacc325834fce35f7d1d83a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e2721998286b7c069661da428bc87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aca2e2721998286b7c069661da428bc87">nielsenInvert</a> (unsigned long i)</td></tr>
<tr class="memdesc:aca2e2721998286b7c069661da428bc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation.  <a href="#aca2e2721998286b7c069661da428bc87">More...</a><br/></td></tr>
<tr class="separator:aca2e2721998286b7c069661da428bc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86954fb497691913b3953f45294f27e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ad86954fb497691913b3953f45294f27e">nielsenCombine</a> (unsigned long i, unsigned long j, long k, bool rightMult=true)</td></tr>
<tr class="memdesc:ad86954fb497691913b3953f45294f27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation.  <a href="#ad86954fb497691913b3953f45294f27e">More...</a><br/></td></tr>
<tr class="separator:ad86954fb497691913b3953f45294f27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac94bfa96fc4ed0813e1a042daa6e307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#aac94bfa96fc4ed0813e1a042daa6e307">intelligentNielsen</a> ()</td></tr>
<tr class="memdesc:aac94bfa96fc4ed0813e1a042daa6e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for Nielsen moves that will simplify the presentation.  <a href="#aac94bfa96fc4ed0813e1a042daa6e307">More...</a><br/></td></tr>
<tr class="separator:aac94bfa96fc4ed0813e1a042daa6e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d28a42235b819f393309e054bf5995"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ae1d28a42235b819f393309e054bf5995">intelligentNielsenDetail</a> ()</td></tr>
<tr class="memdesc:ae1d28a42235b819f393309e054bf5995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for Nielsen moves that will simplify the presentation.  <a href="#ae1d28a42235b819f393309e054bf5995">More...</a><br/></td></tr>
<tr class="separator:ae1d28a42235b819f393309e054bf5995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c700ea77bf99e701f1f71fb0f5c94b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ad7c700ea77bf99e701f1f71fb0f5c94b">homologicalAlignment</a> ()</td></tr>
<tr class="memdesc:ad7c700ea77bf99e701f1f71fb0f5c94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible).  <a href="#ad7c700ea77bf99e701f1f71fb0f5c94b">More...</a><br/></td></tr>
<tr class="separator:ad7c700ea77bf99e701f1f71fb0f5c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47889944690b780d163d942432cd73"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a9d47889944690b780d163d942432cd73">homologicalAlignmentDetail</a> ()</td></tr>
<tr class="memdesc:a9d47889944690b780d163d942432cd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible).  <a href="#a9d47889944690b780d163d942432cd73">More...</a><br/></td></tr>
<tr class="separator:a9d47889944690b780d163d942432cd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2206a04898b099351ef0d99ec82826f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ac2206a04898b099351ef0d99ec82826f">prettyRewriting</a> ()</td></tr>
<tr class="memdesc:ac2206a04898b099351ef0d99ec82826f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entirely cosmetic re-writing of the presentation, which is fast and superficial.  <a href="#ac2206a04898b099351ef0d99ec82826f">More...</a><br/></td></tr>
<tr class="separator:ac2206a04898b099351ef0d99ec82826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69ddfa96721b8eb15936143b5b48c78"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#af69ddfa96721b8eb15936143b5b48c78">prettyRewritingDetail</a> ()</td></tr>
<tr class="memdesc:af69ddfa96721b8eb15936143b5b48c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entirely cosmetic re-writing of the presentation, which is fast and superficial.  <a href="#af69ddfa96721b8eb15936143b5b48c78">More...</a><br/></td></tr>
<tr class="separator:af69ddfa96721b8eb15936143b5b48c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac303e2e4a12269c20fbad2578cdffc5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#ac303e2e4a12269c20fbad2578cdffc5d">identifySimplyIsomorphicTo</a> (const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;other) const </td></tr>
<tr class="memdesc:ac303e2e4a12269c20fbad2578cdffc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>.  <a href="#ac303e2e4a12269c20fbad2578cdffc5d">More...</a><br/></td></tr>
<tr class="separator:ac303e2e4a12269c20fbad2578cdffc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c55285caae5482ff40ffc4e7f39aeb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a99c55285caae5482ff40ffc4e7f39aeb">toTeX</a> () const </td></tr>
<tr class="memdesc:a99c55285caae5482ff40ffc4e7f39aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this group presentation.  <a href="#a99c55285caae5482ff40ffc4e7f39aeb">More...</a><br/></td></tr>
<tr class="separator:a99c55285caae5482ff40ffc4e7f39aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212af78fddee84a4e71e983378d03e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a212af78fddee84a4e71e983378d03e36">writeTeX</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a212af78fddee84a4e71e983378d03e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this group presentation to the given output stream.  <a href="#a212af78fddee84a4e71e983378d03e36">More...</a><br/></td></tr>
<tr class="separator:a212af78fddee84a4e71e983378d03e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9c486153d1230820afe6dc0896666f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a6f9c486153d1230820afe6dc0896666f">toStringCompact</a> () const </td></tr>
<tr class="memdesc:a6f9c486153d1230820afe6dc0896666f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for <a class="el" href="classregina_1_1NGroupPresentation.html#acbb8b3b7a638d200f0c718d8d9b97e7a" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a>, which returns a compact one-line representation of this group presentation.  <a href="#a6f9c486153d1230820afe6dc0896666f">More...</a><br/></td></tr>
<tr class="separator:a6f9c486153d1230820afe6dc0896666f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb8b3b7a638d200f0c718d8d9b97e7a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#acbb8b3b7a638d200f0c718d8d9b97e7a">compact</a> () const </td></tr>
<tr class="memdesc:acbb8b3b7a638d200f0c718d8d9b97e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a compact one-line representation of this group presentation, including details of all generators and relations.  <a href="#acbb8b3b7a638d200f0c718d8d9b97e7a">More...</a><br/></td></tr>
<tr class="separator:acbb8b3b7a638d200f0c718d8d9b97e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1c66975249427c48a4ca0caf7fb0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a3a1c66975249427c48a4ca0caf7fb0a9">writeTextCompact</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a3a1c66975249427c48a4ca0caf7fb0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a compact represesentation of this group to the given output stream.  <a href="#a3a1c66975249427c48a4ca0caf7fb0a9">More...</a><br/></td></tr>
<tr class="separator:a3a1c66975249427c48a4ca0caf7fb0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e81eae50a681c95aac902f1cab4414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a39e81eae50a681c95aac902f1cab4414">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a39e81eae50a681c95aac902f1cab4414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a39e81eae50a681c95aac902f1cab4414">More...</a><br/></td></tr>
<tr class="separator:a39e81eae50a681c95aac902f1cab4414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8315c85735148990045b3059b2aa672b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a8315c85735148990045b3059b2aa672b">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a8315c85735148990045b3059b2aa672b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a8315c85735148990045b3059b2aa672b">More...</a><br/></td></tr>
<tr class="separator:a8315c85735148990045b3059b2aa672b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ab182c97fe654b8929d1fe41dc564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#aea0ab182c97fe654b8929d1fe41dc564">toString</a> () const</td></tr>
<tr class="memdesc:aea0ab182c97fe654b8929d1fe41dc564"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for str().  <a href="#aea0ab182c97fe654b8929d1fe41dc564">More...</a><br/></td></tr>
<tr class="separator:aea0ab182c97fe654b8929d1fe41dc564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f5abced4d1365c34980741b564765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#af32f5abced4d1365c34980741b564765">toStringLong</a> () const</td></tr>
<tr class="memdesc:af32f5abced4d1365c34980741b564765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for detail().  <a href="#af32f5abced4d1365c34980741b564765">More...</a><br/></td></tr>
<tr class="separator:af32f5abced4d1365c34980741b564765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4ab9cd66240f5f0cafa22f3ffd28a7ef"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a4ab9cd66240f5f0cafa22f3ffd28a7ef">nGenerators</a></td></tr>
<tr class="memdesc:a4ab9cd66240f5f0cafa22f3ffd28a7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of generators.  <a href="#a4ab9cd66240f5f0cafa22f3ffd28a7ef">More...</a><br/></td></tr>
<tr class="separator:a4ab9cd66240f5f0cafa22f3ffd28a7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0ff7de301f9171697dbb2d3ffdbfbd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGroupPresentation.html#a5e0ff7de301f9171697dbb2d3ffdbfbd">relations</a></td></tr>
<tr class="memdesc:a5e0ff7de301f9171697dbb2d3ffdbfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relations between the generators.  <a href="#a5e0ff7de301f9171697dbb2d3ffdbfbd">More...</a><br/></td></tr>
<tr class="separator:a5e0ff7de301f9171697dbb2d3ffdbfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a finite presentation of a group. </p>
<p>A presentation consists of a number of generators and a set of relations between these generators that together define the group.</p>
<p>If there are <em>g</em> generators, they will be numbered 0, 1, ..., <em>g</em>-1.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Let's make intelligent simplify a tad more intelligent, and the GUI call a bit more safe. Perhaps parallelize the GUI call, and give users parameters to ensure it won't crash the computer. Also look at the FPGroup package. We should also have a simple way of creating <a class="el" href="classregina_1_1NGroupPresentation.html" title="Represents a finite presentation of a group.">NGroupPresentation</a> objects directly from text strings. We would like to have something like <a class="el" href="classregina_1_1NGroupPresentation.html" title="Represents a finite presentation of a group.">NGroupPresentation</a>( numGens, "abAAB", "bccd" ) etc., with arbitrary numbers of relators. Maybe std::tuple. Or "variadic templates"? </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1bd70f21444f4db13bd9df3e0ba0b5c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGroupPresentation::NGroupPresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new presentation with no generators and no relations. </p>

</div>
</div>
<a class="anchor" id="a3d481aa0fe4ea8b0144620e3127c319d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGroupPresentation::NGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the presentation to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9f19fa64867a83a6ddc0201ae36bd31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGroupPresentation::NGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nGens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that allows you to directly pass an arbitrary number of relators in string format. </p>
<p>The first argument <em>nGens</em> is the number of generators one wants the group to have. The second argument <em>rels</em> is a vector of strings, where each string gives a single relator. See the <a class="el" href="classregina_1_1NGroupExpression.html#a0824c2bfb23e2c5d33212c119597738d" title="Attempts to interpret the given input string as a word in a group.">NGroupExpression::NGroupExpression(const std::string&amp;, bool*)</a> constructor notes for information on what format these strings can take.</p>
<p>If any of the given strings could not be interpreted as words, this routine will insert the trivial (unit) word in its place.</p>
<p>If you are compiling Regina against C++11, you can use the C++11 initializer_list construction to construct an <a class="el" href="classregina_1_1NGroupPresentation.html" title="Represents a finite presentation of a group.">NGroupPresentation</a> directly using syntax of the form <code><a class="el" href="classregina_1_1NGroupPresentation.html" title="Represents a finite presentation of a group.">NGroupPresentation</a>(nGens, { "rel1", "rel2", ... })</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGens</td><td>the number of generators. </td></tr>
    <tr><td class="paramname">rels</td><td>a vector of relations each given in string form, as outlined above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6986de1e84adec2b3e046ed9438f1625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGroupPresentation::~NGroupPresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the group presentation. </p>
<p>All relations that are stored will be deallocated. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6821ded1f6df26493f3bf641b5a1c879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NAbelianGroup.html">NAbelianGroup</a>&gt; regina::NGroupPresentation::abelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated abelianisation of this group. </dd></dl>

</div>
</div>
<a class="anchor" id="aa87b9a6dd0a9266a3304c9ed2bf5bbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NGroupPresentation::addGenerator </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>numToAdd</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one or more generators to the group presentation. </p>
<p>If the new presentation has <em>g</em> generators, the new generators will be numbered <em>g</em>-1, <em>g</em>-2 and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numToAdd</td><td>the number of generators to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of generators in the new presentation. </dd></dl>

</div>
</div>
<a class="anchor" id="a9780575405b68ebfaa8ab221cba71500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::addRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given relation to the group presentation. </p>
<p>The relation must be of the form <code>expression = 1</code>.</p>
<p>This presentation will take ownership of the given expression, may change it and will be responsible for its deallocation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not check whether or not your relation is a word only in the generators of this group. In other words, it does not stop you from using generators beyond the <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a> bound.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>In Python, this routine clones its argument instead of claiming ownership of it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>the expression that the relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this parameter should be the expression <code>g1^2 g2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbb8b3b7a638d200f0c718d8d9b97e7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NGroupPresentation::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a compact one-line representation of this group presentation, including details of all generators and relations. </p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#a3a1c66975249427c48a4ca0caf7fb0a9" title="Writes a compact represesentation of this group to the given output stream.">writeTextCompact()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a compact representation of this group presentation. </dd></dl>

</div>
</div>
<a class="anchor" id="afb324b63105930dc0bc38752a6a9c326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NGroupPresentation::countGenerators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators. </dd></dl>

</div>
</div>
<a class="anchor" id="a04147dca433c6b2ed95ecb0c30d518d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NGroupPresentation::countRelations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of relations in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of relations. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c0d7ec67f1234fef21958aecb66bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NGroupPresentation::getNumberOfGenerators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of generators in this group presentation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a>. See the <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1a73fdb2cb59230adc55d0776c1a7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NGroupPresentation::getNumberOfRelations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of relations in this group presentation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGroupPresentation.html#a04147dca433c6b2ed95ecb0c30d518d0" title="Returns the number of relations in this group presentation.">countRelations()</a>. See the <a class="el" href="classregina_1_1NGroupPresentation.html#a04147dca433c6b2ed95ecb0c30d518d0" title="Returns the number of relations in this group presentation.">countRelations()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a64155c74cbb60dbbc9db76b2b1e5f699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp; regina::NGroupPresentation::getRelation </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the relation at the given index in this group presentation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGroupPresentation.html#a005bf46cda0d29469ec4ab71a62baa6f" title="Returns the relation at the given index in this group presentation.">relation()</a>. See the <a class="el" href="classregina_1_1NGroupPresentation.html#a005bf46cda0d29469ec4ab71a62baa6f" title="Returns the relation at the given index in this group presentation.">relation()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c700ea77bf99e701f1f71fb0f5c94b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::homologicalAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible). </p>
<p>Consider this a <em>homological-alignment</em> of the presentation.</p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#a9d47889944690b780d163d942432cd73" title="Rewrites the presentation so that generators of the group map to generators of the abelianisation...">homologicalAlignmentDetail()</a> for further details on what this routine does.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if presentation was changed, or <code>false</code> if the presentation was already homologically aligned. See <a class="el" href="classregina_1_1NGroupPresentation.html#a9d47889944690b780d163d942432cd73" title="Rewrites the presentation so that generators of the group map to generators of the abelianisation...">homologicalAlignmentDetail()</a> if you wish to get the isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d47889944690b780d163d942432cd73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a>&gt; regina::NGroupPresentation::homologicalAlignmentDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible). </p>
<p>Consider this a <em>homological-alignment</em> of the presentation.</p>
<p>If the abelianisation of this group has rank <em>N</em> and <em>M</em> invariant factors <code>d0 | d2 | ... | d(M-1)</code>, this routine applies Nielsen moves to the presentation to ensure that under the <a class="el" href="classregina_1_1NGroupPresentation.html#aa5b6f1cb98febb418d239069bd93db36" title="Computes the abelianisation of this group.">markedAbelianisation()</a> routine, generators 0 through <em>M-1</em> are mapped to generators of the relevant <code>Z_di</code> group. Similarly, generators <em>M</em> through <em>M</em>+<em>N</em>-1 are mapped to +/-1 in the appropriate factor. All further generators will be mapped to zero.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1NHomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">NHomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism giving the reduction map from the old presentation to the new, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab592a8eb9838e6f3143feab22a659650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::identifyAbelian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to determine if the group is abelian. </p>
<p>A return value of <code>true</code> indicates that this routine successfully certified that the group is abelian. A return value of <code>false</code> indicates an inconclusive result: either the group is non-abelian, or the group is abelian but this routine could not prove so.</p>
<p>If the group is abelian, then markedAbelianization() is the easiest way to see precisely which abelian group it is, and how the generators sit in that group.</p>
<p>You will have better results from this algorithm if the presentation has been simplified, since this algorithm uses small cancellation theory in an attempt to reduce the commutators of all pairs of generators.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have not adequately simplified this presentation this routine will most likely return <code>false</code>. Consider running intelligentSimplify, possibly in concert with <a class="el" href="classregina_1_1NGroupPresentation.html#a2f57990eebf3f93f6181b6eee8284ed8" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, in order to discover adequately many commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the group is shown to be abelian, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="ac303e2e4a12269c20fbad2578cdffc5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::identifySimplyIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>. </p>
<p>A <em>simple isomorphism</em> is an isomorphism where each generator <em>g<sub>i</sub></em> of this presentation is sent to some generator <em>g<sub>j</sub></em><sup>+/-1</sup> of the other presentation. Moreover, at present this routine only looks for maps where both presentations have the same number of generators, and where distinct generators <em>g<sub>i</sub></em> of this presentation correspond to distinct generators <em>g<sub>j</sub></em> of the other presentation (possibly with inversion, as noted above).</p>
<p>If this routine returns <code>true</code>, it means that the two presentations are indeed simply isomorphic.</p>
<p>If this routine returns <code>false</code>, it could mean one of many things:</p>
<ul>
<li>The groups are not isomorphic;</li>
<li>The groups are isomorphic, but not simply isomorphic;</li>
<li>The groups are simply isomorphic but this routine could not prove it, due to difficulties with the word problem.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this routine could certify that the two group presentations are simply isomorphic, or <code>false</code> if it could not. </dd></dl>

</div>
</div>
<a class="anchor" id="aac94bfa96fc4ed0813e1a042daa6e307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::intelligentNielsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for Nielsen moves that will simplify the presentation. </p>
<p>Performs one of the most-effective moves, if it can find any.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if it performed a Nielsen move. You can call <a class="el" href="classregina_1_1NGroupPresentation.html#aac94bfa96fc4ed0813e1a042daa6e307" title="Looks for Nielsen moves that will simplify the presentation.">intelligentNielsen()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1d28a42235b819f393309e054bf5995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a>&gt; regina::NGroupPresentation::intelligentNielsenDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for Nielsen moves that will simplify the presentation. </p>
<p>Performs one of the most-effective moves, if it can find any.</p>
<p>If this routine does return a homomorphism (because some move was performed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1NHomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">NHomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the map from the original presentation to the new presentation, or a null pointer if no move was performed. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad198d9fddaf1b93c94fe5f98e1b331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation as intelligently as possible without further input. </p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#ad13c31d85521542b72dbceca5b7fae71" title="Attempts to simplify the group presentation as intelligently as possible without further input...">intelligentSimplifyDetail()</a> for further details on how the simplification is done.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the group presentation was changed. You can call <a class="el" href="classregina_1_1NGroupPresentation.html#ad13c31d85521542b72dbceca5b7fae71" title="Attempts to simplify the group presentation as intelligently as possible without further input...">intelligentSimplifyDetail()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="ad13c31d85521542b72dbceca5b7fae71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a>&gt; regina::NGroupPresentation::intelligentSimplifyDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation as intelligently as possible without further input. </p>
<p>The current simplification method uses a combination of small cancellation theory and Nielsen moves.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1NHomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">NHomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the reduction map from the original presentation to the new presentation, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a23b274d0033f233ca74df2fa7a9b6d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether all of the relations for the group are indeed words in the generators. </p>
<p>This routine returns <code>false</code> if at least one relator uses an out-of-bound generator, and <code>true</code> otherwise.</p>
<p>This routine is intended only for sanity checking: you should never have an invalid group presentation in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all of the relations are words in the generators. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b6f1cb98febb418d239069bd93db36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NMarkedAbelianGroup.html">NMarkedAbelianGroup</a>&gt; regina::NGroupPresentation::markedAbelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<p>The coordinates in the chain complex correspond to the generators and relators for this group.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated abelianisation of this group. </dd></dl>

</div>
</div>
<a class="anchor" id="ad86954fb497691913b3953f45294f27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::nielsenCombine </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rightMult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation. </p>
<p>It it is the third type of Nielsen move one can apply to a presentation.</p>
<p>This means that, if the new generator <code>Gi</code> is the old <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code>, then we can construct the new presentation from the old by replacing occurrences of <code>Gi</code> by <code>(Gi)(gj)^(-k)</code> or <code>(gj)^(-k)(Gi)</code> respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to replace. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the generator to combine with <code>gi</code>. </td></tr>
    <tr><td class="paramname">k</td><td>indicates the power to which we raise <code>gj</code> when performing the replacement; this may be positive or negative (or zero, but this will have no effect). </td></tr>
    <tr><td class="paramname">rightMult</td><td><code>true</code> if we should replace <code>gi</code> by <code>(gi)(gj)^k</code>, or <code>false</code> if we should replace <code>gi</code> by <code>(gj)^k(gi)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a class="anchor" id="aca2e2721998286b7c069661da428bc87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::nielsenInvert </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation. </p>
<p>This is the second generator type of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> is strictly less than <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8b96f4bacc325834fce35f7d1d83a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::nielsenTransposition </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation. </p>
<p>It is one of the standard Nielsen moves, which is the first of three generator types of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="classregina_1_1NGroupPresentation.html#afb324b63105930dc0bc38752a6a9c326" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the first of the two generators to switch. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the second of the two generators to switch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a class="anchor" id="a56a6e1551739dbbfa7e8fa24bea16b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a>&amp; regina::NGroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group presentation that this will become a copy of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group presentation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2206a04898b099351ef0d99ec82826f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::prettyRewriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entirely cosmetic re-writing of the presentation, which is fast and superficial. </p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#af69ddfa96721b8eb15936143b5b48c78" title="An entirely cosmetic re-writing of the presentation, which is fast and superficial.">prettyRewritingDetail()</a> for further details on what this routine does.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the choice of generators for the group has changed. You can call <a class="el" href="classregina_1_1NGroupPresentation.html#af69ddfa96721b8eb15936143b5b48c78" title="An entirely cosmetic re-writing of the presentation, which is fast and superficial.">prettyRewritingDetail()</a> to get the the isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="af69ddfa96721b8eb15936143b5b48c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a>&gt; regina::NGroupPresentation::prettyRewritingDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entirely cosmetic re-writing of the presentation, which is fast and superficial. </p>
<ol type="1">
<li>If there are any length 1 relators, those generators are deleted, and the remaining relators simplified.</li>
<li>It sorts the relators by number of generator indices that appear, followed by relator numbers (lexico) followed by relator length.</li>
<li>inverts relators if net sign of the generators is negative.</li>
<li>Given each generator, it looks for the smallest word where that generator appears with non-zero weight. If negative weight, it inverts that generator.</li>
<li>It cyclically permutes relators to start with smallest gen.</li>
</ol>
<p>If this routine does return a homomorphism (because the choice of generators was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1NHomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">NHomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>As a final step, make elementary simplifications to aid in seeing standard relators like commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the map from the original presentation to the new presentation, or a null pointer if the choice of generators did not change. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f57990eebf3f93f6181b6eee8284ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::proliferateRelators </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators. </p>
<p>Given a presentation &lt;g_i | r_i&gt;, this routine appends consequences of the relators {r_i} to the presentation that are of the form ab, where both a and b are cyclic permutations of relators from the collection {r_i}.</p>
<p>Passing depth=1 means it will only form products of two relators. Depth=2 means products of three, etc. Depth=4 is typically the last depth before the exponential growth of the operation grows out of hand. It also conveniently trivializes all the complicated trivial group presentations that we've come across so far.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this routine with depth n before having called it at depth n-1 first. Depth=0 is invalid, and depth=1 should be your first call to this routine. This routine gobbles up an exponential amount of memory (exponential in your presentation size times n). So do be careful when using it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>controls the depth of the proliferation, as described above; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bd470a4000d01766581a865cf2bfcdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NGroupPresentation::recogniseGroup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moreUtf8</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to recognise the group corresponding to this presentation. </p>
<p>This routine is much more likely to be successful if you have already called <a class="el" href="classregina_1_1NGroupPresentation.html#a0ad198d9fddaf1b93c94fe5f98e1b331" title="Attempts to simplify the group presentation as intelligently as possible without further input...">intelligentSimplify()</a>.</p>
<p>Currently, the groups this routine recognises include: the trivial group, abelian groups, free groups, extensions over the integers, and free products of any group the algorithm can recognise (inductively).</p>
<p>The string returned from this routine may use some unicode characters, which will be encoding using UTF-8. If <em>moreUtf8</em> is passed as <code>false</code> then unicode will be used sparingly; if <em>moreUtf8</em> is <code>true</code> then unicode will be use more liberally, resulting in strings that look nicer but require more complex fonts to be available on the user's machine.</p>
<p>Examples of the format of the returned string are:</p>
<ul>
<li><code>0</code> for the trivial group;</li>
<li><code>Z_n</code> for cyclic groups with <em>n</em> &gt; 1;</li>
<li><code>Free(n)</code> for free groups with <em>n</em> &gt; 1 generators - see <a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49" title="Returns a short text representation of this object.">NAbelianGroup::str()</a> for how abelian groups are presented;</li>
<li><code>FreeProduct(G1, G2, ... , Gk)</code> for free products, where one replaces <em>G1</em> through <em>Gk</em> by text strings representing the free summands;</li>
<li><code>Z~G w/ monodromy H</code> for extensions over Z, where <em>G</em> is a description of the kernel of the homomorphism to the integers, and <em>H</em> is a text string representing the monodromy - see <a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49" title="Returns a short text representation of this object.">NHomMarkedAbelianGroup.str()</a> for details on how these are presented.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><em>Feature (long-term):</em> Make this recognition more effective.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a simple string representation of the group if it is recognised, or an empty string if the group is not recognised. </dd></dl>

</div>
</div>
<a class="anchor" id="a005bf46cda0d29469ec4ab71a62baa6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp; regina::NGroupPresentation::relation </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relation at the given index in this group presentation. </p>
<p>The relation will be of the form <code>expresson = 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired relation; this must be between 0 and <a class="el" href="classregina_1_1NGroupPresentation.html#a04147dca433c6b2ed95ecb0c30d518d0" title="Returns the number of relations in this group presentation.">countRelations()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expression that the requested relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this will be the expression <code>g1^2 g2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6f957fc2cc4578731f3fda3e706c4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NGroupPresentation::relatorLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sum of the word lengths of the relators. </p>
<p>Word lengths are computing using <a class="el" href="classregina_1_1NGroupExpression.html#ae03a35948953b15ece5165c085a541cb" title="Returns the length of the word, i.e.">NGroupExpression::wordLength()</a>. Used as a coarse measure of the complexity of the presentation.</p>
<dl class="section return"><dt>Returns</dt><dd>the sum of word lengths. </dd></dl>

</div>
</div>
<a class="anchor" id="af7695b6e7b7e700ec0326a6129b36802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::simplifyWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses small cancellation theory to reduce the input word, using the current presentation of the group. </p>
<p>The input word will be modified directly.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is only as good as the relator table for the group. You might want to consider running <a class="el" href="classregina_1_1NGroupPresentation.html#a0ad198d9fddaf1b93c94fe5f98e1b331" title="Attempts to simplify the group presentation as intelligently as possible without further input...">intelligentSimplify()</a>, possibly in concert with <a class="el" href="classregina_1_1NGroupPresentation.html#a2f57990eebf3f93f6181b6eee8284ed8" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, before using this routine for any significant tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is the word you would like to simplify. This must be a word in the generators of this group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the input word was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a2959d98bcfe915ffe7cfe3699f0f76d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGroupPresentation::smallCancellation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation using only small cancellation theory. </p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#aa05088ef75d599f680894cd1cbd67520" title="Attempts to simplify the group presentation using small cancellation theory.">smallCancellationDetail()</a> for further details on how the simplification is done.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the group presentation was changed. You can call <a class="el" href="classregina_1_1NGroupPresentation.html#aa05088ef75d599f680894cd1cbd67520" title="Attempts to simplify the group presentation using small cancellation theory.">smallCancellationDetail()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a class="anchor" id="aa05088ef75d599f680894cd1cbd67520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1NHomGroupPresentation.html">NHomGroupPresentation</a>&gt; regina::NGroupPresentation::smallCancellationDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation using small cancellation theory. </p>
<p>The simplification method is based on the Dehn algorithm for hyperbolic groups, i.e. small cancellation theory. This means we look to see if part of one relator can be used to simplify others. If so, make the substitution and simplify. We continue until no more presentation-shortening substitutions are available. We follow that by killing any available generators using words where generators appear a single time.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1NHomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">NHomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> This routine could use some small tweaks - recognition of utility of some score==0 moves, such as commutators, for example.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the reduction map from the original presentation to the new presentation, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0ab182c97fe654b8929d1fe41dc564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> , false  &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for str(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000253">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type str() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f9c486153d1230820afe6dc0896666f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string regina::NGroupPresentation::toStringCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated alias for <a class="el" href="classregina_1_1NGroupPresentation.html#acbb8b3b7a638d200f0c718d8d9b97e7a" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a>, which returns a compact one-line representation of this group presentation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This routine has been deprecated; use the simpler-to-type <a class="el" href="classregina_1_1NGroupPresentation.html#acbb8b3b7a638d200f0c718d8d9b97e7a" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a compact representation of this group presentation. </dd></dl>

</div>
</div>
<a class="anchor" id="af32f5abced4d1365c34980741b564765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> , false  &gt;::toStringLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for detail(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000254">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type detail() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a long text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a99c55285caae5482ff40ffc4e7f39aeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NGroupPresentation::toTeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this group presentation. </p>
<p>See <a class="el" href="classregina_1_1NGroupPresentation.html#a212af78fddee84a4e71e983378d03e36" title="Writes a TeX represesentation of this group presentation to the given output stream.">writeTeX()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this group presentation. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NGroupPresentation.html">NGroupPresentation</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a212af78fddee84a4e71e983378d03e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this group presentation to the given output stream. </p>
<p>The output will be of the form &lt; generators | relators &gt;. There will be no final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a1c66975249427c48a4ca0caf7fb0a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::writeTextCompact </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a compact represesentation of this group to the given output stream. </p>
<p>The output will be of the form &lt; generators | relators &gt;. The full relations will be included, and the entire output will be written on a single line. There will be no final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8315c85735148990045b3059b2aa672b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39e81eae50a681c95aac902f1cab4414"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10db344f73965ffc6cf9266439229958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGroupPresentation::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this group presentation. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4ab9cd66240f5f0cafa22f3ffd28a7ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::NGroupPresentation::nGenerators</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of generators. </p>

</div>
</div>
<a class="anchor" id="a5e0ff7de301f9171697dbb2d3ffdbfbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NGroupExpression.html">NGroupExpression</a>*&gt; regina::NGroupPresentation::relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The relations between the generators. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="ngrouppresentation_8h.html">ngrouppresentation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
