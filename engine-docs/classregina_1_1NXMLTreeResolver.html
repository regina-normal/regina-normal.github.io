<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NXMLTreeResolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NXMLTreeResolver.html">NXMLTreeResolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1NXMLTreeResolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NXMLTreeResolver Class Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file.  
 <a href="classregina_1_1NXMLTreeResolver.html#details">More...</a></p>

<p><code>#include &lt;packet/nxmltreeresolver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NXMLTreeResolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NXMLTreeResolver.png" usemap="#regina::NXMLTreeResolver_map" alt=""/>
  <map id="regina::NXMLTreeResolver_map" name="regina::NXMLTreeResolver_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a486f510098a7482e5b6349a60afef77c"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classregina_1_1NPacket.html">NPacket</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#a486f510098a7482e5b6349a60afef77c">IDMap</a></td></tr>
<tr class="memdesc:a486f510098a7482e5b6349a60afef77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that maps internal IDs from the data file to the corresponding packets.  <a href="#a486f510098a7482e5b6349a60afef77c">More...</a><br/></td></tr>
<tr class="separator:a486f510098a7482e5b6349a60afef77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f105f90f475f439b7946952a748d8ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#a9f105f90f475f439b7946952a748d8ef">NXMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:a9f105f90f475f439b7946952a748d8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a resolver with no tasks queued.  <a href="#a9f105f90f475f439b7946952a748d8ef">More...</a><br/></td></tr>
<tr class="separator:a9f105f90f475f439b7946952a748d8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2bf72002c2428491692a5de926d286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#afc2bf72002c2428491692a5de926d286">~NXMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:afc2bf72002c2428491692a5de926d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys any tasks that were queued but not performed.  <a href="#afc2bf72002c2428491692a5de926d286">More...</a><br/></td></tr>
<tr class="separator:afc2bf72002c2428491692a5de926d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a50bd0036a97c1416ca6dac364aeba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#ad7a50bd0036a97c1416ca6dac364aeba">queueTask</a> (<a class="el" href="classregina_1_1NXMLTreeResolutionTask.html">NXMLTreeResolutionTask</a> *task)</td></tr>
<tr class="memdesc:ad7a50bd0036a97c1416ca6dac364aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a task for processing.  <a href="#ad7a50bd0036a97c1416ca6dac364aeba">More...</a><br/></td></tr>
<tr class="separator:ad7a50bd0036a97c1416ca6dac364aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4275a0fff28d3290c7678622b1eb38c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#a4275a0fff28d3290c7678622b1eb38c6">storeID</a> (const std::string &amp;id, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:a4275a0fff28d3290c7678622b1eb38c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the fact that the given packet is stored in the data file using the given internal ID.  <a href="#a4275a0fff28d3290c7678622b1eb38c6">More...</a><br/></td></tr>
<tr class="separator:a4275a0fff28d3290c7678622b1eb38c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb06a95a6853f0593f224f16520c54b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NXMLTreeResolver.html#a486f510098a7482e5b6349a60afef77c">IDMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#a8eb06a95a6853f0593f224f16520c54b">ids</a> () const </td></tr>
<tr class="memdesc:a8eb06a95a6853f0593f224f16520c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file.  <a href="#a8eb06a95a6853f0593f224f16520c54b">More...</a><br/></td></tr>
<tr class="separator:a8eb06a95a6853f0593f224f16520c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac674e2b2c52502fab801bc5ae93d0bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef">resolve</a> ()</td></tr>
<tr class="memdesc:ac674e2b2c52502fab801bc5ae93d0bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html#abe3a2894977a7ff9f655ab9c9eb4961f" title="Called by NXMLTreeResolver after the entire data file has been read.">NXMLTreeResolutionTask::resolve()</a> for all queued tasks.  <a href="#ac674e2b2c52502fab801bc5ae93d0bef">More...</a><br/></td></tr>
<tr class="separator:ac674e2b2c52502fab801bc5ae93d0bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file. </p>
<p>There are situations in which, when reading an XML data file, the data stored in an individual packet cannot be fully constructed until after the entire data file has been read. For instance, a packet might need to store pointers or references to other packets that could appear later in the packet tree (e.g., a script storing pointers to its variables).</p>
<p>This problem is solved by the <a class="el" href="classregina_1_1NXMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">NXMLTreeResolver</a> class. The complete process of reading an XML data file works as follows:</p>
<ul>
<li>The top-level routine managing the file I/O constructs a new <a class="el" href="classregina_1_1NXMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">NXMLTreeResolver</a>. This resolver is then passed to each <a class="el" href="classregina_1_1NXMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">NXMLPacketReader</a> in turn as each individual packet is read.</li>
</ul>
<ul>
<li>If an <a class="el" href="classregina_1_1NXMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">NXMLPacketReader</a> is not able to fully flesh out its data because it requires information that is not yet available, it should create a new <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read...">NXMLTreeResolutionTask</a> and queue this task to the resolver via <a class="el" href="classregina_1_1NXMLTreeResolver.html#ad7a50bd0036a97c1416ca6dac364aeba" title="Queues a task for processing.">NXMLTreeResolver::queueTask()</a>.</li>
</ul>
<ul>
<li>Once the entire packet tree has been read, the top-level file I/O manager will call <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">NXMLTreeResolver::resolve()</a>. This will run <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html#abe3a2894977a7ff9f655ab9c9eb4961f" title="Called by NXMLTreeResolver after the entire data file has been read.">NXMLTreeResolutionTask::resolve()</a> for each task in turn, whereby any missing data for individual packets can be resolved.</li>
</ul>
<p>Each task should be an instance of a subclass of <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read...">NXMLTreeResolutionTask</a>, whose virtual <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> function is overridden to perform whatever "fleshing out" work is required for the type of packet under consideration. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a486f510098a7482e5b6349a60afef77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classregina_1_1NPacket.html">NPacket</a>*&gt; <a class="el" href="classregina_1_1NXMLTreeResolver.html#a486f510098a7482e5b6349a60afef77c">regina::NXMLTreeResolver::IDMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that maps internal IDs from the data file to the corresponding packets. </p>
<p>See <a class="el" href="classregina_1_1NXMLTreeResolver.html#a8eb06a95a6853f0593f224f16520c54b" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f105f90f475f439b7946952a748d8ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NXMLTreeResolver::NXMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a resolver with no tasks queued. </p>

</div>
</div>
<a class="anchor" id="afc2bf72002c2428491692a5de926d286"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NXMLTreeResolver::~NXMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys any tasks that were queued but not performed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8eb06a95a6853f0593f224f16520c54b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NXMLTreeResolver.html#a486f510098a7482e5b6349a60afef77c">NXMLTreeResolver::IDMap</a> &amp; regina::NXMLTreeResolver::ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file. </p>
<p>Packets in a data file may have individual string IDs stored alongside them, in the <em>id</em> attribute of the <code>&lt;packet&gt;</code> tag. These strings are optional, and do not need to be human-readable. Although packets are not required to have IDs, any IDs that <em>are</em> stored must be unique (i.e., two different packets cannot share the same ID).</p>
<p>Note that IDs read from the data file need not bear any relation to the IDs that are returned from <a class="el" href="classregina_1_1NPacket.html#a4610a242eaa65affcbf6d36fadae4469" title="Returns a unique string ID that identifies this packet.">NPacket::internalID()</a>, although this is typically how they are constructed when a file is saved.</p>
<p>This map will be fleshed out as the data file is read. In particular, since each task runs <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html#abe3a2894977a7ff9f655ab9c9eb4961f" title="Called by NXMLTreeResolver after the entire data file has been read.">NXMLTreeResolutionTask::resolve()</a> only after the entire tree has been read, tasks may assume that this map contains all IDs that were explicitly stored in the data file.</p>
<p>Only packets with IDs will appear in this map (i.e., there may well be packets in the data file that do not appear in this map at all).</p>
<dl class="section return"><dt>Returns</dt><dd>the map from internal file IDs to packets. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a50bd0036a97c1416ca6dac364aeba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NXMLTreeResolver::queueTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NXMLTreeResolutionTask.html">NXMLTreeResolutionTask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a task for processing. </p>
<p>When the file I/O manager calls <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a>, this will call <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html#abe3a2894977a7ff9f655ab9c9eb4961f" title="Called by NXMLTreeResolver after the entire data file has been read.">NXMLTreeResolutionTask::resolve()</a> for each task that has been queued.</p>
<p>This object will claim ownership of the given task, and will destroy it after <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> has been called (or, if <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> is never called, when this <a class="el" href="classregina_1_1NXMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">NXMLTreeResolver</a> is destroyed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to be queued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac674e2b2c52502fab801bc5ae93d0bef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NXMLTreeResolver::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classregina_1_1NXMLTreeResolutionTask.html#abe3a2894977a7ff9f655ab9c9eb4961f" title="Called by NXMLTreeResolver after the entire data file has been read.">NXMLTreeResolutionTask::resolve()</a> for all queued tasks. </p>
<p>The tasks will then be destroyed and removed from the queue (so subsequent calls to <a class="el" href="classregina_1_1NXMLTreeResolver.html#ac674e2b2c52502fab801bc5ae93d0bef" title="Calls NXMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> are safe and will do nothing). </p>

</div>
</div>
<a class="anchor" id="a4275a0fff28d3290c7678622b1eb38c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NXMLTreeResolver::storeID </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the fact that the given packet is stored in the data file using the given internal ID. </p>
<p>Associations between IDs and packets can be queried through the <a class="el" href="classregina_1_1NXMLTreeResolver.html#a8eb06a95a6853f0593f224f16520c54b" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> function. See <a class="el" href="classregina_1_1NXMLTreeResolver.html#a8eb06a95a6853f0593f224f16520c54b" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for further information on internal IDs.</p>
<p>This will be called automatically by <a class="el" href="classregina_1_1NXMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">NXMLPacketReader</a> as it processes packet tags in the data file. Users and/or subclasses of <a class="el" href="classregina_1_1NXMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">NXMLPacketReader</a> do not need to call this function themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the internal ID of the given packet, as stored in the data file. </td></tr>
    <tr><td class="paramname">packet</td><td>the corresponding packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="nxmltreeresolver_8h.html">nxmltreeresolver.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
