<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::LPMatrix&lt; Integer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1LPMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::LPMatrix&lt; Integer &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A matrix class for use with linear programming.  
 <a href="classregina_1_1LPMatrix.html#details">More...</a></p>

<p><code>#include &lt;enumerate/ntreelp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba03c00655c64bebc1ae8937dc9537ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#aba03c00655c64bebc1ae8937dc9537ec">LPMatrix</a> ()</td></tr>
<tr class="memdesc:aba03c00655c64bebc1ae8937dc9537ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised matrix with no memory storage.  <a href="#aba03c00655c64bebc1ae8937dc9537ec">More...</a><br/></td></tr>
<tr class="separator:aba03c00655c64bebc1ae8937dc9537ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcff355353b833a1a4efd367d6abf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a7bcff355353b833a1a4efd367d6abf67">LPMatrix</a> (unsigned <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150">rows</a>, unsigned cols)</td></tr>
<tr class="memdesc:a7bcff355353b833a1a4efd367d6abf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero.  <a href="#a7bcff355353b833a1a4efd367d6abf67">More...</a><br/></td></tr>
<tr class="separator:a7bcff355353b833a1a4efd367d6abf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52478cdada0d0c8eff59ff271f80e5bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a52478cdada0d0c8eff59ff271f80e5bd">~LPMatrix</a> ()</td></tr>
<tr class="memdesc:a52478cdada0d0c8eff59ff271f80e5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix and all of the data it contains.  <a href="#a52478cdada0d0c8eff59ff271f80e5bd">More...</a><br/></td></tr>
<tr class="separator:a52478cdada0d0c8eff59ff271f80e5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f02ccf74fbee3b911dfa5163d87c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84">reserve</a> (unsigned maxRows, unsigned maxCols)</td></tr>
<tr class="memdesc:af1f02ccf74fbee3b911dfa5163d87c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix.  <a href="#af1f02ccf74fbee3b911dfa5163d87c84">More...</a><br/></td></tr>
<tr class="separator:af1f02ccf74fbee3b911dfa5163d87c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70b701f86e3abbc6eba098cad8af961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad70b701f86e3abbc6eba098cad8af961">initClone</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;clone)</td></tr>
<tr class="memdesc:ad70b701f86e3abbc6eba098cad8af961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to a copy of the given matrix.  <a href="#ad70b701f86e3abbc6eba098cad8af961">More...</a><br/></td></tr>
<tr class="separator:ad70b701f86e3abbc6eba098cad8af961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a334363e30727cac7532d48c0d05669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a6a334363e30727cac7532d48c0d05669">initIdentity</a> (unsigned size)</td></tr>
<tr class="memdesc:a6a334363e30727cac7532d48c0d05669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to the identity matrix of the given size.  <a href="#a6a334363e30727cac7532d48c0d05669">More...</a><br/></td></tr>
<tr class="separator:a6a334363e30727cac7532d48c0d05669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90a66cd20b7c286417f776d9de52c28"><td class="memItemLeft" align="right" valign="top">Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad90a66cd20b7c286417f776d9de52c28">entry</a> (unsigned row, unsigned col)</td></tr>
<tr class="memdesc:ad90a66cd20b7c286417f776d9de52c28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the given element of this matrix.  <a href="#ad90a66cd20b7c286417f776d9de52c28">More...</a><br/></td></tr>
<tr class="separator:ad90a66cd20b7c286417f776d9de52c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa029ce1662ef72298b76e5c9af36d6da"><td class="memItemLeft" align="right" valign="top">const Integer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#aa029ce1662ef72298b76e5c9af36d6da">entry</a> (unsigned row, unsigned col) const </td></tr>
<tr class="memdesc:aa029ce1662ef72298b76e5c9af36d6da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only reference to the given element of this matrix.  <a href="#aa029ce1662ef72298b76e5c9af36d6da">More...</a><br/></td></tr>
<tr class="separator:aa029ce1662ef72298b76e5c9af36d6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7a9578c0eef0f56da70934af07b150"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150">rows</a> () const </td></tr>
<tr class="memdesc:acd7a9578c0eef0f56da70934af07b150"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix.  <a href="#acd7a9578c0eef0f56da70934af07b150">More...</a><br/></td></tr>
<tr class="separator:acd7a9578c0eef0f56da70934af07b150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710407fbce64f4b891aaab6fb5283c69"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a710407fbce64f4b891aaab6fb5283c69">columns</a> () const </td></tr>
<tr class="memdesc:a710407fbce64f4b891aaab6fb5283c69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix.  <a href="#a710407fbce64f4b891aaab6fb5283c69">More...</a><br/></td></tr>
<tr class="separator:a710407fbce64f4b891aaab6fb5283c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860afdebf19ab1f4ce382448787d7bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a860afdebf19ab1f4ce382448787d7bb5">swapRows</a> (unsigned r1, unsigned r2)</td></tr>
<tr class="memdesc:a860afdebf19ab1f4ce382448787d7bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two given rows of this matrix.  <a href="#a860afdebf19ab1f4ce382448787d7bb5">More...</a><br/></td></tr>
<tr class="separator:a860afdebf19ab1f4ce382448787d7bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd9a5fca3701092cf12bfe3e1c8631d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#addd9a5fca3701092cf12bfe3e1c8631d">combRow</a> (const Integer &amp;destCoeff, unsigned dest, const Integer &amp;srcCoeff, unsigned src, const Integer &amp;div)</td></tr>
<tr class="memdesc:addd9a5fca3701092cf12bfe3e1c8631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix.  <a href="#addd9a5fca3701092cf12bfe3e1c8631d">More...</a><br/></td></tr>
<tr class="separator:addd9a5fca3701092cf12bfe3e1c8631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc220b38be89d752cce1d74640c767e2"><td class="memItemLeft" align="right" valign="top">Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#afc220b38be89d752cce1d74640c767e2">combRowAndNorm</a> (const Integer &amp;destCoeff, unsigned dest, const Integer &amp;srcCoeff, unsigned src)</td></tr>
<tr class="memdesc:afc220b38be89d752cce1d74640c767e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix, and then normalises.  <a href="#afc220b38be89d752cce1d74640c767e2">More...</a><br/></td></tr>
<tr class="separator:afc220b38be89d752cce1d74640c767e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d338d4e3ccb2d80dc0fda890d8c706d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a1d338d4e3ccb2d80dc0fda890d8c706d">negateRow</a> (unsigned row)</td></tr>
<tr class="memdesc:a1d338d4e3ccb2d80dc0fda890d8c706d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements in the given row of this matrix.  <a href="#a1d338d4e3ccb2d80dc0fda890d8c706d">More...</a><br/></td></tr>
<tr class="separator:a1d338d4e3ccb2d80dc0fda890d8c706d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af741d99a6a02b11ec99104212f80380b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#af741d99a6a02b11ec99104212f80380b">dump</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:af741d99a6a02b11ec99104212f80380b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this matrix to the given output stream.  <a href="#af741d99a6a02b11ec99104212f80380b">More...</a><br/></td></tr>
<tr class="separator:af741d99a6a02b11ec99104212f80380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Integer&gt;<br/>
class regina::LPMatrix&lt; Integer &gt;</h3>

<p>A matrix class for use with linear programming. </p>
<p>This class is used in the tree traversal algorithms for enumerating and locating vertex normal surfaces, as described in "A tree traversal
algorithm for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079. It is also used for locating a single strict angle structure, and for enumerating all taut angle structures.</p>
<p>The operations on this matrix class are tailored and optimised specifically for use with the dual simplex method in the context of a repetitive backtracking search. As a result, the API is cumbersome and highly specialised, which makes this matrix class inappropriate for general use.</p>
<p>It is <em>critical</em> that, before using such a matrix, you reserve space for its elements, and then fix a specific size. A matrix for which both tasks have been done will be called <em>initialised</em>. You can initialise a matrix in one of two ways:</p>
<ul>
<li>by using the (<em>rows</em>, <em>columns</em>) constructor, which does everything for you;</li>
</ul>
<ul>
<li>by using the default (no-arguments) constructor, then calling <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a>, and then calling one of the initialisation routines <a class="el" href="classregina_1_1LPMatrix.html#ad70b701f86e3abbc6eba098cad8af961" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a6a334363e30727cac7532d48c0d05669" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a>.</li>
</ul>
<p>You may call the initialisation <a class="el" href="classregina_1_1LPMatrix.html#ad70b701f86e3abbc6eba098cad8af961" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> and <a class="el" href="classregina_1_1LPMatrix.html#a6a334363e30727cac7532d48c0d05669" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a> routines more than once (e.g., during a backtracking search), and you may use different matrix sizes each time. However, you may never use more elements than you originally reserved space for.</p>
<p>This matrix is stored in dense form. All elements are of the integer class <em>Integer</em>, which is supplied as a template argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The default constructor for the template class Integer must intialise each new integer to zero. The classes NInteger and <a class="el" href="classregina_1_1NNativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NNativeInteger</a>, for instance, have this property.</dd></dl>
<dl class="section user"><dt>Headers:</dt><dd>Parts of this template class are implemented in a separate header (ntreelp-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aba03c00655c64bebc1ae8937dc9537ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised matrix with no memory storage. </p>
<p>You <em>must</em> call <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> and then either <a class="el" href="classregina_1_1LPMatrix.html#ad70b701f86e3abbc6eba098cad8af961" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a6a334363e30727cac7532d48c0d05669" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a> before this matrix will become initialised. </p>

</div>
</div>
<a class="anchor" id="a7bcff355353b833a1a4efd367d6abf67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero. </p>
<p>This routine reserves space for precisely <em>rows</em> * <em>cols</em> elements. In other words, you may later re-initialise the matrix to become smaller if you like, but you cannot re-initialise the matrix to become larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52478cdada0d0c8eff59ff271f80e5bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::~<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix and all of the data it contains. </p>
<p>You can safely destroy a matrix that is uninitialised or only partially initialised (i.e., space has been reserved but the matrix size is not set). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a710407fbce64f4b891aaab6fb5283c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix. </p>
<p>This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a class="anchor" id="addd9a5fca3701092cf12bfe3e1c8631d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::combRow </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix. </p>
<p>Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) / <em>div</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal. </dd>
<dd>
It is known in advance that every integer in (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) will be divisible by <em>div</em>. In other words, it is known in advance that we can use exact integer division without remainders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">div</td><td>the integer to divide the final row by. This must be non-zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc220b38be89d752cce1d74640c767e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::combRowAndNorm </td>
          <td>(</td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integer &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix, and then normalises. </p>
<p>Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>); then, if row <em>dest</em> is non-zero, it will be normalised by dividing through by the gcd of its elements. Note that this gcd is always taken to be positive (i.e., the final normalisation will never change the signs of the elements in the row).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the positive gcd that row <em>dest</em> was scaled down by, or 0 if row <em>dest</em> is entirely zero. </dd></dl>

</div>
</div>
<a class="anchor" id="af741d99a6a02b11ec99104212f80380b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this matrix to the given output stream. </p>
<p>The output is "rough" and wasteful, and is intended for debugging purposes only. The precise output format is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad90a66cd20b7c286417f776d9de52c28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Integer &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the given element of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#a710407fbce64f4b891aaab6fb5283c69" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa029ce1662ef72298b76e5c9af36d6da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Integer &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only reference to the given element of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#a710407fbce64f4b891aaab6fb5283c69" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad70b701f86e3abbc6eba098cad8af961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::initClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>clone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to a copy of the given matrix. </p>
<p>This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p>You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least clone.rows() * clone.columns() elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clone</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a334363e30727cac7532d48c0d05669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::initIdentity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to the identity matrix of the given size. </p>
<p>This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p>You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least <em>size</em> * <em>size</em> elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows, and also the number of columns, that will be assigned to this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d338d4e3ccb2d80dc0fda890d8c706d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::negateRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all elements in the given row of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row whose elements should be negated. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1f02ccf74fbee3b911dfa5163d87c84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix. </p>
<p>This is just an upper bound: your matrix may end up using fewer elements than this, but it cannot use more.</p>
<p>This matrix will still not be initialised until you call either <a class="el" href="classregina_1_1LPMatrix.html#ad70b701f86e3abbc6eba098cad8af961" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a6a334363e30727cac7532d48c0d05669" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a>. See the class notes for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This matrix was created using the default (no-argument) constructor, and you have not called any other routines on this matrix since.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>To elaborate on the precondition above: you can only call <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> once, and if you did not use the default <a class="el" href="classregina_1_1LPMatrix.html" title="A matrix class for use with linear programming.">LPMatrix</a> constructor then you cannot call it at all. Any additional calls to <a class="el" href="classregina_1_1LPMatrix.html#af1f02ccf74fbee3b911dfa5163d87c84" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> will result in a memory leak.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRows</td><td>an upper bound on the number of rows that you will need for this matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">maxCols</td><td>an upper bound on the number of columns that you will need for this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd7a9578c0eef0f56da70934af07b150"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix. </p>
<p>This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>

</div>
</div>
<a class="anchor" id="a860afdebf19ab1f4ce382448787d7bb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; Integer &gt;::swapRows </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the two given rows of this matrix. </p>
<p>The two arguments <em>r1</em> and <em>r2</em> may be equal (in which case the matrix will be left unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>the index of the first row to swap. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">r2</td><td>the index of the second row to swap. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#acd7a9578c0eef0f56da70934af07b150" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>enumerate/<a class="el" href="ntreeconstraint_8h.html">ntreeconstraint.h</a></li>
<li>enumerate/<a class="el" href="ntreelp_8h.html">ntreelp.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
