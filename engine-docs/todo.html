<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>File <a class="el" href="matrixops_8h.html">matrixops.h</a>  </dt>
<dd><a class="anchor" id="_todo000025"></a><em>Feature (long-term):</em> Add a routine to find the rank of an integer matrix; use this to show the rank of the matching equations.  </dd>
<dt>Class <a class="el" href="classregina_1_1AbelianGroup.html">regina::AbelianGroup</a>  </dt>
<dd><a class="anchor" id="_todo000001"></a><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like.  </dd>
<dt>Class <a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a>  </dt>
<dd><a class="anchor" id="_todo000054"></a><em>Optimise:</em> Insist that sizeof(Piece) is a power of two, and replace expensive division/mod operations with cheap bit operations. </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af37845787a6a80399160c535b9344d08">regina::detail::FacetPairingBase&lt; dim &gt;::findAllPairings</a>  (size_t nSimplices, <a class="el" href="classregina_1_1BoolSet.html" title="A set of booleans.">BoolSet</a> boundary, int nBdryFacets, Use use, void *useArgs=0)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000045"></a><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html#a33569d2db61ab4a22cb8a70441949033">regina::detail::IsomorphismBase&lt; dim &gt;::apply</a>  (const Triangulation&lt; dim &gt; *original) const</dt>
<dd><a class="anchor" id="_todo000046"></a>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied. </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html#a182d11ecefd8675e271db64481fd1a0e">regina::detail::IsomorphismBase&lt; dim &gt;::applyInPlace</a>  (Triangulation&lt; dim &gt; *tri) const</dt>
<dd><a class="anchor" id="_todo000047"></a>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied. </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a13345c67f4c82d9976863c8c5372db5b">regina::detail::TriangulationBase&lt; dim &gt;::barycentricSubdivision</a>  ()</dt>
<dd><a class="anchor" id="_todo000048"></a>Lock the topological properties of the underlying manifold, to avoid recomputing them after the subdivision. However, only do this for <em>valid</em> triangulations (since we can have scenarios where invalid triangulations becoming valid and ideal after subdivision, which may change properties such as Triangulation&lt;4&gt;::knownSimpleLinks).  </dd>
<dt>Member <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af68572c80fc27fc3a069ad01d9615952">regina::detail::TriangulationBase&lt; dim &gt;::isIsomorphicTo</a>  (const Triangulation&lt; dim &gt; &amp;other) const</dt>
<dd><a class="anchor" id="_todo000049"></a><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others. </dd>
<dt>Class <a class="el" href="classregina_1_1DiscSetTet.html">regina::DiscSetTet</a>  </dt>
<dd><a class="anchor" id="_todo000032"></a><em>Bug (long-term):</em> Have some error flag so we can barf politely if the number of normal discs of a given type does not fit into an <code>unsigned long</code>. See how this affects <a class="el" href="classregina_1_1DiscSetTetData.html" title="Stores data of type T for every normal disc inside a single tetrahedron.">DiscSetTetData</a> also.  </dd>
<dt>Member <a class="el" href="group__split.html#ga0cca690bab3b21dc7430fd89ffff3494">regina::formSigCensus</a>  (unsigned order, UseSignature use, void *useArgs=0)</dt>
<dd><a class="anchor" id="_todo000030"></a><em>Feature:</em> Add support for symbols of differing case. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db">regina::GluingPermSearcher&lt; 2 &gt;::runSearch</a>  (long maxDepth=-1)</dt>
<dd><a class="anchor" id="_todo000013"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html#a5e4d7126bf7096e21c92134b59698aea">regina::GluingPermSearcher&lt; 3 &gt;::runSearch</a>  (long maxDepth=-1)</dt>
<dd><a class="anchor" id="_todo000014"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Member <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html#a3a33270bfb8b3c36aecaa3cc65422b37">regina::GluingPermSearcher&lt; 4 &gt;::runSearch</a>  (long maxDepth=-1)</dt>
<dd><a class="anchor" id="_todo000015"></a><em>Feature:</em> Allow cancellation of permutation set generation. </dd>
<dt>Class <a class="el" href="classregina_1_1GraphLoop.html">regina::GraphLoop</a>  </dt>
<dd><a class="anchor" id="_todo000020"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix.  </dd>
<dt>Class <a class="el" href="classregina_1_1GraphPair.html">regina::GraphPair</a>  </dt>
<dd><a class="anchor" id="_todo000021"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix.  </dd>
<dt>Class <a class="el" href="classregina_1_1GraphTriple.html">regina::GraphTriple</a>  </dt>
<dd><a class="anchor" id="_todo000022"></a><em>Optimise:</em> Speed up homology calculations involving orientable base spaces by adding rank afterwards, instead of adding generators for genus into the presentation matrix.  </dd>
<dt>Member <a class="el" href="classregina_1_1GroupExpression.html#a1d02f0fa24e3d333ce3bcfb4e6acee1a">regina::GroupExpression::relabellingsThisToOther</a>  (const <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> &amp;other, bool cyclic=false) const</dt>
<dd><a class="anchor" id="_todo000003"></a>Change this to use less heavyweight types and less deep copying. </dd>
<dt>Class <a class="el" href="classregina_1_1GroupPresentation.html">regina::GroupPresentation</a>  </dt>
<dd><a class="anchor" id="_todo000002"></a>Let's make intelligent simplify a tad more intelligent, and the GUI call a bit more safe. Perhaps parallelize the GUI call, and give users parameters to ensure it won't crash the computer. Also look at the FPGroup package. We should also have a simple way of creating <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> objects directly from text strings. We would like to have something like <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>( numGens, "abAAB", "bccd" ) etc., with arbitrary numbers of relators. Maybe std::tuple. Or "variadic templates"?  </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#ab33c241cd3b0f6bd18e64217cbcd56ae">regina::GroupPresentation::prettyRewritingDetail</a>  ()</dt>
<dd><a class="anchor" id="_todo000006"></a>As a final step, make elementary simplifications to aid in seeing standard relators like commutators. </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#a6dd5465442f764dcca7c9f83683144ff">regina::GroupPresentation::recogniseGroup</a>  (bool moreUtf8=false) const</dt>
<dd><a class="anchor" id="_todo000005"></a><em>Feature (long-term):</em> Make this recognition more effective. </dd>
<dt>Member <a class="el" href="classregina_1_1GroupPresentation.html#af5e18bdc3cc36fee22e8b3fd3a6d7572">regina::GroupPresentation::smallCancellationDetail</a>  ()</dt>
<dd><a class="anchor" id="_todo000004"></a><em>Optimise (long-term):</em> This routine could use some small tweaks - recognition of utility of some score==0 moves, such as commutators, for example. </dd>
<dt>Class <a class="el" href="classregina_1_1HomGroupPresentation.html">regina::HomGroupPresentation</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Add a routine to attempt to verify validity of homomorphism.  </dd>
<dt>Class <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">regina::HomMarkedAbelianGroup</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000009"></a><em>Optimise (long-term):</em> preImageOf in CC and SNF coordinates. This routine would return a generating list of elements in the preimage, thought of as an affine subspace. Or maybe just one element together with the kernel inclusion. IMO smarter to be a list because that way there's a more pleasant way to make it empty. Or we could have a variety of routines among these themes. Store some minimal data for efficient computations of preImage, eventually replacing the internals of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5d3cc3f63fa92d4ee7e2aca0eeb6584b" title="Returns the inverse to a HomMarkedAbelianGroup.">inverseHom()</a> with a more flexible set of tools. Also add an isInImage() in various coordinates.</p>
<p class="interdd"><a class="anchor" id="_todo000010"></a><em>Optimise (long-term):</em> <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2779b4feadb621b496a2ec8e6f8eadc4" title="Short text representation.">writeTextShort()</a> have completely different set of descriptors if an endomorphism domain = range (not so important at the moment though). New descriptors would include things like automorphism, projection, differential, finite order, etc.</p>
<p class="enddd"><a class="anchor" id="_todo000011"></a><em>Optimise (long-term):</em> Add map factorization, so that every homomorphism can be split as a composite of a projection followed by an inclusion. Add kernelInclusion(), coKerMap(), etc. Add a liftMap() call, i.e., a procedure to find a lift of a map if one exists. </p>
</dd>
<dt>Class <a class="el" href="classregina_1_1MarkedAbelianGroup.html">regina::MarkedAbelianGroup</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000008"></a><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like. </p>
<p class="enddd">Testsuite additions: <a class="el" href="classregina_1_1MarkedAbelianGroup.html#aa8266305f2c94b9f7c7880715eba189e" title="Given a vector, determines if it represents a boundary in the chain complex.">isBoundary()</a>, <a class="el" href="classregina_1_1MarkedAbelianGroup.html#abf8c72fcfbf384f9c72742f7fc024f70" title="Computes the differential of the given vector in the chain complex whose kernel is the cycles.">boundaryMap()</a>, writeAsBdry(), <a class="el" href="classregina_1_1MarkedAbelianGroup.html#af38ec35918dfa4fb844982feac3fff28" title="Returns the ith generator of the cycles, i.e., the kernel of M in the chain complex.">cycleGen()</a>.  </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1NormalHypersurface.html#a8126f6c44dc69ca6e66fd6045313bd7b">regina::NormalHypersurface::isThinEdgeLink</a>  () const</dt>
<dd><a class="anchor" id="_todo000018"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalHypersurface.html#a54e8a721415302c5101e5064db14b153">regina::NormalHypersurface::isVertexLink</a>  () const</dt>
<dd><a class="anchor" id="_todo000017"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalHypersurface.html#a842ced3478b08bde5ad883ef77724420">regina::NormalHypersurface::isVertexLinking</a>  () const</dt>
<dd><a class="anchor" id="_todo000016"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalHypersurface.html#a10612a9cb4e27aa9162b2c8e05d082fa">regina::NormalHypersurface::triangulate</a>  () const</dt>
<dd><a class="anchor" id="_todo000019"></a><em>Bug:</em> Check for absurdly large numbers of pieces and return 0 accordingly. </dd>
<dt>Class <a class="el" href="classregina_1_1NormalSurface.html">regina::NormalSurface</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000034"></a><em>Feature:</em> Calculation of Euler characteristic and orientability for non-compact surfaces. </p>
<p class="enddd"><em>Feature (long-term):</em> Determine which faces in the solution space a normal surface belongs to.  </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#a189f95fd5f3a632adb38a0fc6139cd81">regina::NormalSurface::isCentral</a>  () const</dt>
<dd><a class="anchor" id="_todo000039"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#a793261174b6628c83659b523b84ab943">regina::NormalSurface::isCompressingDisc</a>  (bool knownConnected=false) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000040"></a><em>Optimise:</em> Reimplement this to avoid cutting along surfaces. </p>
<p class="enddd"><em>Bug:</em> Check for absurdly large numbers of discs and bail accordingly. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#a330f08b68053b89d2545c0027bbc3405">regina::NormalSurface::isSplitting</a>  () const</dt>
<dd><a class="anchor" id="_todo000038"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#ab82721dfe41b187548593091b7274e6e">regina::NormalSurface::isThinEdgeLink</a>  () const</dt>
<dd><a class="anchor" id="_todo000037"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#af98616d2b0b270a6a427133d3cd88cae">regina::NormalSurface::isVertexLink</a>  () const</dt>
<dd><a class="anchor" id="_todo000036"></a><em>Optimise:</em> Cache results. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurface.html#a8ab8b0a34b4c8a0847aba54974f1c009">regina::NormalSurface::isVertexLinking</a>  () const</dt>
<dd><a class="anchor" id="_todo000035"></a><em>Optimise:</em> Cache results. </dd>
<dt>Class <a class="el" href="classregina_1_1NormalSurfaces.html">regina::NormalSurfaces</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000041"></a><em>Feature:</em> Allow custom matching equations. </p>
<p class="interdd"><em>Feature:</em> Allow enumeration with some coordinates explicitly set to zero. </p>
<p class="interdd"><em>Feature:</em> Allow generating only closed surfaces. </p>
<p class="enddd"><em>Feature:</em> Generate facets of the solution space representing embedded surfaces.  </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurfaces.html#a9324d55752c936e253e9c36cce704908">regina::NormalSurfaces::filterForDisjointPairs</a>  () const</dt>
<dd><a class="anchor" id="_todo000042"></a>Deal properly with surfaces that are too large to handle. </dd>
<dt>Member <a class="el" href="classregina_1_1NormalSurfaces.html#a7ed23bbdd0688519b1eb4a3077cec118">regina::NormalSurfaces::filterForPotentiallyIncompressible</a>  () const</dt>
<dd><a class="anchor" id="_todo000043"></a>Add progress tracking. </dd>
<dt>Class <a class="el" href="classregina_1_1NormalSurfaceVector.html">regina::NormalSurfaceVector</a>  </dt>
<dd><a class="anchor" id="_todo000033"></a><em>Optimise (long-term):</em> Investigate using sparse vectors for storage. </dd>
<dt>Class <a class="el" href="classregina_1_1Packet.html">regina::Packet</a>  </dt>
<dd><a class="anchor" id="_todo000029"></a><em>Feature:</em> Provide automatic name selection/specification upon child packet insertion.  </dd>
<dt>Member <a class="el" href="classregina_1_1Primes.html#a1111cae9b6ad1011023a7387e656bd29">regina::Primes::primeDecomp</a>  (const Integer &amp;n)</dt>
<dd><a class="anchor" id="_todo000026"></a><em>Optimise:</em> Add a version that does not return the factors by value. </dd>
<dt>Member <a class="el" href="classregina_1_1Primes.html#a3ed87b5c7e132010b772c40819f051ac">regina::Primes::primePowerDecomp</a>  (const Integer &amp;n)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000027"></a><em>Optimise:</em> Implement this routine natively to avoid the overhead of the temporary <a class="el" href="classregina_1_1Primes.html#a1111cae9b6ad1011023a7387e656bd29" title="Returns the prime factorisation of the given integer as a list of individual primes (or suspected pri...">primeDecomp()</a> vector.</p>
<p class="enddd"><a class="anchor" id="_todo000028"></a><em>Optimise:</em> Add a version that does not return the factors by value. </p>
</dd>
<dt>Class <a class="el" href="classregina_1_1SatRegion.html">regina::SatRegion</a>  </dt>
<dd><a class="anchor" id="_todo000031"></a><em>Feature:</em> Have this class track the boundary components properly, with annuli grouped and oriented according to the region boundaries (as opposed to individual block boundaries).  </dd>
<dt>Class <a class="el" href="classregina_1_1SFSpace.html">regina::SFSpace</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000023"></a><em>Feature (long-term):</em> Implement recognition of more common names. </p>
<p class="enddd"><em>Feature (long-term):</em> Implement triangulation construction and homology calculation for more Seifert fibred spaces.  </p>
</dd>
<dt>Class <a class="el" href="classregina_1_1SurfaceFilter.html">regina::SurfaceFilter</a>  </dt>
<dd><a class="anchor" id="_todo000044"></a><em>Feature:</em> Implement property <em>lastAppliedTo</em>.  </dd>
<dt>Class <a class="el" href="classregina_1_1TorusBundle.html">regina::TorusBundle</a>  </dt>
<dd><a class="anchor" id="_todo000024"></a><em>Feature:</em> Implement the == operator for finding conjugate and inverse matrices.  </dd>
<dt>Class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html">regina::Triangulation&lt; 3 &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000050"></a><em>Feature:</em> Is the boundary incompressible? </p>
<p class="interdd"><em>Feature (long-term):</em> Am I obviously a handlebody? (Simplify and see if there is nothing left). Am I obviously not a handlebody? (Compare homology with boundary homology). </p>
<p class="interdd"><em>Feature (long-term):</em> Is the triangulation Haken? </p>
<p class="interdd"><em>Feature (long-term):</em> What is the Heegaard genus? </p>
<p class="interdd"><em>Feature (long-term):</em> Have a subcomplex as a child packet of a triangulation. Include routines to crush a subcomplex or to expand a subcomplex to a normal surface. </p>
<p class="enddd"><em>Feature (long-term):</em> Implement <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0e3c9276224681ca932912e989485266" title="Writes a detailed text representation of this object to the given output stream.">writeTextLong()</a> for skeletal objects. </p>
</dd>
<dt>Member <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ac025b93b99f5b674fd448e6374c81142">regina::Triangulation&lt; 3 &gt;::idealToFinite</a>  ()</dt>
<dd><a class="anchor" id="_todo000053"></a><em>Optimise (long-term):</em> Have this routine only use as many tetrahedra as are necessary, leaving finite vertices alone. </dd>
<dt>Member <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e">regina::Triangulation&lt; 3 &gt;::intelligentSimplify</a>  ()</dt>
<dd><a class="anchor" id="_todo000051"></a><em>Optimise:</em> Include random 2-3 moves to get out of wells. </dd>
<dt>Member <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a91bc0ba8cbb3ecef1fbbe71c05b9d067">regina::Triangulation&lt; 3 &gt;::makeZeroEfficient</a>  ()</dt>
<dd><a class="anchor" id="_todo000052"></a>Preserve computed properties of the underlying manifold.</dd>
</dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
