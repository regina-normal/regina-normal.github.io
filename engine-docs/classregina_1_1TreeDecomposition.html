<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::TreeDecomposition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1TreeDecomposition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::TreeDecomposition Class Reference<div class="ingroups"><a class="el" href="group__treewidth.html">Treewidth</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a tree decomposition of a graph.  
 <a href="classregina_1_1TreeDecomposition.html#details">More...</a></p>

<p><code>#include &lt;treewidth/treedecomposition.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TreeDecomposition:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TreeDecomposition.png" usemap="#regina::TreeDecomposition_map" alt=""/>
  <map id="regina::TreeDecomposition_map" name="regina::TreeDecomposition_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; TreeDecomposition &gt;" shape="rect" coords="0,0,223,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a graph, which may be directed or undirected.  <a href="structregina_1_1TreeDecomposition_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a745ee1c4dc79074104a7a013756514a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a745ee1c4dc79074104a7a013756514a6">TreeDecomposition</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a745ee1c4dc79074104a7a013756514a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new copy of the given tree decomposition.  <a href="#a745ee1c4dc79074104a7a013756514a6">More...</a><br /></td></tr>
<tr class="separator:a745ee1c4dc79074104a7a013756514a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a9260954f8e9341c6a25f7610ab8863f8">TreeDecomposition</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a9260954f8e9341c6a25f7610ab8863f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the facet pairing graph of the given triangulation.  <a href="#a9260954f8e9341c6a25f7610ab8863f8">More...</a><br /></td></tr>
<tr class="separator:a9260954f8e9341c6a25f7610ab8863f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a6b22a38314cfa157c7df66ebcc084ffc">TreeDecomposition</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;pairing, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a6b22a38314cfa157c7df66ebcc084ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the given facet pairing graph.  <a href="#a6b22a38314cfa157c7df66ebcc084ffc">More...</a><br /></td></tr>
<tr class="separator:a6b22a38314cfa157c7df66ebcc084ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19321d5f8b29246685ea6b10b9c0298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#ab19321d5f8b29246685ea6b10b9c0298">TreeDecomposition</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ab19321d5f8b29246685ea6b10b9c0298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram.  <a href="#ab19321d5f8b29246685ea6b10b9c0298">More...</a><br /></td></tr>
<tr class="separator:ab19321d5f8b29246685ea6b10b9c0298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2479571bf607d3c08af59bfbae3f754d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2479571bf607d3c08af59bfbae3f754d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a2479571bf607d3c08af59bfbae3f754d">TreeDecomposition</a> (unsigned order, T const **const graph, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a2479571bf607d3c08af59bfbae3f754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of an arbitrary graph.  <a href="#a2479571bf607d3c08af59bfbae3f754d">More...</a><br /></td></tr>
<tr class="separator:a2479571bf607d3c08af59bfbae3f754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbb52e2966ddb006c8f9964e009e2ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a7dbb52e2966ddb006c8f9964e009e2ee">~TreeDecomposition</a> ()</td></tr>
<tr class="memdesc:a7dbb52e2966ddb006c8f9964e009e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tree decomposition and all of its bags.  <a href="#a7dbb52e2966ddb006c8f9964e009e2ee">More...</a><br /></td></tr>
<tr class="separator:a7dbb52e2966ddb006c8f9964e009e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13250fbe35fec8ea038fbbcc628361c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a13250fbe35fec8ea038fbbcc628361c5">width</a> () const</td></tr>
<tr class="memdesc:a13250fbe35fec8ea038fbbcc628361c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the width of this tree decomposition.  <a href="#a13250fbe35fec8ea038fbbcc628361c5">More...</a><br /></td></tr>
<tr class="separator:a13250fbe35fec8ea038fbbcc628361c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805e5fed5d765d73a06cf7bce26b256b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b">size</a> () const</td></tr>
<tr class="memdesc:a805e5fed5d765d73a06cf7bce26b256b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bags in this tree decomposition.  <a href="#a805e5fed5d765d73a06cf7bce26b256b">More...</a><br /></td></tr>
<tr class="separator:a805e5fed5d765d73a06cf7bce26b256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">root</a> () const</td></tr>
<tr class="memdesc:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bag at the root of the underlying tree.  <a href="#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">More...</a><br /></td></tr>
<tr class="separator:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834587b768678b90ff8591725092ab1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a0834587b768678b90ff8591725092ab1">first</a> () const</td></tr>
<tr class="memdesc:a0834587b768678b90ff8591725092ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a postfix iteration through all of the bags in the tree decomposition.  <a href="#a0834587b768678b90ff8591725092ab1">More...</a><br /></td></tr>
<tr class="separator:a0834587b768678b90ff8591725092ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c06b040c85b2bbda234ef7601bc6676"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a7c06b040c85b2bbda234ef7601bc6676">firstPrefix</a> () const</td></tr>
<tr class="memdesc:a7c06b040c85b2bbda234ef7601bc6676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a prefix iteration through all of the bags in the tree decomposition.  <a href="#a7c06b040c85b2bbda234ef7601bc6676">More...</a><br /></td></tr>
<tr class="separator:a7c06b040c85b2bbda234ef7601bc6676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896b10ec6ce8f390e304b4c525925f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a896b10ec6ce8f390e304b4c525925f54">bag</a> (int index) const</td></tr>
<tr class="memdesc:a896b10ec6ce8f390e304b4c525925f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slow (linear-time) routine that returns the bag at the given index.  <a href="#a896b10ec6ce8f390e304b4c525925f54">More...</a><br /></td></tr>
<tr class="separator:a896b10ec6ce8f390e304b4c525925f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf631d4dcefa2e7f025c727ffa313a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#abaf631d4dcefa2e7f025c727ffa313a6">compress</a> ()</td></tr>
<tr class="memdesc:abaf631d4dcefa2e7f025c727ffa313a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant bags from this tree decomposition.  <a href="#abaf631d4dcefa2e7f025c727ffa313a6">More...</a><br /></td></tr>
<tr class="separator:abaf631d4dcefa2e7f025c727ffa313a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c14882c657a38208732e025be562bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#ae0c14882c657a38208732e025be562bc">makeNice</a> (int *heightHint=nullptr)</td></tr>
<tr class="memdesc:ae0c14882c657a38208732e025be562bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a nice tree decomposition.  <a href="#ae0c14882c657a38208732e025be562bc">More...</a><br /></td></tr>
<tr class="separator:ae0c14882c657a38208732e025be562bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa9c488e166bd52474a17abc374eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a8aaa9c488e166bd52474a17abc374eef">reroot</a> (<a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *newRoot)</td></tr>
<tr class="memdesc:a8aaa9c488e166bd52474a17abc374eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition.  <a href="#a8aaa9c488e166bd52474a17abc374eef">More...</a><br /></td></tr>
<tr class="separator:a8aaa9c488e166bd52474a17abc374eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af484fcab0b6693f5ad95c367007685f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af484fcab0b6693f5ad95c367007685f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#af484fcab0b6693f5ad95c367007685f3">reroot</a> (const T *costSame, const T *costReverse, const T *costRoot=nullptr)</td></tr>
<tr class="memdesc:af484fcab0b6693f5ad95c367007685f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags.  <a href="#af484fcab0b6693f5ad95c367007685f3">More...</a><br /></td></tr>
<tr class="separator:af484fcab0b6693f5ad95c367007685f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2518695c74624d2e1a536ab88577e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a2c2518695c74624d2e1a536ab88577e6">writeDot</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2c2518695c74624d2e1a536ab88577e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition in the Graphviz DOT language.  <a href="#a2c2518695c74624d2e1a536ab88577e6">More...</a><br /></td></tr>
<tr class="separator:a2c2518695c74624d2e1a536ab88577e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#af3e2c680f3e8dc9ad87a9b74c94b9b37">dot</a> () const</td></tr>
<tr class="memdesc:af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of this tree decomposition.  <a href="#af3e2c680f3e8dc9ad87a9b74c94b9b37">More...</a><br /></td></tr>
<tr class="separator:af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2668cd1871a2d62c7dca27c8540fca91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a2668cd1871a2d62c7dca27c8540fca91">writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2668cd1871a2d62c7dca27c8540fca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition using the PACE text format.  <a href="#a2668cd1871a2d62c7dca27c8540fca91">More...</a><br /></td></tr>
<tr class="separator:a2668cd1871a2d62c7dca27c8540fca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a0dabce1a3f084a041e1dd15c9a5cdb61">pace</a> () const</td></tr>
<tr class="memdesc:a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of this tree decomposition using the PACE text format.  <a href="#a0dabce1a3f084a041e1dd15c9a5cdb61">More...</a><br /></td></tr>
<tr class="separator:a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d6d08edc8c5224ba9f0033d49bedce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#af5d6d08edc8c5224ba9f0033d49bedce">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af5d6d08edc8c5224ba9f0033d49bedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#af5d6d08edc8c5224ba9f0033d49bedce">More...</a><br /></td></tr>
<tr class="separator:af5d6d08edc8c5224ba9f0033d49bedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2391ff92b92cd58806107fd640be74b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#ad2391ff92b92cd58806107fd640be74b">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad2391ff92b92cd58806107fd640be74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#ad2391ff92b92cd58806107fd640be74b">More...</a><br /></td></tr>
<tr class="separator:ad2391ff92b92cd58806107fd640be74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9511f6eac30596d16296772524a142f6"><td class="memItemLeft" align="right" valign="top"><a id="a9511f6eac30596d16296772524a142f6"></a>
<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;)=delete</td></tr>
<tr class="separator:a9511f6eac30596d16296772524a142f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeaa9effe91aa0076f60d92369d188280"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#aeaa9effe91aa0076f60d92369d188280">fromPACE</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:aeaa9effe91aa0076f60d92369d188280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from a string using the PACE text format.  <a href="#aeaa9effe91aa0076f60d92369d188280">More...</a><br /></td></tr>
<tr class="separator:aeaa9effe91aa0076f60d92369d188280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d359314fe0cc858e479626c5956fa99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html#a4d359314fe0cc858e479626c5956fa99">fromPACE</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a4d359314fe0cc858e479626c5956fa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from an input stream using the PACE text format.  <a href="#a4d359314fe0cc858e479626c5956fa99">More...</a><br /></td></tr>
<tr class="separator:a4d359314fe0cc858e479626c5956fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a tree decomposition of a graph. </p>
<p>Whilst this class can be used to build tree decompositions of arbitrary graphs, it also offers a simple interface for building a tree decomposition of the facet pairing graph of a given triangulation. This is an important step in the implementation of fixed-parameter tractable algorithms on triangulated manifolds.</p>
<p>Given a graph <em>G</em>, a tree decomposition of <em>G</em> consists of (i) an underlying tree <em>T</em>; and (ii) a <em>bag</em> at every node of this tree. Each bag is a set of zero or more nodes of <em>G</em>, and these bags are subject to the following constraints:</p>
<ul>
<li>Every node of <em>G</em> belongs to some bag;</li>
<li>Every arc of <em>G</em> has both its endpoints in some common bag;</li>
<li>For every node <em>v</em> of <em>G</em>, the set of <em>all</em> bags containing <em>v</em> forms a (connected) subtree of <em>T</em>.</li>
</ul>
<p>In Regina, the underlying tree <em>T</em> is a rooted tree, so that every non-root bag has exactly one parent bag, and every bag has some number of children (possibly many, possibly zero).</p>
<p>Tree decompositions are generally considered "better" if their bags are smaller (i.e., contain fewer nodes of <em>G</em>). To this end, the <em>width</em> of a tree decomposition is one less than its largest bag size, and the <em>treewidth</em> of <em>G</em> is the minimum width over all tree decompositions of <em>G</em>.</p>
<p>A tree decomposition is described by a single <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> object, and the class <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a> is used to represent each individual bag.</p>
<ul>
<li>You can build a tree decomposition using the various <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> constructors, and manipulate it using member functions such as <a class="el" href="classregina_1_1TreeDecomposition.html#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> and <a class="el" href="classregina_1_1TreeDecomposition.html#ae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">makeNice()</a>.</li>
<li>To iterate through the bags of the tree decomposition, you can use <a class="el" href="classregina_1_1TreeDecomposition.html#a0834587b768678b90ff8591725092ab1" title="Used for a postfix iteration through all of the bags in the tree decomposition.">TreeDecomposition::first()</a> and <a class="el" href="classregina_1_1TreeBag.html#a1db4d57e569e5abb95e4e5b3c8626909" title="Used for a postfix iteration through all of the bags in a tree decomposition.">TreeBag::next()</a> (for a postfix iteration), or you can use <a class="el" href="classregina_1_1TreeDecomposition.html#a7c06b040c85b2bbda234ef7601bc6676" title="Used for a prefix iteration through all of the bags in the tree decomposition.">TreeDecomposition::firstPrefix()</a> and <a class="el" href="classregina_1_1TreeBag.html#a96126a0728a24e10aedaedfc7dbee139" title="Used for a prefix iteration through all of the bags in a tree decomposition.">TreeBag::nextPrefix()</a> (for a prefix iteration).</li>
</ul>
<p>The bags themselves are stored as sets of integers: it is assumed that the nodes of <em>G</em> are numbered 0,1,2,..., and so the bags simply store the numbers of the nodes that they contain.</p>
<p>This class also numbers its bags 0,1,...,<a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1 in a leaves-to-root, left-to-right manner:</p>
<ul>
<li>for each non-root bag <em>b</em>, the parent of <em>b</em> will have a higher index than <em>b</em>;</li>
<li>for each bag <em>b</em> with a next sibling, the next sibling of <em>b</em> will have a higher index than <em>b</em>.</li>
</ul>
<p>This bag numbering may be useful if you wish to store auxiliary information alongside each bag in a separate array. You can access this numbering through the function <a class="el" href="classregina_1_1TreeBag.html#aa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>. However, note that <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> does <em>not</em> store its bags in an array, and so the "random access" function <a class="el" href="classregina_1_1TreeDecomposition.html#a896b10ec6ce8f390e304b4c525925f54" title="A slow (linear-time) routine that returns the bag at the given index.">bag()</a> is slow, with worst-case linear time.</p>
<p>There are two broad classes of algorithms for building tree decompositions: (i) <em>exact</em> algorithms, which are slow but guarantee to find a tree decomposition of the smallest possible width; and (ii) <em>greedy</em> algorithms, which are fast and which aim to keep the width small but which do not promise minimality. Currently Regina only offers greedy algorithms, though this may change in a future release. See the TreeDecompositionAlg enumeration for a list of all algorithms that are currently available.</p>
<p>Note that individual bags are allowed to be empty. Moreover, if the underlying graph <em>G</em> is empty then the tree decomposition may contain no bags at all. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a745ee1c4dc79074104a7a013756514a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745ee1c4dc79074104a7a013756514a6">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a new copy of the given tree decomposition. </p>
<p>This will be a deep copy, in the sense that all of the bags of <em>cloneMe</em> will be cloned also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the tree decomposition to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9260954f8e9341c6a25f7610ab8863f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9260954f8e9341c6a25f7610ab8863f8">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the facet pairing graph of the given triangulation. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation whose facet pairing graph we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b22a38314cfa157c7df66ebcc084ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b22a38314cfa157c7df66ebcc084ffc">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the given facet pairing graph. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the facet pairing graph that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19321d5f8b29246685ea6b10b9c0298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19321d5f8b29246685ea6b10b9c0298">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram. </p>
<p>The nodes of the graph will be numbered in the same way as the crossings of the given knot / link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the knot or link that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2479571bf607d3c08af59bfbae3f754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2479571bf607d3c08af59bfbae3f754d">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const **const&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of an arbitrary graph. </p>
<p>The graph may be directed or undirected.</p>
<p>The graph is specified by an adjacency matrix. The matrix may contain any data type (this is the template argument <em>T</em>). However, the contents of this matrix will be interpreted as booleans: an arc runs from node <em>i</em> to node <em>j</em> if and only if <em>graph</em>[i][j] is <code>true</code> when interpreted as a boolean.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. Regina's calculation engine already includes explicit instantiations for types <code>bool</code> and <code>int</code>, but for other types you will need to include treedecomposition-impl.h along with this header.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>order</em> is not present (it will be deduced automatically from <em>graph</em>). The adjacency matrix should be given as a list of lists. There is no need to use the same data type <em>T</em> throughout: each element of the matrix will be individually interpreted as a boolean as described above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the number of nodes in the graph. </td></tr>
    <tr><td class="paramname">graph</td><td>the adjacency matrix of the graph. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dbb52e2966ddb006c8f9964e009e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbb52e2966ddb006c8f9964e009e2ee">&#9670;&nbsp;</a></span>~TreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::~TreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tree decomposition and all of its bags. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a896b10ec6ce8f390e304b4c525925f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896b10ec6ce8f390e304b4c525925f54">&#9670;&nbsp;</a></span>bag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeDecomposition::bag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A slow (linear-time) routine that returns the bag at the given index. </p>
<p>Recall that the bags in a tree decomposition are numbered 0,1,...,<a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1. This routine returns the bag with the given number.</p>
<p>This routine is linear-time, and so you should <em>not</em> use it to iterate through all bags. Instead, to iterate through all bags, use <a class="el" href="classregina_1_1TreeDecomposition.html#a0834587b768678b90ff8591725092ab1" title="Used for a postfix iteration through all of the bags in the tree decomposition.">TreeDecomposition::first()</a> and <a class="el" href="classregina_1_1TreeBag.html#a1db4d57e569e5abb95e4e5b3c8626909" title="Used for a postfix iteration through all of the bags in a tree decomposition.">TreeBag::next()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>slow</em>, with a worst-case linear time. This is because the bags are not stored internally in an array, and so this routine must search the tree from the root downwards to find the bag that is being requested.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the number of a bag; this must be between 0 and <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bag with the given number. </dd></dl>

</div>
</div>
<a id="abaf631d4dcefa2e7f025c727ffa313a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf631d4dcefa2e7f025c727ffa313a6">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeDecomposition::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes redundant bags from this tree decomposition. </p>
<p>Specifically, this routine "compresses" the tree decomposition as follows: whenever two bags are adjacent in the underlying tree and one is a subset of the other, these bags will be merged.</p>
<p>Note that some <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a> objects may be destroyed (thereby invalidating pointers or references to them), and for those bags that are not destroyed, their indices (as returned by <a class="el" href="classregina_1_1TreeBag.html#aa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>) may change.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the tree decomposition was changed. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="af3e2c680f3e8dc9ad87a9b74c94b9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e2c680f3e8dc9ad87a9b74c94b9b37">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::dot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of this tree decomposition. </p>
<p>This routine simply returns the output of <a class="el" href="classregina_1_1TreeDecomposition.html#a2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p>See the <a class="el" href="classregina_1_1TreeDecomposition.html#a2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1TreeDecomposition.html#a2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="a0834587b768678b90ff8591725092ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0834587b768678b90ff8591725092ab1">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeDecomposition::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for a postfix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>postfix</em> iteration is one in which all of the children of any bag <em>b</em> will be processed before <em>b</em> itself.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full postfix iteration of bags as follows:</p>
<ul>
<li>the first bag in a postfix iteration is <code>d.first()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.next()</code>;</li>
<li>the iteration terminates when <code>b.next()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>This postfix iteration is equivalent to iterating through bags numbered 0,1,2,...; that is, following the order of <a class="el" href="classregina_1_1TreeBag.html#aa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a postfix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="a7c06b040c85b2bbda234ef7601bc6676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c06b040c85b2bbda234ef7601bc6676">&#9670;&nbsp;</a></span>firstPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::firstPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for a prefix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>prefix</em> iteration is one in which each bag will be processed before any of its children.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full prefix iteration of bags as follows:</p>
<ul>
<li>the first bag in a prefix iteration is <code>d.firstPrefix()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.nextPrefix()</code>;</li>
<li>the iteration terminates when <code>b.nextPrefix()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>Since the first bag in a prefix iteration must be the root bag, this function is identical to calling <a class="el" href="classregina_1_1TreeDecomposition.html#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac" title="Returns the bag at the root of the underlying tree.">root()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a prefix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="aeaa9effe91aa0076f60d92369d188280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa9effe91aa0076f60d92369d188280">&#9670;&nbsp;</a></span>fromPACE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>* regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from a string using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>In short, the format contains a number of lines of text:</p>
<ul>
<li>Any line beginning with <code>c</code> is considered a comment, and will be ignored.</li>
<li>The first non-comment line should be of the form <code>s&#160;td&#160;<em>num_bags</em>&#160;<em>max_bag_size</em>&#160;<em>num_vertices</em></code>.</li>
<li>The next <em>num_bags</em> non-comment lines should describe the contents of the bags. Each such line should be of the form <code>b&#160;<em>bag_number</em>&#160;<em>element</em>&#160;<em>element</em>&#160;...</code>. The bags are numbered 1,2,...,<em>num_bags</em>, and may appear in any order. Likewise, the vertices of the graph are numbered 1,2,...,<em>num_vertices</em>, and within each bag they may again appear in any order.</li>
<li>The remaining <em>num_bags</em> - 1 non-comment lines should indicate the connections between the bags in the tree decomposition. Each such line should be of the form <code><em>first_bag_index</em>&#160;<em>second_bag_index</em></code>, where <em>first_bag_index</em> is smaller than <em>second_bag_index</em>.</li>
</ul>
<p>Bags may be empty, but there must be at least one bag, and the connections between the bags must form a tree. This routine will choose the root of the tree arbitrarily.</p>
<p>An example of this text format is as follows:</p>
<pre class="fragment">c A tree decomposition with 4 bags and width 2
s td 4 3 5
b 1 1 2 3
b 2 2 3 4
b 3 3 4 5
b 4
1 2
2 3
2 4
</pre><p>This routine does some basic error checking as it reads the input, but this checking is not exhaustive; in particular, it does not verify that the connections between bags actually form a tree.</p>
<p>There are two variants of this routine. This variant contains a single string containing the entire text representation. The other variant takes an input stream, from which the text representation will be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tree decomposition, or <code>null</code> if the input was found to be invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a4d359314fe0cc858e479626c5956fa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d359314fe0cc858e479626c5956fa99">&#9670;&nbsp;</a></span>fromPACE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>* regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from an input stream using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>See the constructor TreeDecomposition(const std::string&amp;) for a description of this text format.</p>
<p>There are two variants of this routine. The other variant contains a single string containing the entire text representation. This variant takes an input stream, from which the text representation will be read.</p>
<p>This routine assumes that it should exhaust the input stream (i.e., it should contain no additional text after this text representation).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that provides a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tree decomposition, or <code>null</code> if the input was found to be invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ae0c14882c657a38208732e025be562bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c14882c657a38208732e025be562bc">&#9670;&nbsp;</a></span>makeNice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::makeNice </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>heightHint</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a nice tree decomposition. </p>
<p>A <em>nice</em> tree decomposition is one in which every bag is one of the following types:</p>
<ul>
<li>an <em>introduce</em> bag, which has only one child bag, and which contains all of the nodes in this child bag plus exactly one new node (and nothing else);</li>
<li>a <em>forget</em> bag, which has only one child bag, and which contains all of the nodes in this child bag except for exactly one missing node (and nothing else);</li>
<li>a <em>join</em> bag, which has exactly two child bags, and where each child bag contains exactly the same nodes as the join bag itself.</li>
</ul>
<p>As a special case, each leaf bag (which has no child bags at all) is also considered to be an introduce bag, and will contain exactly one node.</p>
<p>This routine will also ensure that the root bag is a forget bag, containing no nodes at all.</p>
<p>This routine will set <a class="el" href="classregina_1_1TreeBag.html#abe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> and <a class="el" href="classregina_1_1TreeBag.html#ad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> for each bag as follows:</p>
<ul>
<li><a class="el" href="classregina_1_1TreeBag.html#abe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> will be one of the constants from the NiceType enumeration, indicating whether the bag is an introduce, forget or join bag.</li>
<li>For an introduce bag <em>b</em>, <a class="el" href="classregina_1_1TreeBag.html#ad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "new" node was introduced. Specifically, the new node will be <code>b.element(b.subtype())</code>.</li>
<li>For a forget bag <em>b</em>, <a class="el" href="classregina_1_1TreeBag.html#ad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "missing" node was forgotten. Specifically, the missing node will be <code>b.children()-&gt;element(b.subtype())</code>.</li>
<li>For a join bag, <a class="el" href="classregina_1_1TreeBag.html#ad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will be undefined.</li>
</ul>
<p>If the underlying graph is empty, then this routine will produce a tree decomposition with no bags at all.</p>
<p>You may optionally pass an argument <em>heightHint</em>, which is an array indicating how close to the root of the tree you would like each node to be. At present, this only affects the final chain of forget bags leading up to the root bag - if <em>heightHint</em> is passed, then this chain will be ordered so that nodes with a larger <em>heightHint</em> will be forgotten closer to the root bag. These should be considered hints only, in that their effect on the final tree decomposition might change in future versions of Regina.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that <a class="el" href="classregina_1_1TreeBag.html#ad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> is <em>not</em> the number of the new or missing node, but instead gives the <em>index</em> of the new or missing node within the relevant bag.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine calls <a class="el" href="classregina_1_1TreeDecomposition.html#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> automatically, and so there is no need to explicitly call <a class="el" href="classregina_1_1TreeDecomposition.html#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> before calling <a class="el" href="classregina_1_1TreeDecomposition.html#ae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">makeNice()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The <em>heightHint</em> argument is not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heightHint</td><td>an optional array where, for each node <em>i</em>, a higher value of <code>heightHint[i]</code> indicates that the node should be forgotten closer to the root bag. If this is non-null, then the size of this array should be the number of nodes in the underlying graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dabce1a3f084a041e1dd15c9a5cdb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabce1a3f084a041e1dd15c9a5cdb61">&#9670;&nbsp;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::pace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of this tree decomposition using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="classregina_1_1TreeDecomposition.html#aeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>This routine simply returns the output of <a class="el" href="classregina_1_1TreeDecomposition.html#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> as a string, instead of writing it to an output stream.</p>
<p>See the <a class="el" href="classregina_1_1TreeDecomposition.html#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1TreeDecomposition.html#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a>, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a8aaa9c488e166bd52474a17abc374eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaa9c488e166bd52474a17abc374eef">&#9670;&nbsp;</a></span>reroot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td>
          <td class="paramname"><em>newRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition. </p>
<p>All pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newRoot</td><td>the bag that should become the root of this tree decomposition. This must already be a bag of this tree decomposition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af484fcab0b6693f5ad95c367007685f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af484fcab0b6693f5ad95c367007685f3">&#9670;&nbsp;</a></span>reroot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costSame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costReverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costRoot</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags. </p>
<p>The user needs to supply three arrays, which are used to estimate the cost of hanging the tree from any possible root. This routine then identifies which root minimises this cost, and reroots the underlying tree from that bag.</p>
<p>The three arrays play the following roles. Let <em>b</em> be some bag at index <em>i</em> in the original tree decomposition, and let <em>p</em> be its parent bag.</p>
<ul>
<li><code>costSame[i]</code> indicates the cost of <em>preserving</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>p</em> is still the parent bag of <em>b</em>). If <em>b</em> is the root bag of the original tree decomposition then <code>costSame[i]</code> is ignored.</li>
<li><code>costReverse[i]</code> indicates the cost of <em>reversing</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>b</em> is now the parent bag of <em>p</em>). Again, if <em>b</em> is the root bag of the original tree decomposition then <code>costReverse[i]</code> is ignored.</li>
<li><code>costRoot[i]</code> is an additional cost that is incurred if and only if <em>b</em> becomes the new root bag. The argument <em>costRoot</em> may be <code>null</code>, in which case these additional costs are all assumed to be zero.</li>
</ul>
<p>It follows that, for each potential new root, there are <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> costs to aggregate: this comes from <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1 costs from the arrays <em>costSame</em> and/or <em>costReverse</em> (one for each connection between bags in the underlying tree), and one cost from <em>costRoot</em>. These costs will be aggregated by taking the <em>maximum</em> over all individual costs. This means that you do not need to estimate running times and/or memory consumption accurately; instead you only need to find some heuristic that aims to be <em>monotonic</em> in time and/or memory.</p>
<p>So: in essence then, this routine minimises the maximum cost. In the case of a tie, it then minimises multiplicity; that is, it minimises the <em>number</em> of times that this maximum cost occurs over the individual <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> costs that are being aggregated.</p>
<p>Note that the <em>costSame</em> and <em>costReverse</em> arrays are technically defined as a cost per arc, not a cost per bag. If you wish to estimate a cost per bag, the typical way of doing this would be:</p>
<ul>
<li><code>costSame[i]</code> estimates the processing cost at bag <em>i</em> if its relationship with its parent is preserved;</li>
<li><code>costReverse[i]</code> estimates the processing cost at the original <em>parent</em> of bag <em>i</em> if its relationship with bag <em>i</em> is reversed (i.e., it becomes a child of bag <em>i</em>);</li>
<li><code>costRoot[i]</code> estimates the processing cost at bag <em>i</em> if bag <em>i</em> becomes the root.</li>
</ul>
<p>This scheme ensures that, for any possible rerooting, each bag is costed exactly once amongst the three arrays.</p>
<p>After rerooting, all pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for common types.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type being used to estimate costs. It must be possible to assign 0 to a variable of type <em>T</em> using both constructors and the assignment operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">costSame</td><td>An array of <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of preserving each child-parent connection; </td></tr>
    <tr><td class="paramname">costReverse</td><td>An array of <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of reversing each child-parent connection; </td></tr>
    <tr><td class="paramname">costRoot</td><td>An array of <a class="el" href="classregina_1_1TreeDecomposition.html#a805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an additional estimated cost for each bag being the new root. This array may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bag at the root of the underlying tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the root bag, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="a805e5fed5d765d73a06cf7bce26b256b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805e5fed5d765d73a06cf7bce26b256b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeDecomposition::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bags in this tree decomposition. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bags. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python</dt><dd>In addition to <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a13250fbe35fec8ea038fbbcc628361c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13250fbe35fec8ea038fbbcc628361c5">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeDecomposition::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the width of this tree decomposition. </p>
<p>This is one less than the size of the largest bag.</p>
<dl class="section return"><dt>Returns</dt><dd>the width of this tree decomposition. </dd></dl>

</div>
</div>
<a id="a2c2518695c74624d2e1a536ab88577e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2518695c74624d2e1a536ab88577e6">&#9670;&nbsp;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition in the Graphviz DOT language. </p>
<p>This produces a standalone DOT file that can be run through Graphviz in order to visualise the tree decomposition.</p>
<p>This routine generates a directed graph (with arrows running from parent bags to their children). The nodes of this graph will be labelled in a way that indicates the tetrahedra contained in each bag. The resulting DOT file should be used with the <em>dot</em> program shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a2668cd1871a2d62c7dca27c8540fca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2668cd1871a2d62c7dca27c8540fca91">&#9670;&nbsp;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="classregina_1_1TreeDecomposition.html#aeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>If you write a tree decomposition using <a class="el" href="classregina_1_1TreeDecomposition.html#a0dabce1a3f084a041e1dd15c9a5cdb61" title="Returns a text representation of this tree decomposition using the PACE text format.">pace()</a> or <a class="el" href="classregina_1_1TreeDecomposition.html#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> and then read it again using <a class="el" href="classregina_1_1TreeDecomposition.html#aeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE()</a>, you are <em>not</em> guaranteed to obtain an identical tree decomposition. This is because the PACE text format stores the connections between bags as an undirected, unrooted tree.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ad2391ff92b92cd58806107fd640be74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2391ff92b92cd58806107fd640be74b">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d6d08edc8c5224ba9f0033d49bedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d6d08edc8c5224ba9f0033d49bedce">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>treewidth/<a class="el" href="treedecomposition_8h.html">treedecomposition.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
