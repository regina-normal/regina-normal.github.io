<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: Mathematical Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Mathematical Support</div>  </div>
</div><!--header-->
<div class="contents">

<p>Underlying mathematical gruntwork.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCyclotomic.html">regina::NCyclotomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an element of a cyclotomic field.  <a href="classregina_1_1NCyclotomic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNativeInteger.html">regina::NNativeInteger&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for a native, fixed-precision integer type of the given size.  <a href="classregina_1_1NNativeInteger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1InfinityBase.html">regina::InfinityBase&lt; supportInfinity &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal base classes for use with <a class="el" href="classregina_1_1NIntegerBase.html" title="Represents an arbitrary precision integer.">NIntegerBase</a>, templated on whether we should support infinity as an allowed value.  <a href="structregina_1_1InfinityBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NIntegerBase.html">regina::NIntegerBase&lt; supportInfinity &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arbitrary precision integer.  <a href="classregina_1_1NIntegerBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMatrix.html">regina::NMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements of the given type T.  <a href="classregina_1_1NMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMatrixRing.html">regina::NMatrixRing&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements from a given ring T.  <a href="classregina_1_1NMatrixRing.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMatrix2.html">regina::NMatrix2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-by-2 integer matrix.  <a href="classregina_1_1NMatrix2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NMatrixInt.html">regina::NMatrixInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of arbitrary precision integers.  <a href="classregina_1_1NMatrixInt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPerm.html">regina::NPerm&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,...,<em>n</em>-1}.  <a href="classregina_1_1NPerm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPerm_3_012_01_4.html">regina::NPerm&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1}.  <a href="classregina_1_1NPerm_3_012_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPerm_3_013_01_4.html">regina::NPerm&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2}.  <a href="classregina_1_1NPerm_3_013_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPerm_3_014_01_4.html">regina::NPerm&lt; 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3}.  <a href="classregina_1_1NPerm_3_014_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPerm_3_015_01_4.html">regina::NPerm&lt; 5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a permutation of {0,1,2,3,4}.  <a href="classregina_1_1NPerm_3_015_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPolynomial.html">regina::NPolynomial&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single-variable polynomial with coefficients of type <em>T</em>.  <a href="classregina_1_1NPolynomial.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPrimes.html">regina::NPrimes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for finding primes and factorising integers.  <a href="classregina_1_1NPrimes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRational.html">regina::NRational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arbitrary precision rational number.  <a href="classregina_1_1NRational.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRay.html">regina::NRay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fast class for storing a ray rooted at the origin whose coordinates are rational.  <a href="classregina_1_1NRay.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html">regina::NVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimised vector class of elements from a given ring T.  <a href="classregina_1_1NVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa6d69c58fa05d5cee189921c16d3f7ad"><td class="memItemLeft" align="right" valign="top">typedef NIntegerBase&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">regina::NLargeInteger</a></td></tr>
<tr class="memdesc:gaa6d69c58fa05d5cee189921c16d3f7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">NLargeInteger is a typedef for <a class="el" href="classregina_1_1NIntegerBase.html">NIntegerBase&lt;true&gt;</a>, which offers arbitrary precision integers with support for infinity.  <a href="#gaa6d69c58fa05d5cee189921c16d3f7ad">More...</a><br/></td></tr>
<tr class="separator:gaa6d69c58fa05d5cee189921c16d3f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942e77ccea55d2cddf22e61b34f23281"><td class="memItemLeft" align="right" valign="top">typedef NIntegerBase&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga942e77ccea55d2cddf22e61b34f23281">regina::NInteger</a></td></tr>
<tr class="memdesc:ga942e77ccea55d2cddf22e61b34f23281"><td class="mdescLeft">&#160;</td><td class="mdescRight">NInteger is a typedef for NIntegerBase&lt;false&gt;, which offers arbitrary precision integers without support for infinity.  <a href="#ga942e77ccea55d2cddf22e61b34f23281">More...</a><br/></td></tr>
<tr class="separator:ga942e77ccea55d2cddf22e61b34f23281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcb2037b64c828a5b52e9a37f95826a"><td class="memItemLeft" align="right" valign="top">typedef NNativeInteger&lt; sizeof(long)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaebcb2037b64c828a5b52e9a37f95826a">regina::NNativeLong</a></td></tr>
<tr class="memdesc:gaebcb2037b64c828a5b52e9a37f95826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">NNativeLong is a typedef for the <a class="el" href="classregina_1_1NNativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NNativeInteger</a> template class whose underlying integer type is a native long.  <a href="#gaebcb2037b64c828a5b52e9a37f95826a">More...</a><br/></td></tr>
<tr class="separator:gaebcb2037b64c828a5b52e9a37f95826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c89f928c8a927c0b9ddeff8b73f270"><td class="memItemLeft" align="right" valign="top">typedef NPerm&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gae5c89f928c8a927c0b9ddeff8b73f270">regina::NPerm2</a></td></tr>
<tr class="memdesc:gae5c89f928c8a927c0b9ddeff8b73f270"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_012_01_4.html" title="Represents a permutation of {0,1}.">NPerm&lt;2&gt;</a>.  <a href="#gae5c89f928c8a927c0b9ddeff8b73f270">More...</a><br/></td></tr>
<tr class="separator:gae5c89f928c8a927c0b9ddeff8b73f270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b2adcd1bbc701cc469d8a508bc35b0"><td class="memItemLeft" align="right" valign="top">typedef NPerm&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga93b2adcd1bbc701cc469d8a508bc35b0">regina::NPerm3</a></td></tr>
<tr class="memdesc:ga93b2adcd1bbc701cc469d8a508bc35b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_013_01_4.html" title="Represents a permutation of {0,1,2}.">NPerm&lt;3&gt;</a>.  <a href="#ga93b2adcd1bbc701cc469d8a508bc35b0">More...</a><br/></td></tr>
<tr class="separator:ga93b2adcd1bbc701cc469d8a508bc35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042b941e6e73e89abe523886a190f861"><td class="memItemLeft" align="right" valign="top">typedef NPerm&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga042b941e6e73e89abe523886a190f861">regina::NPerm4</a></td></tr>
<tr class="memdesc:ga042b941e6e73e89abe523886a190f861"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_014_01_4.html" title="Represents a permutation of {0,1,2,3}.">NPerm&lt;4&gt;</a>.  <a href="#ga042b941e6e73e89abe523886a190f861">More...</a><br/></td></tr>
<tr class="separator:ga042b941e6e73e89abe523886a190f861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c66523fb68404cef9acf9a1ef2c64f"><td class="memItemLeft" align="right" valign="top">typedef NPerm&lt; 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga52c66523fb68404cef9acf9a1ef2c64f">regina::NPerm5</a></td></tr>
<tr class="memdesc:ga52c66523fb68404cef9acf9a1ef2c64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_015_01_4.html" title="Represents a permutation of {0,1,2,3,4}.">NPerm&lt;5&gt;</a>.  <a href="#ga52c66523fb68404cef9acf9a1ef2c64f">More...</a><br/></td></tr>
<tr class="separator:ga52c66523fb68404cef9acf9a1ef2c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga76dd91301fecb7c828edfd6dc3deed4c"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ga76dd91301fecb7c828edfd6dc3deed4c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga76dd91301fecb7c828edfd6dc3deed4c">regina::isZero</a> (R x)</td></tr>
<tr class="memdesc:ga76dd91301fecb7c828edfd6dc3deed4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is zero.  <a href="#ga76dd91301fecb7c828edfd6dc3deed4c">More...</a><br/></td></tr>
<tr class="separator:ga76dd91301fecb7c828edfd6dc3deed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36332c5c61a618542b73cbae142ed507"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ga36332c5c61a618542b73cbae142ed507"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga36332c5c61a618542b73cbae142ed507">regina::isNonZero</a> (R x)</td></tr>
<tr class="memdesc:ga36332c5c61a618542b73cbae142ed507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is non-zero.  <a href="#ga36332c5c61a618542b73cbae142ed507">More...</a><br/></td></tr>
<tr class="separator:ga36332c5c61a618542b73cbae142ed507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165bad6bef2cacd58c27fd8da839f560"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ga165bad6bef2cacd58c27fd8da839f560"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga165bad6bef2cacd58c27fd8da839f560">regina::isPositive</a> (R x)</td></tr>
<tr class="memdesc:ga165bad6bef2cacd58c27fd8da839f560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is strictly positive.  <a href="#ga165bad6bef2cacd58c27fd8da839f560">More...</a><br/></td></tr>
<tr class="separator:ga165bad6bef2cacd58c27fd8da839f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9a08dbdf32a03f6e15abf8728cbeaf"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:gade9a08dbdf32a03f6e15abf8728cbeaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#gade9a08dbdf32a03f6e15abf8728cbeaf">regina::isNegative</a> (R x)</td></tr>
<tr class="memdesc:gade9a08dbdf32a03f6e15abf8728cbeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is strictly negative.  <a href="#gade9a08dbdf32a03f6e15abf8728cbeaf">More...</a><br/></td></tr>
<tr class="separator:gade9a08dbdf32a03f6e15abf8728cbeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5741179d3bd4c4373efca1e12c8dd8c4"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ga5741179d3bd4c4373efca1e12c8dd8c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga5741179d3bd4c4373efca1e12c8dd8c4">regina::isNonNegative</a> (R x)</td></tr>
<tr class="memdesc:ga5741179d3bd4c4373efca1e12c8dd8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is non-negative.  <a href="#ga5741179d3bd4c4373efca1e12c8dd8c4">More...</a><br/></td></tr>
<tr class="separator:ga5741179d3bd4c4373efca1e12c8dd8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea882c5b244aeacc49b79aa605c6727b"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:gaea882c5b244aeacc49b79aa605c6727b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#gaea882c5b244aeacc49b79aa605c6727b">regina::isNonPositive</a> (R x)</td></tr>
<tr class="memdesc:gaea882c5b244aeacc49b79aa605c6727b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given real number is non-positive.  <a href="#gaea882c5b244aeacc49b79aa605c6727b">More...</a><br/></td></tr>
<tr class="separator:gaea882c5b244aeacc49b79aa605c6727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843e5e406e651715bfdc6e1e09d79590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga843e5e406e651715bfdc6e1e09d79590">regina::smithNormalForm</a> (NMatrixInt &amp;matrix)</td></tr>
<tr class="memdesc:ga843e5e406e651715bfdc6e1e09d79590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given integer matrix into Smith normal form.  <a href="#ga843e5e406e651715bfdc6e1e09d79590">More...</a><br/></td></tr>
<tr class="separator:ga843e5e406e651715bfdc6e1e09d79590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937173e93e62e9a18c2148194f53ac58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga937173e93e62e9a18c2148194f53ac58">regina::smithNormalForm</a> (NMatrixInt &amp;matrix, NMatrixInt &amp;rowSpaceBasis, NMatrixInt &amp;rowSpaceBasisInv, NMatrixInt &amp;colSpaceBasis, NMatrixInt &amp;colSpaceBasisInv)</td></tr>
<tr class="memdesc:ga937173e93e62e9a18c2148194f53ac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Smith normal form algorithm that also returns change of basis matrices.  <a href="#ga937173e93e62e9a18c2148194f53ac58">More...</a><br/></td></tr>
<tr class="separator:ga937173e93e62e9a18c2148194f53ac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b67f7b1391ffcbd905c9306cb8f721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gae1b67f7b1391ffcbd905c9306cb8f721">regina::metricalSmithNormalForm</a> (NMatrixInt &amp;matrix, NMatrixInt *rowSpaceBasis=0, NMatrixInt *rowSpaceBasisInv=0, NMatrixInt *colSpaceBasis=0, NMatrixInt *colSpaceBasisInv=0)</td></tr>
<tr class="memdesc:gae1b67f7b1391ffcbd905c9306cb8f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative Smith normal form algorithm that also returns change of basis matrices.  <a href="#gae1b67f7b1391ffcbd905c9306cb8f721">More...</a><br/></td></tr>
<tr class="separator:gae1b67f7b1391ffcbd905c9306cb8f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7505f81c74696b5a1dcf1c3bae4d464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaa7505f81c74696b5a1dcf1c3bae4d464">regina::rowBasis</a> (NMatrixInt &amp;matrix)</td></tr>
<tr class="memdesc:gaa7505f81c74696b5a1dcf1c3bae4d464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a basis for the row space of the given matrix.  <a href="#gaa7505f81c74696b5a1dcf1c3bae4d464">More...</a><br/></td></tr>
<tr class="separator:gaa7505f81c74696b5a1dcf1c3bae4d464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab962f2a45bf7758ae86e382667d05a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gab962f2a45bf7758ae86e382667d05a67">regina::rowBasisAndOrthComp</a> (NMatrixInt &amp;input, NMatrixInt &amp;complement)</td></tr>
<tr class="memdesc:gab962f2a45bf7758ae86e382667d05a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a basis for the row space of the given matrix, as well as an "incremental" basis for its orthogonal complement.  <a href="#gab962f2a45bf7758ae86e382667d05a67">More...</a><br/></td></tr>
<tr class="separator:gab962f2a45bf7758ae86e382667d05a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1627ce6d88211447292b76a81a7d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaea1627ce6d88211447292b76a81a7d97">regina::columnEchelonForm</a> (NMatrixInt &amp;M, NMatrixInt &amp;R, NMatrixInt &amp;Ri, const std::vector&lt; unsigned &gt; &amp;rowList)</td></tr>
<tr class="memdesc:gaea1627ce6d88211447292b76a81a7d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given matrix into column echelon form with respect to a collection of rows.  <a href="#gaea1627ce6d88211447292b76a81a7d97">More...</a><br/></td></tr>
<tr class="separator:gaea1627ce6d88211447292b76a81a7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbe93440922022ee1c0130443aa3161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::unique_ptr<br class="typebreak"/>
&lt; NMatrixInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaebbe93440922022ee1c0130443aa3161">regina::preImageOfLattice</a> (const NMatrixInt &amp;hom, const std::vector&lt; NLargeInteger &gt; &amp;sublattice)</td></tr>
<tr class="memdesc:gaebbe93440922022ee1c0130443aa3161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a homomorphism from Z^n to Z^k and a sublattice of Z^k, compute the preimage of this sublattice under this homomorphism.  <a href="#gaebbe93440922022ee1c0130443aa3161">More...</a><br/></td></tr>
<tr class="separator:gaebbe93440922022ee1c0130443aa3161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe032fd84b43ae6ae38b97b22c5a4b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::unique_ptr<br class="typebreak"/>
&lt; NMatrixInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gabe032fd84b43ae6ae38b97b22c5a4b7d">regina::torsionAutInverse</a> (const NMatrixInt &amp;input, const std::vector&lt; NLargeInteger &gt; &amp;invF)</td></tr>
<tr class="memdesc:gabe032fd84b43ae6ae38b97b22c5a4b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an automorphism of an abelian group, this procedure computes the inverse automorphism.  <a href="#gabe032fd84b43ae6ae38b97b22c5a4b7d">More...</a><br/></td></tr>
<tr class="separator:gabe032fd84b43ae6ae38b97b22c5a4b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8e7ccf964e8096753d9db89298ffd9"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:gafd8e7ccf964e8096753d9db89298ffd9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#gafd8e7ccf964e8096753d9db89298ffd9">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NIntegerBase&lt; supportInfinity &gt; &amp;i)</td></tr>
<tr class="memdesc:gafd8e7ccf964e8096753d9db89298ffd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given integer to the given output stream.  <a href="#gafd8e7ccf964e8096753d9db89298ffd9">More...</a><br/></td></tr>
<tr class="separator:gafd8e7ccf964e8096753d9db89298ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d19ae6be8a95424e80b6b5661cd1539"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:ga0d19ae6be8a95424e80b6b5661cd1539"><td class="memTemplItemLeft" align="right" valign="top">NIntegerBase&lt; supportInfinity &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga0d19ae6be8a95424e80b6b5661cd1539">regina::operator+</a> (long lhs, const NIntegerBase&lt; supportInfinity &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0d19ae6be8a95424e80b6b5661cd1539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given native integer to the given large integer.  <a href="#ga0d19ae6be8a95424e80b6b5661cd1539">More...</a><br/></td></tr>
<tr class="separator:ga0d19ae6be8a95424e80b6b5661cd1539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beacbd09d79721e777dc4bfc4a403cd"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:ga9beacbd09d79721e777dc4bfc4a403cd"><td class="memTemplItemLeft" align="right" valign="top">NIntegerBase&lt; supportInfinity &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga9beacbd09d79721e777dc4bfc4a403cd">regina::operator*</a> (long lhs, const NIntegerBase&lt; supportInfinity &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9beacbd09d79721e777dc4bfc4a403cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given native integer with the given large integer.  <a href="#ga9beacbd09d79721e777dc4bfc4a403cd">More...</a><br/></td></tr>
<tr class="separator:ga9beacbd09d79721e777dc4bfc4a403cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dc794d98ed6818f7efad9514c50d9f"><td class="memTemplParams" colspan="2">template&lt;int bytes&gt; </td></tr>
<tr class="memitem:gae0dc794d98ed6818f7efad9514c50d9f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#gae0dc794d98ed6818f7efad9514c50d9f">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NNativeInteger&lt; bytes &gt; &amp;i)</td></tr>
<tr class="memdesc:gae0dc794d98ed6818f7efad9514c50d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given integer to the given output stream.  <a href="#gae0dc794d98ed6818f7efad9514c50d9f">More...</a><br/></td></tr>
<tr class="separator:gae0dc794d98ed6818f7efad9514c50d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0057c04ea7557af990f512ddd89febe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga0057c04ea7557af990f512ddd89febe2">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NMatrix2 &amp;mat)</td></tr>
<tr class="memdesc:ga0057c04ea7557af990f512ddd89febe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given matrix to the given output stream.  <a href="#ga0057c04ea7557af990f512ddd89febe2">More...</a><br/></td></tr>
<tr class="separator:ga0057c04ea7557af990f512ddd89febe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a4740031637cf2e6671388d01f3018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga29a4740031637cf2e6671388d01f3018">regina::simpler</a> (const NMatrix2 &amp;m1, const NMatrix2 &amp;m2)</td></tr>
<tr class="memdesc:ga29a4740031637cf2e6671388d01f3018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first given matrix is more aesthetically pleasing than the second.  <a href="#ga29a4740031637cf2e6671388d01f3018">More...</a><br/></td></tr>
<tr class="separator:ga29a4740031637cf2e6671388d01f3018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495f5f718c7783603cee716e4f507b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga495f5f718c7783603cee716e4f507b2f">regina::simpler</a> (const NMatrix2 &amp;pair1first, const NMatrix2 &amp;pair1second, const NMatrix2 &amp;pair2first, const NMatrix2 &amp;pair2second)</td></tr>
<tr class="memdesc:ga495f5f718c7783603cee716e4f507b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first given pair of matrices is more aesthetically pleasing than the second pair.  <a href="#ga495f5f718c7783603cee716e4f507b2f">More...</a><br/></td></tr>
<tr class="separator:ga495f5f718c7783603cee716e4f507b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79522cfe9691b3825e27a3d0d913e209"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga79522cfe9691b3825e27a3d0d913e209">regina::digit</a> (int i)</td></tr>
<tr class="memdesc:ga79522cfe9691b3825e27a3d0d913e209"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to express the integer <em>i</em> in a permutation.  <a href="#ga79522cfe9691b3825e27a3d0d913e209">More...</a><br/></td></tr>
<tr class="separator:ga79522cfe9691b3825e27a3d0d913e209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6de79415ac9f777d8015d05df88d0af"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gae6de79415ac9f777d8015d05df88d0af">regina::factorial</a> (int n)</td></tr>
<tr class="memdesc:gae6de79415ac9f777d8015d05df88d0af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the factorial of <em>n</em>.  <a href="#gae6de79415ac9f777d8015d05df88d0af">More...</a><br/></td></tr>
<tr class="separator:gae6de79415ac9f777d8015d05df88d0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6779a38f766c8043febc4b7feb0e0974"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga6779a38f766c8043febc4b7feb0e0974"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga6779a38f766c8043febc4b7feb0e0974">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NPerm&lt; n &gt; &amp;p)</td></tr>
<tr class="memdesc:ga6779a38f766c8043febc4b7feb0e0974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string representation of the given permutation to the given output stream.  <a href="#ga6779a38f766c8043febc4b7feb0e0974">More...</a><br/></td></tr>
<tr class="separator:ga6779a38f766c8043febc4b7feb0e0974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967924c35cb2d3d29324919cc3e8414a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga967924c35cb2d3d29324919cc3e8414a">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NRational &amp;rat)</td></tr>
<tr class="memdesc:ga967924c35cb2d3d29324919cc3e8414a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given rational to the given output stream.  <a href="#ga967924c35cb2d3d29324919cc3e8414a">More...</a><br/></td></tr>
<tr class="separator:ga967924c35cb2d3d29324919cc3e8414a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfdd6c2b1d4ee52f9a4b8aa244043e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gadcfdd6c2b1d4ee52f9a4b8aa244043e0">regina::reducedMod</a> (long k, long modBase)</td></tr>
<tr class="memdesc:gadcfdd6c2b1d4ee52f9a4b8aa244043e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces <em>k</em> modulo <em>modBase</em> to give the smallest possible absolute value.  <a href="#gadcfdd6c2b1d4ee52f9a4b8aa244043e0">More...</a><br/></td></tr>
<tr class="separator:gadcfdd6c2b1d4ee52f9a4b8aa244043e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e39b29605b70b414862b39309b04284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga9e39b29605b70b414862b39309b04284">regina::gcd</a> (long a, long b)</td></tr>
<tr class="memdesc:ga9e39b29605b70b414862b39309b04284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the greatest common divisor of two signed integers.  <a href="#ga9e39b29605b70b414862b39309b04284">More...</a><br/></td></tr>
<tr class="separator:ga9e39b29605b70b414862b39309b04284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8987cc0ccd544c7f818e799e6a6c540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaa8987cc0ccd544c7f818e799e6a6c540">regina::gcdWithCoeffs</a> (long a, long b, long &amp;u, long &amp;v)</td></tr>
<tr class="memdesc:gaa8987cc0ccd544c7f818e799e6a6c540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the greatest common divisor of two given integers and finds the smallest coefficients with which these integers combine to give their gcd.  <a href="#gaa8987cc0ccd544c7f818e799e6a6c540">More...</a><br/></td></tr>
<tr class="separator:gaa8987cc0ccd544c7f818e799e6a6c540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6fd58ba813b8d2db4ef031dd826bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga6e6fd58ba813b8d2db4ef031dd826bd3">regina::lcm</a> (long a, long b)</td></tr>
<tr class="memdesc:ga6e6fd58ba813b8d2db4ef031dd826bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the lowest common multiple of two signed integers.  <a href="#ga6e6fd58ba813b8d2db4ef031dd826bd3">More...</a><br/></td></tr>
<tr class="separator:ga6e6fd58ba813b8d2db4ef031dd826bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dacbf7a9e5be4e6ee3256b3825df036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga9dacbf7a9e5be4e6ee3256b3825df036">regina::modularInverse</a> (unsigned long n, unsigned long k)</td></tr>
<tr class="memdesc:ga9dacbf7a9e5be4e6ee3256b3825df036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the multiplicative inverse of one integer modulo another.  <a href="#ga9dacbf7a9e5be4e6ee3256b3825df036">More...</a><br/></td></tr>
<tr class="separator:ga9dacbf7a9e5be4e6ee3256b3825df036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8edd301647207bc0b0bb5d22eca959"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gafa8edd301647207bc0b0bb5d22eca959">regina::factorise</a> (unsigned long n, std::list&lt; unsigned long &gt; &amp;factors)</td></tr>
<tr class="memdesc:gafa8edd301647207bc0b0bb5d22eca959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the prime factorisation of the given integer.  <a href="#gafa8edd301647207bc0b0bb5d22eca959">More...</a><br/></td></tr>
<tr class="separator:gafa8edd301647207bc0b0bb5d22eca959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0a99cb70e3947ab6b10cdbf775e90d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gade0a99cb70e3947ab6b10cdbf775e90d">regina::primesUpTo</a> (const NLargeInteger &amp;roof, std::list&lt; NLargeInteger &gt; &amp;primes)</td></tr>
<tr class="memdesc:gade0a99cb70e3947ab6b10cdbf775e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines all primes up to and including the given upper bound.  <a href="#gade0a99cb70e3947ab6b10cdbf775e90d">More...</a><br/></td></tr>
<tr class="separator:gade0a99cb70e3947ab6b10cdbf775e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ad0b8ae9d4910a97e2ddb42375873b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga02ad0b8ae9d4910a97e2ddb42375873b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__maths.html#ga02ad0b8ae9d4910a97e2ddb42375873b">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NVector&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga02ad0b8ae9d4910a97e2ddb42375873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given vector to the given output stream.  <a href="#ga02ad0b8ae9d4910a97e2ddb42375873b">More...</a><br/></td></tr>
<tr class="separator:ga02ad0b8ae9d4910a97e2ddb42375873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4fe97ab3fffa8d543cb7f543a42328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm5&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga4f4fe97ab3fffa8d543cb7f543a42328">regina::perm4to5</a> (const NPerm4 &amp;p)</td></tr>
<tr class="memdesc:ga4f4fe97ab3fffa8d543cb7f543a42328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that converts a 4-element permutation to a 5-element permutation.  <a href="#ga4f4fe97ab3fffa8d543cb7f543a42328">More...</a><br/></td></tr>
<tr class="separator:ga4f4fe97ab3fffa8d543cb7f543a42328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36797c852f3555254cec587516748052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga36797c852f3555254cec587516748052">regina::perm5to4</a> (const NPerm5 &amp;p)</td></tr>
<tr class="memdesc:ga36797c852f3555254cec587516748052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that expresses the given 5-element permutation as a 4-element permutation.  <a href="#ga36797c852f3555254cec587516748052">More...</a><br/></td></tr>
<tr class="separator:ga36797c852f3555254cec587516748052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ea29a6c4f616693a03897b08e6cd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga34ea29a6c4f616693a03897b08e6cd90">regina::perm3to4</a> (const NPerm3 &amp;p)</td></tr>
<tr class="memdesc:ga34ea29a6c4f616693a03897b08e6cd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that converts a 3-element permutation to a 4-element permutation.  <a href="#ga34ea29a6c4f616693a03897b08e6cd90">More...</a><br/></td></tr>
<tr class="separator:ga34ea29a6c4f616693a03897b08e6cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0547b4905146e93f56da3c06ac2ebf6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga0547b4905146e93f56da3c06ac2ebf6f">regina::perm4to3</a> (const NPerm4 &amp;p)</td></tr>
<tr class="memdesc:ga0547b4905146e93f56da3c06ac2ebf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that expresses the given 4-element permutation as a 3-element permutation.  <a href="#ga0547b4905146e93f56da3c06ac2ebf6f">More...</a><br/></td></tr>
<tr class="separator:ga0547b4905146e93f56da3c06ac2ebf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05bd5f365da741a4591115ca63b7f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm5&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gaf05bd5f365da741a4591115ca63b7f03">regina::perm3to5</a> (const NPerm3 &amp;p)</td></tr>
<tr class="memdesc:gaf05bd5f365da741a4591115ca63b7f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that converts a 3-element permutation to a 5-element permutation.  <a href="#gaf05bd5f365da741a4591115ca63b7f03">More...</a><br/></td></tr>
<tr class="separator:gaf05bd5f365da741a4591115ca63b7f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ae8903fa4c40387c231b6ae1f5e8e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NPerm3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga42ae8903fa4c40387c231b6ae1f5e8e2">regina::perm5to3</a> (const NPerm5 &amp;p)</td></tr>
<tr class="memdesc:ga42ae8903fa4c40387c231b6ae1f5e8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that expresses the given 5-element permutation as a 3-element permutation.  <a href="#ga42ae8903fa4c40387c231b6ae1f5e8e2">More...</a><br/></td></tr>
<tr class="separator:ga42ae8903fa4c40387c231b6ae1f5e8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cf5310c52d1bc18b132471ab91c2ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga43cf5310c52d1bc18b132471ab91c2ef">regina::NMatrixInt::NMatrixInt</a> (unsigned long rows, unsigned long cols)</td></tr>
<tr class="memdesc:ga43cf5310c52d1bc18b132471ab91c2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix of the given size.  <a href="#ga43cf5310c52d1bc18b132471ab91c2ef">More...</a><br/></td></tr>
<tr class="separator:ga43cf5310c52d1bc18b132471ab91c2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a50a571799e425ae34ae13322d7705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga10a50a571799e425ae34ae13322d7705">regina::NMatrixInt::NMatrixInt</a> (const NMatrixInt &amp;cloneMe)</td></tr>
<tr class="memdesc:ga10a50a571799e425ae34ae13322d7705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix that is a clone of the given matrix.  <a href="#ga10a50a571799e425ae34ae13322d7705">More...</a><br/></td></tr>
<tr class="separator:ga10a50a571799e425ae34ae13322d7705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga60caeda216c74f534e8ec429429a93a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9">regina::epsilon</a></td></tr>
<tr class="memdesc:ga60caeda216c74f534e8ec429429a93a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very small positive real designed to accommodate for rounding error.  <a href="#ga60caeda216c74f534e8ec429429a93a9">More...</a><br/></td></tr>
<tr class="separator:ga60caeda216c74f534e8ec429429a93a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84400154a9fa3fea46d3632e215cba62"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga84400154a9fa3fea46d3632e215cba62">regina::NMatrixRing&lt; T &gt;::zero</a></td></tr>
<tr class="memdesc:ga84400154a9fa3fea46d3632e215cba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero in the underlying ring.  <a href="#ga84400154a9fa3fea46d3632e215cba62">More...</a><br/></td></tr>
<tr class="separator:ga84400154a9fa3fea46d3632e215cba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612ea16d9301d1fd1cd41a0b7ede6791"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga612ea16d9301d1fd1cd41a0b7ede6791">regina::NMatrixRing&lt; T &gt;::one</a></td></tr>
<tr class="memdesc:ga612ea16d9301d1fd1cd41a0b7ede6791"><td class="mdescLeft">&#160;</td><td class="mdescRight">One (the multiplicative identity) in the underlying ring.  <a href="#ga612ea16d9301d1fd1cd41a0b7ede6791">More...</a><br/></td></tr>
<tr class="separator:ga612ea16d9301d1fd1cd41a0b7ede6791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga7bf8d50ab891667c80d04d5f50774ce5">regina::NVector&lt; T &gt;::zero</a></td></tr>
<tr class="memdesc:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero in the underlying number system.  <a href="#ga7bf8d50ab891667c80d04d5f50774ce5">More...</a><br/></td></tr>
<tr class="separator:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gabfc1c84a78adf6df36ed538f45740bf9">regina::NVector&lt; T &gt;::one</a></td></tr>
<tr class="memdesc:gabfc1c84a78adf6df36ed538f45740bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">One in the underlying number system.  <a href="#gabfc1c84a78adf6df36ed538f45740bf9">More...</a><br/></td></tr>
<tr class="separator:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gafc8368c6a98e3b332af41d21dd7ac9a6">regina::NVector&lt; T &gt;::minusOne</a></td></tr>
<tr class="memdesc:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative one in the underlying number system.  <a href="#gafc8368c6a98e3b332af41d21dd7ac9a6">More...</a><br/></td></tr>
<tr class="separator:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Underlying mathematical gruntwork. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga942e77ccea55d2cddf22e61b34f23281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NIntegerBase&lt;false&gt; <a class="el" href="group__maths.html#ga942e77ccea55d2cddf22e61b34f23281">regina::NInteger</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NInteger is a typedef for NIntegerBase&lt;false&gt;, which offers arbitrary precision integers without support for infinity. </p>
<dl class="section user"><dt>Python:</dt><dd>This typedef is available in Python. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6d69c58fa05d5cee189921c16d3f7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NIntegerBase&lt;true&gt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">regina::NLargeInteger</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NLargeInteger is a typedef for <a class="el" href="classregina_1_1NIntegerBase.html">NIntegerBase&lt;true&gt;</a>, which offers arbitrary precision integers with support for infinity. </p>
<dl class="section user"><dt>Python:</dt><dd>This typedef is available in Python. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebcb2037b64c828a5b52e9a37f95826a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NNativeInteger&lt;sizeof(long)&gt; <a class="el" href="group__maths.html#gaebcb2037b64c828a5b52e9a37f95826a">regina::NNativeLong</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NNativeLong is a typedef for the <a class="el" href="classregina_1_1NNativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NNativeInteger</a> template class whose underlying integer type is a native long. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c89f928c8a927c0b9ddeff8b73f270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NPerm&lt;2&gt; <a class="el" href="group__maths.html#gae5c89f928c8a927c0b9ddeff8b73f270">regina::NPerm2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_012_01_4.html" title="Represents a permutation of {0,1}.">NPerm&lt;2&gt;</a>. </p>

</div>
</div>
<a class="anchor" id="ga93b2adcd1bbc701cc469d8a508bc35b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NPerm&lt;3&gt; <a class="el" href="group__maths.html#ga93b2adcd1bbc701cc469d8a508bc35b0">regina::NPerm3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_013_01_4.html" title="Represents a permutation of {0,1,2}.">NPerm&lt;3&gt;</a>. </p>

</div>
</div>
<a class="anchor" id="ga042b941e6e73e89abe523886a190f861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NPerm&lt;4&gt; <a class="el" href="group__maths.html#ga042b941e6e73e89abe523886a190f861">regina::NPerm4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_014_01_4.html" title="Represents a permutation of {0,1,2,3}.">NPerm&lt;4&gt;</a>. </p>

</div>
</div>
<a class="anchor" id="ga52c66523fb68404cef9acf9a1ef2c64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NPerm&lt;5&gt; <a class="el" href="group__maths.html#ga52c66523fb68404cef9acf9a1ef2c64f">regina::NPerm5</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1NPerm_3_015_01_4.html" title="Represents a permutation of {0,1,2,3,4}.">NPerm&lt;5&gt;</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaea1627ce6d88211447292b76a81a7d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::columnEchelonForm </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>Ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>rowList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a given matrix into column echelon form with respect to a collection of rows. </p>
<p>Given the matrix <em>M</em> and the list <em>rowList</em> of rows from <em>M</em>, this algorithm puts <em>M</em> in column echelon form with respect to the rows in <em>rowList</em>. The only purpose of <em>rowList</em> is to clarify and/or weaken precisely what is meant by "column echelon form"; all rows of <em>M</em> are affected by the resulting column operations that take place.</p>
<p>This routine also returns the corresponding change of coordinate matrices <em>R</em> and <em>Ri:</em> </p>
<ul>
<li>If <em>R</em> and <em>Ri</em> are passed as identity matrices, the returned matrices will be such that <code>original_M * R = final_M</code> and <code>final_M * Ri = original_M</code> (and of course <code>final_M</code> is in column echelon form with respect to the given row list).</li>
<li>If <em>R</em> and <em>Ri</em> are already non-trivial coordinate transformations, they are modified appropriately by the algorithm.</li>
</ul>
<p>Our convention is that a matrix is in column echelon form if:</p>
<ol type="1">
<li>each column is either zero or there is a first non-zero entry which is positive (but see the note regarding <em>rowList</em> below);</li>
<li>moving from the leftmost column to the rightmost column, the rows containing the first non-zero entries for these columns have strictly increasing indices in <em>rowList</em>;</li>
<li>given a first non-zero column entry, in that row all the elements to the left are smaller and non-negative (all elements to the right are already zero by the previous condition);</li>
<li>all the zero columns are on the right hand side of the matrix.</li>
</ol>
<p>By a "zero column" here we simply mean "zero for every row in \a
rowList". Likewise, by "first non-zero entry" we mean "first row in
\a rowList with a non-zero entry".</p>
<p>In a pinch, you can also use this routine to compute the inverse of an invertible square matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>R</em> and <em>Ri</em> are square matrices with side length M.columns(), and these matrices are inverses of each other.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The argument <em>rowList</em> should be supplied as a python list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the matrix to reduce. </td></tr>
    <tr><td class="paramname">R</td><td>used to return the row-reduction matrix, as described above. </td></tr>
    <tr><td class="paramname">Ri</td><td>used to return the inverse of <em>R</em>. </td></tr>
    <tr><td class="paramname">rowList</td><td>the rows to pay attention to. This list must contain distinct integers, all between 0 and M.rows()-1 inclusive. The integers may appear in any order (though changing the order will change the resulting column echelon form).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a class="anchor" id="ga79522cfe9691b3825e27a3d0d913e209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char regina::digit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to express the integer <em>i</em> in a permutation. </p>
<ul>
<li>For <em>i</em> = 0,...,9, this will be the usual digit representing <em>i</em>.</li>
</ul>
<ul>
<li>For <em>i</em> &ge; 10, this will be a lower-case letter. In particular, for <em>i</em> = 10,...,15, this will be the usual hexadecimal digit representing <em>i</em>.</li>
</ul>
<ul>
<li>At present, this routine only supports integers <em>i</em> &lt; 36.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>integer to represent; this must be between 0 and 35 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single character used to represent <em>i</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6de79415ac9f777d8015d05df88d0af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t regina::factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the factorial of <em>n</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any non-negative integer; this must be at most 20 (since otherwise the factorial will overflow). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the factorial of <em>n</em>.. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa8edd301647207bc0b0bb5d22eca959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::factorise </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the prime factorisation of the given integer. </p>
<p>All the prime factors will be inserted into the given list. The algorithm used is <b>very neanderthal</b> and should only be used with reasonably sized integers. Don't use it to do RSA!</p>
<p>If a prime factor is repeated, it will be inserted multiple times into the list. The primes in the list are not guaranteed to appear in any specific order, nor are multiple occurrences of the same prime guaranteed to appear together.</p>
<p>Note that once finished the list will contain the prime factors as well as whatever happened to be in the list before this function was called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given integer is at least 1.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000245">Deprecated:</a></b></dt><dd>This routine is old and slow; please consider using the much faster routines from the <a class="el" href="classregina_1_1NPrimes.html" title="A helper class for finding primes and factorising integers.">NPrimes</a> class instead.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Argument <em>factors</em> is not present; instead this routine returns a python list containing the prime factors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the integer to factorise. </td></tr>
    <tr><td class="paramname">factors</td><td>the list into which prime factors will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e39b29605b70b414862b39309b04284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long regina::gcd </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the greatest common divisor of two signed integers. </p>
<p>This routine is not recursive.</p>
<p>Although the arguments may be negative, the result is guaranteed to be non-negative. As a special case, gcd(0,0) is considered to be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one of the two integers to work with. </td></tr>
    <tr><td class="paramname">b</td><td>the other integer with which to work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8987cc0ccd544c7f818e799e6a6c540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long regina::gcdWithCoeffs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the greatest common divisor of two given integers and finds the smallest coefficients with which these integers combine to give their gcd. </p>
<p>This routine is not recursive.</p>
<p>Note that the given integers need not be non-negative. However, the gcd returned is guaranteed to be non-negative. As a special case, gcd(0,0) is considered to be zero.</p>
<p>If <em>d</em> is the gcd of <em>a</em> and <em>b</em>, the values placed in <em>u</em> and <em>v</em> will be those for which <code>u*a + v*b = d</code>, <code>-abs(a)/d &lt; v*sign(b) &lt;= 0</code> and <code>1 &lt;= u*sign(a) &lt;= abs(b)/d</code>.</p>
<p>In the special case where one of the given integers is zero, the corresponding coefficient will also be zero and the other coefficient will be 1 or -1 so that <code>u*a + v*b = d</code> still holds. If both given integers are zero, both of the coefficients will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one of the integers to work with. </td></tr>
    <tr><td class="paramname">b</td><td>the other integer with which to work. </td></tr>
    <tr><td class="paramname">u</td><td>a variable into which the final coefficient of <em>a</em> will be placed. </td></tr>
    <tr><td class="paramname">v</td><td>a variable into which the final coefficient of <em>b</em> will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade9a08dbdf32a03f6e15abf8728cbeaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isNegative </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is strictly negative. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is strictly negative. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5741179d3bd4c4373efca1e12c8dd8c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isNonNegative </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is non-negative. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is non-negative. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea882c5b244aeacc49b79aa605c6727b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isNonPositive </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is non-positive. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is non-positive. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36332c5c61a618542b73cbae142ed507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isNonZero </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is non-zero. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is approximately non-zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga165bad6bef2cacd58c27fd8da839f560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isPositive </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is strictly positive. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is strictly positive. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76dd91301fecb7c828edfd6dc3deed4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isZero </td>
          <td>(</td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given real number is zero. </p>
<p>Any number within <em><a class="el" href="group__maths.html#ga60caeda216c74f534e8ec429429a93a9" title="A very small positive real designed to accommodate for rounding error.">regina::epsilon</a></em> of zero is considered to be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>R must be of a floating point real type.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given number is approximately zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e6fd58ba813b8d2db4ef031dd826bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long regina::lcm </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the lowest common multiple of two signed integers. </p>
<p>Although the arguments may be negative, the result is guaranteed to be non-negative.</p>
<p>If either of the arguments is zero, the return value will also be zero.</p>
<p>Regarding possible overflow: This routine does not create any temporary integers that are larger than the final LCM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>one of the two integers to work with. </td></tr>
    <tr><td class="paramname">b</td><td>the other integer with which to work. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lowest common multiple of <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1b67f7b1391ffcbd905c9306cb8f721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::metricalSmithNormalForm </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt *&#160;</td>
          <td class="paramname"><em>rowSpaceBasis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt *&#160;</td>
          <td class="paramname"><em>rowSpaceBasisInv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt *&#160;</td>
          <td class="paramname"><em>colSpaceBasis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt *&#160;</td>
          <td class="paramname"><em>colSpaceBasisInv</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alternative Smith normal form algorithm that also returns change of basis matrices. </p>
<p>This routine may be preferable for extremely large matrices. This is a variant of Hafner-McCurley and Havas-Holt-Rees's description of pivoting methods.</p>
<p>The only input argument is <em>matrix</em>. The four remaining arguments (the change of basis matrices), if passed, will be refilled, though they must be constructed with the correct dimensions as seen in the preconditions below. All five arguments are used to return information as follows.</p>
<p>Let <em>M</em> be the initial value of <em>matrix</em>, and let <em>S</em> be the Smith normal form of <em>M</em>. After this routine exits:</p>
<ul>
<li>The argument <em>matrix</em> will contain the Smith normal form <em>S</em>;</li>
<li><code>colSpaceBasis * M * rowSpaceBasis = S</code>;</li>
<li><code>colSpaceBasisInv * S * rowSpaceBasisInv = M</code>;</li>
<li><code>colSpaceBasis * colSpaceBasisInv</code> and <code>rowSpaceBasis * rowSpaceBasisInv</code> are both identity matrices.</li>
</ul>
<p>Thus, one obtains the Smith normal form the original matrix by multiplying on the left by ColSpaceBasis and on the right by RowSpaceBasis.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrices <em>rowSpaceBasis</em> and <em>rowSpaceBasisInv</em>, if passed, must be square with side length matrix.columns(). </dd>
<dd>
The matrices <em>colSpaceBasis</em> and <em>colSpaceBasisInv</em>, if passed, must be square, with side length matrix.rows().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the original matrix to put into Smith Normal Form (this need not be square). When the algorithm terminates, this matrix <em>is</em> in its Smith Normal Form. </td></tr>
    <tr><td class="paramname">rowSpaceBasis</td><td>used to return a change of basis matrix (see above for details). This is optional; you may pass a null pointer instead. </td></tr>
    <tr><td class="paramname">rowSpaceBasisInv</td><td>used to return the inverse of <em>rowSpaceBasis</em>. This is optional; you may pass a null pointer instead. </td></tr>
    <tr><td class="paramname">colSpaceBasis</td><td>used to return a change of basis matrix (see above for details). This is optional; you may pass a null pointer instead. </td></tr>
    <tr><td class="paramname">colSpaceBasisInv</td><td>used to return the inverse of <em>colSpaceBasis</em>. This is optional; you may pass a null pointer instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a class="anchor" id="ga9dacbf7a9e5be4e6ee3256b3825df036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned long regina::modularInverse </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the multiplicative inverse of one integer modulo another. </p>
<p>The inverse returned will be between 0 and <em>n</em>-1 inclusive.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>n</em> and <em>k</em> are both strictly positive; </dd>
<dd>
<em>n</em> and <em>k</em> have no common factors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the modular base in which to work. </td></tr>
    <tr><td class="paramname">k</td><td>the number whose multiplicative inverse should be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse <em>v</em> for which <code>k * v == 1 (mod n)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43cf5310c52d1bc18b132471ab91c2ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NMatrixInt::NMatrixInt </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix of the given size. </p>
<p>All entries will be initialised to zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of rows and columns are both strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10a50a571799e425ae34ae13322d7705"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NMatrixInt::NMatrixInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix that is a clone of the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the matrix to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9beacbd09d79721e777dc4bfc4a403cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NIntegerBase&lt; supportInfinity &gt; regina::operator* </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NIntegerBase&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given native integer with the given large integer. </p>
<p>If the large integer is infinite, the result will also be infinity.</p>
<dl class="section user"><dt>Python:</dt><dd>Not available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the native integer to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>the large integer to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product <em>lhs</em> times <em>rhs</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d19ae6be8a95424e80b6b5661cd1539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NIntegerBase&lt; supportInfinity &gt; regina::operator+ </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NIntegerBase&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given native integer to the given large integer. </p>
<p>If the large integer is infinite, the result will also be infinity.</p>
<dl class="section user"><dt>Python:</dt><dd>Not available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the native integer to add. </td></tr>
    <tr><td class="paramname">rhs</td><td>the large integer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum <em>lhs</em> plus <em>rhs</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0057c04ea7557af990f512ddd89febe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given matrix to the given output stream. </p>
<p>The matrix will be written entirely on a single line, with the first row followed by the second row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02ad0b8ae9d4910a97e2ddb42375873b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given vector to the given output stream. </p>
<p>The vector will be written on a single line with elements separated by a single space. No newline will be written.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">vector</td><td>the vector to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga967924c35cb2d3d29324919cc3e8414a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NRational &amp;&#160;</td>
          <td class="paramname"><em>rat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given rational to the given output stream. </p>
<p>Infinity will be written as <code>Inf</code>. Undefined will be written as <code>Undef</code>. A rational with denominator one will be written as a single integer. All other rationals will be written in the form <code>r/s</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">rat</td><td>the rational to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6779a38f766c8043febc4b7feb0e0974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NPerm&lt; n &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a string representation of the given permutation to the given output stream. </p>
<p>The format will be the same as is used by <a class="el" href="classregina_1_1NPerm.html#a3be5be4a6632f72db14131493a898f8b" title="Returns a string representation of this permutation.">NPerm::str()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">p</td><td>the permutation to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of objects being permuted. This must be between 3 and 16 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafd8e7ccf964e8096753d9db89298ffd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NIntegerBase&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given integer to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">i</td><td>the integer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0dc794d98ed6818f7efad9514c50d9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int bytes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NNativeInteger&lt; bytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given integer to the given output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">i</td><td>the integer to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34ea29a6c4f616693a03897b08e6cd90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm4 regina::perm3to4 </td>
          <td>(</td>
          <td class="paramtype">const NPerm3 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that converts a 3-element permutation to a 4-element permutation. </p>
<p>The resulting 4-element permutation will map 3 to 3, and will map 0, 1 and 2 to their respective images under <em>p</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000249">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_014_01_4.html#a007840f03e47e976b433b5715350b8a7" title="Extends a k-element permutation to a 4-element permutation, where 2 ≤ k &lt; 4.">NPerm4::extend</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 3-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of four elements, not three. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf05bd5f365da741a4591115ca63b7f03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm5 regina::perm3to5 </td>
          <td>(</td>
          <td class="paramtype">const NPerm3 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that converts a 3-element permutation to a 5-element permutation. </p>
<p>The resulting 5-element permutation will map 3 to 3 and 4 to 4, and will map 0, 1 and 2 to their respective images under <em>p</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000251">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_015_01_4.html#ac63699e515d22bcd3604b11115c37885" title="Extends a k-element permutation to a 5-element permutation, where 2 ≤ k &lt; 5.">NPerm5::extend</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 3-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of five elements, not three. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0547b4905146e93f56da3c06ac2ebf6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm3 regina::perm4to3 </td>
          <td>(</td>
          <td class="paramtype">const NPerm4 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that expresses the given 4-element permutation as a 3-element permutation. </p>
<p>The resulting 3-element permutation will map 0, 1 and 2 to their respective images under <em>p</em>. It is assumed that the image of 3 is 3 under <em>p</em>; otherwise this conversion cannot be performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given permutation maps 3 to 3.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000250">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_013_01_4.html#a90b035dccbcea90ddd5ccc43c5a6ae6b" title="Restricts a k-element permutation to an 3-element permutation, where k &gt; 3.">NPerm3::contract</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 4-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of three elements, not four. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f4fe97ab3fffa8d543cb7f543a42328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm5 regina::perm4to5 </td>
          <td>(</td>
          <td class="paramtype">const NPerm4 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that converts a 4-element permutation to a 5-element permutation. </p>
<p>The resulting 5-element permutation will map 4 to 4, and will map 0, 1, 2 and 3 to their respective images under <em>p</em>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000247">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_015_01_4.html#ac63699e515d22bcd3604b11115c37885" title="Extends a k-element permutation to a 5-element permutation, where 2 ≤ k &lt; 5.">NPerm5::extend</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 4-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of five elements, not four. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42ae8903fa4c40387c231b6ae1f5e8e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm3 regina::perm5to3 </td>
          <td>(</td>
          <td class="paramtype">const NPerm5 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that expresses the given 5-element permutation as a 3-element permutation. </p>
<p>The resulting 3-element permutation will map 0, 1 and 2 to their respective images under <em>p</em>. It is assumed that <code>maps</code> 3,4 to 3,4 (but it may do so in either order); otherwise this conversion cannot be performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given permutation maps 3,4 to 3,4 in some order.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000252">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_013_01_4.html#a90b035dccbcea90ddd5ccc43c5a6ae6b" title="Restricts a k-element permutation to an 3-element permutation, where k &gt; 3.">NPerm3::contract</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 5-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of three elements, not five. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36797c852f3555254cec587516748052"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NPerm4 regina::perm5to4 </td>
          <td>(</td>
          <td class="paramtype">const NPerm5 &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that expresses the given 5-element permutation as a 4-element permutation. </p>
<p>The resulting 4-element permutation will map 0, 1, 2 and 3 to their respective images under <em>p</em>. It is assumed that the image of 4 is 4 under <em>p</em>; otherwise this conversion cannot be performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given permutation maps 4 to 4.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000248">Deprecated:</a></b></dt><dd>This routine will be removed from some future release of Regina. You should instead call <a class="el" href="classregina_1_1NPerm_3_014_01_4.html#a47a24eb1e6f73a701db2b91770ec2d65" title="Restricts a k-element permutation to an 4-element permutation, where k &gt; 4.">NPerm4::contract</a>(<em>p</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the given 5-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation <em>p</em> expressed as a permutation of four elements, not five. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebbe93440922022ee1c0130443aa3161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::unique_ptr&lt;NMatrixInt&gt; regina::preImageOfLattice </td>
          <td>(</td>
          <td class="paramtype">const NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>hom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NLargeInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>sublattice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a homomorphism from Z^n to Z^k and a sublattice of Z^k, compute the preimage of this sublattice under this homomorphism. </p>
<p>The homomorphism from Z^n to Z^k is described by the given <em>k</em> by <em>n</em> matrix <em>hom</em>. The sublattice is of the form <code>(p1 Z) * (p2 Z) * ... * (pk Z)</code>, where the non-negative integers <em>p1</em>, ..., <em>pk</em> are passed in the given list <em>sublattice</em>.</p>
<p>An equivalent problem is to consider <em>hom</em> to be a homomorphism from Z^n to Z_p1 + ... + Z_pk; this routine then finds the kernel of this homomorphism.</p>
<p>The preimage of the sublattice (equivalently, the kernel described above) is some rank <em>n</em> lattice in Z^n. This algorithm finds and returns a basis for the lattice.</p>
<dl class="section user"><dt>Python:</dt><dd>The argument <em>sublattice</em> should be supplied as a python list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hom</td><td>the matrix representing the homomorphism from Z^n to Z^k; this must be a <em>k</em> by <em>n</em> matrix. </td></tr>
    <tr><td class="paramname">sublattice</td><td>a list of length <em>k</em> describing the sublattice of Z^k; the elements of this list must be the non-negative integers <em>p1</em>, ..., <em>pk</em> as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new matrix whose columns are a basis for the preimage lattice. This matrix will have precisely <em>n</em> rows.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a class="anchor" id="gade0a99cb70e3947ab6b10cdbf775e90d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::primesUpTo </td>
          <td>(</td>
          <td class="paramtype">const NLargeInteger &amp;&#160;</td>
          <td class="paramname"><em>roof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; NLargeInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>primes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines all primes up to and including the given upper bound. </p>
<p>All the primes found will be inserted into the given list in increasing order.</p>
<p>The algorithm currently used is <b>fairly neanderthal</b>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000246">Deprecated:</a></b></dt><dd>This routine is old and slow; please consider using the much faster routines from the <a class="el" href="classregina_1_1NPrimes.html" title="A helper class for finding primes and factorising integers.">NPrimes</a> class instead.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Argument <em>primes</em> is not present; instead this routine returns a python list containing the primes up to and including <em>roof</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roof</td><td>the upper bound up to which primes will be found. </td></tr>
    <tr><td class="paramname">primes</td><td>the list into which the primes will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcfdd6c2b1d4ee52f9a4b8aa244043e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> long regina::reducedMod </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>modBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces <em>k</em> modulo <em>modBase</em> to give the smallest possible absolute value. </p>
<p>For instance, <code>reducedMod(4,10) = 4</code> but <code>reducedMod(6,10) = -4</code>. In the case of a tie, the positive solution is taken.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>modBase</em> is strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number to reduce modulo <em>modBase</em>. </td></tr>
    <tr><td class="paramname">modBase</td><td>the modular base in which to work. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7505f81c74696b5a1dcf1c3bae4d464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned regina::rowBasis </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a basis for the row space of the given matrix. </p>
<p>This routine will rearrange the rows of the given matrix so that the first <em>rank</em> rows form a basis for the row space (where <em>rank</em> is the rank of the matrix). The rank itself will be returned. No other changes will be made to the matrix aside from swapping rows.</p>
<p>Although this routine takes an integer matrix (and only uses integer operations), we consider the row space to be over the <em>rationals</em>. That is, although we never divide, we act as though we could if we wanted to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to examine and rearrange. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the given matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gab962f2a45bf7758ae86e382667d05a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> unsigned regina::rowBasisAndOrthComp </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>complement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a basis for the row space of the given matrix, as well as an "incremental" basis for its orthogonal complement. </p>
<p>This routine takes an (<em>r</em> by <em>c</em>) matrix <em>input</em>, as well as a square (<em>c</em> by <em>c</em>) matrix <em>complement</em>, and does the following:</p>
<ul>
<li>The rows of <em>input</em> are rearranged so that the first <em>rank</em> rows form a basis for the row space (where <em>rank</em> is the rank of the matrix). No other changes are made to this matrix aside from swapping rows.</li>
</ul>
<ul>
<li>The matrix <em>complement</em> is re-filled (any previous contents are thrown away) so that, for any <em>i</em> between 0 and <em>rank-1</em> inclusive, the final (<em>c</em> - <em>i</em>) rows of <em>complement</em> form a basis for the orthogonal complement of the first <em>i</em> rows of the rearranged <em>input</em>.</li>
</ul>
<ul>
<li>The rank of the matrix <em>input</em> is returned from this routine.</li>
</ul>
<p>This routine can help with larger procedures that need to build up a row space and simultaneously cut down the complement one dimension at a time.</p>
<p>Although this routine takes integer matrices (and only uses integer operations), we consider all bases to be over the <em>rationals</em>. That is, although we never divide, we act as though we could if we wanted to.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrix <em>complement</em> is a square matrix, whose size is equal to the number of columns in <em>input</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input matrix whose row space we will describe; this matrix will be changed (though only by swapping rows). </td></tr>
    <tr><td class="paramname">complement</td><td>the square matrix that will be re-filled with the "incremental" basis for the orthogonal complement of <em>input</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the given matrix <em>input</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29a4740031637cf2e6671388d01f3018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::simpler </td>
          <td>(</td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the first given matrix is more aesthetically pleasing than the second. </p>
<p>The way in which this judgement is made is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the first matrix to examine. </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>m1</em> is deemed to be more pleasing than <em>m2</em>, or <code>false</code> if either the matrices are equal or <em>m2</em> is more pleasing than <em>m1</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga495f5f718c7783603cee716e4f507b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::simpler </td>
          <td>(</td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>pair1first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>pair1second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>pair2first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NMatrix2 &amp;&#160;</td>
          <td class="paramname"><em>pair2second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the first given pair of matrices is more aesthetically pleasing than the second pair. </p>
<p>The way in which this judgement is made is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<p>Note that pairs are ordered, so the pair (<em>M</em>, <em>N</em>) may be more (or perhaps less) pleasing than the pair (<em>N</em>, <em>M</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair1first</td><td>the first matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair1second</td><td>the second matrix of the first pair to examine. </td></tr>
    <tr><td class="paramname">pair2first</td><td>the first matrix of the second pair to examine. </td></tr>
    <tr><td class="paramname">pair2second</td><td>the second matrix of the second pair to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the first pair is deemed to be more pleasing than the second pair, or <code>false</code> if either the ordered pairs are equal or the second pair is more pleasing than the first. </dd></dl>

</div>
</div>
<a class="anchor" id="ga843e5e406e651715bfdc6e1e09d79590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::smithNormalForm </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given integer matrix into Smith normal form. </p>
<p>Note that the given matrix need not be square and need not be of full rank.</p>
<p>Reading down the diagonal, the final Smith normal form will have a series of non-negative, non-decreasing invariant factors followed by zeroes. "Invariant factor" refers to the convention that the <em>i</em>th term divides the (<em>i</em>+1)th term, and so they are unique.</p>
<p>The algorithm used is due to Hafner and McCurley (1991). It does not use modular arithmetic to control the intermediate coefficient explosion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga937173e93e62e9a18c2148194f53ac58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> void regina::smithNormalForm </td>
          <td>(</td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>rowSpaceBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>rowSpaceBasisInv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>colSpaceBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>colSpaceBasisInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Smith normal form algorithm that also returns change of basis matrices. </p>
<p>This is a modification of the one-argument <a class="el" href="group__maths.html#ga843e5e406e651715bfdc6e1e09d79590" title="Transforms the given integer matrix into Smith normal form.">smithNormalForm(NMatrixInt&amp;)</a>. As well as converting the given matrix <em>matrix</em> into Smith normal form, it also returns the appropriate change-of-basis matrices corresponding to all the row and column operations that were performed.</p>
<p>The only input argument is <em>matrix</em>. The four remaining arguments (the change of basis matrices) will be refilled, though they must be constructed with the correct dimensions as seen in the preconditions below. All five arguments are used to return information as follows.</p>
<p>Let <em>M</em> be the initial value of <em>matrix</em>, and let <em>S</em> be the Smith normal form of <em>M</em>. After this routine exits:</p>
<ul>
<li>The argument <em>matrix</em> will contain the Smith normal form <em>S</em>;</li>
<li><code>colSpaceBasis * M * rowSpaceBasis = S</code>;</li>
<li><code>colSpaceBasisInv * S * rowSpaceBasisInv = M</code>;</li>
<li><code>colSpaceBasis * colSpaceBasisInv</code> and <code>rowSpaceBasis * rowSpaceBasisInv</code> are both identity matrices.</li>
</ul>
<p>Thus, one obtains the Smith normal form the original matrix by multiplying on the left by ColSpaceBasis and on the right by RowSpaceBasis.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrices <em>rowSpaceBasis</em> and <em>rowSpaceBasisInv</em> that are passed are square, with side length matrix.columns(). </dd>
<dd>
The matrices <em>colSpaceBasis</em> and <em>colSpaceBasisInv</em> that are passed are square, with side length matrix.rows().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the original matrix to put into Smith Normal Form (this need not be square). When the algorithm terminates, this matrix <em>is</em> in its Smith Normal Form. </td></tr>
    <tr><td class="paramname">rowSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">rowSpaceBasisInv</td><td>used to return the inverse of <em>rowSpaceBasis</em>. </td></tr>
    <tr><td class="paramname">colSpaceBasis</td><td>used to return a change of basis matrix (see above for details). </td></tr>
    <tr><td class="paramname">colSpaceBasisInv</td><td>used to return the inverse of <em>colSpaceBasis</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a class="anchor" id="gabe032fd84b43ae6ae38b97b22c5a4b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::unique_ptr&lt;NMatrixInt&gt; regina::torsionAutInverse </td>
          <td>(</td>
          <td class="paramtype">const NMatrixInt &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NLargeInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>invF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an automorphism of an abelian group, this procedure computes the inverse automorphism. </p>
<p>The abelian group is of the form <code>Z_p1 + Z_p2 + ... + Z_pn</code>. The input is an n-by-n matrix <em>A</em> which represents a lift of the automorphism to just some n-by-n matrix. Specifically, you have a little commutative diagram with <code>Z^n &ndash;A&ndash;&gt; Z^n</code> covering the automorphism of <code>Z_p1 + Z_p2 + ... + Z_pn</code>, where the maps down are the direct sum of the standard quotients <code>Z &ndash;&gt; Z_pi</code>. So if you want this procedure to give you meaningful output, <em>A</em> must be a lift of a genuine automorphism of <code>Z_p1 + ... + Z_pn</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The list p1, p2, ..., pn is a list of invariant factors, which means that p1|p2, ..., p{n-1}|pn.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The argument <em>invF</em> should be supplied as a python list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the n-by-n matrix <em>A</em>, which must be a lift of a genuine automorphism as described above. </td></tr>
    <tr><td class="paramname">invF</td><td>the list p1, p2, ..., pn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse automorphism, also described as an n-by-n matrix as per the discussion above.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga60caeda216c74f534e8ec429429a93a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const double regina::epsilon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A very small positive real designed to accommodate for rounding error. </p>
<p>Any two numbers within <em>epsilon</em> of each other are considered to be equal by the generic zero-testing and sign-testing routines defined in this file (<a class="el" href="group__maths.html#ga76dd91301fecb7c828edfd6dc3deed4c" title="Determines whether the given real number is zero.">isZero()</a>, <a class="el" href="group__maths.html#ga165bad6bef2cacd58c27fd8da839f560" title="Determines whether the given real number is strictly positive.">isPositive()</a>, <a class="el" href="group__maths.html#ga5741179d3bd4c4373efca1e12c8dd8c4" title="Determines whether the given real number is non-negative.">isNonNegative()</a> and so on). </p>

</div>
</div>
<a class="anchor" id="gafc8368c6a98e3b332af41d21dd7ac9a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; T &gt;::minusOne</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative one in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="gabfc1c84a78adf6df36ed538f45740bf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; T &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="ga612ea16d9301d1fd1cd41a0b7ede6791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1NMatrixRing.html">regina::NMatrixRing</a>&lt; T &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One (the multiplicative identity) in the underlying ring. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="ga7bf8d50ab891667c80d04d5f50774ce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; T &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="ga84400154a9fa3fea46d3632e215cba62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1NMatrixRing.html">regina::NMatrixRing</a>&lt; T &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero in the underlying ring. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
