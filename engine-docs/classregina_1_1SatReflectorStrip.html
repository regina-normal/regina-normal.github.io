<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::SatReflectorStrip Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1SatReflectorStrip-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::SatReflectorStrip Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A saturated block that is a reflector strip.  
 <a href="classregina_1_1SatReflectorStrip.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/satblocktypes.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SatReflectorStrip:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SatReflectorStrip.png" usemap="#regina::SatReflectorStrip_map" alt=""/>
  <map id="regina::SatReflectorStrip_map" name="regina::SatReflectorStrip_map">
<area href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space." alt="regina::SatBlock" shape="rect" coords="0,56,164,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SatBlock &gt;" shape="rect" coords="0,0,164,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3f4ac64f5f274a2dd743ce10ce533303"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a></td></tr>
<tr class="memdesc:a3f4ac64f5f274a2dd743ce10ce533303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>.  <a href="#a3f4ac64f5f274a2dd743ce10ce533303">More...</a><br /></td></tr>
<tr class="separator:a3f4ac64f5f274a2dd743ce10ce533303"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30d17a2ced5d69e3cf56847a80f0d9dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#a30d17a2ced5d69e3cf56847a80f0d9dd">SatReflectorStrip</a> (const <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:a30d17a2ced5d69e3cf56847a80f0d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="#a30d17a2ced5d69e3cf56847a80f0d9dd">More...</a><br /></td></tr>
<tr class="separator:a30d17a2ced5d69e3cf56847a80f0d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea1ca51b8b1f1141c2e1c05a821b54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#a3aea1ca51b8b1f1141c2e1c05a821b54">clone</a> () const override</td></tr>
<tr class="memdesc:a3aea1ca51b8b1f1141c2e1c05a821b54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="#a3aea1ca51b8b1f1141c2e1c05a821b54">More...</a><br /></td></tr>
<tr class="separator:a3aea1ca51b8b1f1141c2e1c05a821b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a730e9aa139ef5b4693859b34366f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#ad30a730e9aa139ef5b4693859b34366f">adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:ad30a730e9aa139ef5b4693859b34366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="#ad30a730e9aa139ef5b4693859b34366f">More...</a><br /></td></tr>
<tr class="separator:ad30a730e9aa139ef5b4693859b34366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ae58723734d89763e3cd684b89e352"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#a30ae58723734d89763e3cd684b89e352">writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a30ae58723734d89763e3cd684b89e352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a30ae58723734d89763e3cd684b89e352">More...</a><br /></td></tr>
<tr class="separator:a30ae58723734d89763e3cd684b89e352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf1d38319376efdada01acf757fa342"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#aacf1d38319376efdada01acf757fa342">writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:aacf1d38319376efdada01acf757fa342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="#aacf1d38319376efdada01acf757fa342">More...</a><br /></td></tr>
<tr class="separator:aacf1d38319376efdada01acf757fa342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6315fa72abebfdd6c03f4ed5ea68bab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab">nAnnuli</a> () const</td></tr>
<tr class="memdesc:ab6315fa72abebfdd6c03f4ed5ea68bab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block.  <a href="#ab6315fa72abebfdd6c03f4ed5ea68bab">More...</a><br /></td></tr>
<tr class="separator:ab6315fa72abebfdd6c03f4ed5ea68bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed25d82f9b29328fb95f0ccb15e81d8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#aed25d82f9b29328fb95f0ccb15e81d8b">annulus</a> (unsigned which) const</td></tr>
<tr class="memdesc:aed25d82f9b29328fb95f0ccb15e81d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block.  <a href="#aed25d82f9b29328fb95f0ccb15e81d8b">More...</a><br /></td></tr>
<tr class="separator:aed25d82f9b29328fb95f0ccb15e81d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1893440bbd41f62a28f1c49f7d3bfae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ad1893440bbd41f62a28f1c49f7d3bfae">twistedBoundary</a> () const</td></tr>
<tr class="memdesc:ad1893440bbd41f62a28f1c49f7d3bfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a long Mobius strip?  <a href="#ad1893440bbd41f62a28f1c49f7d3bfae">More...</a><br /></td></tr>
<tr class="separator:ad1893440bbd41f62a28f1c49f7d3bfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d78eef4a11ec11260bb000eaa5a056"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a70d78eef4a11ec11260bb000eaa5a056">hasAdjacentBlock</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:a70d78eef4a11ec11260bb000eaa5a056"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="#a70d78eef4a11ec11260bb000eaa5a056">More...</a><br /></td></tr>
<tr class="separator:a70d78eef4a11ec11260bb000eaa5a056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71720ca0e1d2c086f532416a5522c60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a71720ca0e1d2c086f532416a5522c60a">adjacentBlock</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:a71720ca0e1d2c086f532416a5522c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="#a71720ca0e1d2c086f532416a5522c60a">More...</a><br /></td></tr>
<tr class="separator:a71720ca0e1d2c086f532416a5522c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ca004164b67a9e91dbdc652ba86b0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#abb2ca004164b67a9e91dbdc652ba86b0">adjacentAnnulus</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:abb2ca004164b67a9e91dbdc652ba86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block.  <a href="#abb2ca004164b67a9e91dbdc652ba86b0">More...</a><br /></td></tr>
<tr class="separator:abb2ca004164b67a9e91dbdc652ba86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af146659a1b983afa6eb4776d409011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a5af146659a1b983afa6eb4776d409011">adjacentReflected</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:a5af146659a1b983afa6eb4776d409011"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected.  <a href="#a5af146659a1b983afa6eb4776d409011">More...</a><br /></td></tr>
<tr class="separator:a5af146659a1b983afa6eb4776d409011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae091e96247b17a9bfbee97e4187750e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ae091e96247b17a9bfbee97e4187750e9">adjacentBackwards</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:ae091e96247b17a9bfbee97e4187750e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards.  <a href="#ae091e96247b17a9bfbee97e4187750e9">More...</a><br /></td></tr>
<tr class="separator:ae091e96247b17a9bfbee97e4187750e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43412c3c8b26ef6dee3ed83bfeb5f004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a43412c3c8b26ef6dee3ed83bfeb5f004">setAdjacent</a> (unsigned whichAnnulus, <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *adjBlock, unsigned adjAnnulus, bool adjReflected, bool adjBackwards)</td></tr>
<tr class="memdesc:a43412c3c8b26ef6dee3ed83bfeb5f004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the given saturated block as being adjacent to the given boundary annulus of this block.  <a href="#a43412c3c8b26ef6dee3ed83bfeb5f004">More...</a><br /></td></tr>
<tr class="separator:a43412c3c8b26ef6dee3ed83bfeb5f004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d565eec762b612fbf72b3f41e26dce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#aa4d565eec762b612fbf72b3f41e26dce">transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:aa4d565eec762b612fbf72b3f41e26dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the structure of this block according to the given isomorphism between triangulations.  <a href="#aa4d565eec762b612fbf72b3f41e26dce">More...</a><br /></td></tr>
<tr class="separator:aa4d565eec762b612fbf72b3f41e26dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5dfbf2105ead4220eee5c49e08ff1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a3b5dfbf2105ead4220eee5c49e08ff1b">nextBoundaryAnnulus</a> (unsigned thisAnnulus, <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;nextBlock, unsigned &amp;nextAnnulus, bool &amp;refVert, bool &amp;refHoriz, bool followPrev)</td></tr>
<tr class="memdesc:a3b5dfbf2105ead4220eee5c49e08ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region.  <a href="#a3b5dfbf2105ead4220eee5c49e08ff1b">More...</a><br /></td></tr>
<tr class="separator:a3b5dfbf2105ead4220eee5c49e08ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a7192ac0dfb2fd6c156ab9aa48d2c9570">abbr</a> (bool tex=false) const</td></tr>
<tr class="memdesc:a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block.  <a href="#a7192ac0dfb2fd6c156ab9aa48d2c9570">More...</a><br /></td></tr>
<tr class="separator:a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076736b6fe8a23d801e9bd5179aaf205"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a076736b6fe8a23d801e9bd5179aaf205">operator&lt;</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;compare) const</td></tr>
<tr class="memdesc:a076736b6fe8a23d801e9bd5179aaf205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a consistent ordering of saturated blocks.  <a href="#a076736b6fe8a23d801e9bd5179aaf205">More...</a><br /></td></tr>
<tr class="separator:a076736b6fe8a23d801e9bd5179aaf205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a8ba7b087b1a560891f9f075d443c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a130a8ba7b087b1a560891f9f075d443c">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a130a8ba7b087b1a560891f9f075d443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a130a8ba7b087b1a560891f9f075d443c">More...</a><br /></td></tr>
<tr class="separator:a130a8ba7b087b1a560891f9f075d443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a420ee40707aea3e946614ef3947d72b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#a420ee40707aea3e946614ef3947d72b9">isBlockReflectorStrip</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="classregina_1_1SatBlock.html#aed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:a420ee40707aea3e946614ef3947d72b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (reflector strip).  <a href="#a420ee40707aea3e946614ef3947d72b9">More...</a><br /></td></tr>
<tr class="separator:a420ee40707aea3e946614ef3947d72b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d402821b887395f10cc0812fd236c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#a92d402821b887395f10cc0812fd236c7">insertBlock</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, unsigned length, bool twisted)</td></tr>
<tr class="memdesc:a92d402821b887395f10cc0812fd236c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new reflector strip into the given triangulation, and returns the corresponding block structure.  <a href="#a92d402821b887395f10cc0812fd236c7">More...</a><br /></td></tr>
<tr class="separator:a92d402821b887395f10cc0812fd236c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eeb48f535c22b24dc25699981e38d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4">isBlock</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="classregina_1_1SatBlock.html#aed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:a24eeb48f535c22b24dc25699981e38d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block.  <a href="#a24eeb48f535c22b24dc25699981e38d4">More...</a><br /></td></tr>
<tr class="separator:a24eeb48f535c22b24dc25699981e38d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aefbd29f8ddad38991a3f2209a1ba3974"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html#aefbd29f8ddad38991a3f2209a1ba3974">SatReflectorStrip</a> (unsigned length, bool twisted)</td></tr>
<tr class="memdesc:aefbd29f8ddad38991a3f2209a1ba3974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a partially initialised block of the given length.  <a href="#aefbd29f8ddad38991a3f2209a1ba3974">More...</a><br /></td></tr>
<tr class="separator:aefbd29f8ddad38991a3f2209a1ba3974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab1705b0b0d6a48822121a699d8e0ffb9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ab1705b0b0d6a48822121a699d8e0ffb9">isBad</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, const <a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;list)</td></tr>
<tr class="memdesc:ab1705b0b0d6a48822121a699d8e0ffb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="#ab1705b0b0d6a48822121a699d8e0ffb9">More...</a><br /></td></tr>
<tr class="separator:ab1705b0b0d6a48822121a699d8e0ffb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256141cc960c800628d726ec268ebfd0"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:a256141cc960c800628d726ec268ebfd0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a256141cc960c800628d726ec268ebfd0">isBad</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, const List &amp;list)</td></tr>
<tr class="memdesc:a256141cc960c800628d726ec268ebfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="#a256141cc960c800628d726ec268ebfd0">More...</a><br /></td></tr>
<tr class="separator:a256141cc960c800628d726ec268ebfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d32449ef8e48dcf87e24c10bef03f2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ae5d32449ef8e48dcf87e24c10bef03f2">notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test)</td></tr>
<tr class="memdesc:ae5d32449ef8e48dcf87e24c10bef03f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null.  <a href="#ae5d32449ef8e48dcf87e24c10bef03f2">More...</a><br /></td></tr>
<tr class="separator:ae5d32449ef8e48dcf87e24c10bef03f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd0f929b39e314a96e2c99c699ce85"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ab4dd0f929b39e314a96e2c99c699ce85">notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1)</td></tr>
<tr class="memdesc:ab4dd0f929b39e314a96e2c99c699ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#ab4dd0f929b39e314a96e2c99c699ce85">More...</a><br /></td></tr>
<tr class="separator:ab4dd0f929b39e314a96e2c99c699ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45574f81ee799875b38ad24e3c87e777"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a45574f81ee799875b38ad24e3c87e777">notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2)</td></tr>
<tr class="memdesc:a45574f81ee799875b38ad24e3c87e777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#a45574f81ee799875b38ad24e3c87e777">More...</a><br /></td></tr>
<tr class="separator:a45574f81ee799875b38ad24e3c87e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16a7f145941c3270d2eb37b015e968"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#acd16a7f145941c3270d2eb37b015e968">notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other3)</td></tr>
<tr class="memdesc:acd16a7f145941c3270d2eb37b015e968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#acd16a7f145941c3270d2eb37b015e968">More...</a><br /></td></tr>
<tr class="separator:acd16a7f145941c3270d2eb37b015e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d8b87118dd4442251a5a040612b41"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a3b8d8b87118dd4442251a5a040612b41">notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other3, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other4)</td></tr>
<tr class="memdesc:a3b8d8b87118dd4442251a5a040612b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#a3b8d8b87118dd4442251a5a040612b41">More...</a><br /></td></tr>
<tr class="separator:a3b8d8b87118dd4442251a5a040612b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aca51e567fe4ca52128747f0ea2c6cf4c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#aca51e567fe4ca52128747f0ea2c6cf4c">nAnnuli_</a></td></tr>
<tr class="memdesc:aca51e567fe4ca52128747f0ea2c6cf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary annuli.  <a href="#aca51e567fe4ca52128747f0ea2c6cf4c">More...</a><br /></td></tr>
<tr class="separator:aca51e567fe4ca52128747f0ea2c6cf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a97514c4f3ee1dea5a0331e1161417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a66a97514c4f3ee1dea5a0331e1161417">annulus_</a></td></tr>
<tr class="memdesc:a66a97514c4f3ee1dea5a0331e1161417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of each boundary annulus, as seen from the inside of this saturated block.  <a href="#a66a97514c4f3ee1dea5a0331e1161417">More...</a><br /></td></tr>
<tr class="separator:a66a97514c4f3ee1dea5a0331e1161417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46bf466819a76108db37eb218c4a458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#ab46bf466819a76108db37eb218c4a458">twistedBoundary_</a></td></tr>
<tr class="memdesc:ab46bf466819a76108db37eb218c4a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a Mobius band?  <a href="#ab46bf466819a76108db37eb218c4a458">More...</a><br /></td></tr>
<tr class="separator:ab46bf466819a76108db37eb218c4a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb04cbf5461053c069fe67c54584c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a6fb04cbf5461053c069fe67c54584c04">adjBlock_</a></td></tr>
<tr class="memdesc:a6fb04cbf5461053c069fe67c54584c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known.  <a href="#a6fb04cbf5461053c069fe67c54584c04">More...</a><br /></td></tr>
<tr class="separator:a6fb04cbf5461053c069fe67c54584c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbbe922c434c19fc44f84efe43beb89"><td class="memItemLeft" align="right" valign="top">unsigned *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a8cbbe922c434c19fc44f84efe43beb89">adjAnnulus_</a></td></tr>
<tr class="memdesc:a8cbbe922c434c19fc44f84efe43beb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block.  <a href="#a8cbbe922c434c19fc44f84efe43beb89">More...</a><br /></td></tr>
<tr class="separator:a8cbbe922c434c19fc44f84efe43beb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9015c09cdd1987f7c3d1af08bf777"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#a88f9015c09cdd1987f7c3d1af08bf777">adjReflected_</a></td></tr>
<tr class="memdesc:a88f9015c09cdd1987f7c3d1af08bf777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is reflected (see the class notes above).  <a href="#a88f9015c09cdd1987f7c3d1af08bf777">More...</a><br /></td></tr>
<tr class="separator:a88f9015c09cdd1987f7c3d1af08bf777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcda28943ad300bcfd713f8bb4f59a8"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html#aafcda28943ad300bcfd713f8bb4f59a8">adjBackwards_</a></td></tr>
<tr class="memdesc:aafcda28943ad300bcfd713f8bb4f59a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is backwards (see the class notes above).  <a href="#aafcda28943ad300bcfd713f8bb4f59a8">More...</a><br /></td></tr>
<tr class="separator:aafcda28943ad300bcfd713f8bb4f59a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A saturated block that is a reflector strip. </p>
<p>A reflector strip is a ring of triangular prisms arranged end-to-end, as illustrated in the diagram below. The top rectangle of each prism is identified with the bottom in an orientation-reversing fashion (the back edge moves to the front and vice versa), and the prisms are joined in a loop from left to right. The Seifert fibres run vertically in the diagram, with each saturated boundary annulus shaded at the rear of each prism.</p>
<div class="image">
<img src="reflector.png" alt="reflector.png"/>
</div>
<p>The effect of a reflector strip is to create a reflector boundary in the base orbifold of the surrounding Seifert fibred space. Each prism provides a segment of this reflector boundary.</p>
<p>A reflector strip may have arbitrary length, and it may also include a twist as the ring of prisms wraps back around to meet itself. Note that a twisted reflector strip will have a twisted ring of boundary annuli, as described by <a class="el" href="classregina_1_1SatBlock.html#ad1893440bbd41f62a28f1c49f7d3bfae" title="Is the ring of boundary annuli twisted to form a long Mobius strip?">SatBlock::twistedBoundary()</a>.</p>
<p>The <em>length</em> of a reflector strip is defined to be the number of prisms that are joined together, or equivalently the number of saturated annuli on the boundary. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3f4ac64f5f274a2dd743ce10ce533303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ac64f5f274a2dd743ce10ce533303">&#9670;&nbsp;</a></span>TetList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;*&gt; <a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">regina::SatBlock::TetList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a30d17a2ced5d69e3cf56847a80f0d9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d17a2ced5d69e3cf56847a80f0d9dd">&#9670;&nbsp;</a></span>SatReflectorStrip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatReflectorStrip::SatReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefbd29f8ddad38991a3f2209a1ba3974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbd29f8ddad38991a3f2209a1ba3974">&#9670;&nbsp;</a></span>SatReflectorStrip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatReflectorStrip::SatReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a partially initialised block of the given length. </p>
<p>The boundary annuli will remain uninitialised, and must be initialised before this block can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the new reflector strip, i.e., the number of boundary annuli; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twisted</td><td><code>true</code> if the strip should be twisted (giving a twisted ring of boundary annuli), or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7192ac0dfb2fd6c156ab9aa48d2c9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192ac0dfb2fd6c156ab9aa48d2c9570">&#9670;&nbsp;</a></span>abbr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SatBlock::abbr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block. </p>
<p>This name will reflect the particular block type, but may not provide thorough details.</p>
<p>The name will be no more than a handful of characters long, and will not include a newline (or surrounding dollar signs in TeX mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td><code>true</code> if the name should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abbreviated name for this block. </dd></dl>

</div>
</div>
<a id="abb2ca004164b67a9e91dbdc652ba86b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2ca004164b67a9e91dbdc652ba86b0">&#9670;&nbsp;</a></span>adjacentAnnulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::adjacentAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding annulus number on the other block that is adjacent along this annulus. </dd></dl>

</div>
</div>
<a id="ae091e96247b17a9bfbee97e4187750e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae091e96247b17a9bfbee97e4187750e9">&#9670;&nbsp;</a></span>adjacentBackwards()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentBackwards </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards. </p>
<p>See the class notes for a discussion of backwards adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is backwards, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="a71720ca0e1d2c086f532416a5522c60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71720ca0e1d2c086f532416a5522c60a">&#9670;&nbsp;</a></span>adjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatBlock::adjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other block adjacent along this annulus, or 0 if there is no adjacent block listed. </dd></dl>

</div>
</div>
<a id="a5af146659a1b983afa6eb4776d409011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af146659a1b983afa6eb4776d409011">&#9670;&nbsp;</a></span>adjacentReflected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentReflected </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected. </p>
<p>See the class notes for a discussion of reflected adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is reflected, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="ad30a730e9aa139ef5b4693859b34366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a730e9aa139ef5b4693859b34366f">&#9670;&nbsp;</a></span>adjustSFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatReflectorStrip::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1SatBlock.html#a0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="aed25d82f9b29328fb95f0ccb15e81d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed25d82f9b29328fb95f0ccb15e81d8b">&#9670;&nbsp;</a></span>annulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatBlock::annulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block. </p>
<p>Annuli are numbered from 0 to <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 as described in the class notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which boundary annulus is requested; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested boundary annulus. </dd></dl>

</div>
</div>
<a id="a3aea1ca51b8b1f1141c2e1c05a821b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aea1ca51b8b1f1141c2e1c05a821b54">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatReflectorStrip::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1SatBlock.html#a2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a70d78eef4a11ec11260bb000eaa5a056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d78eef4a11ec11260bb000eaa5a056">&#9670;&nbsp;</a></span>hasAdjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::hasAdjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary annulus has an adjacent block listed, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a92d402821b887395f10cc0812fd236c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d402821b887395f10cc0812fd236c7">&#9670;&nbsp;</a></span>insertBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a>* regina::SatReflectorStrip::insertBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new reflector strip into the given triangulation, and returns the corresponding block structure. </p>
<p>The given triangulation will not be emptied before the new tetrahedra are inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new block should be inserted. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the new reflector strip, i.e., the number of boundary annuli; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new reflector strip should be twisted (causing its ring of boundary annuli to be twisted also), or <code>false</code> if the new strip should not be twisted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structural details of the newly inserted block. </dd></dl>

</div>
</div>
<a id="ab1705b0b0d6a48822121a699d8e0ffb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1705b0b0d6a48822121a699d8e0ffb9">&#9670;&nbsp;</a></span>isBad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="a256141cc960c800628d726ec268ebfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256141cc960c800628d726ec268ebfd0">&#9670;&nbsp;</a></span>isBad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const List &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. It is a generic routine for working with arbitrary list types.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Forward iterators of type <code>List::const_iterator</code> that span the given list can be obtained by calling <code>list.begin()</code> and <code>list.end()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="a24eeb48f535c22b24dc25699981e38d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24eeb48f535c22b24dc25699981e38d4">&#9670;&nbsp;</a></span>isBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>* regina::SatBlock::isBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block. </p>
<p>The annulus should be represented from the inside of the proposed saturated block.</p>
<p>Only certain types of saturated block are recognised by this routine. More exotic saturated blocks will not be identified, and this routine will return <code>null</code> in such cases.</p>
<p>The given list of tetrahedra will not be examined by this routine. That is, only saturated blocks that do not contain any of these tetrahedra will be considered. As a consequence, if the given annulus uses any of these tetrahedra then <code>null</code> will be returned.</p>
<p>If a block is found on the other hand, all of the tetrahedra within this block will be added to the given list.</p>
<p>In the event that a block is found, it is guaranteed that the given annulus will be listed as annulus number 0 in the block structure, without any horizontal or vertical reflection.</p>
<dl class="section user"><dt>Python</dt><dd>The second argument <em>avoidTets</em> is not present. An empty list will be passed instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="a420ee40707aea3e946614ef3947d72b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420ee40707aea3e946614ef3947d72b9">&#9670;&nbsp;</a></span>isBlockReflectorStrip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a>* regina::SatReflectorStrip::isBlockReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html#a3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (reflector strip). </p>
<p>This routine is a specific case of <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ab6315fa72abebfdd6c03f4ed5ea68bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6315fa72abebfdd6c03f4ed5ea68bab">&#9670;&nbsp;</a></span>nAnnuli()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::nAnnuli </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a id="a3b5dfbf2105ead4220eee5c49e08ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5dfbf2105ead4220eee5c49e08ff1b">&#9670;&nbsp;</a></span>nextBoundaryAnnulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::nextBoundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;&#160;</td>
          <td class="paramname"><em>nextBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nextAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refHoriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>followPrev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region. </p>
<p>Suppose that all saturated blocks are merged together according to adjacent boundary annuli, forming larger saturated structures. The remaining annuli that do not have adjacent blocks will group together to form several large boundary rings. Note that each boundary ring might involve annuli from several different blocks, and might or might not have a twist (thus forming a large Klein bottle instead of a large torus).</p>
<p>This routine is used to trace around such a boundary ring. It is assumed that annulus <em>thisAnnulus</em> of this block forms part of a boundary ring (i.e., it has no adjacent block). This routine will then return the next/previous annulus around from this in the large boundary ring. Here "next" means in the direction following from the second triangle of this annulus, and "previous" means in the direction following from the first triangle; the boolean argument <em>followPrev</em> controls which we will be used. This next/previous annulus might belong to another block, or it might even be this original annulus again.</p>
<p>The next/previous annulus itself is not returned, but rather a reference as to how it appears within its enclosing saturated block. Specifically, a block and corresponding annulus number will be returned in the arguments <em>nextBlock</em> and <em>nextAnnulus</em> respectively.</p>
<p>It is possible that the next/previous annulus as it appears within the returned block is oriented differently from how it appears within this large boundary ring. For this reason, two booleans are returned also. The argument <em>refVert</em> will describe whether the annulus is reflected vertically as it appears within the large boundary ring (i.e., the first and second triangles remain the same but the fibre direction is reversed). Similarly, the argument <em>refHoriz</em> will describe whether the annulus is reflected horizontally as it appears within the large boundary ring (i.e., first and second triangles are switched but the fibre direction is unchanged).</p>
<p>It is possible that both a horizontal and vertical reflection take place. Note that any kind of reflection will also affect the locations of the 0/1/2 markings as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes.</p>
<p>Finally, note that if the large boundary ring is twisted (i.e., it forms a Klein bottle), then following the entire boundary ring around using this routine will bring you back to the starting annulus but with the <em>refVert</em> flag set.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Annulus <em>thisAnnulus</em> of this block has no block adjacent to it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to trace around an entire boundary ring, you will need to adjust the argument <em>followPrev</em> according to whether or not the current annulus is reflected horizontally (since, under a horizontal reflection, "next" becomes "previous" and vice versa).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine only takes two arguments (<em>thisAnnulus</em> and <em>followPrev</em>). The return value is a tuple of four values: the block returned in <em>nextBlock</em>, the integer returned in <em>nextAnnulus</em>, the boolean returned in <em>refVert</em>, and the boolean returned in <em>refHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisAnnulus</td><td>describes which original boundary annulus of this block to examine; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">nextBlock</td><td>a reference used to return the block containing the next boundary annulus around from <em>thisAnnulus</em>. </td></tr>
    <tr><td class="paramname">nextAnnulus</td><td>a reference used to return the specific annulus number within <em>nextBlock</em> of the next annulus around; this will be between 0 and <em>nextBlock-&gt;<a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1</em> inclusive, and the corresponding annulus will have no block adjacent to it. </td></tr>
    <tr><td class="paramname">refVert</td><td>a reference used to return <code>true</code> if the next annulus around is vertically reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">refHoriz</td><td>a reference used to return <code>true</code> if the next annulus around is horizontally reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">followPrev</td><td><code>true</code> if we should find the previous boundary annulus, or <code>false</code> if we should find the next boundary annulus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d32449ef8e48dcf87e24c10bef03f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d32449ef8e48dcf87e24c10bef03f2">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<p>The name <a class="el" href="classregina_1_1SatBlock.html#ae5d32449ef8e48dcf87e24c10bef03f2" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> may seem strang for what is essentially a nullity test; in fact this routine is offered as a degenerate case of other variants of <a class="el" href="classregina_1_1SatBlock.html#ae5d32449ef8e48dcf87e24c10bef03f2" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> that take more tetrahedra as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab4dd0f929b39e314a96e2c99c699ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dd0f929b39e314a96e2c99c699ce85">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a45574f81ee799875b38ad24e3c87e777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45574f81ee799875b38ad24e3c87e777">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em> or <em>other2</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="acd16a7f145941c3270d2eb37b015e968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16a7f145941c3270d2eb37b015e968">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em> or <em>other3</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3b8d8b87118dd4442251a5a040612b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8d8b87118dd4442251a5a040612b41">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1SatBlock.html#a24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other4</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em>, <em>other3</em> or <em>other4</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a076736b6fe8a23d801e9bd5179aaf205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076736b6fe8a23d801e9bd5179aaf205">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a consistent ordering of saturated blocks. </p>
<p>This ordering is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the saturated block with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this block comes before the given block according to the ordering of saturated blocks, or <code>false</code> if either the blocks are identical or this block comes after the given block. </dd></dl>

</div>
</div>
<a id="a43412c3c8b26ef6dee3ed83bfeb5f004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43412c3c8b26ef6dee3ed83bfeb5f004">&#9670;&nbsp;</a></span>setAdjacent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::setAdjacent </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>adjBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>adjAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjReflected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjBackwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists the given saturated block as being adjacent to the given boundary annulus of this block. </p>
<p>Both block structures (this and the given block) will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block has the new adjacency; this must be between 0 and <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjBlock</td><td>the other saturated block that is adjacent to this. </td></tr>
    <tr><td class="paramname">adjAnnulus</td><td>indicates which boundary annulus of the adjacent block meets the given boundary annulus of this block; this must be between 0 and adjBlock-&gt;<a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjReflected</td><td>indicates whether the new adjacency is reflected (see the class notes for details). </td></tr>
    <tr><td class="paramname">adjBackwards</td><td>indicates whether the new adjacency is backwards (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python</dt><dd>In addition to <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d565eec762b612fbf72b3f41e26dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d565eec762b612fbf72b3f41e26dce">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the structure of this block according to the given isomorphism between triangulations. </p>
<p>Any triangulation-specific information will be transformed accordingly (for instance, the routine <a class="el" href="structregina_1_1SatAnnulus.html#aadb34c281222b5a95a4d3a2bd4206fcf" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">SatAnnulus::transform()</a> will be called for each boundary annulus).</p>
<p>Information regarding adjacent blocks will <em>not</em> be changed. Only structural information for this particular block will be updated.</p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this block must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called the block will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This block currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any subclasses of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> that store additional triangulation-specific information will need to override this routine. When doing so, be sure to call <a class="el" href="classregina_1_1SatBlock.html#aa4d565eec762b612fbf72b3f41e26dce" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">SatBlock::transform()</a> so that the generic changes defined here will still take place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this saturated block. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated block structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1SatLST.html#ada8a6cf454d624c3457b9e57c8595e6d">regina::SatLST</a>.</p>

</div>
</div>
<a id="ad1893440bbd41f62a28f1c49f7d3bfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1893440bbd41f62a28f1c49f7d3bfae">&#9670;&nbsp;</a></span>twistedBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a long Mobius strip? </p>
<p>Recall from the class notes that the twist occurs between boundary annuli <a class="el" href="classregina_1_1SatBlock.html#ab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 and 0.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the ring of boundary annuli is twisted, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aacf1d38319376efdada01acf757fa342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf1d38319376efdada01acf757fa342">&#9670;&nbsp;</a></span>writeAbbr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatReflectorStrip::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1SatBlock.html#ab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="a130a8ba7b087b1a560891f9f075d443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130a8ba7b087b1a560891f9f075d443c">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ae58723734d89763e3cd684b89e352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ae58723734d89763e3cd684b89e352">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatReflectorStrip::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1SatBlock.html#a27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8cbbe922c434c19fc44f84efe43beb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbbe922c434c19fc44f84efe43beb89">&#9670;&nbsp;</a></span>adjAnnulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned* regina::SatBlock::adjAnnulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block. </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="aafcda28943ad300bcfd713f8bb4f59a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcda28943ad300bcfd713f8bb4f59a8">&#9670;&nbsp;</a></span>adjBackwards_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjBackwards_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is backwards (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="a6fb04cbf5461053c069fe67c54584c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb04cbf5461053c069fe67c54584c04">&#9670;&nbsp;</a></span>adjBlock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>** regina::SatBlock::adjBlock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known. </p>

</div>
</div>
<a id="a88f9015c09cdd1987f7c3d1af08bf777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9015c09cdd1987f7c3d1af08bf777">&#9670;&nbsp;</a></span>adjReflected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjReflected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is reflected (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="a66a97514c4f3ee1dea5a0331e1161417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a97514c4f3ee1dea5a0331e1161417">&#9670;&nbsp;</a></span>annulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>* regina::SatBlock::annulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Details of each boundary annulus, as seen from the inside of this saturated block. </p>

</div>
</div>
<a id="aca51e567fe4ca52128747f0ea2c6cf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca51e567fe4ca52128747f0ea2c6cf4c">&#9670;&nbsp;</a></span>nAnnuli_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::nAnnuli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary annuli. </p>

</div>
</div>
<a id="ab46bf466819a76108db37eb218c4a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46bf466819a76108db37eb218c4a458">&#9670;&nbsp;</a></span>twistedBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a Mobius band? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="satblocktypes_8h.html">satblocktypes.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
