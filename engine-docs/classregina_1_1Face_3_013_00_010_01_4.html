<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::Face&lt; 3, 0 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html">Face< 3, 0 ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Face_3_013_00_010_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Face&lt; 3, 0 &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dim3.html">3-Manifold Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a vertex in the skeleton of a 3-manifold triangulation.  
 <a href="classregina_1_1Face_3_013_00_010_01_4.html#details">More...</a></p>

<p><code>#include &lt;triangulation/dim3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Face&lt; 3, 0 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Face_3_013_00_010_01_4.png" usemap="#regina::Face&lt; 3, 0 &gt;_map" alt=""/>
  <map id="regina::Face&lt; 3, 0 &gt;_map" name="regina::Face&lt; 3, 0 &gt;_map">
<area href="classregina_1_1detail_1_1FaceBase.html" alt="regina::detail::FaceBase&lt; 3, 0 &gt;" shape="rect" coords="0,448,468,472"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Face&lt; dim, subdim &gt; &gt;" shape="rect" coords="478,336,946,360"/>
<area href="classregina_1_1alias_1_1FaceOfSimplex.html" alt="regina::alias::FaceOfSimplex&lt; FaceBase&lt; dim, subdim &gt;, dim, subdim-1 &gt;" shape="rect" coords="478,280,946,304"/>
<area href="classregina_1_1MarkedElement.html" title="A base class for elements of MarkedVector." alt="regina::MarkedElement" shape="rect" coords="478,224,946,248"/>
<area href="classregina_1_1FaceNumbering.html" title="Specifies how subdim-faces are numbered within a dim-dimensional simplex." alt="regina::FaceNumbering&lt; dim, subdim &gt;" shape="rect" coords="478,168,946,192"/>
<area href="classregina_1_1detail_1_1FaceOrientability.html" alt="regina::detail::FaceOrientability&lt; allowsNonOrientableLinks(dim, subdim)&gt;" shape="rect" coords="478,112,946,136"/>
<area href="classregina_1_1detail_1_1FaceValidity.html" alt="regina::detail::FaceValidity&lt; allowsInvalidFaces(dim, subdim), standardDim(dim)&gt;" shape="rect" coords="478,56,946,80"/>
<area href="classregina_1_1detail_1_1FaceStorage.html" alt="regina::detail::FaceStorage&lt; dim, dim-subdim &gt;" shape="rect" coords="478,0,946,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a34beeab677315bd4b5e0091ea1645c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645c">LinkType</a> { <br/>
&#160;&#160;<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645ca2bf5faa23b062281a1a2320d1337bc05">SPHERE</a> = 1, 
<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645ca8672c0ae2f51ee6e3f9af4941bfb76d2">DISC</a> = 2, 
<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645ca82cce2a6053a92d04efaa1135d425220">TORUS</a> = 3, 
<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645caccb5da4a6cddf14df333422dd5c24aec">KLEIN_BOTTLE</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645caf19fa3672680ee945e836b6fbae0ef17">NON_STANDARD_CUSP</a> = 5, 
<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645ca1971e44e60c0052a04c8f02e20e0e2a3">INVALID</a> = 6
<br/>
 }</td></tr>
<tr class="memdesc:a3a34beeab677315bd4b5e0091ea1645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categorises the possible links of a vertex into a small number of common types.  <a href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645c">More...</a><br/></td></tr>
<tr class="separator:a3a34beeab677315bd4b5e0091ea1645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab375e6c4829ff149955889353050935c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#ab375e6c4829ff149955889353050935c">~Face</a> ()</td></tr>
<tr class="memdesc:ab375e6c4829ff149955889353050935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#ab375e6c4829ff149955889353050935c">More...</a><br/></td></tr>
<tr class="separator:ab375e6c4829ff149955889353050935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79dbbc03c3f1b6fc484d60c07006e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645c">LinkType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#af79dbbc03c3f1b6fc484d60c07006e94">link</a> () const </td></tr>
<tr class="memdesc:af79dbbc03c3f1b6fc484d60c07006e94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a broad categorisation of the link of the vertex.  <a href="#af79dbbc03c3f1b6fc484d60c07006e94">More...</a><br/></td></tr>
<tr class="separator:af79dbbc03c3f1b6fc484d60c07006e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703d334cadcf7416314b85e52623ad02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02">buildLink</a> () const </td></tr>
<tr class="memdesc:a703d334cadcf7416314b85e52623ad02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex.  <a href="#a703d334cadcf7416314b85e52623ad02">More...</a><br/></td></tr>
<tr class="separator:a703d334cadcf7416314b85e52623ad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d25e530de9262dc74acfbbae6fdf59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#aa6d25e530de9262dc74acfbbae6fdf59">buildLinkDetail</a> (bool labels=true, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; **inclusion=0) const </td></tr>
<tr class="memdesc:aa6d25e530de9262dc74acfbbae6fdf59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex.  <a href="#aa6d25e530de9262dc74acfbbae6fdf59">More...</a><br/></td></tr>
<tr class="separator:aa6d25e530de9262dc74acfbbae6fdf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c2d77c9bdbc41e4d74d57dfc142dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a573c2d77c9bdbc41e4d74d57dfc142dd">isLinkClosed</a> () const </td></tr>
<tr class="memdesc:a573c2d77c9bdbc41e4d74d57dfc142dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the link of this vertex is closed.  <a href="#a573c2d77c9bdbc41e4d74d57dfc142dd">More...</a><br/></td></tr>
<tr class="separator:a573c2d77c9bdbc41e4d74d57dfc142dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6964b03eaaad0c3530e062a0d3eebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a0b6964b03eaaad0c3530e062a0d3eebb">isIdeal</a> () const </td></tr>
<tr class="memdesc:a0b6964b03eaaad0c3530e062a0d3eebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vertex is an ideal vertex.  <a href="#a0b6964b03eaaad0c3530e062a0d3eebb">More...</a><br/></td></tr>
<tr class="separator:a0b6964b03eaaad0c3530e062a0d3eebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5fdc65c8a944da07779a5993696427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#afd5fdc65c8a944da07779a5993696427">isStandard</a> () const </td></tr>
<tr class="memdesc:afd5fdc65c8a944da07779a5993696427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vertex is standard.  <a href="#afd5fdc65c8a944da07779a5993696427">More...</a><br/></td></tr>
<tr class="separator:afd5fdc65c8a944da07779a5993696427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7eac70f8cab66b6122078096ff2897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#adf7eac70f8cab66b6122078096ff2897">linkEulerChar</a> () const </td></tr>
<tr class="memdesc:adf7eac70f8cab66b6122078096ff2897"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the vertex link.  <a href="#adf7eac70f8cab66b6122078096ff2897">More...</a><br/></td></tr>
<tr class="separator:adf7eac70f8cab66b6122078096ff2897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fa1861e6fc4b44538f1b26fe80d4d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#ac6fa1861e6fc4b44538f1b26fe80d4d2">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac6fa1861e6fc4b44538f1b26fe80d4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#ac6fa1861e6fc4b44538f1b26fe80d4d2">More...</a><br/></td></tr>
<tr class="separator:ac6fa1861e6fc4b44538f1b26fe80d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa90ce5491297fb08634a2108fae4e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#aaaa90ce5491297fb08634a2108fae4e3">index</a> () const</td></tr>
<tr class="memdesc:aaaa90ce5491297fb08634a2108fae4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of this face within the underlying triangulation.  <a href="#aaaa90ce5491297fb08634a2108fae4e3">More...</a><br/></td></tr>
<tr class="separator:aaaa90ce5491297fb08634a2108fae4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd856e56bf1f13cf26dfebe3b27230b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#a3bd856e56bf1f13cf26dfebe3b27230b">triangulation</a> () const</td></tr>
<tr class="memdesc:a3bd856e56bf1f13cf26dfebe3b27230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation to which this face belongs.  <a href="#a3bd856e56bf1f13cf26dfebe3b27230b">More...</a><br/></td></tr>
<tr class="separator:a3bd856e56bf1f13cf26dfebe3b27230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad219b3f19e64cdf25d153859772b9112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#ad219b3f19e64cdf25d153859772b9112">component</a> () const</td></tr>
<tr class="memdesc:ad219b3f19e64cdf25d153859772b9112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component of the triangulation to which this face belongs.  <a href="#ad219b3f19e64cdf25d153859772b9112">More...</a><br/></td></tr>
<tr class="separator:ad219b3f19e64cdf25d153859772b9112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34356247cebdc4002c479c6e6bd9674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#aa34356247cebdc4002c479c6e6bd9674">boundaryComponent</a> () const</td></tr>
<tr class="memdesc:aa34356247cebdc4002c479c6e6bd9674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boundary component of the triangulation to which this face belongs.  <a href="#aa34356247cebdc4002c479c6e6bd9674">More...</a><br/></td></tr>
<tr class="separator:aa34356247cebdc4002c479c6e6bd9674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d18bbe888a506d895e057a98d9b6e77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#a0d18bbe888a506d895e057a98d9b6e77">isBoundary</a> () const</td></tr>
<tr class="memdesc:a0d18bbe888a506d895e057a98d9b6e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face lies entirely on the boundary of the triangulation.  <a href="#a0d18bbe888a506d895e057a98d9b6e77">More...</a><br/></td></tr>
<tr class="separator:a0d18bbe888a506d895e057a98d9b6e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6628902d37fef49b158697d3ad5c3fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, lowerdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#a6628902d37fef49b158697d3ad5c3fd9">face</a> (int face) const</td></tr>
<tr class="memdesc:a6628902d37fef49b158697d3ad5c3fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>lowerdim</em>-face of the underlying triangulation that appears as the given <em>lowerdim</em>-dimensional subface of this face.  <a href="#a6628902d37fef49b158697d3ad5c3fd9">More...</a><br/></td></tr>
<tr class="separator:a6628902d37fef49b158697d3ad5c3fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2276fab83ff533df66934156307866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#a1e2276fab83ff533df66934156307866">faceMapping</a> (int <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a6628902d37fef49b158697d3ad5c3fd9">face</a>) const</td></tr>
<tr class="memdesc:a1e2276fab83ff533df66934156307866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the given <em>lowerdim</em>-dimensional subface of this face, and returns the mapping between the underlying <em>lowerdim</em>-face of the triangulation and the individual vertices of this face.  <a href="#a1e2276fab83ff533df66934156307866">More...</a><br/></td></tr>
<tr class="separator:a1e2276fab83ff533df66934156307866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a1300d8ed77dc894be81d1fb4e5144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html#ac7a1300d8ed77dc894be81d1fb4e5144">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac7a1300d8ed77dc894be81d1fb4e5144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#ac7a1300d8ed77dc894be81d1fb4e5144">More...</a><br/></td></tr>
<tr class="separator:ac7a1300d8ed77dc894be81d1fb4e5144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac96492727dc5fdfc20c611e37633602"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#aac96492727dc5fdfc20c611e37633602">degree</a> () const</td></tr>
<tr class="memdesc:aac96492727dc5fdfc20c611e37633602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of this face.  <a href="#aac96492727dc5fdfc20c611e37633602">More...</a><br/></td></tr>
<tr class="separator:aac96492727dc5fdfc20c611e37633602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4f3a919a1bc44bb47cb2c47b55ce6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim-codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#a4e4f3a919a1bc44bb47cb2c47b55ce6a">embedding</a> (size_t <a class="el" href="classregina_1_1detail_1_1FaceBase.html#aaaa90ce5491297fb08634a2108fae4e3">index</a>) const</td></tr>
<tr class="memdesc:a4e4f3a919a1bc44bb47cb2c47b55ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the ways in which this face appears within a top-dimensional simplex of the underlying triangluation.  <a href="#a4e4f3a919a1bc44bb47cb2c47b55ce6a">More...</a><br/></td></tr>
<tr class="separator:a4e4f3a919a1bc44bb47cb2c47b55ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520fc9ee5ab6bcee50ca27de710e4927"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a><br class="typebreak"/>
&lt; dim, dim-codim &gt;<br class="typebreak"/>
 &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#a520fc9ee5ab6bcee50ca27de710e4927">begin</a> () const</td></tr>
<tr class="memdesc:a520fc9ee5ab6bcee50ca27de710e4927"><td class="mdescLeft">&#160;</td><td class="mdescRight">A begin function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation.  <a href="#a520fc9ee5ab6bcee50ca27de710e4927">More...</a><br/></td></tr>
<tr class="separator:a520fc9ee5ab6bcee50ca27de710e4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fe1cb4689cfe36d15ae27bbc6de18b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a><br class="typebreak"/>
&lt; dim, dim-codim &gt;<br class="typebreak"/>
 &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#aa6fe1cb4689cfe36d15ae27bbc6de18b">end</a> () const</td></tr>
<tr class="memdesc:aa6fe1cb4689cfe36d15ae27bbc6de18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An end function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation.  <a href="#aa6fe1cb4689cfe36d15ae27bbc6de18b">More...</a><br/></td></tr>
<tr class="separator:aa6fe1cb4689cfe36d15ae27bbc6de18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d57928ddd7deb8071540c338a223f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim-codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#ab2d57928ddd7deb8071540c338a223f5">front</a> () const</td></tr>
<tr class="memdesc:ab2d57928ddd7deb8071540c338a223f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first appearance of this face within a top-dimensional simplex of the underlying triangluation.  <a href="#ab2d57928ddd7deb8071540c338a223f5">More...</a><br/></td></tr>
<tr class="separator:ab2d57928ddd7deb8071540c338a223f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dcfef4931d8b36e453ead4dac26736"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim-codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#a54dcfef4931d8b36e453ead4dac26736">back</a> () const</td></tr>
<tr class="memdesc:a54dcfef4931d8b36e453ead4dac26736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last appearance of this face within a top-dimensional simplex of the underlying triangluation.  <a href="#a54dcfef4931d8b36e453ead4dac26736">More...</a><br/></td></tr>
<tr class="separator:a54dcfef4931d8b36e453ead4dac26736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c22f338840773e0720f2dedc73f8cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#ae2c22f338840773e0720f2dedc73f8cc">inMaximalForest</a> () const</td></tr>
<tr class="memdesc:ae2c22f338840773e0720f2dedc73f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a codimension-1-face represents a dual edge in the maximal forest that has been chosen for the dual 1-skeleton of the triangulation.  <a href="#ae2c22f338840773e0720f2dedc73f8cc">More...</a><br/></td></tr>
<tr class="separator:ae2c22f338840773e0720f2dedc73f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd439c351f0cb7776982f09272494153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html#abd439c351f0cb7776982f09272494153">isValid</a> () const</td></tr>
<tr class="memdesc:abd439c351f0cb7776982f09272494153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is valid.  <a href="#abd439c351f0cb7776982f09272494153">More...</a><br/></td></tr>
<tr class="separator:abd439c351f0cb7776982f09272494153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2cf123b674397a74daac2fccfb0174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html#abc2cf123b674397a74daac2fccfb0174">hasBadIdentification</a> () const</td></tr>
<tr class="memdesc:abc2cf123b674397a74daac2fccfb0174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is identified with itself under a non-identity permutation.  <a href="#abc2cf123b674397a74daac2fccfb0174">More...</a><br/></td></tr>
<tr class="separator:abc2cf123b674397a74daac2fccfb0174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b05fffb0dc7b9cd2f0670ea9bb3d4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html#a4b05fffb0dc7b9cd2f0670ea9bb3d4ef">hasBadLink</a> () const</td></tr>
<tr class="memdesc:a4b05fffb0dc7b9cd2f0670ea9bb3d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face does not have an appropriate link.  <a href="#a4b05fffb0dc7b9cd2f0670ea9bb3d4ef">More...</a><br/></td></tr>
<tr class="separator:a4b05fffb0dc7b9cd2f0670ea9bb3d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaad1f75fdd8c3d43d306b67d96a5c72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceOrientability.html#acaad1f75fdd8c3d43d306b67d96a5c72">isLinkOrientable</a> () const</td></tr>
<tr class="memdesc:acaad1f75fdd8c3d43d306b67d96a5c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the link of this face is orientable.  <a href="#acaad1f75fdd8c3d43d306b67d96a5c72">More...</a><br/></td></tr>
<tr class="separator:acaad1f75fdd8c3d43d306b67d96a5c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29dbd59ab567de78a4cf083988a0e8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html#abf29dbd59ab567de78a4cf083988a0e8">markedIndex</a> () const </td></tr>
<tr class="memdesc:abf29dbd59ab567de78a4cf083988a0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="#abf29dbd59ab567de78a4cf083988a0e8">More...</a><br/></td></tr>
<tr class="separator:abf29dbd59ab567de78a4cf083988a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b">ordering</a> (unsigned <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a6628902d37fef49b158697d3ad5c3fd9">face</a>)</td></tr>
<tr class="memdesc:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <em>subdim</em>-face number within a <em>dim</em>-dimensional simplex, returns the corresponding canonical ordering of the simplex vertices.  <a href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b">More...</a><br/></td></tr>
<tr class="separator:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7466eaf4d128e641797687eb31f13e7e"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7466eaf4d128e641797687eb31f13e7e">faceNumber</a> (<a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; vertices)</td></tr>
<tr class="memdesc:ga7466eaf4d128e641797687eb31f13e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies which <em>subdim</em>-face in a <em>dim</em>-dimensional simplex is represented by the first (<em>subdim</em> + 1) elements of the given permutation.  <a href="group__detail.html#ga7466eaf4d128e641797687eb31f13e7e">More...</a><br/></td></tr>
<tr class="separator:ga7466eaf4d128e641797687eb31f13e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0bd32f838bfb204c98ddb985ce1ba3c0">containsVertex</a> (unsigned <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a6628902d37fef49b158697d3ad5c3fd9">face</a>, unsigned vertex)</td></tr>
<tr class="memdesc:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given <em>subdim</em>-face of a <em>dim</em>-dimensional simplex contains the given vertex of the simplex.  <a href="group__detail.html#ga0bd32f838bfb204c98ddb985ce1ba3c0">More...</a><br/></td></tr>
<tr class="separator:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga4cdd4377e3549620d4c90f967729df88"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">nFaces</a></td></tr>
<tr class="memdesc:ga4cdd4377e3549620d4c90f967729df88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex.  <a href="#ga4cdd4377e3549620d4c90f967729df88">More...</a><br/></td></tr>
<tr class="separator:ga4cdd4377e3549620d4c90f967729df88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a25c2e07eb96409c1c93b1710ca102724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html#a25c2e07eb96409c1c93b1710ca102724">push_back</a> (const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim-codim &gt; &amp;emb)</td></tr>
<tr class="memdesc:a25c2e07eb96409c1c93b1710ca102724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal routine to help build the skeleton of a triangulation.  <a href="#a25c2e07eb96409c1c93b1710ca102724">More...</a><br/></td></tr>
<tr class="separator:a25c2e07eb96409c1c93b1710ca102724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a26ac5852aa92757743c04baca2e319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html#a8a26ac5852aa92757743c04baca2e319">markBadIdentification</a> ()</td></tr>
<tr class="memdesc:a8a26ac5852aa92757743c04baca2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a non-identity self-identification.  <a href="#a8a26ac5852aa92757743c04baca2e319">More...</a><br/></td></tr>
<tr class="separator:a8a26ac5852aa92757743c04baca2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cefa7ced48da051d277243cba998d6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html#a7cefa7ced48da051d277243cba998d6f">markBadLink</a> ()</td></tr>
<tr class="memdesc:a7cefa7ced48da051d277243cba998d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a bad link.  <a href="#a7cefa7ced48da051d277243cba998d6f">More...</a><br/></td></tr>
<tr class="separator:a7cefa7ced48da051d277243cba998d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f328344dd6d04f49de244edda465b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceOrientability.html#a3f328344dd6d04f49de244edda465b15">markLinkNonorientable</a> ()</td></tr>
<tr class="memdesc:a3f328344dd6d04f49de244edda465b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the link of this face as non-orientable.  <a href="#a3f328344dd6d04f49de244edda465b15">More...</a><br/></td></tr>
<tr class="separator:a3f328344dd6d04f49de244edda465b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:a1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a830f8fd15be1fd552a1b44d4801d89e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:a830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;&gt;<br/>
class regina::Face&lt; 3, 0 &gt;</h3>

<p>Represents a vertex in the skeleton of a 3-manifold triangulation. </p>
<p>This is a specialisation of the generic <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a> class template; see the documentation for <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a> for a general overview of how this class works.</p>
<p>These specialisations for Regina's <a class="el" href="stddim.html">standard dimensions</a> offer significant extra functionality. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645c">LinkType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Categorises the possible links of a vertex into a small number of common types. </p>
<p>Here a vertex link is considered only up to its topology (not the combinatorics of its triangulation).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#af79dbbc03c3f1b6fc484d60c07006e94" title="Returns a broad categorisation of the link of the vertex.">link</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645ca2bf5faa23b062281a1a2320d1337bc05"></a>SPHERE</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that is a sphere. </p>
<p>In other words, the vertex is internal. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645ca8672c0ae2f51ee6e3f9af4941bfb76d2"></a>DISC</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that is a disc. </p>
<p>In other words, the vertex lies on a real boundary component. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645ca82cce2a6053a92d04efaa1135d425220"></a>TORUS</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that is a torus. </p>
<p>In other words, this is an ideal vertex representing a torus cusp. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645caccb5da4a6cddf14df333422dd5c24aec"></a>KLEIN_BOTTLE</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that is a Klein bottle. </p>
<p>In other words, this is an ideal vertex representing a Klein bottle cusp. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645caf19fa3672680ee945e836b6fbae0ef17"></a>NON_STANDARD_CUSP</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that is closed and is not a sphere, torus or Klein bottle. </p>
<p>In other words, this is an ideal vertex but not one of the standard ideal vertex types. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3a34beeab677315bd4b5e0091ea1645ca1971e44e60c0052a04c8f02e20e0e2a3"></a>INVALID</em>&nbsp;</td><td class="fielddoc">
<p>Specifies a vertex link that has boundary and is not a disc. </p>
<p>In other words, this vertex makes the triangulation invalid. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab375e6c4829ff149955889353050935c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::~<a class="el" href="classregina_1_1Face.html">Face</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a54dcfef4931d8b36e453ead4dac26736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;dim, dim - codim&gt;&amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last appearance of this face within a top-dimensional simplex of the underlying triangluation. </p>
<p>This is equivalent to calling <code>embedding(degree()-1)</code>.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where the appearances of a face are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle). In particular, for a boundary face of codimension 2, both front() and back() will refer to the two appearances of this face on the (<em>dim</em>-1)-dimensional boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the last appearance. </dd></dl>

</div>
</div>
<a class="anchor" id="a520fc9ee5ab6bcee50ca27de710e4927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;dim, dim - codim&gt; &gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A begin function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation. </p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<p>An iteration from begin() to end() will run through degree() appearances in total.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. However, Python users can call the Python-only routine embeddings(), which will return all appearances (from begin() through to end()) in a Python sequence.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a iterator that points to the first appearance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa34356247cebdc4002c479c6e6bd9674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boundary component of the triangulation to which this face belongs. </p>
<p>See the note in the BoundaryComponent overview regarding what happens if the link of the face itself has more than one boundary component. Note that such a link makes both the face and the underlying triangulation invalid.</p>
<p>For dimensions in which ideal and/or invalid vertices are both possible and recognised: an ideal vertex will have its own individual boundary component to which it belongs, and so will an invalid vertex boundary component if the invalid vertex does not already belong to some real boundary component.</p>
<dl class="section return"><dt>Returns</dt><dd>the boundary component containing this face, or 0 if this face does not lie entirely within the boundary of the triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a703d334cadcf7416314b85e52623ad02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; * <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::buildLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex. </p>
<p>This routine is fast (it uses a pre-computed triangulation if possible). The downside is that the triangulation is read-only, and does not contain any information on how the triangles in the link correspond to tetrahedra in the original triangulation (though this is easily deduced; see below). If you want a writable triangulation, or one with this extra information, then call <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#aa6d25e530de9262dc74acfbbae6fdf59" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLinkDetail()</a> instead.</p>
<p>The triangulation of the vertex link is built as follows. Let <em>i</em> lie between 0 and <a class="el" href="classregina_1_1detail_1_1FaceStorage.html#aac96492727dc5fdfc20c611e37633602" title="Returns the degree of this face.">degree()</a>-1 inclusive, let <em>tet</em> represent <code>embedding(i).tetrahedron()</code>, and let <em>v</em> represent <code>embedding(i).vertex()</code>. Then <code><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> is the triangle in the vertex link that "slices off" vertex <em>v</em> from tetrahedron <em>tet</em>. In other words, <code><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> in the vertex link is parallel to triangle <code>tet-&gt;triangle(v)</code> in the surrounding 3-manifold triangulation.</p>
<p>The vertices of each triangle in the vertex link are numbered as follows. Following the discussion above, suppose that <code><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> sits within <code>tet</code> and is parallel to <code>tet-&gt;triangle(v)</code>. Then vertices 0,1,2 of the triangle in the link will be parallel to vertices 0,1,2 of the corresponding Triangle&lt;3&gt;. The permutation <code>tet-&gt;triangleMapping(v)</code> will map vertices 0,1,2 of the triangle in the link to the corresponding vertices of <code>tet</code> (those opposite <code>v</code>), and will map 3 to <code>v</code> itself.</p>
<p>This Vertex&lt;3&gt; object will retain ownership of the triangulation that is returned. If you wish to edit the triangulation, you should make a new clone and edit the clone instead.</p>
<dl class="section user"><dt>Python:</dt><dd>Since Python does not distinguish between const and non-const, this routine will make a deep copy of the vertex link. You are free to modify the triangulation that is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the read-only triangulated link of the vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6d25e530de9262dc74acfbbae6fdf59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::buildLinkDetail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; **&#160;</td>
          <td class="paramname"><em>inclusion</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex. </p>
<p>This routine is heavyweight (it computes a new triangulation each time). The benefit is that the triangulation is writeable, and optionally contain detailed information on how the triangles in the link correspond to tetrahedra in the original triangulation. If you do not need this extra information, consider using the faster <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a> instead.</p>
<p>See the <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a> documentation for an explanation of exactly how the triangulation will be constructed.</p>
<p>If <em>labels</em> is passed as <code>true</code>, each triangle of the new vertex link will be given a text description of the form <code>t&#160;(v)</code>, where <code>t</code> is the index of the tetrahedron the triangle is from, and <code>v</code> is the vertex of that tetrahedron that this triangle links.</p>
<p>If <em>inclusion</em> is non-null (i.e., it points to some <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> pointer <em>p</em>), then it will be modified to point to a new <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> that describes in detail how the individual triangles of the link sit within tetrahedra of the original triangulation. Specifically, after this routine is called, <code>p-&gt;tetImage(i)</code> will indicate which tetrahedron <em>tet</em> of the 3-manifold triangulation contains the <em>i</em>th triangle of the link. Moreover, <code>p-&gt;facePerm(i)</code> will indicate exactly where the <em>i</em>th triangle sits within <em>tet:</em> it will send 3 to the vertex of <em>t</em> that the triangle links, and it will send 0,1,2 to the vertices of <em>tet</em> that are parallel to vertices 0,1,2 of this triangle.</p>
<p>The triangulation that is returned, as well as the isomorphism if one was requested, will be newly allocated. The caller of this routine is responsible for destroying these objects.</p>
<p>Strictly speaking, this is an abuse of the <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> class (the domain is a triangulation of the wrong dimension, and the map is not 1-to-1 into the range tetrahedra). We use it anyway, but you should not attempt to call any high-level routines (such as <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html#a298819ac0a9b208dd0b6ebe7dafd8480" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation...">Isomorphism&lt;3&gt;::apply</a>).</p>
<dl class="section user"><dt>Python:</dt><dd>The second (isomorphism) argument is not present. Instead this routine returns a pair (triangulation, isomorphism). As a side-effect, the isomorphism will always be constructed (i.e., it is not optional).</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since Python does not distinguish between const and non-const, this routine will make a deep copy of the vertex link. You are free to modify the triangulation that is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation of the link of this vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="ad219b3f19e64cdf25d153859772b9112"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the component of the triangulation to which this face belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this face. </dd></dl>

</div>
</div>
<a class="anchor" id="aac96492727dc5fdfc20c611e37633602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the degree of this face. </p>
<p>This is the number of different ways in which the face appears within the various top-dimensional simplices of the underlying triangulation.</p>
<p>Note that if this face appears multiple times within the same top-dimensional simplex, then it will be counted multiple times by this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the degree of this face. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4f3a919a1bc44bb47cb2c47b55ce6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;dim, dim - codim&gt;&amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::embedding </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the ways in which this face appears within a top-dimensional simplex of the underlying triangluation. </p>
<p>For convenience, you can also use begin() and end() to iterate through all such appearances.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested appearance. This must be between 0 and degree()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested appearance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6fe1cb4689cfe36d15ae27bbc6de18b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;dim, dim - codim&gt; &gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An end function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation. </p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<p>An iteration from begin() to end() will run through degree() appearances in total.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. However, Python users can call the Python-only routine embeddings(), which will return all appearances (from begin() through to end()) in a Python sequence.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a "beyond the end" iterator that comes immediately after the last appearance. </dd></dl>

</div>
</div>
<a class="anchor" id="a6628902d37fef49b158697d3ad5c3fd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, lowerdim&gt;* <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>lowerdim</em>-face of the underlying triangulation that appears as the given <em>lowerdim</em>-dimensional subface of this face. </p>
<p>The argument <em>face</em> must represent a <em>lowerdim</em>-face number within a <em>subdim</em>-simplex. This <em>lowerdim</em>-face number will be interpreted with respect to the inherent labelling (0, ..., <em>subdim</em>) of the vertices of this <em>subdim</em>-face. See FaceEmbedding&lt;dim, subdim&gt;::vertices() for details on how these map to the vertex numbers of the <em>dim</em>-dimensional simplices that contain this face in the overall triangulation.</p>
<p>See FaceNumbering&lt;subdim, lowerdim&gt; for the conventions of how <em>lowerdim</em>-faces are numbered within a <em>subdim</em>-simplex.</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(lowerdim, face)</code>; that is, the template parameter <em>lowerdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>lowerdim</em>-face of this <em>subdim</em>-face to examine. This should be between 0 and (<em>subdim</em>+1 choose <em>lowerdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>lowerdim</em>-face of the triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e2276fab83ff533df66934156307866"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim + 1&gt; <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::faceMapping </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the given <em>lowerdim</em>-dimensional subface of this face, and returns the mapping between the underlying <em>lowerdim</em>-face of the triangulation and the individual vertices of this face. </p>
<p>The argument <em>face</em> must represent a <em>lowerdim</em>-face number within a <em>subdim</em>-simplex. This <em>lowerdim</em>-face number will be interpreted with respect to the inherent labelling (0, ..., <em>subdim</em>) of the vertices of this <em>subdim</em>-face. See FaceEmbedding&lt;dim, subdim&gt;::vertices() for details on how these map to the vertex numbers of the <em>dim</em>-dimensional simplices that contain this face in the overall triangulation.</p>
<p>Let <em>F</em> denote this <em>subdim</em>-face of the triangulation, and let <em>L</em> denote the <em>lowerdim</em>-face of the triangulation that corresponds to the given subface of <em>F</em>. Then the permutation returned by this routine maps the vertex numbers (0, ..., <em>lowerdim</em>) of <em>L</em> to the corresponding vertex numbers of <em>F</em>. This is with respect to the inherent labellings (0, ..., <em>lowerdim</em>) and (0, ..., <em>subdim</em>) of the vertices of <em>L</em> and <em>F</em> respectively.</p>
<p>In particular, if this routine returns the permutation <em>p</em>, then the images <em>p</em>[0,...,<em>lowerdim</em>] will be some permutation of the vertices Face&lt;subdim, lowerdim&gt;::ordering(face)[0,...,<em>lowerdim</em>].</p>
<p>This routine differs from <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;lowerdim&gt;()</a> in how it handles the images of (<em>lowerdim</em>+1, ..., <em>dim</em>):</p>
<ul>
<li>This routine will map (<em>lowerdim</em>+1, ..., <em>subdim</em>) to the remaining vertices of this face in an arbitrary order, and will map (<em>subdim</em>+1, ..., <em>dim</em>) to (<em>subdim</em>+1, ..., <em>dim</em>) again in an arbitrary order.</li>
</ul>
<ul>
<li>In contrast, <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;lowerdim&gt;()</a> chooses the images of (<em>lowerdim</em>+1, ..., <em>dim</em>) to satisfy an additional orientability constraint.</li>
</ul>
<p>See FaceNumbering&lt;subdim, lowerdim&gt; for the conventions of how <em>lowerdim</em>-faces are numbered within a <em>subdim</em>-simplex.</p>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>faceMapping(lowerdim, face)</code>; that is, the template parameter <em>lowerdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>lowerdim</em>-face of this <em>subdim</em>-face to examine. This should be between 0 and (<em>subdim</em>+1 choose <em>lowerdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>lowerdim</em>-face of the triangulation to the vertices of this <em>subdim</em>-face. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2d57928ddd7deb8071540c338a223f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;dim, dim - codim&gt;&amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first appearance of this face within a top-dimensional simplex of the underlying triangluation. </p>
<p>This is equivalent to calling <code>*begin()</code>, or <code>embedding(0)</code>.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where the appearances of a face are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle). In particular, for a boundary face of codimension 2, both front() and back() will refer to the two appearances of this face on the (<em>dim</em>-1)-dimensional boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the first appearance. </dd></dl>

</div>
</div>
<a class="anchor" id="abc2cf123b674397a74daac2fccfb0174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::hasBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face is identified with itself under a non-identity permutation. </p>
<p>For example, if this face is an edge then this routine tests whether the edge is identified with itself in reverse.</p>
<p>Such a face will always be marked as invalid. Note that, for <a class="el" href="stddim.html">standard dimensions</a> <em>dim</em>, there are other types of invalid faces also. See isValid() for a full discussion of what it means for a face to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face is identified with itself under a non-identity permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b05fffb0dc7b9cd2f0670ea9bb3d4ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::hasBadLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face does not have an appropriate link. </p>
<p>See condition (2) in the documentation for isValid() for a full description of what "appropriate" means.</p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, since testing this condition in arbitrary dimensions is undecidable. For higher dimensions <em>dim</em>, this routine is not present.</p>
<p>A face whose link is not appropriate will always be marked as invalid. Note that there are other types of invalid faces also. See isValid() for a full discussion of what it means for a face to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link of this face is not appropriate. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaa90ce5491297fb08634a2108fae4e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of this face within the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this face. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c22f338840773e0720f2dedc73f8cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::inMaximalForest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a codimension-1-face represents a dual edge in the maximal forest that has been chosen for the dual 1-skeleton of the triangulation. </p>
<p>This routine is only available for faces of codimension 1; that is, (<em>dim</em>-1)-faces of a <em>dim</em>-dimensional triangulation.</p>
<p>When the skeletal structure of a triangulation is first computed, a maximal forest in the dual 1-skeleton of the triangulation is also constructed. Each dual edge in this maximal forest represents a (<em>dim</em>-1)-face of the (primal) triangulation.</p>
<p>This maximal forest will remain fixed until the triangulation changes, at which point it will be recomputed (as will all other skeletal objects, such as connected components and so on). There is no guarantee that, when it is recomputed, the maximal forest will use the same dual edges as before.</p>
<p>This routine identifies whether this (<em>dim</em>-1)-face belongs to the dual forest. In this sense it performs a similar role to Simplex::facetInMaximalForest(), but this routine is typically easier to use.</p>
<p>If the skeleton has already been computed, then this routine is very fast (since it just returns a precomputed answer).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this (<em>dim</em>-1)-face represents a dual edge in the maximal forest. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d18bbe888a506d895e057a98d9b6e77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::isBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face lies entirely on the boundary of the triangulation. </p>
<p>For dimensions in which ideal and/or invalid vertices are both possible and recognised: both ideal and invalid vertices are considered to be on the boundary.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face lies on the boundary. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6964b03eaaad0c3530e062a0d3eebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vertex is an ideal vertex. </p>
<p>This requires the vertex link to be closed and not a 2-sphere.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is an ideal vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a573c2d77c9bdbc41e4d74d57dfc142dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isLinkClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the link of this vertex is closed. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link of this vertex is closed. </dd></dl>

</div>
</div>
<a class="anchor" id="acaad1f75fdd8c3d43d306b67d96a5c72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; allowsNonorientable &gt;::isLinkOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the link of this face is orientable. </p>
<p>This routine is fast: it uses pre-computed information, and does not need to build a full triangulation of the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this face is identified with itself under a non-identity permutation (which makes the face invalid), then the return value of this routine is undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link is orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="afd5fdc65c8a944da07779a5993696427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vertex is standard. </p>
<p>This requires the vertex link to be a sphere, disc, torus or Klein bottle.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this vertex is standard. </dd></dl>

</div>
</div>
<a class="anchor" id="abd439c351f0cb7776982f09272494153"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face is valid. </p>
<p>There are several conditions that might make a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if the face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if the face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of the triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> &ge; 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>subdim</em> and <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If this face is invalid, then it is possible to find out why. In non-standard dimensions, this must mean that the face fails condition (1) above. In standard dimensions, you can call the functions hasBadIdentification() and/or hasBadLink() to determine whether the failure is due to conditions (1) or (2) respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>for standard dimensions <em>dim</em>, returns <code>true</code> if and only if this face is valid according to both conditions (1) and (2) above; for non-standard dimensions <em>dim</em>, returns <code>true</code> if and only if this face is valid according to condition (1). </dd></dl>

</div>
</div>
<a class="anchor" id="af79dbbc03c3f1b6fc484d60c07006e94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a3a34beeab677315bd4b5e0091ea1645c">LinkType</a> <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a broad categorisation of the link of the vertex. </p>
<p>This considers topological information only, not the combinatorics of how the link is triangulated.</p>
<p>This routine does not require a full triangulation of the vertex link, and so can be much faster than analysing the result of <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a broad categorisation of the vertex link. </dd></dl>

</div>
</div>
<a class="anchor" id="adf7eac70f8cab66b6122078096ff2897"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::linkEulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the vertex link. </p>
<p>This routine does not require a full triangulation of the vertex link, and so can be much faster than calling <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html#a703d334cadcf7416314b85e52623ad02" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>.eulerChar().</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the vertex link. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a26ac5852aa92757743c04baca2e319"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::markBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a non-identity self-identification. </p>

</div>
</div>
<a class="anchor" id="a7cefa7ced48da051d277243cba998d6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::markBadLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a bad link. </p>

</div>
</div>
<a class="anchor" id="abf29dbd59ab567de78a4cf083988a0e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedElement::markedIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>. </p>
<p>If this object does not belong to an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>, the return value is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the index at which this object is stored. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f328344dd6d04f49de244edda465b15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; allowsNonorientable &gt;::markLinkNonorientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the link of this face as non-orientable. </p>

</div>
</div>
<a class="anchor" id="a25c2e07eb96409c1c93b1710ca102724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim-codim &gt; &amp;&#160;</td>
          <td class="paramname"><em>emb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal routine to help build the skeleton of a triangulation. </p>
<p>This routine pushes the given object onto the end of the internal list of appearances of this face within top-dimensional simplices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emb</td><td>the appearance to push onto the end of the internal list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bd856e56bf1f13cf26dfebe3b27230b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation to which this face belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this face. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7a1300d8ed77dc894be81d1fb4e5144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>The class <a class="el" href="classregina_1_1Face.html">Face&lt;dim, subdim&gt;</a> may safely override this function, since the output routines cast down to <a class="el" href="classregina_1_1Face.html">Face&lt;dim, subdim&gt;</a> before calling it.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6fa1861e6fc4b44538f1b26fe80d4d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ga4cdd4377e3549620d4c90f967729df88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; dim, subdim, lex &gt;::nFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/dim3/<a class="el" href="vertex3_8h.html">vertex3.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
