<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::NormalSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalSurface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NormalSurface Class Reference<div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single normal surface in a 3-manifold.  
 <a href="classregina_1_1NormalSurface.html#details">More...</a></p>

<p><code>#include &lt;surfaces/normalsurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalSurface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalSurface.png" usemap="#regina::NormalSurface_map" alt=""/>
  <map id="regina::NormalSurface_map" name="regina::NormalSurface_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; NormalSurface &gt;" shape="rect" coords="0,56,236,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalSurface, false &gt;" shape="rect" coords="0,0,236,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a311cdd4d11c01e88da4f5c12031e89e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a311cdd4d11c01e88da4f5c12031e89e3">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *newVector)</td></tr>
<tr class="memdesc:a311cdd4d11c01e88da4f5c12031e89e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector.  <a href="#a311cdd4d11c01e88da4f5c12031e89e3">More...</a><br /></td></tr>
<tr class="separator:a311cdd4d11c01e88da4f5c12031e89e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d249fdec933b17b2dd7a7157061100f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a6d249fdec933b17b2dd7a7157061100f">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coordSystem, List allCoords)</td></tr>
<tr class="memdesc:a6d249fdec933b17b2dd7a7157061100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that creates a new normal surface inside the given triangulation with the given coordinate vector.  <a href="#a6d249fdec933b17b2dd7a7157061100f">More...</a><br /></td></tr>
<tr class="separator:a6d249fdec933b17b2dd7a7157061100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc2b6c49ccae3b357fbfa8902800f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#af2dc2b6c49ccae3b357fbfa8902800f1">~NormalSurface</a> ()</td></tr>
<tr class="memdesc:af2dc2b6c49ccae3b357fbfa8902800f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this normal surface.  <a href="#af2dc2b6c49ccae3b357fbfa8902800f1">More...</a><br /></td></tr>
<tr class="separator:af2dc2b6c49ccae3b357fbfa8902800f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5b4c6b7ac6ae63df0efece67fef06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#aa8f5b4c6b7ac6ae63df0efece67fef06">clone</a> () const</td></tr>
<tr class="memdesc:aa8f5b4c6b7ac6ae63df0efece67fef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this normal surface.  <a href="#aa8f5b4c6b7ac6ae63df0efece67fef06">More...</a><br /></td></tr>
<tr class="separator:aa8f5b4c6b7ac6ae63df0efece67fef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a62b05e3ae22fb0c59bb08c28f88ccdbc">doubleSurface</a> () const</td></tr>
<tr class="memdesc:a62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated surface that is the double of this surface.  <a href="#a62b05e3ae22fb0c59bb08c28f88ccdbc">More...</a><br /></td></tr>
<tr class="separator:a62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8">triangles</a> (size_t tetIndex, int vertex) const</td></tr>
<tr class="memdesc:aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8">More...</a><br /></td></tr>
<tr class="separator:aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a22958ed66c5118c06e8fc861b5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a778a22958ed66c5118c06e8fc861b5b7">orientedTriangles</a> (size_t tetIndex, int vertex, bool orientation) const</td></tr>
<tr class="memdesc:a778a22958ed66c5118c06e8fc861b5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="#a778a22958ed66c5118c06e8fc861b5b7">More...</a><br /></td></tr>
<tr class="separator:a778a22958ed66c5118c06e8fc861b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8380567805860ecdbde4bde09a5fc9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c">quads</a> (size_t tetIndex, int quadType) const</td></tr>
<tr class="memdesc:ac8380567805860ecdbde4bde09a5fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="#ac8380567805860ecdbde4bde09a5fc9c">More...</a><br /></td></tr>
<tr class="separator:ac8380567805860ecdbde4bde09a5fc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1782b65da2df0fe8921002d28139938e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a1782b65da2df0fe8921002d28139938e">orientedQuads</a> (size_t tetIndex, int quadType, bool orientation) const</td></tr>
<tr class="memdesc:a1782b65da2df0fe8921002d28139938e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#a1782b65da2df0fe8921002d28139938e">More...</a><br /></td></tr>
<tr class="separator:a1782b65da2df0fe8921002d28139938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae51e35ce30784d586dfca6576243ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee">octs</a> (size_t tetIndex, int octType) const</td></tr>
<tr class="memdesc:abae51e35ce30784d586dfca6576243ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="#abae51e35ce30784d586dfca6576243ee">More...</a><br /></td></tr>
<tr class="separator:abae51e35ce30784d586dfca6576243ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0471c5364a23009d61817fa084cdcc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ab0471c5364a23009d61817fa084cdcc9">edgeWeight</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:ab0471c5364a23009d61817fa084cdcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="#ab0471c5364a23009d61817fa084cdcc9">More...</a><br /></td></tr>
<tr class="separator:ab0471c5364a23009d61817fa084cdcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a0872585e068bfc47cfdc417c63dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a00a0872585e068bfc47cfdc417c63dd0">arcs</a> (size_t triIndex, int triVertex) const</td></tr>
<tr class="memdesc:a00a0872585e068bfc47cfdc417c63dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#a00a0872585e068bfc47cfdc417c63dd0">More...</a><br /></td></tr>
<tr class="separator:a00a0872585e068bfc47cfdc417c63dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a06c1a51568cc60c9699b083876a16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a1a06c1a51568cc60c9699b083876a16c">octPosition</a> () const</td></tr>
<tr class="memdesc:a1a06c1a51568cc60c9699b083876a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first coordinate position at which this surface has a non-zero octagonal coordinate.  <a href="#a1a06c1a51568cc60c9699b083876a16c">More...</a><br /></td></tr>
<tr class="separator:a1a06c1a51568cc60c9699b083876a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c32deec0eb7a70975316c73614dcca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ac3c32deec0eb7a70975316c73614dcca">countCoords</a> () const</td></tr>
<tr class="memdesc:ac3c32deec0eb7a70975316c73614dcca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used.  <a href="#ac3c32deec0eb7a70975316c73614dcca">More...</a><br /></td></tr>
<tr class="separator:ac3c32deec0eb7a70975316c73614dcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78737ee6d2d74ef5b7b5d9748a0daa10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a78737ee6d2d74ef5b7b5d9748a0daa10">triangulation</a> () const</td></tr>
<tr class="memdesc:a78737ee6d2d74ef5b7b5d9748a0daa10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal surface resides.  <a href="#a78737ee6d2d74ef5b7b5d9748a0daa10">More...</a><br /></td></tr>
<tr class="separator:a78737ee6d2d74ef5b7b5d9748a0daa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66f7c42869115a48a9260432252e4b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a1b66f7c42869115a48a9260432252e4b">name</a> () const</td></tr>
<tr class="memdesc:a1b66f7c42869115a48a9260432252e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal surface.  <a href="#a1b66f7c42869115a48a9260432252e4b">More...</a><br /></td></tr>
<tr class="separator:a1b66f7c42869115a48a9260432252e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5317f117563f37bd5486fed52b6cf81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a5317f117563f37bd5486fed52b6cf81e">setName</a> (const std::string &amp;newName)</td></tr>
<tr class="memdesc:a5317f117563f37bd5486fed52b6cf81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal surface.  <a href="#a5317f117563f37bd5486fed52b6cf81e">More...</a><br /></td></tr>
<tr class="separator:a5317f117563f37bd5486fed52b6cf81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b1867108288341c2706866539106fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a81b1867108288341c2706866539106fa">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a81b1867108288341c2706866539106fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this surface to the given output stream, using standard triangle-quad-oct coordinates.  <a href="#a81b1867108288341c2706866539106fa">More...</a><br /></td></tr>
<tr class="separator:a81b1867108288341c2706866539106fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c634e7cf69ee372834d25107d8b1d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a7c634e7cf69ee372834d25107d8b1d69">writeRawVector</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a7c634e7cf69ee372834d25107d8b1d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the underlying coordinate vector to the given output stream in text format.  <a href="#a7c634e7cf69ee372834d25107d8b1d69">More...</a><br /></td></tr>
<tr class="separator:a7c634e7cf69ee372834d25107d8b1d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649c72e89a76adcddbe5afb8ceae23b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ab649c72e89a76adcddbe5afb8ceae23b">writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ab649c72e89a76adcddbe5afb8ceae23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal surface and all of its properties.  <a href="#ab649c72e89a76adcddbe5afb8ceae23b">More...</a><br /></td></tr>
<tr class="separator:ab649c72e89a76adcddbe5afb8ceae23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24929a9b7ed24295c1010b205179b2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ad24929a9b7ed24295c1010b205179b2c">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad24929a9b7ed24295c1010b205179b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is empty (has no discs whatsoever).  <a href="#ad24929a9b7ed24295c1010b205179b2c">More...</a><br /></td></tr>
<tr class="separator:ad24929a9b7ed24295c1010b205179b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abc1a8ab16f13d8108df83290ec013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a40abc1a8ab16f13d8108df83290ec013">isCompact</a> () const</td></tr>
<tr class="memdesc:a40abc1a8ab16f13d8108df83290ec013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is compact (has finitely many discs).  <a href="#a40abc1a8ab16f13d8108df83290ec013">More...</a><br /></td></tr>
<tr class="separator:a40abc1a8ab16f13d8108df83290ec013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553c0aff30c704a13d4833f84263c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#aa553c0aff30c704a13d4833f84263c7a">eulerChar</a> () const</td></tr>
<tr class="memdesc:aa553c0aff30c704a13d4833f84263c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this surface.  <a href="#aa553c0aff30c704a13d4833f84263c7a">More...</a><br /></td></tr>
<tr class="separator:aa553c0aff30c704a13d4833f84263c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58653ebccb7decb1d64d1ac20f87ea5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a58653ebccb7decb1d64d1ac20f87ea5f">isOrientable</a> () const</td></tr>
<tr class="memdesc:a58653ebccb7decb1d64d1ac20f87ea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is orientable.  <a href="#a58653ebccb7decb1d64d1ac20f87ea5f">More...</a><br /></td></tr>
<tr class="separator:a58653ebccb7decb1d64d1ac20f87ea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116c8925b42deeee786f3d4642b5bfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a116c8925b42deeee786f3d4642b5bfd7">isTwoSided</a> () const</td></tr>
<tr class="memdesc:a116c8925b42deeee786f3d4642b5bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is two-sided.  <a href="#a116c8925b42deeee786f3d4642b5bfd7">More...</a><br /></td></tr>
<tr class="separator:a116c8925b42deeee786f3d4642b5bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9cd3d6628242dff5c7248c5bcb62c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a8de9cd3d6628242dff5c7248c5bcb62c">isConnected</a> () const</td></tr>
<tr class="memdesc:a8de9cd3d6628242dff5c7248c5bcb62c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is connected.  <a href="#a8de9cd3d6628242dff5c7248c5bcb62c">More...</a><br /></td></tr>
<tr class="separator:a8de9cd3d6628242dff5c7248c5bcb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015d445ca92c0e77a8f8638ac9e562a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a0015d445ca92c0e77a8f8638ac9e562a">hasRealBoundary</a> () const</td></tr>
<tr class="memdesc:a0015d445ca92c0e77a8f8638ac9e562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation.  <a href="#a0015d445ca92c0e77a8f8638ac9e562a">More...</a><br /></td></tr>
<tr class="separator:a0015d445ca92c0e77a8f8638ac9e562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab8b0a34b4c8a0847aba54974f1c009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a8ab8b0a34b4c8a0847aba54974f1c009">isVertexLinking</a> () const</td></tr>
<tr class="memdesc:a8ab8b0a34b4c8a0847aba54974f1c009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is vertex linking.  <a href="#a8ab8b0a34b4c8a0847aba54974f1c009">More...</a><br /></td></tr>
<tr class="separator:a8ab8b0a34b4c8a0847aba54974f1c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98616d2b0b270a6a427133d3cd88cae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#af98616d2b0b270a6a427133d3cd88cae">isVertexLink</a> () const</td></tr>
<tr class="memdesc:af98616d2b0b270a6a427133d3cd88cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this surface is the link of a single vertex.  <a href="#af98616d2b0b270a6a427133d3cd88cae">More...</a><br /></td></tr>
<tr class="separator:af98616d2b0b270a6a427133d3cd88cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82721dfe41b187548593091b7274e6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ab82721dfe41b187548593091b7274e6e">isThinEdgeLink</a> () const</td></tr>
<tr class="memdesc:ab82721dfe41b187548593091b7274e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this surface is the thin link of a single edge.  <a href="#ab82721dfe41b187548593091b7274e6e">More...</a><br /></td></tr>
<tr class="separator:ab82721dfe41b187548593091b7274e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330f08b68053b89d2545c0027bbc3405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a330f08b68053b89d2545c0027bbc3405">isSplitting</a> () const</td></tr>
<tr class="memdesc:a330f08b68053b89d2545c0027bbc3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a splitting surface.  <a href="#a330f08b68053b89d2545c0027bbc3405">More...</a><br /></td></tr>
<tr class="separator:a330f08b68053b89d2545c0027bbc3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f95fd5f3a632adb38a0fc6139cd81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a189f95fd5f3a632adb38a0fc6139cd81">isCentral</a> () const</td></tr>
<tr class="memdesc:a189f95fd5f3a632adb38a0fc6139cd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a central surface.  <a href="#a189f95fd5f3a632adb38a0fc6139cd81">More...</a><br /></td></tr>
<tr class="separator:a189f95fd5f3a632adb38a0fc6139cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a8ccd5e4c57c74080dcc2b2e37a75eeb0">countBoundaries</a> () const</td></tr>
<tr class="memdesc:a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of disjoint boundary curves on this surface.  <a href="#a8ccd5e4c57c74080dcc2b2e37a75eeb0">More...</a><br /></td></tr>
<tr class="separator:a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793261174b6628c83659b523b84ab943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a793261174b6628c83659b523b84ab943">isCompressingDisc</a> (bool knownConnected=false) const</td></tr>
<tr class="memdesc:a793261174b6628c83659b523b84ab943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface represents a compressing disc in the underlying 3-manifold.  <a href="#a793261174b6628c83659b523b84ab943">More...</a><br /></td></tr>
<tr class="separator:a793261174b6628c83659b523b84ab943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40448875fc5e68801492acfd10dc680b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a40448875fc5e68801492acfd10dc680b">isIncompressible</a> () const</td></tr>
<tr class="memdesc:a40448875fc5e68801492acfd10dc680b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is an incompressible surface within the surrounding 3-manifold.  <a href="#a40448875fc5e68801492acfd10dc680b">More...</a><br /></td></tr>
<tr class="separator:a40448875fc5e68801492acfd10dc680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32842aede0b65c4e3c80c73e3216cdb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a32842aede0b65c4e3c80c73e3216cdb4">cutAlong</a> () const</td></tr>
<tr class="memdesc:a32842aede0b65c4e3c80c73e3216cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts the associated triangulation along this surface and returns a newly created resulting triangulation.  <a href="#a32842aede0b65c4e3c80c73e3216cdb4">More...</a><br /></td></tr>
<tr class="separator:a32842aede0b65c4e3c80c73e3216cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd5ac2fff434e5124b15ecc6c25b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a54bd5ac2fff434e5124b15ecc6c25b79">crush</a> () const</td></tr>
<tr class="memdesc:a54bd5ac2fff434e5124b15ecc6c25b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crushes this surface to a point in the associated triangulation and returns a newly created resulting triangulation.  <a href="#a54bd5ac2fff434e5124b15ecc6c25b79">More...</a><br /></td></tr>
<tr class="separator:a54bd5ac2fff434e5124b15ecc6c25b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042f4e0908964b3cec8fcf336f147f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a042f4e0908964b3cec8fcf336f147f22">sameSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:a042f4e0908964b3cec8fcf336f147f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface in fact represent the same normal (or almost normal) surface.  <a href="#a042f4e0908964b3cec8fcf336f147f22">More...</a><br /></td></tr>
<tr class="separator:a042f4e0908964b3cec8fcf336f147f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a8803a3a19f5a6f7db0c2ae0e18499bfa">normal</a> () const</td></tr>
<tr class="memdesc:a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface contains only triangle and/or quadrilateral discs.  <a href="#a8803a3a19f5a6f7db0c2ae0e18499bfa">More...</a><br /></td></tr>
<tr class="separator:a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcf349ea8b66bf635454d805af45bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#acfcf349ea8b66bf635454d805af45bc9">embedded</a> () const</td></tr>
<tr class="memdesc:acfcf349ea8b66bf635454d805af45bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface is embedded.  <a href="#acfcf349ea8b66bf635454d805af45bc9">More...</a><br /></td></tr>
<tr class="separator:acfcf349ea8b66bf635454d805af45bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#aa1aa3f944bc8cd084d2a00aadc0f0eb2">locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface are locally compatible.  <a href="#aa1aa3f944bc8cd084d2a00aadc0f0eb2">More...</a><br /></td></tr>
<tr class="separator:aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda2f060aca3d7228ce8758f67eefeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a7bda2f060aca3d7228ce8758f67eefeb">disjoint</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:a7bda2f060aca3d7228ce8758f67eefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class.  <a href="#a7bda2f060aca3d7228ce8758f67eefeb">More...</a><br /></td></tr>
<tr class="separator:a7bda2f060aca3d7228ce8758f67eefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a0b6b0e73ae35e166dc07e3ac1cd54cae">boundaryIntersections</a> () const</td></tr>
<tr class="memdesc:a0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the information about the boundary slopes of this surface at each cusp of the triangulation.  <a href="#a0b6b0e73ae35e166dc07e3ac1cd54cae">More...</a><br /></td></tr>
<tr class="separator:a0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b0d740fe1591e8aa622a3c6d5eeab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a09b0d740fe1591e8aa622a3c6d5eeab6">rawVector</a> () const</td></tr>
<tr class="memdesc:a09b0d740fe1591e8aa622a3c6d5eeab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the raw vector that sits beneath this normal surface.  <a href="#a09b0d740fe1591e8aa622a3c6d5eeab6">More...</a><br /></td></tr>
<tr class="separator:a09b0d740fe1591e8aa622a3c6d5eeab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca77e328a62cce379c0ab4815caffd8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#aca77e328a62cce379c0ab4815caffd8d">systemAllowsAlmostNormal</a> () const</td></tr>
<tr class="memdesc:aca77e328a62cce379c0ab4815caffd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#aca77e328a62cce379c0ab4815caffd8d">More...</a><br /></td></tr>
<tr class="separator:aca77e328a62cce379c0ab4815caffd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1599fbfed6929c341d4be8aa502f2346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a1599fbfed6929c341d4be8aa502f2346">systemAllowsSpun</a> () const</td></tr>
<tr class="memdesc:a1599fbfed6929c341d4be8aa502f2346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for spun normal surfaces.  <a href="#a1599fbfed6929c341d4be8aa502f2346">More...</a><br /></td></tr>
<tr class="separator:a1599fbfed6929c341d4be8aa502f2346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8041fb1a328bbea67533be9ba597f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#adc8041fb1a328bbea67533be9ba597f3">systemAllowsOriented</a> () const</td></tr>
<tr class="memdesc:adc8041fb1a328bbea67533be9ba597f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for transversely oriented normal surfaces.  <a href="#adc8041fb1a328bbea67533be9ba597f3">More...</a><br /></td></tr>
<tr class="separator:adc8041fb1a328bbea67533be9ba597f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa619d75e08df3c56a4ceb6e03122af7a"><td class="memItemLeft" align="right" valign="top"><a id="aa619d75e08df3c56a4ceb6e03122af7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NormalSurface</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=delete</td></tr>
<tr class="separator:aa619d75e08df3c56a4ceb6e03122af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2b9201704d6db18a95de6689440523"><td class="memItemLeft" align="right" valign="top"><a id="a1e2b9201704d6db18a95de6689440523"></a>
<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=delete</td></tr>
<tr class="separator:a1e2b9201704d6db18a95de6689440523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6cfc95271eee926bea070c37f12d94bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a6cfc95271eee926bea070c37f12d94bc">calculateOctPosition</a> () const</td></tr>
<tr class="memdesc:a6cfc95271eee926bea070c37f12d94bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the position of the first non-zero octagon coordinate and stores it as a property.  <a href="#a6cfc95271eee926bea070c37f12d94bc">More...</a><br /></td></tr>
<tr class="separator:a6cfc95271eee926bea070c37f12d94bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9e3815b9c61458d68bb7bf195ca21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a2c9e3815b9c61458d68bb7bf195ca21a">calculateEulerChar</a> () const</td></tr>
<tr class="memdesc:a2c9e3815b9c61458d68bb7bf195ca21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Euler characteristic of this surface and stores it as a property.  <a href="#a2c9e3815b9c61458d68bb7bf195ca21a">More...</a><br /></td></tr>
<tr class="separator:a2c9e3815b9c61458d68bb7bf195ca21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca0dcbd2425783033c88d4082b8c247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a5ca0dcbd2425783033c88d4082b8c247">calculateOrientable</a> () const</td></tr>
<tr class="memdesc:a5ca0dcbd2425783033c88d4082b8c247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this surface is orientable and/or two-sided and stores the results as properties.  <a href="#a5ca0dcbd2425783033c88d4082b8c247">More...</a><br /></td></tr>
<tr class="separator:a5ca0dcbd2425783033c88d4082b8c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea8973551e9dc69d3e321f6d05ec4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ae3ea8973551e9dc69d3e321f6d05ec4d">calculateRealBoundary</a> () const</td></tr>
<tr class="memdesc:ae3ea8973551e9dc69d3e321f6d05ec4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this surface has any real boundary and stores the result as a property.  <a href="#ae3ea8973551e9dc69d3e321f6d05ec4d">More...</a><br /></td></tr>
<tr class="separator:ae3ea8973551e9dc69d3e321f6d05ec4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5766df28d3440415fb1e055fa47be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a8b5766df28d3440415fb1e055fa47be5">calculateBoundaries</a> () const</td></tr>
<tr class="memdesc:a8b5766df28d3440415fb1e055fa47be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of disjoint boundary curves and stores the result as a property.  <a href="#a8b5766df28d3440415fb1e055fa47be5">More...</a><br /></td></tr>
<tr class="separator:a8b5766df28d3440415fb1e055fa47be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a898d6149eef5330881b0318305a0f910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a898d6149eef5330881b0318305a0f910">vector</a></td></tr>
<tr class="memdesc:a898d6149eef5330881b0318305a0f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal surface in whichever space is appropriate.  <a href="#a898d6149eef5330881b0318305a0f910">More...</a><br /></td></tr>
<tr class="separator:a898d6149eef5330881b0318305a0f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a2bb9ec018706c2e5b2d12d6a1d5a0c63">triangulation_</a></td></tr>
<tr class="memdesc:a2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal surface resides.  <a href="#a2bb9ec018706c2e5b2d12d6a1d5a0c63">More...</a><br /></td></tr>
<tr class="separator:a2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f559575a99f46ef3bf189016d2eee0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a78f559575a99f46ef3bf189016d2eee0">name_</a></td></tr>
<tr class="memdesc:a78f559575a99f46ef3bf189016d2eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this surface.  <a href="#a78f559575a99f46ef3bf189016d2eee0">More...</a><br /></td></tr>
<tr class="separator:a78f559575a99f46ef3bf189016d2eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33abf9e1043c41decc8730cc38685f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a33abf9e1043c41decc8730cc38685f51">octPosition_</a></td></tr>
<tr class="memdesc:a33abf9e1043c41decc8730cc38685f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of the first non-zero octagonal coordinate, or <a class="el" href="structregina_1_1DiscType.html#a4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no non-zero octagonal coordinate.  <a href="#a33abf9e1043c41decc8730cc38685f51">More...</a><br /></td></tr>
<tr class="separator:a33abf9e1043c41decc8730cc38685f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556b33e656f0b26e2ba6d10d265045a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a9556b33e656f0b26e2ba6d10d265045a">eulerChar_</a></td></tr>
<tr class="memdesc:a9556b33e656f0b26e2ba6d10d265045a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic of this surface.  <a href="#a9556b33e656f0b26e2ba6d10d265045a">More...</a><br /></td></tr>
<tr class="separator:a9556b33e656f0b26e2ba6d10d265045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010b5302c8fdcb68d24f52d0f9ce85ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a010b5302c8fdcb68d24f52d0f9ce85ac">boundaries_</a></td></tr>
<tr class="memdesc:a010b5302c8fdcb68d24f52d0f9ce85ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of disjoint boundary curves on this surface.  <a href="#a010b5302c8fdcb68d24f52d0f9ce85ac">More...</a><br /></td></tr>
<tr class="separator:a010b5302c8fdcb68d24f52d0f9ce85ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda9da8ad3e4daf0aac417ad63d08e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#abda9da8ad3e4daf0aac417ad63d08e31">orientable</a></td></tr>
<tr class="memdesc:abda9da8ad3e4daf0aac417ad63d08e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface orientable?  <a href="#abda9da8ad3e4daf0aac417ad63d08e31">More...</a><br /></td></tr>
<tr class="separator:abda9da8ad3e4daf0aac417ad63d08e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc009a0545d1feba9ecb90777e8aa37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a6fc009a0545d1feba9ecb90777e8aa37">twoSided</a></td></tr>
<tr class="memdesc:a6fc009a0545d1feba9ecb90777e8aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface two-sided?  <a href="#a6fc009a0545d1feba9ecb90777e8aa37">More...</a><br /></td></tr>
<tr class="separator:a6fc009a0545d1feba9ecb90777e8aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fe97e906c4ee7b1522508769457844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a12fe97e906c4ee7b1522508769457844">connected</a></td></tr>
<tr class="memdesc:a12fe97e906c4ee7b1522508769457844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface connected?  <a href="#a12fe97e906c4ee7b1522508769457844">More...</a><br /></td></tr>
<tr class="separator:a12fe97e906c4ee7b1522508769457844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a6145fd6eb987cb0320a8b498d6c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#ab1a6145fd6eb987cb0320a8b498d6c59">realBoundary</a></td></tr>
<tr class="memdesc:ab1a6145fd6eb987cb0320a8b498d6c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this surface have real boundary (i.e.  <a href="#ab1a6145fd6eb987cb0320a8b498d6c59">More...</a><br /></td></tr>
<tr class="separator:ab1a6145fd6eb987cb0320a8b498d6c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e3ed674b668351b758b1cf7f3a67b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html#a4c2e3ed674b668351b758b1cf7f3a67b">compact</a></td></tr>
<tr class="memdesc:a4c2e3ed674b668351b758b1cf7f3a67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface compact (i.e.  <a href="#a4c2e3ed674b668351b758b1cf7f3a67b">More...</a><br /></td></tr>
<tr class="separator:a4c2e3ed674b668351b758b1cf7f3a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a04f8801fb7fded49eac81613912fd32e"><td class="memItemLeft" align="right" valign="top"><a id="a04f8801fb7fded49eac81613912fd32e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalSurfaceReader</b></td></tr>
<tr class="separator:a04f8801fb7fded49eac81613912fd32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a single normal surface in a 3-manifold. </p>
<p>Once the underlying triangulation changes, this normal surface object is no longer valid.</p>
<p>The information provided by the various query methods is independent of the underlying coordinate system being used. See the <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> class notes for details of what to do when introducing a new coordinate system.</p>
<p>Note that non-compact surfaces (surfaces with infinitely many discs, such as spun-normal surfaces) are allowed; in these cases, the corresponding coordinate lookup routines will return <a class="el" href="classregina_1_1IntegerBase.html#ac071d748e8a784b5a425b01292aaa76a" title="Globally available infinity.">LargeInteger::infinity</a> where appropriate.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><p class="startdd"><em>Feature:</em> Calculation of Euler characteristic and orientability for non-compact surfaces. </p>
<p class="enddd"><em>Feature (long-term):</em> Determine which faces in the solution space a normal surface belongs to. </p>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a311cdd4d11c01e88da4f5c12031e89e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311cdd4d11c01e88da4f5c12031e89e3">&#9670;&nbsp;</a></span>NormalSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>newVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector. </p>
<p>This normal surface will claim ownership of the given vector (i.e., you should not change or delete the vector yourself afterwards).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector represents a normal surface inside the given triangulation. </dd>
<dd>
The given coordinate vector cannot be the null pointer.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">newVector</td><td>a vector containing the coordinates of the normal surface in whichever space is appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d249fdec933b17b2dd7a7157061100f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d249fdec933b17b2dd7a7157061100f">&#9670;&nbsp;</a></span>NormalSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coordSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>allCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that creates a new normal surface inside the given triangulation with the given coordinate vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate system is one in which Regina is able to enumerate and store normal surfaces (not a system like <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae" title="Represents edge weight coordinates for normal surfaces.">regina::NS_EDGE_WEIGHT</a>, which is for viewing purposes only). </dd>
<dd>
The given coordinate vector represents a normal surface inside the given triangulation (in particular, it satisfies the relevant system of matching equations). This will not be checked, and things <em>will</em> go wrong if you break it.</dd></dl>
<dl class="section user"><dt>C++:\n Not available; this routine is for Python only.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coordSystem</td><td>the coordinate system used by this normal surface. </td></tr>
    <tr><td class="paramname">allCoords</td><td>the corresponding vector of normal coordinates, expressed as a Python list. The list elements will be converted internally to LargeInteger objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2dc2b6c49ccae3b357fbfa8902800f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dc2b6c49ccae3b357fbfa8902800f1">&#9670;&nbsp;</a></span>~NormalSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::~NormalSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this normal surface. </p>
<p>The underlying vector of coordinates will also be deallocated. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00a0872585e068bfc47cfdc417c63dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0872585e068bfc47cfdc417c63dd0">&#9670;&nbsp;</a></span>arcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

</div>
</div>
<a id="a0b6b0e73ae35e166dc07e3ac1cd54cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b0e73ae35e166dc07e3ac1cd54cae">&#9670;&nbsp;</a></span>boundaryIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurface::boundaryIntersections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the information about the boundary slopes of this surface at each cusp of the triangulation. </p>
<p>This is for use with spun-normal surfaces (since for closed surfaces all boundary slopes are zero).</p>
<p>This routine is only available for use with SnapPea triangulations, since it needs to know the specific meridian and longitude on each cusp. This information is <em>only</em> available through the SnapPea kernel, since Regina does not use or store peripheral curves for its own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class. Therefore, if the underlying triangulation (as returned by <a class="el" href="classregina_1_1NormalSurface.html#a78737ee6d2d74ef5b7b5d9748a0daa10" title="Returns the triangulation in which this normal surface resides.">triangulation()</a>) is not of the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, this routine will simply return 0.</p>
<p>All cusps are treated as complete. That is, any Dehn fillings stored in the SnapPea triangulation will be ignored.</p>
<p>The results are returned in a matrix with <em>V</em> rows and two columns, where <em>V</em> is the number of vertices in the triangulation. If row <em>i</em> of the matrix contains the integers <em>M</em> and <em>L</em>, this indicates that at the <em>i</em>th cusp, the boundary curves have algebraic intersection number <em>M</em> with the meridian and <em>L</em> with the longitude. Equivalently, the boundary curves pass <em>L</em> times around the meridian and <em>-M</em> times around the longitude. The rational boundary slope is therefore <code>-L/M</code>, and there are <code>gcd(L,M)</code> boundary curves with this slope.</p>
<p>The orientations of the boundary curves of a spun-normal surface are chosen so that <em>if</em> meridian and longitude are a positive basis as vieved from the cusp, then as one travels along an oriented boundary curve, the spun-normal surface spirals into the cusp to one's right and down into the manifold to one's left.</p>
<p>If the triangulation contains more than one vertex, the rows in the resulting matrix are ordered by cusp index (as stored by SnapPea). You can call SnapPeaTriangulation::cuspVertex() to map these to Regina's vertex indices if needed.</p>
<p>At present, Regina can only compute boundary slopes if the triangulation is oriented, if every vertex link in the triangulation is a torus, and if the underlying coordinate system is for normal surfaces (not almost normal surfaces). If these conditions are not met, this routine will return 0.</p>
<dl class="section author"><dt>Author</dt><dd>William Pettersson and Stephan Tillmann</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated matrix with <em>number_of_vertices</em> rows and two columns as described above, or 0 if the boundary slopes cannot be computed (e.g., if the underlying triangulation is not of type <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, or if it fails to meet the preconditions outlined above). </dd></dl>

</div>
</div>
<a id="a8b5766df28d3440415fb1e055fa47be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5766df28d3440415fb1e055fa47be5">&#9670;&nbsp;</a></span>calculateBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateBoundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of disjoint boundary curves and stores the result as a property. </p>

</div>
</div>
<a id="a2c9e3815b9c61458d68bb7bf195ca21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9e3815b9c61458d68bb7bf195ca21a">&#9670;&nbsp;</a></span>calculateEulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateEulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Euler characteristic of this surface and stores it as a property. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact (has finitely many discs). </dd></dl>

</div>
</div>
<a id="a6cfc95271eee926bea070c37f12d94bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfc95271eee926bea070c37f12d94bc">&#9670;&nbsp;</a></span>calculateOctPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateOctPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the position of the first non-zero octagon coordinate and stores it as a property. </p>

</div>
</div>
<a id="a5ca0dcbd2425783033c88d4082b8c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca0dcbd2425783033c88d4082b8c247">&#9670;&nbsp;</a></span>calculateOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this surface is orientable and/or two-sided and stores the results as properties. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs). </dd></dl>

</div>
</div>
<a id="ae3ea8973551e9dc69d3e321f6d05ec4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ea8973551e9dc69d3e321f6d05ec4d">&#9670;&nbsp;</a></span>calculateRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this surface has any real boundary and stores the result as a property. </p>

</div>
</div>
<a id="aa8f5b4c6b7ac6ae63df0efece67fef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f5b4c6b7ac6ae63df0efece67fef06">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* regina::NormalSurface::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this normal surface. </p>
<p>The name of the normal surface will <em>not</em> be copied to the clone; instead the clone will have an empty name.</p>
<dl class="section return"><dt>Returns</dt><dd>a clone of this normal surface. </dd></dl>

</div>
</div>
<a id="a8ccd5e4c57c74080dcc2b2e37a75eeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccd5e4c57c74080dcc2b2e37a75eeb0">&#9670;&nbsp;</a></span>countBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::countBoundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of disjoint boundary curves on this surface. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal arcs on the boundary. If the normal coordinates are extremely large, (in particular, of a similar order of magnitude as the largest possible long integer), then the behaviour of this routine is undefined.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of disjoint boundary curves. </dd></dl>

</div>
</div>
<a id="ac3c32deec0eb7a70975316c73614dcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c32deec0eb7a70975316c73614dcca">&#9670;&nbsp;</a></span>countCoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::countCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="a54bd5ac2fff434e5124b15ecc6c25b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bd5ac2fff434e5124b15ecc6c25b79">&#9670;&nbsp;</a></span>crush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::crush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crushes this surface to a point in the associated triangulation and returns a newly created resulting triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Crushing the surface will produce a number of tetrahedra, triangular pillows and/or footballs. The pillows and footballs will then be flattened to triangles and edges respectively (resulting in the possible changes mentioned below) to produce a proper triangulation.</p>
<p>Note that the new triangulation will have at most the same number of tetrahedra as the old triangulation, and will have strictly fewer tetrahedra if this surface is not vertex linking.</p>
<p>The act of flattening pillows and footballs as described above can lead to unintended topological side-effects, beyond the effects of merely cutting along this surface and identifying the new boundary surface(s) to points. Examples of these unintended side-effects can include connected sum decompositions, removal of 3-spheres and small Lens spaces and so on; a full list of possible changes is beyond the scope of this API documentation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine can have unintended topological side-effects, as described above. </dd>
<dd>
In exceptional cases with non-orientable 3-manifolds, these side-effects might lead to invalid edges (edges whose midpoints are projective plane cusps).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated resulting triangulation. </dd></dl>

</div>
</div>
<a id="a32842aede0b65c4e3c80c73e3216cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32842aede0b65c4e3c80c73e3216cdb4">&#9670;&nbsp;</a></span>cutAlong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::cutAlong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts the associated triangulation along this surface and returns a newly created resulting triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Note that, unlike crushing a surface to a point, this operation will not change the topology of the underlying 3-manifold beyond simply slicing along this surface.</p>
<dl class="section warning"><dt>Warning</dt><dd>The number of tetrahedra in the new triangulation can be <em>very</em> large.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated resulting triangulation. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7bda2f060aca3d7228ce8758f67eefeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda2f060aca3d7228ce8758f67eefeb">&#9670;&nbsp;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class. </p>
<p>This is a global constraint, and therefore gives a stronger test than <a class="el" href="classregina_1_1NormalSurface.html#aa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">locallyCompatible()</a>. However, this global constraint is also much slower to test; the running time is proportional to the total number of normal discs in both surfaces.</p>
<p>Note that this routine has a number of preconditions. Most importantly, it will only work if both this and the given surface use the <em>same</em> coordinate system. Running this test over two surfaces with different coordinate systems could give unpredictable results, and might crash the program entirely.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation. </dd>
<dd>
Both this and the given normal surface are stored using the same coordinate system (i.e., the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>). </dd>
<dd>
Both this and the given surface are compact (have finitely many discs), embedded, non-empty and connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test alongside this surface for potential intersections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces can be embedded without intersecting anywhere, or <code>false</code> if this and the given surface are forced to intersect at some point. </dd></dl>

</div>
</div>
<a id="a62b05e3ae22fb0c59bb08c28f88ccdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b05e3ae22fb0c59bb08c28f88ccdbc">&#9670;&nbsp;</a></span>doubleSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* regina::NormalSurface::doubleSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated surface that is the double of this surface. </p>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal surface. </dd></dl>

</div>
</div>
<a id="ab0471c5364a23009d61817fa084cdcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0471c5364a23009d61817fa084cdcc9">&#9670;&nbsp;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

</div>
</div>
<a id="acfcf349ea8b66bf635454d805af45bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcf349ea8b66bf635454d805af45bc9">&#9670;&nbsp;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::embedded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting quadrilateral and/or octagon types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is embedded. </dd></dl>

</div>
</div>
<a id="aa553c0aff30c704a13d4833f84263c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa553c0aff30c704a13d4833f84263c7a">&#9670;&nbsp;</a></span>eulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::eulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this surface. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic. </dd></dl>

</div>
</div>
<a id="a0015d445ca92c0e77a8f8638ac9e562a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015d445ca92c0e77a8f8638ac9e562a">&#9670;&nbsp;</a></span>hasRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface has real boundary. </dd></dl>

</div>
</div>
<a id="a189f95fd5f3a632adb38a0fc6139cd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f95fd5f3a632adb38a0fc6139cd81">&#9670;&nbsp;</a></span>isCentral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::isCentral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a central surface. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If this surface is central, the number of tetrahedra that it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that this surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="a40abc1a8ab16f13d8108df83290ec013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40abc1a8ab16f13d8108df83290ec013">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface is compact (has finitely many discs). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal surface is compact. </dd></dl>

</div>
</div>
<a id="a793261174b6628c83659b523b84ab943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793261174b6628c83659b523b84ab943">&#9670;&nbsp;</a></span>isCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompressingDisc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>knownConnected</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface represents a compressing disc in the underlying 3-manifold. </p>
<p>Let this surface be <em>D</em> and let the underlying 3-manifold be <em>M</em> with boundary <em>B</em>. To be a compressing disc, <em>D</em> must be a properly embedded disc in <em>M</em>, and the boundary of <em>D</em> must not bound a disc in <em>B</em>.</p>
<p>The implementation of this routine is somewhat inefficient at present, since it cuts along the disc, retriangulates and then examines the resulting boundary components.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise:</em> Reimplement this to avoid cutting along surfaces. </p>
<p class="enddd"><em>Bug:</em> Check for absurdly large numbers of discs and bail accordingly.</p>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine might cut along the surface and retriangulate, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knownConnected</td><td><code>true</code> if this normal surface is already known to be connected (for instance, if it came from an enumeration of vertex normal surfaces), or <code>false</code> if we should not assume any such information about this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is a compressing disc, or <code>false</code> if this surface is not a compressing disc. </dd></dl>

</div>
</div>
<a id="a8de9cd3d6628242dff5c7248c5bcb62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de9cd3d6628242dff5c7248c5bcb62c">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is connected. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is connected, or <code>false</code> if this surface is disconnected. </dd></dl>

</div>
</div>
<a id="ad24929a9b7ed24295c1010b205179b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24929a9b7ed24295c1010b205179b2c">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal surface is empty (has no discs whatsoever). </p>

</div>
</div>
<a id="a40448875fc5e68801492acfd10dc680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40448875fc5e68801492acfd10dc680b">&#9670;&nbsp;</a></span>isIncompressible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isIncompressible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is an incompressible surface within the surrounding 3-manifold. </p>
<p>At present, this routine is only implemented for surfaces embedded within <em>closed</em> and <em>irreducible</em> 3-manifold triangulations.</p>
<p>Let <em>D</em> be some disc embedded in the underlying 3-manifold, and let <em>B</em> be the boundary of <em>D</em>. We call <em>D</em> a <em>compressing disc</em> for this surface if (i) the intersection of <em>D</em> with this surface is the boundary <em>B</em>, and (ii) although <em>B</em> bounds a disc within the 3-manifold, it does not bound a disc within this surface.</p>
<p>We declare this surface to be <em>incompressible</em> if there are no such compressing discs. For our purposes, spheres are never considered incompressible (so if this surface is a sphere then this routine will always return <code>false</code>).</p>
<p>This test is designed exclusively for two-sided surfaces. If this surface is one-sided, the incompressibility test will be run on its two-sided double cover.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may in some circumstances be extremely slow. This is because the underlying algorithm cuts along this surface, retriangulates (possibly using a very large number of tetrahedra), and then searches for a normal compressing disc in each component of the cut-open triangulation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation is valid and closed, and represents an irreducible 3-manifold. </dd>
<dd>
This normal surface is compact, embedded and connected, and contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is incompressible, or <code>false</code> if this surface is not incompressible (or if it is a sphere). </dd></dl>

</div>
</div>
<a id="a58653ebccb7decb1d64d1ac20f87ea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58653ebccb7decb1d64d1ac20f87ea5f">&#9670;&nbsp;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is orientable. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is orientable, or <code>false</code> if this surface is non-orientable. </dd></dl>

</div>
</div>
<a id="a330f08b68053b89d2545c0027bbc3405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330f08b68053b89d2545c0027bbc3405">&#9670;&nbsp;</a></span>isSplitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isSplitting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a splitting surface. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a splitting surface. </dd></dl>

</div>
</div>
<a id="ab82721dfe41b187548593091b7274e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82721dfe41b187548593091b7274e6e">&#9670;&nbsp;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; regina::NormalSurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this surface is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which this surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If this surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If this surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section user"><dt>Python:\n This routine returns a tuple of size 2.</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="a116c8925b42deeee786f3d4642b5bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116c8925b42deeee786f3d4642b5bfd7">&#9670;&nbsp;</a></span>isTwoSided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is two-sided. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is two-sided, or <code>false</code> if this surface is one-sided. </dd></dl>

</div>
</div>
<a id="af98616d2b0b270a6a427133d3cd88cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98616d2b0b270a6a427133d3cd88cae">&#9670;&nbsp;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * regina::NormalSurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this surface is the link of a single vertex. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a id="a8ab8b0a34b4c8a0847aba54974f1c009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab8b0a34b4c8a0847aba54974f1c009">&#9670;&nbsp;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is vertex linking. </dd></dl>

</div>
</div>
<a id="aa1aa3f944bc8cd084d2a00aadc0f0eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aa3f944bc8cd084d2a00aadc0f0eb2">&#9670;&nbsp;</a></span>locallyCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface are locally compatible. </p>
<p>Local compatibility means that, within each individual tetrahedron of the triangulation, it is possible to arrange the normal discs of both surfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all tetrahedra <em>simultaneously</em>. To test the global constraint, see the (much slower) routine <a class="el" href="classregina_1_1NormalSurface.html#a7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">disjoint()</a> instead.</p>
<p>Local compatibility can be formulated in terms of normal disc types. Two normal (or almost normal) surfaces are locally compatible if and only if they together have at most one quadrilateral or octagonal disc type per tetrahedron.</p>
<p>Note again that this is a local constraint only. In particular, for almost normal surfaces, it does <em>not</em> insist that there is at most one octagonal disc type anywhere within the triangulation.</p>
<p>If one of the two surfaces breaks the local compatibility constraints on its own (for instance, it contains two different quadrilateral disc types within the same tetrahedron), then this routine will return <code>false</code> regardless of what the other surface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test for local compatibility with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two surfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="a1b66f7c42869115a48a9260432252e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66f7c42869115a48a9260432252e4b">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalSurface::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this surface. </dd></dl>

</div>
</div>
<a id="a8803a3a19f5a6f7db0c2ae0e18499bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8803a3a19f5a6f7db0c2ae0e18499bfa">&#9670;&nbsp;</a></span>normal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this surface contains only triangle and/or quadrilateral discs. </p>
<p>This is to distinguish normal surfaces from more general surfaces such as almost normal surfaces (which also contain octagonal pieces).</p>
<p>Even if the underlying coordinate system supports other disc types (such as octagons), this routine will still return <code>true</code> if this particular surface does not use them. This is in contrast to the routine <a class="el" href="classregina_1_1NormalSurfaces.html#a286441732edb4692736f33e769489dde" title="Determines if the coordinate system being used allows for almost normal surfaces, that is,...">NormalSurfaces::allowsAlmostNormal()</a>, which only examines the underlying coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface contains only triangles and/or quadrilaterals. </dd></dl>

</div>
</div>
<a id="a1a06c1a51568cc60c9699b083876a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a06c1a51568cc60c9699b083876a16c">&#9670;&nbsp;</a></span>octPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscType.html">DiscType</a> regina::NormalSurface::octPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first coordinate position at which this surface has a non-zero octagonal coordinate. </p>
<p>In other words, if this routine returns the disc type <em>t</em>, then the octagonal coordinate returned by octs(t.tetIndex, t.type) is non-zero. Here <a class="el" href="structregina_1_1DiscType.html#a71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> represents an octagon type within a tetrahedron, and takes values between 0 and 2 inclusive.</p>
<p>If this surface does not contain any octagons, this routine returns <a class="el" href="structregina_1_1DiscType.html#a4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> instead.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately. Moreover, if the underlying coordinate system does not support almost normal surfaces, then even the first call is fast (it returns <a class="el" href="structregina_1_1DiscType.html#a4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> immediately).</p>
<dl class="section return"><dt>Returns</dt><dd>the position of the first non-zero octagonal coordinate, or <a class="el" href="structregina_1_1DiscType.html#a4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no such coordinate. </dd></dl>

</div>
</div>
<a id="abae51e35ce30784d586dfca6576243ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae51e35ce30784d586dfca6576243ee">&#9670;&nbsp;</a></span>octs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of octagons, defined by how they separate the four tetrahedron vertices into two pairs. Octagon type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to intersect edges <em>i</em> and (5-<em>i</em>) of the tetrahedron twice each, and to intersect the remaining edges once each. This means:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of octagons in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

</div>
</div>
<a id="a1782b65da2df0fe8921002d28139938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1782b65da2df0fe8921002d28139938e">&#9670;&nbsp;</a></span>orientedQuads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>This routine is for coordinate systems that support transversely oriented normal surfaces; for details see "The Thurston norm via normal surfaces", Stephan Tillmann and Daryl Cooper, Pacific Journal of Mathematics 239 (2009), 1-15.</p>
<p>An oriented quadrilateral disc type is identified by specifying a tetrahedron, a quadrilateral type (0, 1 or 2) as described in <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a>, and a boolean orientation. The <code>true</code> orientation indicates a transverse orientation pointing to the edge containing vertex 0 of the tetrahedron, and the <code>false</code> orientation indicates a transverse orientation pointing to the opposite edge.</p>
<p>If the underlying coordinate system does not support transverse orientation, this routine will simply return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the quadrilateral disc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

</div>
</div>
<a id="a778a22958ed66c5118c06e8fc861b5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778a22958ed66c5118c06e8fc861b5b7">&#9670;&nbsp;</a></span>orientedTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>This routine is for coordinate systems that support transversely oriented normal surfaces; for details see "The Thurston norm via normal surfaces", Stephan Tillmann and Daryl Cooper, Pacific Journal of Mathematics 239 (2009), 1-15.</p>
<p>An oriented triangular disc type is identified by specifying a tetrahedron, a vertex of that tetrahedron that the triangle surrounds, and a boolean orientation. The <code>true</code> orientation indicates a transverse orientation pointing to the nearby vertex, and the <code>false</code> orientation indicates a transverse orientation pointing to the opposite face.</p>
<p>If the underlying coordinate system does not support transverse orientation, this routine will simply return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

</div>
</div>
<a id="ac8380567805860ecdbde4bde09a5fc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8380567805860ecdbde4bde09a5fc9c">&#9670;&nbsp;</a></span>quads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of quadrilaterals, defined by how they separate the four tetrahedron vertices into two pairs. Quadrilateral type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to separate edge <em>i</em> of the tetrahedron from edge (5-<em>i</em>). That is:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of quadrilaterals in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

</div>
</div>
<a id="a09b0d740fe1591e8aa622a3c6d5eeab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b0d740fe1591e8aa622a3c6d5eeab6">&#9670;&nbsp;</a></span>rawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurface::rawVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the raw vector that sits beneath this normal surface. </p>
<p>Generally users should not need this function. However, it is provided here in case the need should arise (e.g., for reasons of efficiency).</p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a> does not know what underlying coordinate system its raw vector uses. Unless you already know the coordinate system in advance (i.e., you created the surface yourself), it is best to keep to the coordinate-system-agnostic access functions such as <a class="el" href="classregina_1_1NormalSurfaceVector.html#a3ea2312f446f4f7b1c3066925d7f1e2c" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurfaceVector::triangles()</a> and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a570ee5188151835875872bb11c5849da" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurfaceVector::quads()</a>.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying raw vector. </dd></dl>

</div>
</div>
<a id="a042f4e0908964b3cec8fcf336f147f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042f4e0908964b3cec8fcf336f147f22">&#9670;&nbsp;</a></span>sameSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::sameSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface in fact represent the same normal (or almost normal) surface. </p>
<p>Specifically, this routine examines (or computes) the number of normal or almost normal discs of each type, and returns <code>true</code> if and only if these counts are the same for both surfaces.</p>
<p>It does not matter what coordinate systems the two surfaces use. In particular, it does not matter if this and the given surface use different coordinate systems, and it does not matter if one surface uses an almost normal coordinate system and the other does not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the surface to be compared with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces represent the same normal or almost normal surface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a5317f117563f37bd5486fed52b6cf81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5317f117563f37bd5486fed52b6cf81e">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newName</td><td>the new name to associate with this surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:\n In addition to str(), this is also used as the</dt><dd>Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aca77e328a62cce379c0ab4815caffd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca77e328a62cce379c0ab4815caffd8d">&#9670;&nbsp;</a></span>systemAllowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>This is a property of the coordinate system in which this surface is natively stored, <em>not</em> a property of the surface itself. For example, if this surface has no octagons but is stored using standard almost normal coordinates, then this routine will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="adc8041fb1a328bbea67533be9ba597f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8041fb1a328bbea67533be9ba597f3">&#9670;&nbsp;</a></span>systemAllowsOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="a1599fbfed6929c341d4be8aa502f2346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1599fbfed6929c341d4be8aa502f2346">&#9670;&nbsp;</a></span>systemAllowsSpun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for spun normal surfaces. </p>
<p>This is a property of the coordinate system in which this surface is natively stored, <em>not</em> a property of the surface itself. For example, if this surface is compact but is stored using quad coordinates, then this routine will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun normal surface are supported in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="aa25f8c4dad5d3efcfe3f01aeca20c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>A triangular disc type is identified by specifying a tetrahedron and a vertex of that tetrahedron that the triangle surrounds.</p>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of triangles in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

</div>
</div>
<a id="a78737ee6d2d74ef5b7b5d9748a0daa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78737ee6d2d74ef5b7b5d9748a0daa10">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * regina::NormalSurface::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal surface resides. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a7c634e7cf69ee372834d25107d8b1d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c634e7cf69ee372834d25107d8b1d69">&#9670;&nbsp;</a></span>writeRawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeRawVector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the underlying coordinate vector to the given output stream in text format. </p>
<p>No indication will be given as to which coordinate system is being used or what each coordinate means. No newline will be written.</p>
<dl class="section user"><dt>Python:\n The paramater <em>out</em> does not exist, and is</dt><dd>taken to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81b1867108288341c2706866539106fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b1867108288341c2706866539106fa">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this surface to the given output stream, using standard triangle-quad-oct coordinates. </p>
<p>Octagonal coordinates will only be written if the surface is stored using a coordinate system that supports almost normal surfaces.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab649c72e89a76adcddbe5afb8ceae23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab649c72e89a76adcddbe5afb8ceae23b">&#9670;&nbsp;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal surface and all of its properties. </p>
<p>This routine will be called from within <a class="el" href="classregina_1_1NormalSurfaces.html#aa5539ec7f016ba2e9fca94f00971f4c3" title="Writes a chunk of XML containing the data for this packet only.">NormalSurfaces::writeXMLPacketData()</a>.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a010b5302c8fdcb68d24f52d0f9ce85ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010b5302c8fdcb68d24f52d0f9ce85ac">&#9670;&nbsp;</a></span>boundaries_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;size_t&gt; regina::NormalSurface::boundaries_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of disjoint boundary curves on this surface. </p>

</div>
</div>
<a id="a4c2e3ed674b668351b758b1cf7f3a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2e3ed674b668351b758b1cf7f3a67b">&#9670;&nbsp;</a></span>compact</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::compact</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface compact (i.e. </p>
<p>does it only contain finitely many discs)? </p>

</div>
</div>
<a id="a12fe97e906c4ee7b1522508769457844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fe97e906c4ee7b1522508769457844">&#9670;&nbsp;</a></span>connected</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::connected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface connected? </p>

</div>
</div>
<a id="a9556b33e656f0b26e2ba6d10d265045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9556b33e656f0b26e2ba6d10d265045a">&#9670;&nbsp;</a></span>eulerChar_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&gt; regina::NormalSurface::eulerChar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Euler characteristic of this surface. </p>

</div>
</div>
<a id="a78f559575a99f46ef3bf189016d2eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f559575a99f46ef3bf189016d2eee0">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalSurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this surface. </p>

</div>
</div>
<a id="a33abf9e1043c41decc8730cc38685f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33abf9e1043c41decc8730cc38685f51">&#9670;&nbsp;</a></span>octPosition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="structregina_1_1DiscType.html">DiscType</a>&gt; regina::NormalSurface::octPosition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of the first non-zero octagonal coordinate, or <a class="el" href="structregina_1_1DiscType.html#a4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no non-zero octagonal coordinate. </p>
<p>Here <a class="el" href="structregina_1_1DiscType.html#a71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> is an octagon type between 0 and 2 inclusive. </p>

</div>
</div>
<a id="abda9da8ad3e4daf0aac417ad63d08e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda9da8ad3e4daf0aac417ad63d08e31">&#9670;&nbsp;</a></span>orientable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::orientable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface orientable? </p>

</div>
</div>
<a id="ab1a6145fd6eb987cb0320a8b498d6c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a6145fd6eb987cb0320a8b498d6c59">&#9670;&nbsp;</a></span>realBoundary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::realBoundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this surface have real boundary (i.e. </p>
<p>does it meet any boundary triangles)? </p>

</div>
</div>
<a id="a2bb9ec018706c2e5b2d12d6a1d5a0c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb9ec018706c2e5b2d12d6a1d5a0c63">&#9670;&nbsp;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal surface resides. </p>

</div>
</div>
<a id="a6fc009a0545d1feba9ecb90777e8aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc009a0545d1feba9ecb90777e8aa37">&#9670;&nbsp;</a></span>twoSided</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::twoSided</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface two-sided? </p>

</div>
</div>
<a id="a898d6149eef5330881b0318305a0f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898d6149eef5330881b0318305a0f910">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurface::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal surface in whichever space is appropriate. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="normalsurface_8h.html">normalsurface.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
