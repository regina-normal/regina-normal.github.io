<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::GluingPermSearcher&lt; 3 &gt; Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html">GluingPermSearcher&lt; 3 &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1GluingPermSearcher_3_013_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::GluingPermSearcher&lt; 3 &gt; Class Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A utility class for searching through all possible gluing permutation sets that correspond to a given tetrahedron face pairing.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;census/gluingpermsearcher3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GluingPermSearcher&lt; 3 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GluingPermSearcher_3_013_01_4.png" usemap="#regina::GluingPermSearcher_3C_203_20_3E_map" alt=""/>
  <map id="regina::GluingPermSearcher_3C_203_20_3E_map" name="regina::GluingPermSearcher_3C_203_20_3E_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; GluingPermSearcher&lt; 3 &gt; &gt;" shape="rect" coords="155,56,455,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GluingPermSearcher&lt; 3 &gt;, false &gt;" shape="rect" coords="155,0,455,24"/>
<area href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f..." alt="regina::CompactSearcher" shape="rect" coords="0,168,300,192"/>
<area href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link..." alt="regina::EulerSearcher" shape="rect" coords="310,168,610,192"/>
<area href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed..." alt="regina::ClosedPrimeMinSearcher" shape="rect" coords="0,224,300,248"/>
<area href="classregina_1_1HyperbolicMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only minimal id..." alt="regina::HyperbolicMinSearcher" shape="rect" coords="310,224,610,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff253a267442411a5da7c485ede51238" id="r_aff253a267442411a5da7c485ede51238"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff253a267442411a5da7c485ede51238">GluingPermSearcher</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge)</td></tr>
<tr class="memdesc:aff253a267442411a5da7c485ede51238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <br /></td></tr>
<tr class="separator:aff253a267442411a5da7c485ede51238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada85329cec472f0ef0216796e7caabc" id="r_aada85329cec472f0ef0216796e7caabc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada85329cec472f0ef0216796e7caabc">GluingPermSearcher</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:aada85329cec472f0ef0216796e7caabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <br /></td></tr>
<tr class="separator:aada85329cec472f0ef0216796e7caabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7a99b96a260e7afe855ba9ce24acf" id="r_a20b7a99b96a260e7afe855ba9ce24acf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b7a99b96a260e7afe855ba9ce24acf">~GluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:a20b7a99b96a260e7afe855ba9ce24acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <br /></td></tr>
<tr class="separator:a20b7a99b96a260e7afe855ba9ce24acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a30b20a6f0b9051de8dcddb562cb572" id="r_a8a30b20a6f0b9051de8dcddb562cb572"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a8a30b20a6f0b9051de8dcddb562cb572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572">runSearch</a> (Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8a30b20a6f0b9051de8dcddb562cb572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <br /></td></tr>
<tr class="separator:a8a30b20a6f0b9051de8dcddb562cb572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2298c5145ff75ef61405b8413244b" id="r_a1fa2298c5145ff75ef61405b8413244b"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a1fa2298c5145ff75ef61405b8413244b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fa2298c5145ff75ef61405b8413244b">partialSearch</a> (long maxDepth, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1fa2298c5145ff75ef61405b8413244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a partial search for all possible gluing permutations that satisfy the search criteria, branching only to the given depth and no further.  <br /></td></tr>
<tr class="separator:a1fa2298c5145ff75ef61405b8413244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700bd99a9f6255a07df0ace0a9a442a" id="r_ad700bd99a9f6255a07df0ace0a9a442a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad700bd99a9f6255a07df0ace0a9a442a">isComplete</a> () const</td></tr>
<tr class="memdesc:ad700bd99a9f6255a07df0ace0a9a442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <br /></td></tr>
<tr class="separator:ad700bd99a9f6255a07df0ace0a9a442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aae09c481982555e0a9f744264e8dc" id="r_a68aae09c481982555e0a9f744264e8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68aae09c481982555e0a9f744264e8dc">dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a68aae09c481982555e0a9f744264e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <br /></td></tr>
<tr class="separator:a68aae09c481982555e0a9f744264e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb81ca0d2dc30c293cecd37c45802d0" id="r_a1eb81ca0d2dc30c293cecd37c45802d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0">taggedData</a> () const</td></tr>
<tr class="memdesc:a1eb81ca0d2dc30c293cecd37c45802d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <br /></td></tr>
<tr class="separator:a1eb81ca0d2dc30c293cecd37c45802d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f65e0d9e84e884c5205aa327ba52c6" id="r_a57f65e0d9e84e884c5205aa327ba52c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6">dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a57f65e0d9e84e884c5205aa327ba52c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <br /></td></tr>
<tr class="separator:a57f65e0d9e84e884c5205aa327ba52c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9fda6e57f48ae36ee4cf9a55aa20c9" id="r_a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9">data</a> () const</td></tr>
<tr class="memdesc:a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all internal data in a plain text format.  <br /></td></tr>
<tr class="separator:a1e9fda6e57f48ae36ee4cf9a55aa20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab59c19d79ad769be986408bfff7e9a" id="r_acab59c19d79ad769be986408bfff7e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab59c19d79ad769be986408bfff7e9a">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:acab59c19d79ad769be986408bfff7e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:acab59c19d79ad769be986408bfff7e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf6f38c5460e9bf2dc6ba37cf98f705" id="r_a0bf6f38c5460e9bf2dc6ba37cf98f705"><td class="memItemLeft" align="right" valign="top"><a id="a0bf6f38c5460e9bf2dc6ba37cf98f705" name="a0bf6f38c5460e9bf2dc6ba37cf98f705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GluingPermSearcher</b> (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:a0bf6f38c5460e9bf2dc6ba37cf98f705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60d3731a625ff08c38d84f72a88b2f0" id="r_aa60d3731a625ff08c38d84f72a88b2f0"><td class="memItemLeft" align="right" valign="top"><a id="aa60d3731a625ff08c38d84f72a88b2f0" name="aa60d3731a625ff08c38d84f72a88b2f0"></a>
<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:aa60d3731a625ff08c38d84f72a88b2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3c0db014ab83e17f618477c7412bcf57" id="r_a3c0db014ab83e17f618477c7412bcf57"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a3c0db014ab83e17f618477c7412bcf57"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c0db014ab83e17f618477c7412bcf57">findAllPerms</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c0db014ab83e17f618477c7412bcf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <br /></td></tr>
<tr class="separator:a3c0db014ab83e17f618477c7412bcf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054b62a34fcc7bd6f86c32fb45ccc955" id="r_a054b62a34fcc7bd6f86c32fb45ccc955"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054b62a34fcc7bd6f86c32fb45ccc955">bestSearcher</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; pairing, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt; purge)</td></tr>
<tr class="memdesc:a054b62a34fcc7bd6f86c32fb45ccc955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <br /></td></tr>
<tr class="separator:a054b62a34fcc7bd6f86c32fb45ccc955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809bd79cc004ea30eb752dfd4f018574" id="r_a809bd79cc004ea30eb752dfd4f018574"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a809bd79cc004ea30eb752dfd4f018574">fromTaggedData</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a809bd79cc004ea30eb752dfd4f018574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <br /></td></tr>
<tr class="separator:a809bd79cc004ea30eb752dfd4f018574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d5c83555812ec5537ee85dfa12a71b" id="r_a87d5c83555812ec5537ee85dfa12a71b"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d5c83555812ec5537ee85dfa12a71b">fromTaggedData</a> (std::string <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9">data</a>)</td></tr>
<tr class="memdesc:a87d5c83555812ec5537ee85dfa12a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data stored in the given string.  <br /></td></tr>
<tr class="separator:a87d5c83555812ec5537ee85dfa12a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4c2ac4768e4097f4f37cab2fd795dc81" id="r_a4c2ac4768e4097f4f37cab2fd795dc81"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2ac4768e4097f4f37cab2fd795dc81">dataTag</a> = 'g'</td></tr>
<tr class="memdesc:a4c2ac4768e4097f4f37cab2fd795dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <br /></td></tr>
<tr class="separator:a4c2ac4768e4097f4f37cab2fd795dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ab4a4aee3a8183e5f79b7a171872462a2" id="r_ab4a4aee3a8183e5f79b7a171872462a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> = std::function&lt;void(const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt;&amp;)&gt;</td></tr>
<tr class="memdesc:ab4a4aee3a8183e5f79b7a171872462a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to hold the user's action function and arguments when enumerating gluing permutations.  <br /></td></tr>
<tr class="separator:ab4a4aee3a8183e5f79b7a171872462a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa838ef5adde96dd8681e70413a59bb54" id="r_aa838ef5adde96dd8681e70413a59bb54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa838ef5adde96dd8681e70413a59bb54">searchImpl</a> (long maxDepth, <a class="el" href="#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> &amp;&amp;action)</td></tr>
<tr class="memdesc:aa838ef5adde96dd8681e70413a59bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A de-templatised implementation of <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>.  <br /></td></tr>
<tr class="separator:aa838ef5adde96dd8681e70413a59bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e6c6d0cce1efb0335a09ae6bdcd1f" id="r_a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7e6c6d0cce1efb0335a09ae6bdcd1f">isCanonical</a> () const</td></tr>
<tr class="memdesc:a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <br /></td></tr>
<tr class="separator:a8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941c419f7a3a7d86e850a8d32a6bdd86" id="r_a941c419f7a3a7d86e850a8d32a6bdd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a941c419f7a3a7d86e850a8d32a6bdd86">badEdgeLink</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face) const</td></tr>
<tr class="memdesc:a941c419f7a3a7d86e850a8d32a6bdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <br /></td></tr>
<tr class="separator:a941c419f7a3a7d86e850a8d32a6bdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4089dd2a85f436724655825f082b81" id="r_a9f4089dd2a85f436724655825f082b81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4089dd2a85f436724655825f082b81">lowDegreeEdge</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face, bool testDegree12, bool testDegree3) const</td></tr>
<tr class="memdesc:a9f4089dd2a85f436724655825f082b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <br /></td></tr>
<tr class="separator:a9f4089dd2a85f436724655825f082b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a8d7405efc6728d46be43c6ead90cd" id="r_a25a8d7405efc6728d46be43c6ead90cd"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a8d7405efc6728d46be43c6ead90cd">dataTagInternal</a> () const</td></tr>
<tr class="memdesc:a25a8d7405efc6728d46be43c6ead90cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character used to identify this class when storing tagged data in text format.  <br /></td></tr>
<tr class="separator:a25a8d7405efc6728d46be43c6ead90cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a526564cd5833ff23c26c6f5bd7895add" id="r_a526564cd5833ff23c26c6f5bd7895add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a526564cd5833ff23c26c6f5bd7895add">perms_</a></td></tr>
<tr class="memdesc:a526564cd5833ff23c26c6f5bd7895add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of gluing permutations under construction.  <br /></td></tr>
<tr class="separator:a526564cd5833ff23c26c6f5bd7895add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b55f535b4cc3677b6176b766ba9fec8" id="r_a0b55f535b4cc3677b6176b766ba9fec8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b55f535b4cc3677b6176b766ba9fec8">autos_</a></td></tr>
<tr class="memdesc:a0b55f535b4cc3677b6176b766ba9fec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <br /></td></tr>
<tr class="separator:a0b55f535b4cc3677b6176b766ba9fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7086cef35b30a1e10385ec3f12bce31" id="r_ae7086cef35b30a1e10385ec3f12bce31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7086cef35b30a1e10385ec3f12bce31">orientableOnly_</a></td></tr>
<tr class="memdesc:ae7086cef35b30a1e10385ec3f12bce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <br /></td></tr>
<tr class="separator:ae7086cef35b30a1e10385ec3f12bce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107d4ea96e2006fce01b49508221e604" id="r_a107d4ea96e2006fce01b49508221e604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a107d4ea96e2006fce01b49508221e604">finiteOnly_</a></td></tr>
<tr class="memdesc:a107d4ea96e2006fce01b49508221e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <br /></td></tr>
<tr class="separator:a107d4ea96e2006fce01b49508221e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223af4f18c75892d5eccea336e49151" id="r_a1223af4f18c75892d5eccea336e49151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1223af4f18c75892d5eccea336e49151">purge_</a></td></tr>
<tr class="memdesc:a1223af4f18c75892d5eccea336e49151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? See the constructor documentation for further details on this search parameter.  <br /></td></tr>
<tr class="separator:a1223af4f18c75892d5eccea336e49151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ef778b520739058cf77d70963d7ab6" id="r_a46ef778b520739058cf77d70963d7ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ef778b520739058cf77d70963d7ab6">started</a></td></tr>
<tr class="memdesc:a46ef778b520739058cf77d70963d7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <br /></td></tr>
<tr class="separator:a46ef778b520739058cf77d70963d7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07986d0a577e24601d762c07c43226eb" id="r_a07986d0a577e24601d762c07c43226eb"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07986d0a577e24601d762c07c43226eb">orientation</a></td></tr>
<tr class="memdesc:a07986d0a577e24601d762c07c43226eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <br /></td></tr>
<tr class="separator:a07986d0a577e24601d762c07c43226eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8738eee160530cfdcf10a05f626212da" id="r_a8738eee160530cfdcf10a05f626212da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8738eee160530cfdcf10a05f626212da">order</a></td></tr>
<tr class="memdesc:a8738eee160530cfdcf10a05f626212da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <br /></td></tr>
<tr class="separator:a8738eee160530cfdcf10a05f626212da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1716e934d96c4657abb5e6d0118f18a1" id="r_a1716e934d96c4657abb5e6d0118f18a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1716e934d96c4657abb5e6d0118f18a1">orderSize</a></td></tr>
<tr class="memdesc:a1716e934d96c4657abb5e6d0118f18a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <br /></td></tr>
<tr class="separator:a1716e934d96c4657abb5e6d0118f18a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c8899d3f4b3b789905c0b24d670715" id="r_ad1c8899d3f4b3b789905c0b24d670715"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c8899d3f4b3b789905c0b24d670715">orderElt</a></td></tr>
<tr class="memdesc:ad1c8899d3f4b3b789905c0b24d670715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <br /></td></tr>
<tr class="separator:ad1c8899d3f4b3b789905c0b24d670715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class for searching through all possible gluing permutation sets that correspond to a given tetrahedron face pairing. </p>
<p>Subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> correspond to specialised (and heavily optimised) search algorithms that may be used in sufficiently constrained scenarios. The main class <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> offers a default (but slower) search algorithm that may be used in more general contexts.</p>
<p>The simplest way of performing a search through all possible gluing permutations is by calling the static method <a class="el" href="#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. This will examine the search parameters and ensure that the best possible algorithm is used. For finer control over the program flow, the static method <a class="el" href="#a054b62a34fcc7bd6f86c32fb45ccc955" title="Constructs a search manager of the best possible class for the given search parameters.">bestSearcher()</a> can be used to create a search manager of the most suitable class and then <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> can be called on this object directly. For absolute control, a specific algorithm can be forced by explicitly constructing an object of the corresponding class (and again calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on that object directly).</p>
<p>This class is designed to manage the construction of a large census of triangulations, and so it does not support copying, moving or swapping. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab4a4aee3a8183e5f79b7a171872462a2" name="ab4a4aee3a8183e5f79b7a171872462a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a4aee3a8183e5f79b7a171872462a2">&#9670;&#160;</a></span>ActionWrapper</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::ActionWrapper = std::function&lt;void(const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt;&amp;)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type used to hold the user's action function and arguments when enumerating gluing permutations. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff253a267442411a5da7c485ede51238" name="aff253a267442411a5da7c485ede51238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff253a267442411a5da7c485ede51238">&#9670;&#160;</a></span>GluingPermSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::GluingPermSearcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finiteOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail.</p>
<p>Parameter <em>purge</em> may be used to avoid constructing permutation sets that correspond to triangulations satisfying certain constraints (such as non-minimality). The use of this parameter, combined with parameters <em>orientableOnly</em> and <em>finiteOnly</em>, can significantly speed up the permutation set generation. For some combinations of these parameters entirely different algorithms are used.</p>
<p>Note that not all permutation sets described by parameter <em>purge</em> will be avoided (i.e., you may get gluing permutation sets that you did not want). It is guaranteed however that every permutation set whose corresonding triangulation does <em>not</em> satisfy the <em>purge</em> constraints will be generated.</p>
<p>Similarly, even if <em>finiteOnly</em> is set to <code>true</code>, some non-finite triangulations might still slip through the net (since the full vertex links are not always constructed). However, like <em>purge</em>, setting <em>finiteOnly</em> to <code>true</code> allow the census algorithm to take shortcuts and therefore run faster. The resulting triangulations may be tested for finiteness (and other properties) by calling triangulate().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of tetrahedron faces that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given face pairing, and will generally be the set of all such automorphisms (which you can generate via <code>pairing.findAutomorphisms()</code>). </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">finiteOnly</td><td><code>true</code> if only gluing permutations corresponding to finite triangulations are required, or <code>false</code> if there is no such requirement. Note that regardless of this value, some non-finite triangulations might still be produced; see the notes above for details. </td></tr>
    <tr><td class="paramname">purge</td><td>specifies which permutation sets we may avoid constructing (see the function notes above for details). This should be a bitwise OR of constants from the CensusPurge enumeration, or else <code><a class="el" href="group__census.html#gga5157ce6fdc8425882c834c706985b10ca6adf97f83acf6453d4a6a4b1070f3754" title="Indicates that no triangulations should be ignored.">CensusPurge::None</a></code> (or just empty braces <code>{}</code>) if we should simply generate every possible permutation set. If several purge constants are bitwise ORed together, then permutation sets whose triangulation satisfies <em>any</em> of these constraints might be avoided. Note that not <em>all</em> such permutation sets will be avoided, but enough are avoided that the performance increase is noticeable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aada85329cec472f0ef0216796e7caabc" name="aada85329cec472f0ef0216796e7caabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada85329cec472f0ef0216796e7caabc">&#9670;&#160;</a></span>GluingPermSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::GluingPermSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The data found in the input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. This constructor is fundamentally designed around working through a single input stream as we make our way from base class constructors down to subclass constructors. Python users should use <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead, which incorporate this same text data as part of their richer text format.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b7a99b96a260e7afe855ba9ce24acf" name="a20b7a99b96a260e7afe855ba9ce24acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7a99b96a260e7afe855ba9ce24acf">&#9670;&#160;</a></span>~GluingPermSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::~<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a941c419f7a3a7d86e850a8d32a6bdd86" name="a941c419f7a3a7d86e850a8d32a6bdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941c419f7a3a7d86e850a8d32a6bdd86">&#9670;&#160;</a></span>badEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::badEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>face</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse. </p>
<p>Note that such edges can only occur in non-orientable triangulations.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<p>If <em>finiteOnly_</em> is <code>true</code> in the search criteria, additional tests will be run that can eliminate triangulations with non-orientable vertex links. Although these tests are not searching for bad edge links per se, they can be performed within this routine with very little additional work needing to be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to an edge identified with itself in reverse, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="a054b62a34fcc7bd6f86c32fb45ccc955" name="a054b62a34fcc7bd6f86c32fb45ccc955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054b62a34fcc7bd6f86c32fb45ccc955">&#9670;&#160;</a></span>bestSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finiteOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> instead.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager. </dd></dl>

</div>
</div>
<a id="a1e9fda6e57f48ae36ee4cf9a55aa20c9" name="a1e9fda6e57f48ae36ee4cf9a55aa20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all internal data in a plain text format. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for the appropriate class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>If subclasses override this function, they should write subclass data after superclass data. This means it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will be lost).</p>
<p>This routine returns the same information that <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> writes.</p>
<p>The key difference between <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> and <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> is that <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is available, but the matching input stream constructor is not. Python users should use <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all of this object's internal data in plain text format. </dd></dl>

</div>
</div>
<a id="a25a8d7405efc6728d46be43c6ead90cd" name="a25a8d7405efc6728d46be43c6ead90cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a8d7405efc6728d46be43c6ead90cd">&#9670;&#160;</a></span>dataTagInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dataTagInternal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html#a14d5c4fe5070dd321c8bc2d010e8c495">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1CompactSearcher.html#a0ffe622cd83d5c03f69db80d21a7e1d5">regina::CompactSearcher</a>, <a class="el" href="classregina_1_1EulerSearcher.html#accfc6d817749b340a6d2290bb31436a3">regina::EulerSearcher</a>, and <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#aafb35fb4974fe505202111b50745e6ca">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a57f65e0d9e84e884c5205aa327ba52c6" name="a57f65e0d9e84e884c5205aa327ba52c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f65e0d9e84e884c5205aa327ba52c6">&#9670;&#160;</a></span>dumpData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for the appropriate class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>If subclasses override this function, they should write subclass data after superclass data. This means it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will be lost).</p>
<p>This routine outputs the same information that <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> returns.</p>
<p>The key difference between <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> is that <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. You can instead use <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a>, which returns this same information as a string. However, the matching input stream constructor is not available in Python either, so it is recommended that Python users use <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html#a78cc8a2c28e1b77c523112553758339e">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1CompactSearcher.html#af8172bfeeadd2eca2825b4e2228333d1">regina::CompactSearcher</a>, <a class="el" href="classregina_1_1EulerSearcher.html#a5531da4b1c649408364359cafb5d862d">regina::EulerSearcher</a>, and <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#a6f67121d4c28ba2f28b73d42d5ed93bd">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="a68aae09c481982555e0a9f744264e8dc" name="a68aae09c481982555e0a9f744264e8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68aae09c481982555e0a9f744264e8dc">&#9670;&#160;</a></span>dumpTaggedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<p>This routine outputs the same information that <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> returns.</p>
<p>The key difference between <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> is that <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a>, which returns this same information as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0db014ab83e17f618477c7412bcf57" name="a3c0db014ab83e17f618477c7412bcf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0db014ab83e17f618477c7412bcf57">&#9670;&#160;</a></span>findAllPerms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList</td>          <td class="paramname"><span class="paramname"><em>autos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>orientableOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finiteOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>purge</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given face pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> and then calls <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results via <em>action</em> and <em>args</em>..</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here). </dd></dl>

</div>
</div>
<a id="a809bd79cc004ea30eb752dfd4f018574" name="a809bd79cc004ea30eb752dfd4f018574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809bd79cc004ea30eb752dfd4f018574">&#9670;&#160;</a></span>fromTaggedData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::fromTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The data found in the given input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant of <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> that takes its input as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager, or <code>null</code> if the data in the input stream was invalid or incorrectly formatted. </dd></dl>

</div>
</div>
<a id="a87d5c83555812ec5537ee85dfa12a71b" name="a87d5c83555812ec5537ee85dfa12a71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d5c83555812ec5537ee85dfa12a71b">&#9670;&#160;</a></span>fromTaggedData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; &gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::fromTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data stored in the given string. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format returned by <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="#a57f65e0d9e84e884c5205aa327ba52c6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The data found in the given string is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the tagged data from which to reconstruct a search manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new search manager, or <code>null</code> if the data in the given string was invalid or incorrectly formatted. </dd></dl>

</div>
</div>
<a id="a8c7e6c6d0cce1efb0335a09ae6bdcd1f" name="a8c7e6c6d0cce1efb0335a09ae6bdcd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7e6c6d0cce1efb0335a09ae6bdcd1f">&#9670;&#160;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad700bd99a9f6255a07df0ace0a9a442a" name="ad700bd99a9f6255a07df0ace0a9a442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700bd99a9f6255a07df0ace0a9a442a">&#9670;&#160;</a></span>isComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::isComplete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>action</em> routine when running partial depth-based searches. See <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9f4089dd2a85f436724655825f082b81" name="a9f4089dd2a85f436724655825f082b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4089dd2a85f436724655825f082b81">&#9670;&#160;</a></span>lowDegreeEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::lowDegreeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>face</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>testDegree12</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>testDegree3</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with a low degree edge. </p>
<p>Precisely which types of low degree edges are identified must be specified through parameters <em>testDegree12</em> and <em>testDegree3</em>.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
    <tr><td class="paramname">testDegree12</td><td><code>true</code> if we should test for non-boundary edges of degree 1 or 2. </td></tr>
    <tr><td class="paramname">testDegree3</td><td><code>true</code> if we should test for non-boundary edges of degree 3 involving three distinct tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a low-degree edge as specified by parameters <em>testDegree12</em> and <em>testDegree3</em>, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="a1fa2298c5145ff75ef61405b8413244b" name="a1fa2298c5145ff75ef61405b8413244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa2298c5145ff75ef61405b8413244b">&#9670;&#160;</a></span>partialSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::partialSearch </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>maxDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a partial search for all possible gluing permutations that satisfy the search criteria, branching only to the given depth and no further. </p>
<p>This routine essentially does some but not all of the work of <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. See the <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> documentation for a detailed overview of what the full search aims to achieve.</p>
<p>If <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> enumerates an entire search tree, then you can think of <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> as only enumerating the first <em>maxDepth</em> levels of this search tree. Rather than producing complete gluing permutation sets, this search will produce a series of partially-constructed permutation sets. A partial search can be continued by calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> again on the underlying <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> (perhaps after being frozen, or passed on to a different processor via <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> and <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a>). If necessary, the <em>action</em> routine may call <a class="el" href="#ad700bd99a9f6255a07df0ace0a9a442a" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">isComplete()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<p>If the search tree is shallow enough (or if <em>maxDepth</em> is large enough), it is possible that this routine will produce complete gluing permutation sets.</p>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run. A negative number indicates that a full search should be run. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each permutation set (partial or complete) that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial permutation set argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a30b20a6f0b9051de8dcddb562cb572" name="a8a30b20a6f0b9051de8dcddb562cb572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a30b20a6f0b9051de8dcddb562cb572">&#9670;&#160;</a></span>runSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="#a3c0db014ab83e17f618477c7412bcf57" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a const reference to a <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;3&gt;</a>. This will be the permutation set that was found. If <em>action</em> wishes to keep the permutation set, it should take a deep copy (not a reference), since the permutation set may be changed and reused after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<p>It is possible to run only a partial search, branching to a given depth but no further; for this you should use the separate routine <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>, not <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial gluing permutation set (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each permutation set that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial permutation set argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa838ef5adde96dd8681e70413a59bb54" name="aa838ef5adde96dd8681e70413a59bb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa838ef5adde96dd8681e70413a59bb54">&#9670;&#160;</a></span>searchImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::searchImpl </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>maxDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab4a4aee3a8183e5f79b7a171872462a2">ActionWrapper</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A de-templatised implementation of <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a>. </p>
<p>Here the templated action plus arguments are bundled together in a wrapper whose full type is known in advance.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>See <a class="el" href="#a8a30b20a6f0b9051de8dcddb562cb572" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> and <a class="el" href="#a1fa2298c5145ff75ef61405b8413244b" title="Runs a partial search for all possible gluing permutations that satisfy the search criteria,...">partialSearch()</a> for further details. </p>

<p>Reimplemented in <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html#a0d47b072ebb824979ca0f089f4c2c4da">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1CompactSearcher.html#a9b890328fcc2dedf52a5d08c630333dc">regina::CompactSearcher</a>, <a class="el" href="classregina_1_1EulerSearcher.html#aed8be67de5d3c79fa8a90d84d2953871">regina::EulerSearcher</a>, and <a class="el" href="classregina_1_1HyperbolicMinSearcher.html#a0a38bbe30a8533db040c1f2b48fd3553">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a1eb81ca0d2dc30c293cecd37c45802d0" name="a1eb81ca0d2dc30c293cecd37c45802d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb81ca0d2dc30c293cecd37c45802d0">&#9670;&#160;</a></span>taggedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::taggedData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="#a809bd79cc004ea30eb752dfd4f018574" title="Creates a new search manager based on tagged data read from the given input stream.">fromTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<p>This routine returns the same information that <a class="el" href="#a68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> writes.</p>
<p>The key difference between <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> and <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> is that <a class="el" href="#a1eb81ca0d2dc30c293cecd37c45802d0" title="Returns all internal data in a plain text format, along with a marker to signify which precise class ...">taggedData()</a> preserves all internal information even if this object belongs to a subclass of <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a>, whereas <a class="el" href="#a1e9fda6e57f48ae36ee4cf9a55aa20c9" title="Returns all internal data in a plain text format.">data()</a> only writes information pertaining to this base class.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all of this object's internal data in plain text format. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acab59c19d79ad769be986408bfff7e9a" name="acab59c19d79ad769be986408bfff7e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab59c19d79ad769be986408bfff7e9a">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0b55f535b4cc3677b6176b766ba9fec8" name="a0b55f535b4cc3677b6176b766ba9fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b55f535b4cc3677b6176b766ba9fec8">&#9670;&#160;</a></span>autos_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;3&gt;::IsoList <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying face pairing. </p>

</div>
</div>
<a id="a4c2ac4768e4097f4f37cab2fd795dc81" name="a4c2ac4768e4097f4f37cab2fd795dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2ac4768e4097f4f37cab2fd795dc81">&#9670;&#160;</a></span>dataTag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dataTag = 'g'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="a107d4ea96e2006fce01b49508221e604" name="a107d4ea96e2006fce01b49508221e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107d4ea96e2006fce01b49508221e604">&#9670;&#160;</a></span>finiteOnly_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite triangulations? </p>

</div>
</div>
<a id="a8738eee160530cfdcf10a05f626212da" name="a8738eee160530cfdcf10a05f626212da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8738eee160530cfdcf10a05f626212da">&#9670;&#160;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;3&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to faces. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying face pairing graph, which in turn represents a tetrahedron face and its image under the given face pairing.</p>
<p>The specific tetrahedron face stored in this array for each edge of the underlying face pairing graph will be the smaller of the two identified tetrahedron faces (unless otherwise specified for a particular edge type; see <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> for examples). </p>

</div>
</div>
<a id="ad1c8899d3f4b3b789905c0b24d670715" name="ad1c8899d3f4b3b789905c0b24d670715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c8899d3f4b3b789905c0b24d670715">&#9670;&#160;</a></span>orderElt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a id="a1716e934d96c4657abb5e6d0118f18a1" name="a1716e934d96c4657abb5e6d0118f18a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1716e934d96c4657abb5e6d0118f18a1">&#9670;&#160;</a></span>orderSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a id="ae7086cef35b30a1e10385ec3f12bce31" name="ae7086cef35b30a1e10385ec3f12bce31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7086cef35b30a1e10385ec3f12bce31">&#9670;&#160;</a></span>orientableOnly_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a id="a07986d0a577e24601d762c07c43226eb" name="a07986d0a577e24601d762c07c43226eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07986d0a577e24601d762c07c43226eb">&#9670;&#160;</a></span>orientation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each tetrahedron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply 1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a id="a526564cd5833ff23c26c6f5bd7895add" name="a526564cd5833ff23c26c6f5bd7895add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526564cd5833ff23c26c6f5bd7895add">&#9670;&#160;</a></span>perms_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::perms_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of gluing permutations under construction. </p>

</div>
</div>
<a id="a1223af4f18c75892d5eccea336e49151" name="a1223af4f18c75892d5eccea336e49151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223af4f18c75892d5eccea336e49151">&#9670;&#160;</a></span>purge_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt;<a class="el" href="group__census.html#ga5157ce6fdc8425882c834c706985b10c">CensusPurge</a>&gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::purge_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there any types of triangulation that we may optionally avoid constructing? See the constructor documentation for further details on this search parameter. </p>

</div>
</div>
<a id="a46ef778b520739058cf77d70963d7ab6" name="a46ef778b520739058cf77d70963d7ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ef778b520739058cf77d70963d7ab6">&#9670;&#160;</a></span>started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingpermsearcher3_8h.html">gluingpermsearcher3.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
