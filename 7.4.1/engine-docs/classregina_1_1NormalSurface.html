<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::NormalSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalSurface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::NormalSurface Class Reference<div class="ingroups"><a class="el" href="group__surface.html">Normal Surfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a single normal surface in a 3-manifold triangulation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;surface/normalsurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalSurface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalSurface.png" usemap="#regina::NormalSurface_map" alt=""/>
  <map id="regina::NormalSurface_map" name="regina::NormalSurface_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; NormalSurface &gt;" shape="rect" coords="0,56,236,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalSurface, false &gt;" shape="rect" coords="0,0,236,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cd862446bad0775d113250dc9b4db74" id="r_a2cd862446bad0775d113250dc9b4db74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd862446bad0775d113250dc9b4db74">NormalSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=default</td></tr>
<tr class="memdesc:a2cd862446bad0775d113250dc9b4db74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal surface.  <br /></td></tr>
<tr class="separator:a2cd862446bad0775d113250dc9b4db74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb45d3d57b26d945d2eee12d3f5802d0" id="r_abb45d3d57b26d945d2eee12d3f5802d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb45d3d57b26d945d2eee12d3f5802d0">NormalSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;src, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="#a0e446c1e71f8f7db55f66b30c273549f">triangulation</a>)</td></tr>
<tr class="memdesc:abb45d3d57b26d945d2eee12d3f5802d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal surface, but relocated to the given triangulation.  <br /></td></tr>
<tr class="separator:abb45d3d57b26d945d2eee12d3f5802d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae06d8924609641e1128dc288a5221d" id="r_a7ae06d8924609641e1128dc288a5221d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae06d8924609641e1128dc288a5221d">NormalSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;src, const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;<a class="el" href="#a0e446c1e71f8f7db55f66b30c273549f">triangulation</a>)</td></tr>
<tr class="memdesc:a7ae06d8924609641e1128dc288a5221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given normal surface, but relocated to the given triangulation.  <br /></td></tr>
<tr class="separator:a7ae06d8924609641e1128dc288a5221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49eae62cb857571140b77a1bb3abc69" id="r_ab49eae62cb857571140b77a1bb3abc69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab49eae62cb857571140b77a1bb3abc69">NormalSurface</a> (<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ab49eae62cb857571140b77a1bb3abc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given surface into this new normal surface.  <br /></td></tr>
<tr class="separator:ab49eae62cb857571140b77a1bb3abc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777be00c6c6e45ee9a8e9b9b1df84beb" id="r_a777be00c6c6e45ee9a8e9b9b1df84beb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a777be00c6c6e45ee9a8e9b9b1df84beb">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triang)</td></tr>
<tr class="memdesc:a777be00c6c6e45ee9a8e9b9b1df84beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the empty surface within the given triangulation.  <br /></td></tr>
<tr class="separator:a777be00c6c6e45ee9a8e9b9b1df84beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704d642d9881fc164cb0438db67db9c8" id="r_a704d642d9881fc164cb0438db67db9c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704d642d9881fc164cb0438db67db9c8">NormalSurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;triang)</td></tr>
<tr class="memdesc:a704d642d9881fc164cb0438db67db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the empty surface within the given triangulation.  <br /></td></tr>
<tr class="separator:a704d642d9881fc164cb0438db67db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c7c78fd9bac2f274e39a1a9ffbd403" id="r_a12c7c78fd9bac2f274e39a1a9ffbd403"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a12c7c78fd9bac2f274e39a1a9ffbd403"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12c7c78fd9bac2f274e39a1a9ffbd403">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triang, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:a12c7c78fd9bac2f274e39a1a9ffbd403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:a12c7c78fd9bac2f274e39a1a9ffbd403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2da1eb45b513f8910158a48af924347" id="r_ad2da1eb45b513f8910158a48af924347"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2da1eb45b513f8910158a48af924347">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triang, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:ad2da1eb45b513f8910158a48af924347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:ad2da1eb45b513f8910158a48af924347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e537b48cec2b2d1bace0982a60eaacc" id="r_a4e537b48cec2b2d1bace0982a60eaacc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4e537b48cec2b2d1bace0982a60eaacc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e537b48cec2b2d1bace0982a60eaacc">NormalSurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;triang, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:a4e537b48cec2b2d1bace0982a60eaacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:a4e537b48cec2b2d1bace0982a60eaacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fdc7273cea56ac41f5fcc8d805b393" id="r_a20fdc7273cea56ac41f5fcc8d805b393"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20fdc7273cea56ac41f5fcc8d805b393">NormalSurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;triang, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:a20fdc7273cea56ac41f5fcc8d805b393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding.  <br /></td></tr>
<tr class="separator:a20fdc7273cea56ac41f5fcc8d805b393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5c7d0adf010b3cf9adb1d782b3e5b5" id="r_a4e5c7d0adf010b3cf9adb1d782b3e5b5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4e5c7d0adf010b3cf9adb1d782b3e5b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e5c7d0adf010b3cf9adb1d782b3e5b5">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triang, <a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:a4e5c7d0adf010b3cf9adb1d782b3e5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:a4e5c7d0adf010b3cf9adb1d782b3e5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce2e6c88fe7ef64ccdd87aaac0cc8b2" id="r_abce2e6c88fe7ef64ccdd87aaac0cc8b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce2e6c88fe7ef64ccdd87aaac0cc8b2">NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;triang, <a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:abce2e6c88fe7ef64ccdd87aaac0cc8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:abce2e6c88fe7ef64ccdd87aaac0cc8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915c5ddb5f1f1f64d590395298feda41" id="r_a915c5ddb5f1f1f64d590395298feda41"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a915c5ddb5f1f1f64d590395298feda41"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a915c5ddb5f1f1f64d590395298feda41">NormalSurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;triang, <a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:a915c5ddb5f1f1f64d590395298feda41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:a915c5ddb5f1f1f64d590395298feda41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf8fbd5bd0a34e3fa160386ec72924" id="r_aaabf8fbd5bd0a34e3fa160386ec72924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaabf8fbd5bd0a34e3fa160386ec72924">NormalSurface</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;triang, <a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>)</td></tr>
<tr class="memdesc:aaabf8fbd5bd0a34e3fa160386ec72924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system.  <br /></td></tr>
<tr class="separator:aaabf8fbd5bd0a34e3fa160386ec72924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785fe921cdb394f08f241bd05871fd6a" id="r_a785fe921cdb394f08f241bd05871fd6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785fe921cdb394f08f241bd05871fd6a">operator=</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=default</td></tr>
<tr class="memdesc:a785fe921cdb394f08f241bd05871fd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given normal surface.  <br /></td></tr>
<tr class="separator:a785fe921cdb394f08f241bd05871fd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe10a28b71a5ddfac6cb5fda5965869" id="r_acfe10a28b71a5ddfac6cb5fda5965869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe10a28b71a5ddfac6cb5fda5965869">operator=</a> (<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:acfe10a28b71a5ddfac6cb5fda5965869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given normal surface to this surface.  <br /></td></tr>
<tr class="separator:acfe10a28b71a5ddfac6cb5fda5965869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a6541e5a18984537c70e105c84bced" id="r_ae9a6541e5a18984537c70e105c84bced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a6541e5a18984537c70e105c84bced">swap</a> (<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ae9a6541e5a18984537c70e105c84bced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given normal surface.  <br /></td></tr>
<tr class="separator:ae9a6541e5a18984537c70e105c84bced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dd722a1381b44ed5e0e2243825cd06" id="r_a75dd722a1381b44ed5e0e2243825cd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75dd722a1381b44ed5e0e2243825cd06">doubleSurface</a> () const</td></tr>
<tr class="memdesc:a75dd722a1381b44ed5e0e2243825cd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the double of this surface.  <br /></td></tr>
<tr class="separator:a75dd722a1381b44ed5e0e2243825cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef986687b3c0c5631e426e43b82818ad" id="r_aef986687b3c0c5631e426e43b82818ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef986687b3c0c5631e426e43b82818ad">operator+</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aef986687b3c0c5631e426e43b82818ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of this and the given surface.  <br /></td></tr>
<tr class="separator:aef986687b3c0c5631e426e43b82818ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e838ad77532c318e9a23e192f63b0" id="r_ae33e838ad77532c318e9a23e192f63b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33e838ad77532c318e9a23e192f63b0">operator*</a> (const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;coeff) const</td></tr>
<tr class="memdesc:ae33e838ad77532c318e9a23e192f63b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given integer multiple of this surface.  <br /></td></tr>
<tr class="separator:ae33e838ad77532c318e9a23e192f63b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e87d906c720446b25e1842472445f" id="r_a4d9e87d906c720446b25e1842472445f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d9e87d906c720446b25e1842472445f">operator*=</a> (const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;coeff)</td></tr>
<tr class="memdesc:a4d9e87d906c720446b25e1842472445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this surface into the given integer multiple of itself.  <br /></td></tr>
<tr class="separator:a4d9e87d906c720446b25e1842472445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f070feb9eb0f0a39e5c1ca2fed1919" id="r_a22f070feb9eb0f0a39e5c1ca2fed1919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f070feb9eb0f0a39e5c1ca2fed1919">scaleDown</a> ()</td></tr>
<tr class="memdesc:a22f070feb9eb0f0a39e5c1ca2fed1919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this surface into its smallest positive rational multiple with integer coordinates.  <br /></td></tr>
<tr class="separator:a22f070feb9eb0f0a39e5c1ca2fed1919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25f8c4dad5d3efcfe3f01aeca20c8a8" id="r_aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8">triangles</a> (size_t tetIndex, int vertex) const</td></tr>
<tr class="memdesc:aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of triangular discs of the given type in this normal surface.  <br /></td></tr>
<tr class="separator:aa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8380567805860ecdbde4bde09a5fc9c" id="r_ac8380567805860ecdbde4bde09a5fc9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8380567805860ecdbde4bde09a5fc9c">quads</a> (size_t tetIndex, int quadType) const</td></tr>
<tr class="memdesc:ac8380567805860ecdbde4bde09a5fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of quadrilateral discs of the given type in this normal surface.  <br /></td></tr>
<tr class="separator:ac8380567805860ecdbde4bde09a5fc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae51e35ce30784d586dfca6576243ee" id="r_abae51e35ce30784d586dfca6576243ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae51e35ce30784d586dfca6576243ee">octs</a> (size_t tetIndex, int octType) const</td></tr>
<tr class="memdesc:abae51e35ce30784d586dfca6576243ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of octagonal discs of the given type in this normal surface.  <br /></td></tr>
<tr class="separator:abae51e35ce30784d586dfca6576243ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0471c5364a23009d61817fa084cdcc9" id="r_ab0471c5364a23009d61817fa084cdcc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0471c5364a23009d61817fa084cdcc9">edgeWeight</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:ab0471c5364a23009d61817fa084cdcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times this normal surface crosses the given edge.  <br /></td></tr>
<tr class="separator:ab0471c5364a23009d61817fa084cdcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a0872585e068bfc47cfdc417c63dd0" id="r_a00a0872585e068bfc47cfdc417c63dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a0872585e068bfc47cfdc417c63dd0">arcs</a> (size_t triIndex, int triVertex) const</td></tr>
<tr class="memdesc:a00a0872585e068bfc47cfdc417c63dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arcs in which this normal surface intersects the given triangle in the given direction.  <br /></td></tr>
<tr class="separator:a00a0872585e068bfc47cfdc417c63dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a06c1a51568cc60c9699b083876a16c" id="r_a1a06c1a51568cc60c9699b083876a16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a06c1a51568cc60c9699b083876a16c">octPosition</a> () const</td></tr>
<tr class="memdesc:a1a06c1a51568cc60c9699b083876a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first coordinate position at which this surface has a non-zero octagonal coordinate.  <br /></td></tr>
<tr class="separator:a1a06c1a51568cc60c9699b083876a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e446c1e71f8f7db55f66b30c273549f" id="r_a0e446c1e71f8f7db55f66b30c273549f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e446c1e71f8f7db55f66b30c273549f">triangulation</a> () const</td></tr>
<tr class="memdesc:a0e446c1e71f8f7db55f66b30c273549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation in which this normal surface resides.  <br /></td></tr>
<tr class="separator:a0e446c1e71f8f7db55f66b30c273549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66f7c42869115a48a9260432252e4b" id="r_a1b66f7c42869115a48a9260432252e4b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b66f7c42869115a48a9260432252e4b">name</a> () const</td></tr>
<tr class="memdesc:a1b66f7c42869115a48a9260432252e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name associated with this normal surface.  <br /></td></tr>
<tr class="separator:a1b66f7c42869115a48a9260432252e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc02da051a9ee5351ebd2e945d208e1e" id="r_adc02da051a9ee5351ebd2e945d208e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc02da051a9ee5351ebd2e945d208e1e">setName</a> (const std::string &amp;<a class="el" href="#a1b66f7c42869115a48a9260432252e4b">name</a>)</td></tr>
<tr class="memdesc:adc02da051a9ee5351ebd2e945d208e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal surface.  <br /></td></tr>
<tr class="separator:adc02da051a9ee5351ebd2e945d208e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b1867108288341c2706866539106fa" id="r_a81b1867108288341c2706866539106fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b1867108288341c2706866539106fa">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a81b1867108288341c2706866539106fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this surface to the given output stream, using standard triangle-quad-oct coordinates.  <br /></td></tr>
<tr class="separator:a81b1867108288341c2706866539106fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197a0fbeb7286375ee54cf11c33ef29" id="r_a7197a0fbeb7286375ee54cf11c33ef29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7197a0fbeb7286375ee54cf11c33ef29">writeXMLData</a> (std::ostream &amp;out, <a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a> format, const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *list) const</td></tr>
<tr class="memdesc:a7197a0fbeb7286375ee54cf11c33ef29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal surface and all of its properties.  <br /></td></tr>
<tr class="separator:a7197a0fbeb7286375ee54cf11c33ef29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24929a9b7ed24295c1010b205179b2c" id="r_ad24929a9b7ed24295c1010b205179b2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad24929a9b7ed24295c1010b205179b2c">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad24929a9b7ed24295c1010b205179b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is empty (has no discs whatsoever).  <br /></td></tr>
<tr class="separator:ad24929a9b7ed24295c1010b205179b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e12af8c63e17e3f82b2f97fe52eb3f" id="r_a02e12af8c63e17e3f82b2f97fe52eb3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e12af8c63e17e3f82b2f97fe52eb3f">hasMultipleOctDiscs</a> () const</td></tr>
<tr class="memdesc:a02e12af8c63e17e3f82b2f97fe52eb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <br /></td></tr>
<tr class="separator:a02e12af8c63e17e3f82b2f97fe52eb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abc1a8ab16f13d8108df83290ec013" id="r_a40abc1a8ab16f13d8108df83290ec013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40abc1a8ab16f13d8108df83290ec013">isCompact</a> () const</td></tr>
<tr class="memdesc:a40abc1a8ab16f13d8108df83290ec013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is compact (has finitely many discs).  <br /></td></tr>
<tr class="separator:a40abc1a8ab16f13d8108df83290ec013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553c0aff30c704a13d4833f84263c7a" id="r_aa553c0aff30c704a13d4833f84263c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa553c0aff30c704a13d4833f84263c7a">eulerChar</a> () const</td></tr>
<tr class="memdesc:aa553c0aff30c704a13d4833f84263c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euler characteristic of this surface.  <br /></td></tr>
<tr class="separator:aa553c0aff30c704a13d4833f84263c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58653ebccb7decb1d64d1ac20f87ea5f" id="r_a58653ebccb7decb1d64d1ac20f87ea5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58653ebccb7decb1d64d1ac20f87ea5f">isOrientable</a> () const</td></tr>
<tr class="memdesc:a58653ebccb7decb1d64d1ac20f87ea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this surface is orientable.  <br /></td></tr>
<tr class="separator:a58653ebccb7decb1d64d1ac20f87ea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116c8925b42deeee786f3d4642b5bfd7" id="r_a116c8925b42deeee786f3d4642b5bfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116c8925b42deeee786f3d4642b5bfd7">isTwoSided</a> () const</td></tr>
<tr class="memdesc:a116c8925b42deeee786f3d4642b5bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this surface is two-sided.  <br /></td></tr>
<tr class="separator:a116c8925b42deeee786f3d4642b5bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9cd3d6628242dff5c7248c5bcb62c" id="r_a8de9cd3d6628242dff5c7248c5bcb62c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de9cd3d6628242dff5c7248c5bcb62c">isConnected</a> () const</td></tr>
<tr class="memdesc:a8de9cd3d6628242dff5c7248c5bcb62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this surface is connected.  <br /></td></tr>
<tr class="separator:a8de9cd3d6628242dff5c7248c5bcb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015d445ca92c0e77a8f8638ac9e562a" id="r_a0015d445ca92c0e77a8f8638ac9e562a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0015d445ca92c0e77a8f8638ac9e562a">hasRealBoundary</a> () const</td></tr>
<tr class="memdesc:a0015d445ca92c0e77a8f8638ac9e562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation.  <br /></td></tr>
<tr class="separator:a0015d445ca92c0e77a8f8638ac9e562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f7f421d6a2c85be7df72fa41f88ac5" id="r_a46f7f421d6a2c85be7df72fa41f88ac5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46f7f421d6a2c85be7df72fa41f88ac5">components</a> () const</td></tr>
<tr class="memdesc:a46f7f421d6a2c85be7df72fa41f88ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this surface into connected components.  <br /></td></tr>
<tr class="separator:a46f7f421d6a2c85be7df72fa41f88ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab8b0a34b4c8a0847aba54974f1c009" id="r_a8ab8b0a34b4c8a0847aba54974f1c009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab8b0a34b4c8a0847aba54974f1c009">isVertexLinking</a> () const</td></tr>
<tr class="memdesc:a8ab8b0a34b4c8a0847aba54974f1c009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is vertex linking.  <br /></td></tr>
<tr class="separator:a8ab8b0a34b4c8a0847aba54974f1c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98616d2b0b270a6a427133d3cd88cae" id="r_af98616d2b0b270a6a427133d3cd88cae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gaa2d0c69ce4cea268f94f93dbbcfbc21d">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af98616d2b0b270a6a427133d3cd88cae">isVertexLink</a> () const</td></tr>
<tr class="memdesc:af98616d2b0b270a6a427133d3cd88cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this surface is the link of a single vertex.  <br /></td></tr>
<tr class="separator:af98616d2b0b270a6a427133d3cd88cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82721dfe41b187548593091b7274e6e" id="r_ab82721dfe41b187548593091b7274e6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab82721dfe41b187548593091b7274e6e">isThinEdgeLink</a> () const</td></tr>
<tr class="memdesc:ab82721dfe41b187548593091b7274e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this surface is the thin link of a single edge.  <br /></td></tr>
<tr class="separator:ab82721dfe41b187548593091b7274e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78ead45e91f901445f05048e48f887" id="r_a3b78ead45e91f901445f05048e48f887"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; * &gt;, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b78ead45e91f901445f05048e48f887">isNormalEdgeLink</a> () const</td></tr>
<tr class="memdesc:a3b78ead45e91f901445f05048e48f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this surface is the normalised link of a single edge.  <br /></td></tr>
<tr class="separator:a3b78ead45e91f901445f05048e48f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f26abbafb1498524889ad3c7e9dc9" id="r_a223f26abbafb1498524889ad3c7e9dc9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223f26abbafb1498524889ad3c7e9dc9">isThinTriangleLink</a> () const</td></tr>
<tr class="memdesc:a223f26abbafb1498524889ad3c7e9dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this surface is the thin link of a single triangle.  <br /></td></tr>
<tr class="separator:a223f26abbafb1498524889ad3c7e9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5cfe2476623cefb240180431800aa1" id="r_a7b5cfe2476623cefb240180431800aa1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; * &gt;, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b5cfe2476623cefb240180431800aa1">isNormalTriangleLink</a> () const</td></tr>
<tr class="memdesc:a7b5cfe2476623cefb240180431800aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a positive rational multiple of this surface is the normalised link of a single triangle.  <br /></td></tr>
<tr class="separator:a7b5cfe2476623cefb240180431800aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330f08b68053b89d2545c0027bbc3405" id="r_a330f08b68053b89d2545c0027bbc3405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a330f08b68053b89d2545c0027bbc3405">isSplitting</a> () const</td></tr>
<tr class="memdesc:a330f08b68053b89d2545c0027bbc3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a splitting surface.  <br /></td></tr>
<tr class="separator:a330f08b68053b89d2545c0027bbc3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea5c390372c408ec4ccca4802bb0e44" id="r_a6ea5c390372c408ec4ccca4802bb0e44"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea5c390372c408ec4ccca4802bb0e44">isCentral</a> () const</td></tr>
<tr class="memdesc:a6ea5c390372c408ec4ccca4802bb0e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a central surface.  <br /></td></tr>
<tr class="separator:a6ea5c390372c408ec4ccca4802bb0e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccd5e4c57c74080dcc2b2e37a75eeb0" id="r_a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ccd5e4c57c74080dcc2b2e37a75eeb0">countBoundaries</a> () const</td></tr>
<tr class="memdesc:a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of disjoint boundary curves on this surface.  <br /></td></tr>
<tr class="separator:a8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793261174b6628c83659b523b84ab943" id="r_a793261174b6628c83659b523b84ab943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a793261174b6628c83659b523b84ab943">isCompressingDisc</a> (bool knownConnected=false) const</td></tr>
<tr class="memdesc:a793261174b6628c83659b523b84ab943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface represents a compressing disc in the underlying 3-manifold.  <br /></td></tr>
<tr class="separator:a793261174b6628c83659b523b84ab943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40448875fc5e68801492acfd10dc680b" id="r_a40448875fc5e68801492acfd10dc680b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40448875fc5e68801492acfd10dc680b">isIncompressible</a> () const</td></tr>
<tr class="memdesc:a40448875fc5e68801492acfd10dc680b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is an incompressible surface within the surrounding 3-manifold.  <br /></td></tr>
<tr class="separator:a40448875fc5e68801492acfd10dc680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45c9bc097ee75c1509d6ec6ad3b4fe" id="r_aab45c9bc097ee75c1509d6ec6ad3b4fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab45c9bc097ee75c1509d6ec6ad3b4fe">cutAlong</a> () const</td></tr>
<tr class="memdesc:aab45c9bc097ee75c1509d6ec6ad3b4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts the underlying triangulation along this surface and returns the result as a new triangulation.  <br /></td></tr>
<tr class="separator:aab45c9bc097ee75c1509d6ec6ad3b4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbc90c271a8a0b96fb62023f2daa91" id="r_a79fbc90c271a8a0b96fb62023f2daa91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79fbc90c271a8a0b96fb62023f2daa91">crush</a> () const</td></tr>
<tr class="memdesc:a79fbc90c271a8a0b96fb62023f2daa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crushes this surface to a point in the underlying triangulation and returns the result as a new triangulation.  <br /></td></tr>
<tr class="separator:a79fbc90c271a8a0b96fb62023f2daa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941a7cd6c0d8368ced19d60b40e774d7" id="r_a941a7cd6c0d8368ced19d60b40e774d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a941a7cd6c0d8368ced19d60b40e774d7">removeOcts</a> () const</td></tr>
<tr class="memdesc:a941a7cd6c0d8368ced19d60b40e774d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an isotopic normal surface that contains no octagons, placed within a homeomorphic (but possibly different) triangulation.  <br /></td></tr>
<tr class="separator:a941a7cd6c0d8368ced19d60b40e774d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a7382380fd07286d7da275409b87f6" id="r_a56a7382380fd07286d7da275409b87f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56a7382380fd07286d7da275409b87f6">operator==</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:a56a7382380fd07286d7da275409b87f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface in fact represent the same normal (or almost normal) surface.  <br /></td></tr>
<tr class="separator:a56a7382380fd07286d7da275409b87f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501dbb7915f107c4bf6d8225f2384906" id="r_a501dbb7915f107c4bf6d8225f2384906"><td class="memItemLeft" align="right" valign="top">std::weak_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501dbb7915f107c4bf6d8225f2384906">operator&lt;=&gt;</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a501dbb7915f107c4bf6d8225f2384906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given surface under a total ordering of all normal and almost normal surfaces.  <br /></td></tr>
<tr class="separator:a501dbb7915f107c4bf6d8225f2384906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803a3a19f5a6f7db0c2ae0e18499bfa" id="r_a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8803a3a19f5a6f7db0c2ae0e18499bfa">normal</a> () const</td></tr>
<tr class="memdesc:a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface contains only triangle and/or quadrilateral discs.  <br /></td></tr>
<tr class="separator:a8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcf349ea8b66bf635454d805af45bc9" id="r_acfcf349ea8b66bf635454d805af45bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfcf349ea8b66bf635454d805af45bc9">embedded</a> () const</td></tr>
<tr class="memdesc:acfcf349ea8b66bf635454d805af45bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface is embedded.  <br /></td></tr>
<tr class="separator:acfcf349ea8b66bf635454d805af45bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa3f944bc8cd084d2a00aadc0f0eb2" id="r_aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1aa3f944bc8cd084d2a00aadc0f0eb2">locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface are locally compatible.  <br /></td></tr>
<tr class="separator:aa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda2f060aca3d7228ce8758f67eefeb" id="r_a7bda2f060aca3d7228ce8758f67eefeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bda2f060aca3d7228ce8758f67eefeb">disjoint</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:a7bda2f060aca3d7228ce8758f67eefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class.  <br /></td></tr>
<tr class="separator:a7bda2f060aca3d7228ce8758f67eefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6df0a57dfc810cbde7845cd8ae9a31" id="r_adc6df0a57dfc810cbde7845cd8ae9a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc6df0a57dfc810cbde7845cd8ae9a31">boundaryIntersections</a> () const</td></tr>
<tr class="memdesc:adc6df0a57dfc810cbde7845cd8ae9a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the information about the boundary slopes of this surface at each cusp of the triangulation.  <br /></td></tr>
<tr class="separator:adc6df0a57dfc810cbde7845cd8ae9a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b56885a01e289daff0f480ba9c5170" id="r_aa2b56885a01e289daff0f480ba9c5170"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a> () const</td></tr>
<tr class="memdesc:aa2b56885a01e289daff0f480ba9c5170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the integer vector that Regina uses internally to represent this surface.  <br /></td></tr>
<tr class="separator:aa2b56885a01e289daff0f480ba9c5170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7d356c59e7a3f1e94fcdcd4a5bb6f6" id="r_a4a7d356c59e7a3f1e94fcdcd4a5bb6f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a7d356c59e7a3f1e94fcdcd4a5bb6f6">encoding</a> () const</td></tr>
<tr class="memdesc:a4a7d356c59e7a3f1e94fcdcd4a5bb6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific integer vector encoding that this surface uses internally.  <br /></td></tr>
<tr class="separator:a4a7d356c59e7a3f1e94fcdcd4a5bb6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b54da809cf5f00936f4eb359228136" id="r_ad0b54da809cf5f00936f4eb359228136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0b54da809cf5f00936f4eb359228136">couldBeAlmostNormal</a> () const</td></tr>
<tr class="memdesc:ad0b54da809cf5f00936f4eb359228136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the internal vector encoding for this surface supports almost normal surfaces.  <br /></td></tr>
<tr class="separator:ad0b54da809cf5f00936f4eb359228136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0720fdc5b8f07a113f1afafeb478aed" id="r_ae0720fdc5b8f07a113f1afafeb478aed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0720fdc5b8f07a113f1afafeb478aed">couldBeNonCompact</a> () const</td></tr>
<tr class="memdesc:ae0720fdc5b8f07a113f1afafeb478aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the internal vector encoding for this surface supports non-compact surfaces.  <br /></td></tr>
<tr class="separator:ae0720fdc5b8f07a113f1afafeb478aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1e4e7dd00c4ae8ecb50552a67e766dec" id="r_a1e4e7dd00c4ae8ecb50552a67e766dec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e4e7dd00c4ae8ecb50552a67e766dec">reconstructTriangles</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;<a class="el" href="#aa2b56885a01e289daff0f480ba9c5170">vector</a>, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc)</td></tr>
<tr class="memdesc:a1e4e7dd00c4ae8ecb50552a67e766dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the triangle coordinates in the given integer vector.  <br /></td></tr>
<tr class="separator:a1e4e7dd00c4ae8ecb50552a67e766dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7fe45697e6bfb1750488bdb3601560e8" id="r_a7fe45697e6bfb1750488bdb3601560e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fe45697e6bfb1750488bdb3601560e8">enc_</a></td></tr>
<tr class="memdesc:a7fe45697e6bfb1750488bdb3601560e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specific encoding of a normal surface used by the coordinate vector.  <br /></td></tr>
<tr class="separator:a7fe45697e6bfb1750488bdb3601560e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac30104f9ce828b81f6411940cc1f51c" id="r_aac30104f9ce828b81f6411940cc1f51c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac30104f9ce828b81f6411940cc1f51c">vector_</a></td></tr>
<tr class="memdesc:aac30104f9ce828b81f6411940cc1f51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal surface.  <br /></td></tr>
<tr class="separator:aac30104f9ce828b81f6411940cc1f51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8295e0b8668759daa676e739140bcd27" id="r_a8295e0b8668759daa676e739140bcd27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8295e0b8668759daa676e739140bcd27">triangulation_</a></td></tr>
<tr class="memdesc:a8295e0b8668759daa676e739140bcd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal surface resides.  <br /></td></tr>
<tr class="separator:a8295e0b8668759daa676e739140bcd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f559575a99f46ef3bf189016d2eee0" id="r_a78f559575a99f46ef3bf189016d2eee0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78f559575a99f46ef3bf189016d2eee0">name_</a></td></tr>
<tr class="memdesc:a78f559575a99f46ef3bf189016d2eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this surface.  <br /></td></tr>
<tr class="separator:a78f559575a99f46ef3bf189016d2eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822c62b7fdfb5396f627ecd0942ac362" id="r_a822c62b7fdfb5396f627ecd0942ac362"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a822c62b7fdfb5396f627ecd0942ac362">octPosition_</a></td></tr>
<tr class="memdesc:a822c62b7fdfb5396f627ecd0942ac362"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of the first non-zero octagonal coordinate, or a null disc type if there is no non-zero octagonal coordinate.  <br /></td></tr>
<tr class="separator:a822c62b7fdfb5396f627ecd0942ac362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b76ecbd28f7c5b8dfb1a6b2c0bba40" id="r_a27b76ecbd28f7c5b8dfb1a6b2c0bba40"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b76ecbd28f7c5b8dfb1a6b2c0bba40">eulerChar_</a></td></tr>
<tr class="memdesc:a27b76ecbd28f7c5b8dfb1a6b2c0bba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic of this surface.  <br /></td></tr>
<tr class="separator:a27b76ecbd28f7c5b8dfb1a6b2c0bba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777d04afc658246c3fa61a1ea3efdfa" id="r_a3777d04afc658246c3fa61a1ea3efdfa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3777d04afc658246c3fa61a1ea3efdfa">boundaries_</a></td></tr>
<tr class="memdesc:a3777d04afc658246c3fa61a1ea3efdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of disjoint boundary curves on this surface.  <br /></td></tr>
<tr class="separator:a3777d04afc658246c3fa61a1ea3efdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e0538e051f9862459a0f5a2978684" id="r_a9a0e0538e051f9862459a0f5a2978684"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a0e0538e051f9862459a0f5a2978684">orientable_</a></td></tr>
<tr class="memdesc:a9a0e0538e051f9862459a0f5a2978684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface orientable? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:a9a0e0538e051f9862459a0f5a2978684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc524b638f28a70858c36ab13e6abdd3" id="r_acc524b638f28a70858c36ab13e6abdd3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc524b638f28a70858c36ab13e6abdd3">twoSided_</a></td></tr>
<tr class="memdesc:acc524b638f28a70858c36ab13e6abdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface two-sided? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:acc524b638f28a70858c36ab13e6abdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44a7bc466fa79002847f5071af338c6" id="r_ad44a7bc466fa79002847f5071af338c6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad44a7bc466fa79002847f5071af338c6">connected_</a></td></tr>
<tr class="memdesc:ad44a7bc466fa79002847f5071af338c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface connected? This is std::nullopt if it has not yet been computed.  <br /></td></tr>
<tr class="separator:ad44a7bc466fa79002847f5071af338c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c2cb19b3e122b76214a3b874133d8a" id="r_aa9c2cb19b3e122b76214a3b874133d8a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c2cb19b3e122b76214a3b874133d8a">realBoundary_</a></td></tr>
<tr class="memdesc:aa9c2cb19b3e122b76214a3b874133d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this surface have real boundary (i.e.  <br /></td></tr>
<tr class="separator:aa9c2cb19b3e122b76214a3b874133d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2498a9bb61162987fc338e589e35ac84" id="r_a2498a9bb61162987fc338e589e35ac84"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2498a9bb61162987fc338e589e35ac84">compact_</a></td></tr>
<tr class="memdesc:a2498a9bb61162987fc338e589e35ac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface compact (i.e.  <br /></td></tr>
<tr class="separator:a2498a9bb61162987fc338e589e35ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3555b1171347a9041af35e95ab1738" id="r_a1d3555b1171347a9041af35e95ab1738"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d3555b1171347a9041af35e95ab1738">linkOf_</a> { 0 }</td></tr>
<tr class="memdesc:a1d3555b1171347a9041af35e95ab1738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which dimensions of face a positive rational multiple of this surface is a thin or normalised link of.  <br /></td></tr>
<tr class="separator:a1d3555b1171347a9041af35e95ab1738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a04f8801fb7fded49eac81613912fd32e" id="r_a04f8801fb7fded49eac81613912fd32e"><td class="memItemLeft" align="right" valign="top"><a id="a04f8801fb7fded49eac81613912fd32e" name="a04f8801fb7fded49eac81613912fd32e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalSurfaceReader</b></td></tr>
<tr class="separator:a04f8801fb7fded49eac81613912fd32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a single normal surface in a 3-manifold triangulation. </p>
<p>The normal surface is described internally by an integer vector (discussed in more detail below). Since different surfaces may use different vector encodings, you should not rely on the raw vector entries unless absolutely necessary. Instead, the query routines such as <a class="el" href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a>, <a class="el" href="#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a>, <a class="el" href="#ab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">edgeWeight()</a> and so on are independent of the underlying vector encoding being used.</p>
<p>Note that non-compact surfaces (surfaces with infinitely many discs, such as spun-normal surfaces) are allowed; in these cases, the corresponding lookup routines (such as <a class="el" href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a>) will return <a class="el" href="classregina_1_1IntegerBase.html#a127260b6be26c7f4600b12268e86f73c" title="Globally available infinity.">LargeInteger::infinity</a> where appropriate.</p>
<p>Since Regina 7.0, you can modify or even destroy the original triangulation that was used to create this normal surface. If you do, then this normal surface will automatically make a private copy of the original triangulation as an ongoing reference. Different normal surfaces (and angle structures) can all share the same private copy, so this is not an expensive process.</p>
<p>Internally, a normal surface is represented by a Vector&lt;LargeInteger&gt; (possibly using a different coordinate system from the one in which the surfaces were originally enumerated). This contains a block of coordinates for each tetrahedron, in order from the first tetrahedron to the last. Each block begins with four triangle coordinates (always), then three quadrilateral coordinates (always), and finally three octagon coordinates (only for some coordinate systems). Therefore the vector that is stored will always have length 7<em>n</em> or 10<em>n</em> where <em>n</em> is the number of tetrahedra in the underlying triangulation.</p>
<p>When adding support for a new coordinate system:</p>
<ul>
<li>The file <a class="el" href="normalcoords_8h.html" title="Defines constants for normal surface coordinate systems.">normalcoords.h</a> must be updated. This includes a new enum value for NormalCoords, a new case for the <a class="el" href="classregina_1_1NormalEncoding.html" title="Indicates precisely how a normal surface is encoded by an integer vector.">NormalEncoding</a> constructor, and new cases for the functions in <a class="el" href="classregina_1_1NormalInfo.html" title="A class used to query general information about different normal coordinate systems.">NormalInfo</a>. Do not forget to update the python bindings for NormalCoords also.</li>
<li>The global routines <a class="el" href="group__hypersurface.html#ga0736934b2b18b263665b5e6ef0f4eb9f" title="Generates the validity constraints representing the condition that normal hypersurfaces be embedded.">makeEmbeddedConstraints()</a> and <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> should be updated to incorporate the new coordinate system.</li>
</ul>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo</a></b></dt><dd><p class="startdd"><em>Feature:</em> Calculation of Euler characteristic and orientability for non-compact surfaces. </p>
<p class="enddd"><em>Feature (long-term):</em> Determine which faces in the solution space a normal surface belongs to.</p>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2cd862446bad0775d113250dc9b4db74" name="a2cd862446bad0775d113250dc9b4db74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd862446bad0775d113250dc9b4db74">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal surface. </p>

</div>
</div>
<a id="abb45d3d57b26d945d2eee12d3f5802d0" name="abb45d3d57b26d945d2eee12d3f5802d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb45d3d57b26d945d2eee12d3f5802d0">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal surface, but relocated to the given triangulation. </p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal surface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is either the same as, or is combinatorially identical to, the triangulation in which <em>src</em> resides.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal surface to copy. </td></tr>
    <tr><td class="paramname">triangulation</td><td>the triangulation in which this new surface will reside. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ae06d8924609641e1128dc288a5221d" name="a7ae06d8924609641e1128dc288a5221d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae06d8924609641e1128dc288a5221d">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given normal surface, but relocated to the given triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is either the same as, or is combinatorially identical to, the triangulation in which <em>src</em> resides.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal surface to copy. </td></tr>
    <tr><td class="paramname">triangulation</td><td>a snapshot, frozen in time, of the triangulation in which this new surface will reside. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49eae62cb857571140b77a1bb3abc69" name="ab49eae62cb857571140b77a1bb3abc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49eae62cb857571140b77a1bb3abc69">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given surface into this new normal surface. </p>
<p>This is a fast (constant time) operation.</p>
<p>The surface that is passed will no longer be usable. </p>

</div>
</div>
<a id="a777be00c6c6e45ee9a8e9b9b1df84beb" name="a777be00c6c6e45ee9a8e9b9b1df84beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777be00c6c6e45ee9a8e9b9b1df84beb">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the empty surface within the given triangulation. </p>
<p>All normal coordinates will be zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a704d642d9881fc164cb0438db67db9c8" name="a704d642d9881fc164cb0438db67db9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704d642d9881fc164cb0438db67db9c8">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the empty surface within the given triangulation. </p>
<p>All normal coordinates will be zero.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal surface resides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c7c78fd9bac2f274e39a1a9ffbd403" name="a12c7c78fd9bac2f274e39a1a9ffbd403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c7c78fd9bac2f274e39a1a9ffbd403">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this surface will keep the given encoding: <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal surface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The supported types for the template parameter <em>U</em> are <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> and <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>. You may also, if you prefer, pass <em>vector</em> as a Python list of integers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal surface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2da1eb45b513f8910158a48af924347" name="ad2da1eb45b513f8910158a48af924347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2da1eb45b513f8910158a48af924347">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this surface will keep the given encoding: <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal surface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal surface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e537b48cec2b2d1bace0982a60eaacc" name="a4e537b48cec2b2d1bace0982a60eaacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e537b48cec2b2d1bace0982a60eaacc">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this surface will keep the given encoding: <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal surface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20fdc7273cea56ac41f5fcc8d805b393" name="a20fdc7273cea56ac41f5fcc8d805b393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fdc7273cea56ac41f5fcc8d805b393">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given vector encoding. </p>
<p>There is no guarantee that this surface will keep the given encoding: <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> will sometimes convert the vector to use a different encoding for its own internal storage.</p>
<p>Despite what is said in the class notes, it is okay if the given vector encoding does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the given encoding. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation and copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">enc</td><td>indicates precisely how the given vector encodes a normal surface. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5c7d0adf010b3cf9adb1d782b3e5b5" name="a4e5c7d0adf010b3cf9adb1d782b3e5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5c7d0adf010b3cf9adb1d782b3e5b5">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this surface uses the vector encoding described by <code>NormalEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal surface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this surface will use <code>NormalEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal surface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the encoding <code>NormalEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The supported types for the template parameter <em>U</em> are <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> and <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>. You may also, if you prefer, pass <em>vector</em> as a Python list of integers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce2e6c88fe7ef64ccdd87aaac0cc8b2" name="abce2e6c88fe7ef64ccdd87aaac0cc8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce2e6c88fe7ef64ccdd87aaac0cc8b2">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this surface uses the vector encoding described by <code>NormalEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal surface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this surface will use <code>NormalEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<p>A snapshot will be taken of the given triangulation as it appears right now. You may change or even delete the triangulation later on; if so, then this normal surface will still refer to the frozen snapshot that was taken at the time of construction.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the encoding <code>NormalEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a915c5ddb5f1f1f64d590395298feda41" name="a915c5ddb5f1f1f64d590395298feda41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915c5ddb5f1f1f64d590395298feda41">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this surface uses the vector encoding described by <code>NormalEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal surface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this surface will use <code>NormalEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the encoding <code>NormalEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>the type of object held by the given vector. It must be possible to assign an object of type <em>U</em> to a <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaabf8fbd5bd0a34e3fa160386ec72924" name="aaabf8fbd5bd0a34e3fa160386ec72924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabf8fbd5bd0a34e3fa160386ec72924">&#9670;&#160;</a></span>NormalSurface() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triang</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surface.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector, using the given coordinate system. </p>
<p>It is assumed that this surface uses the vector encoding described by <code>NormalEncoding(coords)</code>. Be careful with this if you are extracting the vector from some other normal surface, since Regina may internally convert to use a different encoding from whatever was used during enumeration and/or read from file. In the same spirit, there is no guarantee that this surface will use <code>NormalEncoding(coords)</code> as its internal encoding method.</p>
<p>Despite what is said in the class notes, it is okay if the given coordinate system does not include triangle coordinates. (If this is the case, the vector will be converted automatically.)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector does indeed represent a normal surface inside the given triangulation, using the encoding <code>NormalEncoding(coords)</code>. This will not be checked!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the version that takes a "pure" triangulation and copies <em>vector</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>a snapshot, frozen in time, of the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system from which the vector encoding will be deduced. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00a0872585e068bfc47cfdc417c63dd0" name="a00a0872585e068bfc47cfdc417c63dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0872585e068bfc47cfdc417c63dd0">&#9670;&#160;</a></span>arcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>triIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>triVertex</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0ff1fb3c66e81c2d533e1fac79439126" title="A dimension-specific alias for countFaces&lt;2&gt;().">Triangulation&lt;3&gt;::countTriangles()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

</div>
</div>
<a id="adc6df0a57dfc810cbde7845cd8ae9a31" name="adc6df0a57dfc810cbde7845cd8ae9a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6df0a57dfc810cbde7845cd8ae9a31">&#9670;&#160;</a></span>boundaryIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga03a9df11c8b8434e6ba30d1dc1fc50f6">MatrixInt</a> regina::NormalSurface::boundaryIntersections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the information about the boundary slopes of this surface at each cusp of the triangulation. </p>
<p>This is for use with spun-normal surfaces (since for closed surfaces all boundary slopes are zero).</p>
<p>This routine is only available for use with SnapPea triangulations, since it needs to know the specific meridian and longitude on each cusp. These meridians and longitudes are <em>only</em> available through the SnapPea kernel, since Regina does not use or store peripheral curves for its own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class. Therefore:</p>
<ul>
<li>If the underlying triangulation (as returned by <a class="el" href="#a0e446c1e71f8f7db55f66b30c273549f" title="Returns the triangulation in which this normal surface resides.">triangulation()</a>) is not of the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, this routine will throw an exception (see below).</li>
<li>In particular, this <em>will</em> happen if you have edited or deleted the original triangulation that was used to construct this normal surface. This is because such a modification will trigger an internal deep copy of the original, and this will only copy Regina's native <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> data.</li>
</ul>
<p>All cusps are treated as complete. That is, any Dehn fillings stored in the SnapPea triangulation will be ignored.</p>
<p>The results are returned in a matrix with <em>V</em> rows and two columns, where <em>V</em> is the number of vertices in the triangulation. If row <em>i</em> of the matrix contains the integers <em>M</em> and <em>L</em>, this indicates that at the <em>i</em>th cusp, the boundary curves have algebraic intersection number <em>M</em> with the meridian and <em>L</em> with the longitude. Equivalently, the boundary curves pass <em>L</em> times around the meridian and <em>-M</em> times around the longitude. The rational boundary slope is therefore <code>-L/M</code>, and there are <code>gcd(L,M)</code> boundary curves with this slope.</p>
<p>The orientations of the boundary curves of a spun-normal surface are chosen so that <em>if</em> meridian and longitude are a positive basis as vieved from the cusp, then as one travels along an oriented boundary curve, the spun-normal surface spirals into the cusp to one's right and down into the manifold to one's left.</p>
<p>If the triangulation contains more than one vertex, the rows in the resulting matrix are ordered by cusp index (as stored by SnapPea). You can call SnapPeaTriangulation::cuspVertex() to map these to Regina's vertex indices if needed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>As noted above, the underlying triangulation must be a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>; this will be checked, and this routine will throw an exception if this requirement is not met.</dd>
<dd>
At present, Regina can only compute boundary slopes if the triangulation is oriented, if every vertex link in the triangulation is a torus, and if the underlying coordinate system is for normal surfaces only (not almost normal surfaces). These conditions will likewise be checked, and this routine will throw an exception if they are not met.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1SnapPeaIsNull.html" title="An exception thrown when the SnapPea kernel is asked to work with a null SnapPea triangulation.">SnapPeaIsNull</a></td><td>This is a null SnapPea triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>One or more of the preconditions listed above was not met.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>William Pettersson and Stephan Tillmann</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix with <em>number_of_vertices</em> rows and two columns as described above. </dd></dl>

</div>
</div>
<a id="a46f7f421d6a2c85be7df72fa41f88ac5" name="a46f7f421d6a2c85be7df72fa41f88ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f7f421d6a2c85be7df72fa41f88ac5">&#9670;&#160;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt; regina::NormalSurface::components </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits this surface into connected components. </p>
<p>A list of connected components will be returned. These components will always be encoded using standard (tri-quad or tri-quad-oct) coordinates, regardless of the internal vector encoding that is used by this surface.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of connected components. </dd></dl>

</div>
</div>
<a id="ad0b54da809cf5f00936f4eb359228136" name="ad0b54da809cf5f00936f4eb359228136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b54da809cf5f00936f4eb359228136">&#9670;&#160;</a></span>couldBeAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::couldBeAlmostNormal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the internal vector encoding for this surface supports almost normal surfaces. </p>
<p>If this routine returns <code>true</code>, it does not mean that the surface actually <em>contains</em> one or more octagons; you should use <a class="el" href="#a8803a3a19f5a6f7db0c2ae0e18499bfa" title="Determines whether this surface contains only triangle and/or quadrilateral discs.">normal()</a> to test for that. This routine simply queries a basic property of the vector encoding that is being used, and this property is often inherited from whatever coordinate system was used to perform the normal surface enumeration.</p>
<p>On the other hand, if this routine returns <code>false</code>, it is a guarantee that this surface is normal.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the internal encoding supports almost normal surfaces. </dd></dl>

</div>
</div>
<a id="ae0720fdc5b8f07a113f1afafeb478aed" name="ae0720fdc5b8f07a113f1afafeb478aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0720fdc5b8f07a113f1afafeb478aed">&#9670;&#160;</a></span>couldBeNonCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::couldBeNonCompact </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the internal vector encoding for this surface supports non-compact surfaces. </p>
<p>Non-compact surfaces are surfaces that contain infinitely many discs (i.e., spun-normal surfaces).</p>
<p>If this routine returns <code>true</code>, it does not mean that the surface actually <em>is</em> non-compact; you should use <a class="el" href="#a40abc1a8ab16f13d8108df83290ec013" title="Determines if this normal surface is compact (has finitely many discs).">isCompact()</a> to test for that. This routine simply queries a basic property of the vector encoding that is being used, and this property is often inherited from whatever coordinate system was used to perform the normal surface enumeration.</p>
<p>On the other hand, if this routine returns <code>false</code>, it is a guarantee that this surface is compact.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the internal encoding supports almost normal surfaces. </dd></dl>

</div>
</div>
<a id="a8ccd5e4c57c74080dcc2b2e37a75eeb0" name="a8ccd5e4c57c74080dcc2b2e37a75eeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccd5e4c57c74080dcc2b2e37a75eeb0">&#9670;&#160;</a></span>countBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::countBoundaries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of disjoint boundary curves on this surface. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal arcs on the boundary. If the normal coordinates are extremely large, (in particular, of a similar order of magnitude as the largest possible long integer), then the behaviour of this routine is undefined.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of disjoint boundary curves. </dd></dl>

</div>
</div>
<a id="a79fbc90c271a8a0b96fb62023f2daa91" name="a79fbc90c271a8a0b96fb62023f2daa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbc90c271a8a0b96fb62023f2daa91">&#9670;&#160;</a></span>crush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::NormalSurface::crush </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crushes this surface to a point in the underlying triangulation and returns the result as a new triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Crushing the surface will produce a number of tetrahedra, triangular pillows and/or footballs. The pillows and footballs will then be flattened to triangles and edges respectively (resulting in the possible changes mentioned below) to produce a proper triangulation.</p>
<p>Note that the new triangulation will have at most the same number of tetrahedra as the old triangulation, and will have strictly fewer tetrahedra if this surface is not vertex linking.</p>
<p>The act of flattening pillows and footballs as described above can lead to unintended topological side-effects, beyond the effects of merely cutting along this surface and identifying the new boundary surface(s) to points. Examples of these unintended side-effects can include connected sum decompositions, removal of 3-spheres and small Lens spaces and so on; a full list of possible changes is beyond the scope of this API documentation.</p>
<p>If the original triangulation is oriented, then the crushing operation will preserve this orientation.</p>
<p>This routine will ignore any locks on tetrahedra and/or triangles of the original triangulation (and of course the original triangulation will be left safely unchanged). The triangulation that is returned will not have any locks at all.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine can have unintended topological side-effects, as described above.</dd>
<dd>
In exceptional cases with non-orientable 3-manifolds, these side-effects might lead to invalid edges (edges whose midpoints are projective plane cusps).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting crushed triangulation. </dd></dl>

</div>
</div>
<a id="aab45c9bc097ee75c1509d6ec6ad3b4fe" name="aab45c9bc097ee75c1509d6ec6ad3b4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab45c9bc097ee75c1509d6ec6ad3b4fe">&#9670;&#160;</a></span>cutAlong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::NormalSurface::cutAlong </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts the underlying triangulation along this surface and returns the result as a new triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Note that, unlike crushing a surface to a point, this operation will not change the topology of the underlying 3-manifold beyond simply slicing along this surface.</p>
<p>As of Regina 7.1, this routine can happily cut along <em>almost</em> normal surfaces as well as normal surfaces. That is, it can now handle octagons, including cases with multiple octagons in the same tetrahedron and/or octagons in multiple tetrahedra.</p>
<p>This operation does <em>not</em> preserve orientation. That is, even if the original triangulation is oriented, there are no guarantees regarding the orientation of the tetrahedra in the cut-open triangulation. The cut-open triangulation might have the same or opposite orientation as the original, or it might not be oriented at all. If you need to preserve orientation, consider whether <a class="el" href="#a79fbc90c271a8a0b96fb62023f2daa91" title="Crushes this surface to a point in the underlying triangulation and returns the result as a new trian...">crush()</a> (which <em>does</em> preserve orientation) might work for you instead.</p>
<p>This routine will ignore any locks on tetrahedra and/or triangles of the original triangulation (and of course the original triangulation will be left safely unchanged). The triangulation that is returned will not have any locks at all.</p>
<dl class="section warning"><dt>Warning</dt><dd>The number of tetrahedra in the new triangulation can be <em>very</em> large.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting cut-open triangulation. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7bda2f060aca3d7228ce8758f67eefeb" name="a7bda2f060aca3d7228ce8758f67eefeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda2f060aca3d7228ce8758f67eefeb">&#9670;&#160;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class. </p>
<p>This is a global constraint, and therefore gives a stronger test than <a class="el" href="#aa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">locallyCompatible()</a>. However, this global constraint is also much slower to test; the running time is proportional to the total number of normal discs in both surfaces.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation. </dd>
<dd>
Both this and the given surface are compact (have finitely many discs), embedded, non-empty and connected.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, since it performs a depth-first search over the entire set of normal discs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test alongside this surface for potential intersections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces can be embedded without intersecting anywhere, or <code>false</code> if this and the given surface are forced to intersect at some point. </dd></dl>

</div>
</div>
<a id="a75dd722a1381b44ed5e0e2243825cd06" name="a75dd722a1381b44ed5e0e2243825cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dd722a1381b44ed5e0e2243825cd06">&#9670;&#160;</a></span>doubleSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> regina::NormalSurface::doubleSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the double of this surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000195">Deprecated</a></b></dt><dd>Normal surfaces can now be multiplied by integer constants. In particular, this routine has exactly the same effect as multiplying the surface by 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal surface. </dd></dl>

</div>
</div>
<a id="ab0471c5364a23009d61817fa084cdcc9" name="ab0471c5364a23009d61817fa084cdcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0471c5364a23009d61817fa084cdcc9">&#9670;&#160;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>edgeIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of times this normal surface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#addf438f54b1ccec5a42916b00132ed2f" title="A dimension-specific alias for countFaces&lt;1&gt;().">Triangulation&lt;3&gt;::countEdges()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

</div>
</div>
<a id="acfcf349ea8b66bf635454d805af45bc9" name="acfcf349ea8b66bf635454d805af45bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcf349ea8b66bf635454d805af45bc9">&#9670;&#160;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::embedded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting quadrilateral and/or octagon types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is embedded. </dd></dl>

</div>
</div>
<a id="a4a7d356c59e7a3f1e94fcdcd4a5bb6f6" name="a4a7d356c59e7a3f1e94fcdcd4a5bb6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7d356c59e7a3f1e94fcdcd4a5bb6f6">&#9670;&#160;</a></span>encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalSurface::encoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific integer vector encoding that this surface uses internally. </p>
<p>This is the encoding that should be used to interpret <a class="el" href="#aa2b56885a01e289daff0f480ba9c5170" title="Gives read-only access to the integer vector that Regina uses internally to represent this surface.">vector()</a>.</p>
<p>Note that this might differ from the encoding originally passed to the class constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>the internal vector encoding. </dd></dl>

</div>
</div>
<a id="aa553c0aff30c704a13d4833f84263c7a" name="aa553c0aff30c704a13d4833f84263c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa553c0aff30c704a13d4833f84263c7a">&#9670;&#160;</a></span>eulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::eulerChar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euler characteristic of this surface. </p>
<p>For properly embedded surfaces, this is of course just the ordinary Euler characteristic of the surface.</p>
<p>For immersed or singular surfaces, the situation is more complex since Regina does not know how many branch points there are (if any). Regina's approach is to compute everything locally, assuming that the surface is an immersion. This means that <a class="el" href="#aa553c0aff30c704a13d4833f84263c7a" title="Returns the Euler characteristic of this surface.">eulerChar()</a> will report the correct result for an immersed surface, but for singular surfaces it will report a <em>larger</em> number than it should since it essentially counts each branch point as multiple vertices.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic. </dd></dl>

</div>
</div>
<a id="a02e12af8c63e17e3f82b2f97fe52eb3f" name="a02e12af8c63e17e3f82b2f97fe52eb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e12af8c63e17e3f82b2f97fe52eb3f">&#9670;&#160;</a></span>hasMultipleOctDiscs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a id="a0015d445ca92c0e77a8f8638ac9e562a" name="a0015d445ca92c0e77a8f8638ac9e562a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015d445ca92c0e77a8f8638ac9e562a">&#9670;&#160;</a></span>hasRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface has real boundary. </dd></dl>

</div>
</div>
<a id="a6ea5c390372c408ec4ccca4802bb0e44" name="a6ea5c390372c408ec4ccca4802bb0e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea5c390372c408ec4ccca4802bb0e44">&#9670;&#160;</a></span>isCentral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::isCentral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a central surface. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If this surface is central, the number of tetrahedra that it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that this surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="a40abc1a8ab16f13d8108df83290ec013" name="a40abc1a8ab16f13d8108df83290ec013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40abc1a8ab16f13d8108df83290ec013">&#9670;&#160;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompact </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal surface is compact (has finitely many discs). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal surface is compact. </dd></dl>

</div>
</div>
<a id="a793261174b6628c83659b523b84ab943" name="a793261174b6628c83659b523b84ab943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793261174b6628c83659b523b84ab943">&#9670;&#160;</a></span>isCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompressingDisc </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>knownConnected</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface represents a compressing disc in the underlying 3-manifold. </p>
<p>Let this surface be <em>D</em> and let the underlying 3-manifold be <em>M</em> with boundary <em>B</em>. To be a compressing disc, <em>D</em> must be a properly embedded disc in <em>M</em>, and the boundary of <em>D</em> must not bound a disc in <em>B</em>.</p>
<p>The implementation of this routine is somewhat inefficient at present, since it cuts along the disc, retriangulates and then examines the resulting boundary components.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo</a></b></dt><dd><p class="startdd"><em>Optimise:</em> Reimplement this to avoid cutting along surfaces. </p>
<p class="enddd"><em>Bug:</em> Check for absurdly large numbers of discs and bail accordingly.</p>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine might cut along the surface and retriangulate, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knownConnected</td><td><code>true</code> if this normal surface is already known to be connected (for instance, if it came from an enumeration of vertex normal surfaces), or <code>false</code> if we should not assume any such information about this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is a compressing disc, or <code>false</code> if this surface is not a compressing disc. </dd></dl>

</div>
</div>
<a id="a8de9cd3d6628242dff5c7248c5bcb62c" name="a8de9cd3d6628242dff5c7248c5bcb62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de9cd3d6628242dff5c7248c5bcb62c">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this surface is connected. </p>
<p>For our purposes, the empty surface is considered to be connected.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is connected, or <code>false</code> if this surface is disconnected. </dd></dl>

</div>
</div>
<a id="ad24929a9b7ed24295c1010b205179b2c" name="ad24929a9b7ed24295c1010b205179b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24929a9b7ed24295c1010b205179b2c">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface is empty (has no discs whatsoever). </p>

</div>
</div>
<a id="a40448875fc5e68801492acfd10dc680b" name="a40448875fc5e68801492acfd10dc680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40448875fc5e68801492acfd10dc680b">&#9670;&#160;</a></span>isIncompressible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isIncompressible </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is an incompressible surface within the surrounding 3-manifold. </p>
<p>At present, this routine is only implemented for surfaces embedded within <em>closed</em> and <em>irreducible</em> 3-manifold triangulations.</p>
<p>Let <em>D</em> be some disc embedded in the underlying 3-manifold, and let <em>B</em> be the boundary of <em>D</em>. We call <em>D</em> a <em>compressing disc</em> for this surface if (i) the intersection of <em>D</em> with this surface is the boundary <em>B</em>, and (ii) although <em>B</em> bounds a disc within the 3-manifold, it does not bound a disc within this surface.</p>
<p>We declare this surface to be <em>incompressible</em> if there are no such compressing discs. For our purposes, spheres are never considered incompressible (so if this surface is a sphere then this routine will always return <code>false</code>).</p>
<p>This test is designed exclusively for two-sided surfaces. If this surface is one-sided, the incompressibility test will be run on its two-sided double cover.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may in some circumstances be extremely slow. This is because the underlying algorithm cuts along this surface, retriangulates (possibly using a very large number of tetrahedra), and then searches for a normal compressing disc in each component of the cut-open triangulation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation is valid and closed, and represents an irreducible 3-manifold. </dd>
<dd>
This normal surface is compact, embedded and connected, and contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is incompressible, or <code>false</code> if this surface is not incompressible (or if it is a sphere). </dd></dl>

</div>
</div>
<a id="a3b78ead45e91f901445f05048e48f887" name="a3b78ead45e91f901445f05048e48f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b78ead45e91f901445f05048e48f887">&#9670;&#160;</a></span>isNormalEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; * &gt;, unsigned &gt; regina::NormalSurface::isNormalEdgeLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this surface is the normalised link of a single edge. </p>
<p>Here the phrase <em>normalised</em> link of an edge <em>e</em> means the frontier of a regular neighbourhood of <em>e</em>, converted into a normal surface by expanding away from the edge using the normalisation process. It could be that there is no normalisation required at all (in which case it is also a <em>thin</em> edge link). However, it could be that the normalisation process expands the surface far away from the edge itself, or changes its topology, or disconnects the surface, or even normalises it away to an empty surface.</p>
<p>In particular, this test behaves differently from <a class="el" href="#ab82721dfe41b187548593091b7274e6e" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single e...">isThinEdgeLink()</a>, which tests for thin edge links only (where no additional normalisation is required). If you are only interested in thin edge links, then you should call <a class="el" href="#ab82721dfe41b187548593091b7274e6e" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single e...">isThinEdgeLink()</a>, which has much less overhead.</p>
<p>A surface (or its positive rational multiple) could be the normalised link of many edges. The return value will be a pair (<em>v</em>, <em>thin</em>), where:</p>
<ul>
<li><em>v</em> is a vector containing all such edges. This will begin with the edges for which this surface is a thin link, followed by the edges where normalisation was required; within each category the edges will be ordered by their index within the triangulation.</li>
<li><em>thin</em> is either 0, 1 or 2, indicating how many edges this surface is a thin link for. This uses an unsigned type, since it will often be compared to <code>v.size()</code>.</li>
</ul>
<p>If no positive rational multiple of this surface is the normalised link of any edge, then <em>link</em> will be 0 and <em>v</em> will be the empty vector.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the edge(s) linked by a positive rational multiple of this surface and an integer indicating how many of these links are thin, as described above. </dd></dl>

</div>
</div>
<a id="a7b5cfe2476623cefb240180431800aa1" name="a7b5cfe2476623cefb240180431800aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5cfe2476623cefb240180431800aa1">&#9670;&#160;</a></span>isNormalTriangleLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; * &gt;, unsigned &gt; regina::NormalSurface::isNormalTriangleLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this surface is the normalised link of a single triangle. </p>
<p>Here the phrase <em>normalised</em> link of a triangle <em>t</em> means the frontier of a regular neighbourhood of <em>t</em>, converted into a normal surface by expanding away from the triangle using the normalisation process. It could be that there is no normalisation required at all (in which case it is also a <em>thin</em> triangle link). However, it could be that the normalisation process expands the surface far away from the triangle itself, or changes its topology, or disconnects the surface, or even normalises it away to an empty surface.</p>
<p>In particular, this test behaves differently from <a class="el" href="#a223f26abbafb1498524889ad3c7e9dc9" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single t...">isThinTriangleLink()</a>, which tests for thin triangle links only (where no additional normalisation is required). Unlike the tests for edge links, the routines <a class="el" href="#a223f26abbafb1498524889ad3c7e9dc9" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single t...">isThinTriangleLink()</a> and <a class="el" href="#a7b5cfe2476623cefb240180431800aa1" title="Determines whether or not a positive rational multiple of this surface is the normalised link of a si...">isNormalTriangleLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A surface (or its positive rational multiple) could be the normalised link of many triangles. The return value will be a pair (<em>v</em>, <em>thin</em>), where:</p>
<ul>
<li><em>v</em> is a vector containing all such triangles. This will begin with the triangles for which this surface is a thin link, followed by the triangles where normalisation was required; within each category the triangles will be ordered by their index within the triangulation.</li>
<li><em>thin</em> is either 0, 1 or 2, indicating how many triangles this surface is a thin link for. This uses an unsigned type, since it will often be compared to <code>v.size()</code>.</li>
</ul>
<p>If no positive rational multiple of this surface is the normalised link of any triangle, then <em>link</em> will be 0 and <em>v</em> will be the empty vector.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the triangle(s) linked by a positive rational multiple of this surface and an integer indicating how many of these links are thin, as described above. </dd></dl>

</div>
</div>
<a id="a58653ebccb7decb1d64d1ac20f87ea5f" name="a58653ebccb7decb1d64d1ac20f87ea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58653ebccb7decb1d64d1ac20f87ea5f">&#9670;&#160;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this surface is orientable. </p>
<p>For our purposes, the empty surface is considered to be orientable.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is orientable, or <code>false</code> if this surface is non-orientable. </dd></dl>

</div>
</div>
<a id="a330f08b68053b89d2545c0027bbc3405" name="a330f08b68053b89d2545c0027bbc3405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330f08b68053b89d2545c0027bbc3405">&#9670;&#160;</a></span>isSplitting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isSplitting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a splitting surface. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a splitting surface. </dd></dl>

</div>
</div>
<a id="ab82721dfe41b187548593091b7274e6e" name="ab82721dfe41b187548593091b7274e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82721dfe41b187548593091b7274e6e">&#9670;&#160;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga8908257b6e32cb8aa136a30fa909a4bd">Edge</a>&lt; 3 &gt; * &gt; regina::NormalSurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this surface is the thin link of a single edge. </p>
<p>Here a <em>thin</em> edge link is a normal surface which appears naturally as the frontier of a regular neighbourhood of an edge, with no need for any further normalisation.</p>
<p>This behaves differently from <a class="el" href="#a3b78ead45e91f901445f05048e48f887" title="Determines whether or not a positive rational multiple of this surface is the normalised link of a si...">isNormalEdgeLink()</a>, which tests for a <em>normalised</em> edge link (which could end up far away from the edge, or could be normalised into a surface with different topology, or could even be normalised away to nothing). Although <a class="el" href="#a3b78ead45e91f901445f05048e48f887" title="Determines whether or not a positive rational multiple of this surface is the normalised link of a si...">isNormalEdgeLink()</a> will also indicate thin edge links, this test has significantly less overhead (and so should be faster).</p>
<p>A surface (or its positive rational multiple) can be the <em>thin</em> edge link of at most two edges. If there are indeed two different edges <em>e1</em> and <em>e2</em> for which a multiple of this surface can be expressed as the thin edge link, then the pair (<em>e1</em>, <em>e2</em>) will be returned. If there is only one such edge <em>e</em>, then the pair (<em>e</em>, <code>null</code>) will be returned. If no positive rational multiple of this surface is the thin link of any edge, then the pair (<code>null</code>, <code>null</code>) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by a positive rational multiple of this surface, as described above. </dd></dl>

</div>
</div>
<a id="a223f26abbafb1498524889ad3c7e9dc9" name="a223f26abbafb1498524889ad3c7e9dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223f26abbafb1498524889ad3c7e9dc9">&#9670;&#160;</a></span>isThinTriangleLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga1c370546ac30ee701314f56e63767bda">Triangle</a>&lt; 3 &gt; * &gt; regina::NormalSurface::isThinTriangleLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this surface is the thin link of a single triangle. </p>
<p>Here a <em>thin</em> triangle link is a normal surface which appears naturally as the frontier of a regular neighbourhood of a triangle, with no need for any further normalisation.</p>
<p>This behaves differently from <a class="el" href="#a7b5cfe2476623cefb240180431800aa1" title="Determines whether or not a positive rational multiple of this surface is the normalised link of a si...">isNormalTriangleLink()</a>, which tests for a <em>normalised</em> triangle link (which could end up far away from the triangle, or could be normalised into a surface with different topology, or could even be normalised away to nothing). Unlike the tests for edge links, the routines <a class="el" href="#a223f26abbafb1498524889ad3c7e9dc9" title="Determines whether or not a positive rational multiple of this surface is the thin link of a single t...">isThinTriangleLink()</a> and <a class="el" href="#a7b5cfe2476623cefb240180431800aa1" title="Determines whether or not a positive rational multiple of this surface is the normalised link of a si...">isNormalTriangleLink()</a> use essentially the same implementation (so testing for only thin links may be a little faster, but not by much).</p>
<p>A surface (or its positive rational multiple) can be the <em>thin</em> link of at most two triangles. If there are indeed two different triangles <em>t1</em> and <em>t2</em> for which a multiple of this surface can be expressed as the thin triangle link, then the pair (<em>t1</em>, <em>t2</em>) will be returned. If there is only one such triangle <em>t</em>, then the pair (<em>t</em>, <code>null</code>) will be returned. If no positive rational multiple of this surface is the thin link of any triangle, then the pair (<code>null</code>, <code>null</code>) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the triangle(s) linked by a positive rational multiple of this surface, as described above. </dd></dl>

</div>
</div>
<a id="a116c8925b42deeee786f3d4642b5bfd7" name="a116c8925b42deeee786f3d4642b5bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116c8925b42deeee786f3d4642b5bfd7">&#9670;&#160;</a></span>isTwoSided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this surface is two-sided. </p>
<p>For our purposes, the empty surface is considered to be two-sided.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is two-sided, or <code>false</code> if this surface is one-sided. </dd></dl>

</div>
</div>
<a id="af98616d2b0b270a6a427133d3cd88cae" name="af98616d2b0b270a6a427133d3cd88cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98616d2b0b270a6a427133d3cd88cae">&#9670;&#160;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gaa2d0c69ce4cea268f94f93dbbcfbc21d">Vertex</a>&lt; 3 &gt; * regina::NormalSurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not a positive rational multiple of this surface is the link of a single vertex. </p>
<p>This behaves differently from <a class="el" href="#a8ab8b0a34b4c8a0847aba54974f1c009" title="Determines whether or not this surface is vertex linking.">isVertexLinking()</a>, which will also detect a union of several different vertex links. In contrast, this routine will only identify the link of a <em>single</em> vertex (or a multiple of such a link).</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by a positive rational multiple of this surface, or <code>null</code> if this surface is not a multiple of a single vertex link. </dd></dl>

</div>
</div>
<a id="a8ab8b0a34b4c8a0847aba54974f1c009" name="a8ab8b0a34b4c8a0847aba54974f1c009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab8b0a34b4c8a0847aba54974f1c009">&#9670;&#160;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this surface is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>This behaves differently from <a class="el" href="#af98616d2b0b270a6a427133d3cd88cae" title="Determines whether or not a positive rational multiple of this surface is the link of a single vertex...">isVertexLink()</a>, which only detects the link of a single vertex (or a multiple of such a link). In contrast, this routine will also detect the union of several <em>different</em> vertex links.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is vertex linking. </dd></dl>

</div>
</div>
<a id="aa1aa3f944bc8cd084d2a00aadc0f0eb2" name="aa1aa3f944bc8cd084d2a00aadc0f0eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aa3f944bc8cd084d2a00aadc0f0eb2">&#9670;&#160;</a></span>locallyCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface are locally compatible. </p>
<p>Local compatibility means that, within each individual tetrahedron of the triangulation, it is possible to arrange the normal discs of both surfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all tetrahedra <em>simultaneously</em>. To test the global constraint, see the (much slower) routine <a class="el" href="#a7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">disjoint()</a> instead.</p>
<p>Local compatibility can be formulated in terms of normal disc types. Two normal (or almost normal) surfaces are locally compatible if and only if they together have at most one quadrilateral or octagonal disc type per tetrahedron.</p>
<p>Note again that this is a local constraint only. In particular, for almost normal surfaces, it does <em>not</em> insist that there is at most one octagonal disc type anywhere within the triangulation.</p>
<p>If one of the two surfaces breaks the local compatibility constraints on its own (for instance, it contains two different quadrilateral disc types within the same tetrahedron), then this routine will return <code>false</code> regardless of what the other surface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test for local compatibility with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two surfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="a1b66f7c42869115a48a9260432252e4b" name="a1b66f7c42869115a48a9260432252e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66f7c42869115a48a9260432252e4b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalSurface::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this surface. </dd></dl>

</div>
</div>
<a id="a8803a3a19f5a6f7db0c2ae0e18499bfa" name="a8803a3a19f5a6f7db0c2ae0e18499bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8803a3a19f5a6f7db0c2ae0e18499bfa">&#9670;&#160;</a></span>normal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::normal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this surface contains only triangle and/or quadrilateral discs. </p>
<p>This is to distinguish normal surfaces from more general surfaces such as almost normal surfaces (which also contain octagonal pieces).</p>
<p>Even if the underlying vector encoding supports other disc types (such as octagons), this routine will still return <code>true</code> if this particular surface does not use them. This is in contrast to the routine <a class="el" href="classregina_1_1NormalSurfaces.html#a286441732edb4692736f33e769489dde" title="Determines if the coordinate system that was used for enumeration allows for almost normal surfaces.">NormalSurfaces::allowsAlmostNormal()</a>, which only examines the underlying coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface contains only triangles and/or quadrilaterals. </dd></dl>

</div>
</div>
<a id="a1a06c1a51568cc60c9699b083876a16c" name="a1a06c1a51568cc60c9699b083876a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a06c1a51568cc60c9699b083876a16c">&#9670;&#160;</a></span>octPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscType.html">DiscType</a> regina::NormalSurface::octPosition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first coordinate position at which this surface has a non-zero octagonal coordinate. </p>
<p>In other words, if this routine returns the disc type <em>t</em>, then the octagonal coordinate returned by octs(t.tetIndex, t.type) is non-zero. Here <a class="el" href="structregina_1_1DiscType.html#a71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> represents an octagon type within a tetrahedron, and takes values between 0 and 2 inclusive.</p>
<p>If this surface does not contain any octagons, this routine returns a null disc type instead.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately. Moreover, if the underlying coordinate system does not support almost normal surfaces, then even the first call is fast (it returns a null disc type immediately).</p>
<dl class="section return"><dt>Returns</dt><dd>the position of the first non-zero octagonal coordinate, or a null disc type if there is no such coordinate. </dd></dl>

</div>
</div>
<a id="abae51e35ce30784d586dfca6576243ee" name="abae51e35ce30784d586dfca6576243ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae51e35ce30784d586dfca6576243ee">&#9670;&#160;</a></span>octs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::octs </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>tetIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>octType</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of octagonal discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of octagons, defined by how they separate the four tetrahedron vertices into two pairs. Octagon type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to intersect edges <em>i</em> and (5-<em>i</em>) of the tetrahedron twice each, and to intersect the remaining edges once each. This means:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

</div>
</div>
<a id="ae33e838ad77532c318e9a23e192f63b0" name="ae33e838ad77532c318e9a23e192f63b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e838ad77532c318e9a23e192f63b0">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> regina::NormalSurface::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given integer multiple of this surface. </p>
<p>The resulting surface will use the same internal vector encoding as this surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>the coefficient to multiply this surface by; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting multiple of this surface. </dd></dl>

</div>
</div>
<a id="a4d9e87d906c720446b25e1842472445f" name="a4d9e87d906c720446b25e1842472445f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e87d906c720446b25e1842472445f">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp; regina::NormalSurface::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this surface into the given integer multiple of itself. </p>
<p>The internal vector encoding used by this surface will not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>the coefficient to multiply this surface by; this must be non-negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this surface. </dd></dl>

</div>
</div>
<a id="aef986687b3c0c5631e426e43b82818ad" name="aef986687b3c0c5631e426e43b82818ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef986687b3c0c5631e426e43b82818ad">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> regina::NormalSurface::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sum of this and the given surface. </p>
<p>This will combine all triangles, quadrilaterals and/or octagons from both surfaces.</p>
<p>The two surfaces do not need to use the same coordinate system and/or internal vector encodings. Moreover, the resulting surface might well use an encoding different from both of these, or even a hybrid encoding that does not come from one of Regina's ready-made coordinate systems.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface use the same underlying triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the surface to sum with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of both normal surfaces. </dd></dl>

</div>
</div>
<a id="a501dbb7915f107c4bf6d8225f2384906" name="a501dbb7915f107c4bf6d8225f2384906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501dbb7915f107c4bf6d8225f2384906">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ordering regina::NormalSurface::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares this against the given surface under a total ordering of all normal and almost normal surfaces. </p>
<p>This ordering is not mathematically meaningful; it is merely provided for scenarios where you need to be able to sort surfaces (e.g., when using them as keys in a map).</p>
<p>The order <em>is</em> well-defined, and will be preserved across copy/move operations, different program executions, and different platforms (since it is defined purely in terms of the normal coordinates, and does not use transient properties such as locations in memory).</p>
<p>This operation is consistent with the equality test. In particular, it does not matter whether the two surfaces belong to different triangulations, or use different encodings, or if one but not the other supports non-compact or almost normal surfaces. See the equality test <a class="el" href="#a56a7382380fd07286d7da275409b87f6" title="Determines whether this and the given surface in fact represent the same normal (or almost normal) su...">operator==()</a> for further details.</p>
<p>This routine generates all of the usual comparison operators, including <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This spaceship operator <code>x &lt;=&gt; y</code> is not available, but the other comparison operators that it generates <em>are</em> available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the surface to compare this surface with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison between this and the given surface. This is marked as a weak ordering (not a strong ordering) to reflect the fact that (for example) surfaces in different triangulations or using different encodings could be considered equal under this comparison. </dd></dl>

</div>
</div>
<a id="a785fe921cdb394f08f241bd05871fd6a" name="a785fe921cdb394f08f241bd05871fd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785fe921cdb394f08f241bd05871fd6a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp; regina::NormalSurface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given normal surface. </p>
<p>This and the given normal surface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then this surface will be adjusted accordingly.</p>
<p>This operator induces a deep copy of the given normal surface.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this normal surface. </dd></dl>

</div>
</div>
<a id="acfe10a28b71a5ddfac6cb5fda5965869" name="acfe10a28b71a5ddfac6cb5fda5965869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe10a28b71a5ddfac6cb5fda5965869">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp; regina::NormalSurface::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given normal surface to this surface. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given normal surface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then this surface will be adjusted accordingly.</p>
<p>The surface that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this normal surface. </dd></dl>

</div>
</div>
<a id="a56a7382380fd07286d7da275409b87f6" name="a56a7382380fd07286d7da275409b87f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a7382380fd07286d7da275409b87f6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface in fact represent the same normal (or almost normal) surface. </p>
<p>Specifically, this routine examines (or computes) the number of normal or almost normal discs of each type, and returns <code>true</code> if and only if these counts are the same for both surfaces.</p>
<p>It does not matter what vector encodings the two surfaces use. In particular, it does not matter if the two surfaces use different encodings, or if one but not the other supports almost normal and/or spun-normal surfaces.</p>
<p>This routine is safe to call even if this and the given surface do not belong to the same triangulation:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will test whether this surface, if transplanted into the other triangulation using the same tetrahedron numbering and the same normal disc types, would be the same as <em>other</em>.</li>
<li>If the two triangulations have different sizes, then this routine will return <code>false</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the surface to be compared with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces represent the same normal or almost normal surface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ac8380567805860ecdbde4bde09a5fc9c" name="ac8380567805860ecdbde4bde09a5fc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8380567805860ecdbde4bde09a5fc9c">&#9670;&#160;</a></span>quads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::quads </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>tetIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>quadType</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of quadrilateral discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of quadrilaterals, defined by how they separate the four tetrahedron vertices into two pairs. Quadrilateral type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to separate edge <em>i</em> of the tetrahedron from edge (5-<em>i</em>). That is:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

</div>
</div>
<a id="a1e4e7dd00c4ae8ecb50552a67e766dec" name="a1e4e7dd00c4ae8ecb50552a67e766dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4e7dd00c4ae8ecb50552a67e766dec">&#9670;&#160;</a></span>reconstructTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalSurface::reconstructTriangles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>enc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs the triangle coordinates in the given integer vector. </p>
<p>The given vector must represent a normal surface within the given triangulation, using the given vector encoding.</p>
<ul>
<li>If the given encoding does not already store triangle coordinates, then the vector will be modified directly to use a new encoding that does, and this new encoding will be returned.</li>
<li>If the given encoding does already store triangles, then this routine will do nothing and immediately return <em>enc</em>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which the normal surface lives. </td></tr>
    <tr><td class="paramname">vector</td><td>an integer vector that encodes a normal (or almost normal) surface within <em>tri</em>; this will be modified directly. </td></tr>
    <tr><td class="paramname">enc</td><td>the encoding used by the given integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new encoding used by the modified <em>vector</em>. </dd></dl>

</div>
</div>
<a id="a941a7cd6c0d8368ced19d60b40e774d7" name="a941a7cd6c0d8368ced19d60b40e774d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941a7cd6c0d8368ced19d60b40e774d7">&#9670;&#160;</a></span>removeOcts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> regina::NormalSurface::removeOcts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an isotopic normal surface that contains no octagons, placed within a homeomorphic (but possibly different) triangulation. </p>
<p>Specifically: this routine returns a surface <em>s</em> within a triangulation <em>t</em>, where <em>t</em> is homeomorphic to the triangulation containing this surface, and where <em>s</em> is a normal (not almost normal) surface isotopic to this. Only the surface <em>s</em> is returned; you can access <em>t</em> by calling <code>s.triangulation()</code>.</p>
<p>If this surface is already normal (i.e., it does not contain any octagons), then the surface returned will simply be a copy of this surface (but possibly using a different vector encoding), living within the same triangulation.</p>
<p>If this surface does contain octagons, then the triangulation <em>t</em> will be obtained from the original by replacing each tetrahedron containing octagons with <em>three</em> tetrahedra (essentially performing a 0-2 move). Each octagon can then be subdivided into a quadrilateral and four triangles. If the original triangulation is oriented, then the new triangulation <em>t</em> will preserve this orientation.</p>
<p>In all cases, the surface that is returned will use a vector encoding that does not store octagons.</p>
<p>Note: this routine can happily cope with multiple octagons in the same tetrahedron, and/or multiple tetrahedra containing octagons.</p>
<p>This routine ignores tetrahedron locks entirely. If there are octagons present and the triangulation does change, then the new triangulation will have no tetrahedron or triangle locks at all. In particular, such locks will not stop this routine from subdividing those tetrahedra that contain octagons. Of course, the original triangulation will remain untouched, with all of its locks intact.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This surface is embedded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isotopic normal (not almost normal) surface <em>s</em>, as described above. </dd></dl>

</div>
</div>
<a id="a22f070feb9eb0f0a39e5c1ca2fed1919" name="a22f070feb9eb0f0a39e5c1ca2fed1919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f070feb9eb0f0a39e5c1ca2fed1919">&#9670;&#160;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::scaleDown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this surface into its smallest positive rational multiple with integer coordinates. </p>
<p>Note that the scaling factor will be independent of which internal vector encoding is used. This is essentially because integer quad coordinates (which are stored in every encoding) and integer octagon coordinates (which are stored in every almost normal encoding) are enough to guarantee integer triangle coordinates (which might or might not be stored).</p>
<dl class="section return"><dt>Returns</dt><dd>the integer by which the original surface was divided (i.e., the gcd of all normal coordinates in the original surface). This will always be strictly positive. </dd></dl>

</div>
</div>
<a id="adc02da051a9ee5351ebd2e945d208e1e" name="adc02da051a9ee5351ebd2e945d208e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc02da051a9ee5351ebd2e945d208e1e">&#9670;&#160;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name to associate with this surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae9a6541e5a18984537c70e105c84bced" name="ae9a6541e5a18984537c70e105c84bced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a6541e5a18984537c70e105c84bced">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given normal surface. </p>
<p>This is a fast (constant time) operation.</p>
<p>This and the given normal surface do not need to live in the same underlying triangulation, and they do not need to have the same length vectors or use the same normal coordinate system - if any of these properties differs then the two surfaces will be adjusted accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the normal surface whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa25f8c4dad5d3efcfe3f01aeca20c8a8" name="aa25f8c4dad5d3efcfe3f01aeca20c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8">&#9670;&#160;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> regina::NormalSurface::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>tetIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of triangular discs of the given type in this normal surface. </p>
<p>A triangular disc type is identified by specifying a tetrahedron and a vertex of that tetrahedron that the triangle surrounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

</div>
</div>
<a id="a0e446c1e71f8f7db55f66b30c273549f" name="a0e446c1e71f8f7db55f66b30c273549f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e446c1e71f8f7db55f66b30c273549f">&#9670;&#160;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; regina::NormalSurface::triangulation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation in which this normal surface resides. </p>
<p>This will be a snapshot frozen in time of the triangulation that was originally passed to the <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> constructor.</p>
<p>This will return a correct result even if the original triangulation has since been modified or destroyed. However, in order to ensure this behaviour, it is possible that at different points in time this function may return references to different C++ objects.</p>
<p>The rules for using the <a class="el" href="#a0e446c1e71f8f7db55f66b30c273549f" title="Returns the triangulation in which this normal surface resides.">triangulation()</a> reference are:</p>
<ul>
<li>Do not keep the resulting reference as a long-term reference or pointer of your own, since in time you may find yourself referring to the wrong object (see above). Just call this function again.</li>
<li>You must respect the read-only nature of the result (i.e., you must not cast the constness away). The snapshotting process detects modifications, and modifying the frozen snapshot may result in an exception being thrown.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa2b56885a01e289daff0f480ba9c5170" name="aa2b56885a01e289daff0f480ba9c5170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b56885a01e289daff0f480ba9c5170">&#9670;&#160;</a></span>vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a> &gt; &amp; regina::NormalSurface::vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the integer vector that Regina uses internally to represent this surface. </p>
<p>Note that this vector might not use the same coordinate system in which the surfaces were originally enumerated. (For example, this vector will always include triangle coordinates, even if the surfaces were originally enumerated in quad or quad-oct coordinates.) You can call <a class="el" href="#a4a7d356c59e7a3f1e94fcdcd4a5bb6f6" title="Returns the specific integer vector encoding that this surface uses internally.">encoding()</a> to find out precisley how the coordinates of this vector should be interpreted.</p>
<p>See the <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> class notes for information on how this vector is structured.</p>
<dl class="section note"><dt>Note</dt><dd>If you wish to access the numbers of triangles, quads and so on, you should use the functions <a class="el" href="#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a>, <a class="el" href="#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a>, etc., which do not require any knowledge of the internal vector encoding that this surface uses.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying integer vector. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81b1867108288341c2706866539106fa" name="a81b1867108288341c2706866539106fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b1867108288341c2706866539106fa">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this surface to the given output stream, using standard triangle-quad-oct coordinates. </p>
<p>Octagonal coordinates will only be written if the surface is stored using an encoding that supports almost normal surfaces.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7197a0fbeb7286375ee54cf11c33ef29" name="a7197a0fbeb7286375ee54cf11c33ef29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7197a0fbeb7286375ee54cf11c33ef29">&#9670;&#160;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__file.html#ga9888b0803d972a428b069fbf473aca68">FileFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal surface and all of its properties. </p>
<p>This routine will be called from within NormalSurfaces::writeXMLPacketData().</p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
    <tr><td class="paramname">format</td><td>indicates which of Regina's XML file formats to write. </td></tr>
    <tr><td class="paramname">list</td><td>the enclosing normal surface list. Currently this is only relevant when writing to the older <a class="el" href="group__file.html#gga9888b0803d972a428b069fbf473aca68a8ebe490ca48cc932225a7c441864abd1" title="Indicates the second-generation file format used from Regina 3.0 through to Regina 6....">FileFormat::XmlGen2</a> format; it will be ignored (and may be <code>null</code>) for newer file formats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3777d04afc658246c3fa61a1ea3efdfa" name="a3777d04afc658246c3fa61a1ea3efdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3777d04afc658246c3fa61a1ea3efdfa">&#9670;&#160;</a></span>boundaries_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; regina::NormalSurface::boundaries_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of disjoint boundary curves on this surface. </p>
<p>This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a2498a9bb61162987fc338e589e35ac84" name="a2498a9bb61162987fc338e589e35ac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2498a9bb61162987fc338e589e35ac84">&#9670;&#160;</a></span>compact_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalSurface::compact_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface compact (i.e. </p>
<p>does it only contain finitely many discs)? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="ad44a7bc466fa79002847f5071af338c6" name="ad44a7bc466fa79002847f5071af338c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44a7bc466fa79002847f5071af338c6">&#9670;&#160;</a></span>connected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalSurface::connected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface connected? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a7fe45697e6bfb1750488bdb3601560e8" name="a7fe45697e6bfb1750488bdb3601560e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe45697e6bfb1750488bdb3601560e8">&#9670;&#160;</a></span>enc_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalSurface::enc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The specific encoding of a normal surface used by the coordinate vector. </p>

</div>
</div>
<a id="a27b76ecbd28f7c5b8dfb1a6b2c0bba40" name="a27b76ecbd28f7c5b8dfb1a6b2c0bba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b76ecbd28f7c5b8dfb1a6b2c0bba40">&#9670;&#160;</a></span>eulerChar_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&gt; regina::NormalSurface::eulerChar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Euler characteristic of this surface. </p>
<p>This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a1d3555b1171347a9041af35e95ab1738" name="a1d3555b1171347a9041af35e95ab1738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3555b1171347a9041af35e95ab1738">&#9670;&#160;</a></span>linkOf_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t regina::NormalSurface::linkOf_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which dimensions of face a positive rational multiple of this surface is a thin or normalised link of. </p>
<p>This is treated as a bitmask: for each i=0,1,2, the (2i+1)th bit indicates whether this surface scales to the link of an i-face, and the (2i)th bit indicates whether this information has actually been computed yet; if it has not been computed, then the (2i+1)th bit will be zero. </p>

</div>
</div>
<a id="a78f559575a99f46ef3bf189016d2eee0" name="a78f559575a99f46ef3bf189016d2eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f559575a99f46ef3bf189016d2eee0">&#9670;&#160;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalSurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this surface. </p>

</div>
</div>
<a id="a822c62b7fdfb5396f627ecd0942ac362" name="a822c62b7fdfb5396f627ecd0942ac362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822c62b7fdfb5396f627ecd0942ac362">&#9670;&#160;</a></span>octPosition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structregina_1_1DiscType.html">DiscType</a>&gt; regina::NormalSurface::octPosition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of the first non-zero octagonal coordinate, or a null disc type if there is no non-zero octagonal coordinate. </p>
<p>Here <a class="el" href="structregina_1_1DiscType.html#a71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> is an octagon type between 0 and 2 inclusive. This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a9a0e0538e051f9862459a0f5a2978684" name="a9a0e0538e051f9862459a0f5a2978684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0e0538e051f9862459a0f5a2978684">&#9670;&#160;</a></span>orientable_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalSurface::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface orientable? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="aa9c2cb19b3e122b76214a3b874133d8a" name="aa9c2cb19b3e122b76214a3b874133d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c2cb19b3e122b76214a3b874133d8a">&#9670;&#160;</a></span>realBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalSurface::realBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this surface have real boundary (i.e. </p>
<p>does it meet any boundary triangles)? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="a8295e0b8668759daa676e739140bcd27" name="a8295e0b8668759daa676e739140bcd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8295e0b8668759daa676e739140bcd27">&#9670;&#160;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt;<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt; &gt; regina::NormalSurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal surface resides. </p>

</div>
</div>
<a id="acc524b638f28a70858c36ab13e6abdd3" name="acc524b638f28a70858c36ab13e6abdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc524b638f28a70858c36ab13e6abdd3">&#9670;&#160;</a></span>twoSided_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; regina::NormalSurface::twoSided_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface two-sided? This is std::nullopt if it has not yet been computed. </p>

</div>
</div>
<a id="aac30104f9ce828b81f6411940cc1f51c" name="aac30104f9ce828b81f6411940cc1f51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac30104f9ce828b81f6411940cc1f51c">&#9670;&#160;</a></span>vector_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt;<a class="el" href="group__maths.html#ga09ee46ba09e6de43ed86f26fe90b81f9">LargeInteger</a>&gt; regina::NormalSurface::vector_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal surface. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surface/<a class="el" href="normalsurface_8h.html">normalsurface.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
