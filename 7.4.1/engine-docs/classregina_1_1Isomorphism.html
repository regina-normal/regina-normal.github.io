<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::Isomorphism&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1Isomorphism-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Isomorphism&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__generic.html">Generic triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a combinatorial isomorphism from one <em>dim</em>-manifold triangulation into another.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/generic.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Isomorphism&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Isomorphism.png" usemap="#regina::Isomorphism_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::Isomorphism_3C_20dim_20_3E_map" name="regina::Isomorphism_3C_20dim_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Isomorphism&lt; dim &gt; &gt;" shape="rect" coords="0,0,352,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Isomorphism&lt; dim &gt; &gt;" shape="rect" coords="362,0,714,24"/>
<area href="classregina_1_1alias_1_1IsomorphismImage.html" alt="regina::alias::IsomorphismImage&lt; Isomorphism&lt; dim &gt;, dim &gt;" shape="rect" coords="724,0,1076,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6eb987b8089f111e1c0908500c01eb6e" id="r_a6eb987b8089f111e1c0908500c01eb6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb987b8089f111e1c0908500c01eb6e">Isomorphism</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:a6eb987b8089f111e1c0908500c01eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new isomorphism with no initialisation.  <br /></td></tr>
<tr class="separator:a6eb987b8089f111e1c0908500c01eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9f2112ee5058c263535563715c585e" id="r_a8f9f2112ee5058c263535563715c585e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f9f2112ee5058c263535563715c585e">Isomorphism</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;src)</td></tr>
<tr class="memdesc:a8f9f2112ee5058c263535563715c585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given isomorphism.  <br /></td></tr>
<tr class="separator:a8f9f2112ee5058c263535563715c585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a8b6612fe01e4ecc8bfad1423898c8" id="r_ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a8b6612fe01e4ecc8bfad1423898c8">Isomorphism</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this new isomorphism.  <br /></td></tr>
<tr class="separator:ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cf1afeffd310db7d7ca89d19b2437" id="r_ac99cf1afeffd310db7d7ca89d19b2437"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99cf1afeffd310db7d7ca89d19b2437">~Isomorphism</a> ()</td></tr>
<tr class="memdesc:ac99cf1afeffd310db7d7ca89d19b2437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this isomorphism.  <br /></td></tr>
<tr class="separator:ac99cf1afeffd310db7d7ca89d19b2437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdfca99e94446a343b101ec6331f77" id="r_aadbdfca99e94446a343b101ec6331f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadbdfca99e94446a343b101ec6331f77">operator=</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;src)</td></tr>
<tr class="memdesc:aadbdfca99e94446a343b101ec6331f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given isomorphism into this isomorphism.  <br /></td></tr>
<tr class="separator:aadbdfca99e94446a343b101ec6331f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4812ece221766e1dfd2cca99f007f5" id="r_a0a4812ece221766e1dfd2cca99f007f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4812ece221766e1dfd2cca99f007f5">operator=</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a0a4812ece221766e1dfd2cca99f007f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this isomorphism.  <br /></td></tr>
<tr class="separator:a0a4812ece221766e1dfd2cca99f007f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add60c472f78f9fbabaa4990bcea77d4b" id="r_add60c472f78f9fbabaa4990bcea77d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add60c472f78f9fbabaa4990bcea77d4b">swap</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:add60c472f78f9fbabaa4990bcea77d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given isomorphism.  <br /></td></tr>
<tr class="separator:add60c472f78f9fbabaa4990bcea77d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d931b107736175dd59b4463be7beb4" id="r_a77d931b107736175dd59b4463be7beb4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d931b107736175dd59b4463be7beb4">size</a> () const</td></tr>
<tr class="memdesc:a77d931b107736175dd59b4463be7beb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplices in the source triangulation associated with this isomorphism.  <br /></td></tr>
<tr class="separator:a77d931b107736175dd59b4463be7beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37b1d0c51871819f5c8a9cfcb1285c4" id="r_ac37b1d0c51871819f5c8a9cfcb1285c4"><td class="memItemLeft" align="right" valign="top">ssize_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac37b1d0c51871819f5c8a9cfcb1285c4">simpImage</a> (size_t sourceSimp)</td></tr>
<tr class="memdesc:ac37b1d0c51871819f5c8a9cfcb1285c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the image of the given source simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:ac37b1d0c51871819f5c8a9cfcb1285c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e1af908613357cfb4b0fd9a1d87a9f" id="r_a93e1af908613357cfb4b0fd9a1d87a9f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e1af908613357cfb4b0fd9a1d87a9f">simpImage</a> (size_t sourceSimp) const</td></tr>
<tr class="memdesc:a93e1af908613357cfb4b0fd9a1d87a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:a93e1af908613357cfb4b0fd9a1d87a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0479919ce5f18f7bee47caed5b78c9" id="r_a0c0479919ce5f18f7bee47caed5b78c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c0479919ce5f18f7bee47caed5b78c9">setSimpImage</a> (size_t sourceSimp, ssize_t image)</td></tr>
<tr class="memdesc:a0c0479919ce5f18f7bee47caed5b78c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only routine that sets the image of the given source simplex to the given value under this isomorphism.  <br /></td></tr>
<tr class="separator:a0c0479919ce5f18f7bee47caed5b78c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88d67222559aeac9d1dbd93a18b171a" id="r_ab88d67222559aeac9d1dbd93a18b171a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab88d67222559aeac9d1dbd93a18b171a">facetPerm</a> (size_t sourceSimp)</td></tr>
<tr class="memdesc:ab88d67222559aeac9d1dbd93a18b171a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:ab88d67222559aeac9d1dbd93a18b171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f09f23249eac6f30f7fcd3f54f6f2" id="r_ad31f09f23249eac6f30f7fcd3f54f6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad31f09f23249eac6f30f7fcd3f54f6f2">facetPerm</a> (size_t sourceSimp) const</td></tr>
<tr class="memdesc:ad31f09f23249eac6f30f7fcd3f54f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:ad31f09f23249eac6f30f7fcd3f54f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68080c46920e8e102f0dd0a72b63fdc" id="r_af68080c46920e8e102f0dd0a72b63fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af68080c46920e8e102f0dd0a72b63fdc">setFacetPerm</a> (size_t sourceSimp, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; perm)</td></tr>
<tr class="memdesc:af68080c46920e8e102f0dd0a72b63fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only routine that sets the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:af68080c46920e8e102f0dd0a72b63fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b5f3b813d309d8e0b91e347635e163" id="r_af6b5f3b813d309d8e0b91e347635e163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b5f3b813d309d8e0b91e347635e163">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:af6b5f3b813d309d8e0b91e347635e163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex facet under this isomorphism.  <br /></td></tr>
<tr class="separator:af6b5f3b813d309d8e0b91e347635e163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e50ac413fde3e237c905aa210afca" id="r_a880e50ac413fde3e237c905aa210afca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a880e50ac413fde3e237c905aa210afca">isIdentity</a> () const</td></tr>
<tr class="memdesc:a880e50ac413fde3e237c905aa210afca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this is an identity isomorphism.  <br /></td></tr>
<tr class="separator:a880e50ac413fde3e237c905aa210afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab10fe5c9b8c532c178bc16b1d48fa8" id="r_a5ab10fe5c9b8c532c178bc16b1d48fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ab10fe5c9b8c532c178bc16b1d48fa8">operator()</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:a5ab10fe5c9b8c532c178bc16b1d48fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.  <br /></td></tr>
<tr class="separator:a5ab10fe5c9b8c532c178bc16b1d48fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b92ac940e94b5e316d88a37336b9b7" id="r_a61b92ac940e94b5e316d88a37336b9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61b92ac940e94b5e316d88a37336b9b7">operator()</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;f) const</td></tr>
<tr class="memdesc:a61b92ac940e94b5e316d88a37336b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the image of the given facet-of-simplex under this isomorphism.  <br /></td></tr>
<tr class="separator:a61b92ac940e94b5e316d88a37336b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bef162a2366d06cf500bcd829c13b5" id="r_a14bef162a2366d06cf500bcd829c13b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bef162a2366d06cf500bcd829c13b5">operator()</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="memdesc:a14bef162a2366d06cf500bcd829c13b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given facet pairing, and returns the result as a new facet pairing.  <br /></td></tr>
<tr class="separator:a14bef162a2366d06cf500bcd829c13b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4b99d17b4ac449bdb7573d9b949946" id="r_a1d4b99d17b4ac449bdb7573d9b949946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d4b99d17b4ac449bdb7573d9b949946">apply</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:a1d4b99d17b4ac449bdb7573d9b949946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that applies this isomorphism to the given triangulation, and returns the result as a new triangulation.  <br /></td></tr>
<tr class="separator:a1d4b99d17b4ac449bdb7573d9b949946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa78db49451ace59647d31fa33336739" id="r_afa78db49451ace59647d31fa33336739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa78db49451ace59647d31fa33336739">applyInPlace</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:afa78db49451ace59647d31fa33336739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that applies this isomorphism to the given triangulation, modifying the given triangulation directly.  <br /></td></tr>
<tr class="separator:afa78db49451ace59647d31fa33336739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651b16d2278cea837a1174241694d6b" id="r_a5651b16d2278cea837a1174241694d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5651b16d2278cea837a1174241694d6b">operator*</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a5651b16d2278cea837a1174241694d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of this isomorphism with the given isomorphism.  <br /></td></tr>
<tr class="separator:a5651b16d2278cea837a1174241694d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4a10117f941ed3f6d274582310f3e" id="r_ae4b4a10117f941ed3f6d274582310f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b4a10117f941ed3f6d274582310f3e">operator*</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;rhs) const</td></tr>
<tr class="memdesc:ae4b4a10117f941ed3f6d274582310f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of this isomorphism with the given isomorphism.  <br /></td></tr>
<tr class="separator:ae4b4a10117f941ed3f6d274582310f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba485488b0b1a4c03d5b5b3611f382c" id="r_a2ba485488b0b1a4c03d5b5b3611f382c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba485488b0b1a4c03d5b5b3611f382c">inverse</a> () const</td></tr>
<tr class="memdesc:a2ba485488b0b1a4c03d5b5b3611f382c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of this isomorphism.  <br /></td></tr>
<tr class="separator:a2ba485488b0b1a4c03d5b5b3611f382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef7b43f2c133c24bb83f8cb8de16784" id="r_a7ef7b43f2c133c24bb83f8cb8de16784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef7b43f2c133c24bb83f8cb8de16784">operator++</a> ()</td></tr>
<tr class="memdesc:a7ef7b43f2c133c24bb83f8cb8de16784"><td class="mdescLeft">&#160;</td><td class="mdescRight">A preincrement operator that changes this to be the next isomorphism in an iteration through all possible isomorphisms of this size.  <br /></td></tr>
<tr class="separator:a7ef7b43f2c133c24bb83f8cb8de16784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef21c9bb34621a0b17b450da31c8b55" id="r_a1ef21c9bb34621a0b17b450da31c8b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef21c9bb34621a0b17b450da31c8b55">operator++</a> (int)</td></tr>
<tr class="memdesc:a1ef21c9bb34621a0b17b450da31c8b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A postincrement operator that changes this to be the next isomorphism in an iteration through all possible isomorphisms of this size.  <br /></td></tr>
<tr class="separator:a1ef21c9bb34621a0b17b450da31c8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae0f834bdc1cf66270c383626ff3801" id="r_a5ae0f834bdc1cf66270c383626ff3801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae0f834bdc1cf66270c383626ff3801">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5ae0f834bdc1cf66270c383626ff3801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this isomorphism to the given output stream.  <br /></td></tr>
<tr class="separator:a5ae0f834bdc1cf66270c383626ff3801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b944c2c93b301727c302ca5d7ae8c" id="r_a3e1b944c2c93b301727c302ca5d7ae8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e1b944c2c93b301727c302ca5d7ae8c">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a3e1b944c2c93b301727c302ca5d7ae8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a3e1b944c2c93b301727c302ca5d7ae8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce6b558d467de401dbdd5d1bc1e339a" id="r_abce6b558d467de401dbdd5d1bc1e339a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce6b558d467de401dbdd5d1bc1e339a">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:abce6b558d467de401dbdd5d1bc1e339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:abce6b558d467de401dbdd5d1bc1e339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368f8ed113d2bc0f2d10b3697309c494" id="r_a368f8ed113d2bc0f2d10b3697309c494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a368f8ed113d2bc0f2d10b3697309c494">operator==</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;other) const</td></tr>
<tr class="memdesc:a368f8ed113d2bc0f2d10b3697309c494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given isomorphism are identical.  <br /></td></tr>
<tr class="separator:a368f8ed113d2bc0f2d10b3697309c494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51197dbd112bb60b7893cc51a09003" id="r_a2c51197dbd112bb60b7893cc51a09003"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a2c51197dbd112bb60b7893cc51a09003">hash</a> () const</td></tr>
<tr class="memdesc:a2c51197dbd112bb60b7893cc51a09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:a2c51197dbd112bb60b7893cc51a09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad39b1a791c06935238f56d243b4685dc" id="r_ad39b1a791c06935238f56d243b4685dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39b1a791c06935238f56d243b4685dc">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:ad39b1a791c06935238f56d243b4685dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an isomorphism from its given tight encoding.  <br /></td></tr>
<tr class="separator:ad39b1a791c06935238f56d243b4685dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c565a9838914646dcebd1bc06292a1" id="r_a90c565a9838914646dcebd1bc06292a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c565a9838914646dcebd1bc06292a1">identity</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:a90c565a9838914646dcebd1bc06292a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity isomorphism for the given number of simplices.  <br /></td></tr>
<tr class="separator:a90c565a9838914646dcebd1bc06292a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb293fe603065ae43cbfb9432b9048a6" id="r_abb293fe603065ae43cbfb9432b9048a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb293fe603065ae43cbfb9432b9048a6">random</a> (size_t nSimplices, bool even=false)</td></tr>
<tr class="memdesc:abb293fe603065ae43cbfb9432b9048a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random isomorphism for the given number of simplices.  <br /></td></tr>
<tr class="separator:abb293fe603065ae43cbfb9432b9048a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6cb90d8b4eb9ea70fdc100ea025ff3f0" id="r_a6cb90d8b4eb9ea70fdc100ea025ff3f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb90d8b4eb9ea70fdc100ea025ff3f0">size_</a></td></tr>
<tr class="memdesc:a6cb90d8b4eb9ea70fdc100ea025ff3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices in the source triangulation.  <br /></td></tr>
<tr class="separator:a6cb90d8b4eb9ea70fdc100ea025ff3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00909c11fbb045f331b2d8e2b8f7ed" id="r_abc00909c11fbb045f331b2d8e2b8f7ed"><td class="memItemLeft" align="right" valign="top">ssize_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc00909c11fbb045f331b2d8e2b8f7ed">simpImage_</a></td></tr>
<tr class="memdesc:abc00909c11fbb045f331b2d8e2b8f7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to.  <br /></td></tr>
<tr class="separator:abc00909c11fbb045f331b2d8e2b8f7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f8449939cf548ae66b62b0853d269c" id="r_aa3f8449939cf548ae66b62b0853d269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f8449939cf548ae66b62b0853d269c">facetPerm_</a></td></tr>
<tr class="memdesc:aa3f8449939cf548ae66b62b0853d269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The permutation applied to the facets of each source simplex.  <br /></td></tr>
<tr class="separator:aa3f8449939cf548ae66b62b0853d269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::Isomorphism&lt; dim &gt;</div><p>Represents a combinatorial isomorphism from one <em>dim</em>-manifold triangulation into another. </p>
<p>In essence, a combinatorial isomorphism from triangulation <em>T</em> to triangulation <em>U</em> is a one-to-one map from the simplices of <em>T</em> to the simplices of <em>U</em> that allows relabelling of both the simplices and their facets (or equivalently, their vertices), and that preserves gluings across adjacent simplices.</p>
<p>More precisely: An isomorphism consists of (i) a one-to-one map <em>f</em> from the simplices of <em>T</em> to the simplices of <em>U</em>, and (ii) for each simplex <em>S</em> of <em>T</em>, a permutation <em>f<sub>S</sub></em> of the facets (0,...,<em>dim</em>) of <em>S</em>, for which the following condition holds:</p>
<ul>
<li>If facet <em>k</em> of simplex <em>S</em> and facet <em>k'</em> of simplex <em>S'</em> are identified in <em>T</em>, then facet <em>f<sub>S</sub></em>(<em>k</em>) of <em>f(S)</em> and facet <em>f<sub>S'</sub></em>(<em>k'</em>) of <em>f</em>(S') are identified in <em>U</em>. Moreover, their gluing is consistent with the facet/vertex permutations; that is, there is a commutative square involving the gluing maps in <em>T</em> and <em>U</em> and the permutations <em>f<sub>S</sub></em> and <em>f<sub>S'</sub></em>.</li>
</ul>
<p>Isomorphisms can be <em>boundary complete</em> or <em>boundary incomplete</em>. A boundary complete isomorphism satisfies the additional condition:</p>
<ul>
<li>If facet <em>x</em> is a boundary facet of <em>T</em> then facet <em>f(x)</em> is a boundary facet of <em>U</em>.</li>
</ul>
<p>A boundary complete isomorphism thus indicates that a copy of triangulation <em>T</em> is present as an entire component (or components) of <em>U</em>, whereas a boundary incomplete isomorphism represents an embedding of a copy of triangulation <em>T</em> as a subcomplex of some possibly larger component (or components) of <em>U</em>.</p>
<p>Note that for all types of isomorphism, triangulation <em>U</em> is allowed to contain more simplices than triangulation <em>T</em>.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., Isomorphism2 and Isomorphism3 for dimensions 2 and 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the triangulations that this isomorphism class works with. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6eb987b8089f111e1c0908500c01eb6e" name="a6eb987b8089f111e1c0908500c01eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb987b8089f111e1c0908500c01eb6e">&#9670;&#160;</a></span>Isomorphism() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::Isomorphism </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new isomorphism with no initialisation. </p>
<p>The images of the simplices and their vertices must be explicitly set using <a class="el" href="#ac37b1d0c51871819f5c8a9cfcb1285c4" title="Returns a read-write reference to the image of the given source simplex under this isomorphism.">simpImage()</a> and <a class="el" href="#ab88d67222559aeac9d1dbd93a18b171a" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the images of the simplices and their vertices must be set using <a class="el" href="#a0c0479919ce5f18f7bee47caed5b78c9" title="Python-only routine that sets the image of the given source simplex to the given value under this iso...">setSimpImage()</a> and <a class="el" href="#af68080c46920e8e102f0dd0a72b63fdc" title="Python-only routine that sets the permutation that is applied to the (dim + 1) facets of the given so...">setFacetPerm()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices in the source triangulation associated with this isomorphism. This is allowed to be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9f2112ee5058c263535563715c585e" name="a8f9f2112ee5058c263535563715c585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9f2112ee5058c263535563715c585e">&#9670;&#160;</a></span>Isomorphism() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::Isomorphism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given isomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a8b6612fe01e4ecc8bfad1423898c8" name="ad3a8b6612fe01e4ecc8bfad1423898c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a8b6612fe01e4ecc8bfad1423898c8">&#9670;&#160;</a></span>Isomorphism() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::Isomorphism </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this new isomorphism. </p>
<p>This is a fast (constant time) operation.</p>
<p>The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99cf1afeffd310db7d7ca89d19b2437" name="ac99cf1afeffd310db7d7ca89d19b2437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cf1afeffd310db7d7ca89d19b2437">&#9670;&#160;</a></span>~Isomorphism()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this isomorphism. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d4b99d17b4ac449bdb7573d9b949946" name="a1d4b99d17b4ac449bdb7573d9b949946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4b99d17b4ac449bdb7573d9b949946">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that applies this isomorphism to the given triangulation, and returns the result as a new triangulation. </p>
<p>If the given triangulation has any locks on top-dimensional simplices and/or their facets, then the triangulation that is returned will have matching locks that have been carried through the isomorphism correctly (i.e., the locks will be copied over to the appropriate destination simplices and/or facets).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000272">Deprecated</a></b></dt><dd>If this isomorphism is <em>iso</em>, then this routine is equivalent to calling <code>iso(tri)</code>. See the bracket operator for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of top-dimensional simplices in the given triangulation is not equal to <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new isomorphic triangulation. </dd></dl>

</div>
</div>
<a id="afa78db49451ace59647d31fa33336739" name="afa78db49451ace59647d31fa33336739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa78db49451ace59647d31fa33336739">&#9670;&#160;</a></span>applyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::applyInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that applies this isomorphism to the given triangulation, modifying the given triangulation directly. </p>
<p>If the given triangulation has any locks on top-dimensional simplices and/or their facets, then these locks will be carried through the isomorphism correctly (i.e., the locks will be moved to the appropriate destination simplices and/or facets).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000273">Deprecated</a></b></dt><dd>If this isomorphism is <em>iso</em>, then this routine is equivalent to calling <code>tri = iso(tri)</code>. See the bracket operator for further details.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of top-dimensional simplices in the given triangulation is not equal to <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab88d67222559aeac9d1dbd93a18b171a" name="ab88d67222559aeac9d1dbd93a18b171a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88d67222559aeac9d1dbd93a18b171a">&#9670;&#160;</a></span>facetPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p>Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to facet <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<p>If the dimension <em>dim</em> is 2 or 3, then you can also access this permutation through the dimension-specific alias edgePerm() or facePerm() respectively.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="#ab88d67222559aeac9d1dbd93a18b171a" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a> is a read-only function that returns by value. To edit the isomorphism, use the Python-only routine <a class="el" href="#af68080c46920e8e102f0dd0a72b63fdc" title="Python-only routine that sets the permutation that is applied to the (dim + 1) facets of the given so...">setFacetPerm()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a read-write reference to the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="ad31f09f23249eac6f30f7fcd3f54f6f2" name="ad31f09f23249eac6f30f7fcd3f54f6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31f09f23249eac6f30f7fcd3f54f6f2">&#9670;&#160;</a></span>facetPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p>Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to face <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<p>If the dimension <em>dim</em> is 2 or 3, then you can also access this permutation through the dimension-specific alias edgePerm() or facePerm() respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="a2c51197dbd112bb60b7893cc51a09003" name="a2c51197dbd112bb60b7893cc51a09003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51197dbd112bb60b7893cc51a09003">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>This hash function makes use of Regina's tight encodings. In particular, any two objects with the same tight encoding will have equal hashes. This implementation (and therefore the specific hash value for each object) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows objects of this type to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this object. </dd></dl>

</div>
</div>
<a id="a90c565a9838914646dcebd1bc06292a1" name="a90c565a9838914646dcebd1bc06292a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c565a9838914646dcebd1bc06292a1">&#9670;&#160;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity isomorphism for the given number of simplices. </p>
<p>This isomorphism sends every simplex and every vertex to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identity isomorphism. </dd></dl>

</div>
</div>
<a id="a2ba485488b0b1a4c03d5b5b3611f382c" name="a2ba485488b0b1a4c03d5b5b3611f382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba485488b0b1a4c03d5b5b3611f382c">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of this isomorphism. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination triangulation has precisely the same number of simplices as the source triangulation. In other words, there are no "gaps" in the simplex images: the values <code>simpImage(0)</code>, ..., <code>simpImage(<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1)</code> must be a permutation of 0, ..., <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse isomorphism. </dd></dl>

</div>
</div>
<a id="a880e50ac413fde3e237c905aa210afca" name="a880e50ac413fde3e237c905aa210afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e50ac413fde3e237c905aa210afca">&#9670;&#160;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this is an identity isomorphism. </p>
<p>In an identity isomorphism, each simplex image is itself, and within each simplex the facet/vertex permutation is the identity permutation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an identity isomorphism, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a14bef162a2366d06cf500bcd829c13b5" name="a14bef162a2366d06cf500bcd829c13b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bef162a2366d06cf500bcd829c13b5">&#9670;&#160;</a></span>operator()() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given facet pairing, and returns the result as a new facet pairing. </p>
<p>Although the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class was designed to represent mappings between isomorphic triangulations, it can just as well describe mappings between isomorphic facet pairings. In particular, if <em>iso</em> represents this isomorphism and if <em>p</em> were the facet pairing of some triangulation <em>tri</em>, then <code>iso(p)</code> would be the facet pairing for the triangulation <code>iso(tri)</code>. Of course, this routine works directly with the facet pairing, and does not actually construct any triangulations at all.</p>
<p>This routine behaves correctly even if some facets of <em>p</em> are unmatched (i.e., if <em>p</em> models a triangulation with boundary facets).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of top-dimensional simplices described by the given facet pairing is not equal to <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the facet pairing to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new isomorphic facet pairing. </dd></dl>

</div>
</div>
<a id="a61b92ac940e94b5e316d88a37336b9b7" name="a61b92ac940e94b5e316d88a37336b9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b92ac940e94b5e316d88a37336b9b7">&#9670;&#160;</a></span>operator()() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the image of the given facet-of-simplex under this isomorphism. </p>
<p>Specifically:</p>
<ul>
<li>If <code>f.simp</code> is in the range 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 inclusive (i.e., <em>f</em> denotes a facet of an actual top-dimensional simplex), then this routine will return an object denoting facet <code>facetPerm(f.facet)</code> of simplex <code>simpImage(f.simp)</code>.</li>
<li>If <code>f.simp</code> is negative (i.e., <em>f</em> takes a before-the-start value), or if <code>f.simp</code> is at least <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> (i.e., <em>f</em> takes a boundary or past-the-end value), then this routine will return <em>f</em> unchanged (but see the precondition below).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>If this isomorphism maps a smaller triangulation into a larger triangulation (in particular, if the simplex images under this isomorphism are not just some reordering of 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1), then <em>f</em> must not denote a boundary or past-the-end value. This is because a boundary or past-the-end value is encoded by using a past-the-end value of <code><a class="el" href="structregina_1_1FacetSpec.html#a222da77f26f79f1dbc57fcfc7eef8178" title="The simplex referred to.">FacetSpec::simp</a></code>. If this isomorphism maps into a larger triangulation then this past-the-end simplex number would need to change, but the isomorphism does not actually know what the new value of <code><a class="el" href="structregina_1_1FacetSpec.html#a222da77f26f79f1dbc57fcfc7eef8178" title="The simplex referred to.">FacetSpec::simp</a></code> should be.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the facet-of-simplex which should be transformed by this isomorphism. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of <em>f</em> under this isomorphism. </dd></dl>

</div>
</div>
<a id="a5ab10fe5c9b8c532c178bc16b1d48fa8" name="a5ab10fe5c9b8c532c178bc16b1d48fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab10fe5c9b8c532c178bc16b1d48fa8">&#9670;&#160;</a></span>operator()() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given triangulation, and returns the result as a new triangulation. </p>
<p>An isomorphism represents a combinatorial map from a triangulation <em>T</em> to a triangulation <em>U</em>. This routine treats the given triangulation as the domain <em>T</em>, and returns the corresponding range <em>U</em>. The given triangulation <em>T</em> is not modified in any way.</p>
<p>In more detail: A new triangulation <em>U</em> is returned, so that this isomorphism represents a one-to-one, onto and boundary complete isomorphism from <em>T</em> to <em>U</em>. That is, <em>T</em> and <em>U</em> will be combinatorially isomorphic triangulations, and this isomorphism describes the mapping from the simplices of <em>T</em> and their facets to the simplices of <em>U</em> and their facets.</p>
<p>If the given triangulation <em>T</em> has any locks on top-dimensional simplices and/or their facets, then the resulting triangulation <em>U</em> will have matching locks that have been carried through the isomorphism correctly (i.e., the locks will be copied over to the appropriate destination simplices and/or facets).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of top-dimensional simplices in the given triangulation is not equal to <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new isomorphic triangulation. </dd></dl>

</div>
</div>
<a id="a5651b16d2278cea837a1174241694d6b" name="a5651b16d2278cea837a1174241694d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5651b16d2278cea837a1174241694d6b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of this isomorphism with the given isomorphism. </p>
<p>This follows the same order convention as Regina's permutation classes: the composition <code>a * b</code> first applies the right-hand isomorphism <em>b</em>, and then the left-hand isomorphism <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The source triangulation for this isomorphism (the left-hand side) is at least as large as the destination triangulation for <em>rhs</em> (the right-hand side). In other words, the maximum value of <code>rhs.simpImage(i)</code> over all <em>i</em> must be less than <code>this-&gt;<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both isomorphisms. </dd></dl>

</div>
</div>
<a id="ae4b4a10117f941ed3f6d274582310f3e" name="ae4b4a10117f941ed3f6d274582310f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b4a10117f941ed3f6d274582310f3e">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of this isomorphism with the given isomorphism. </p>
<p>This follows the same order convention as Regina's permutation classes: the composition <code>a * b</code> first applies the right-hand isomorphism <em>b</em>, and then the left-hand isomorphism <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The source triangulation for this isomorphism (the left-hand side) is at least as large as the destination triangulation for <em>rhs</em> (the right-hand side). In other words, the maximum value of <code>rhs.simpImage(i)</code> over all <em>i</em> must be less than <code>this-&gt;<a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both isomorphisms. </dd></dl>

</div>
</div>
<a id="a7ef7b43f2c133c24bb83f8cb8de16784" name="a7ef7b43f2c133c24bb83f8cb8de16784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef7b43f2c133c24bb83f8cb8de16784">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A preincrement operator that changes this to be the next isomorphism in an iteration through all possible isomorphisms of this size. </p>
<p>The order of iteration is lexicographical, by the sequence of simplex images and then by the sequence of facet permutations. Facet permutations, in turn, are ordered by their indices in the array <a class="el" href="classregina_1_1Perm.html#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;dim&gt;::Sn</a>.</p>
<p>In particular, the identity isomorphism is the first in such an iteration. If this isomorphism is the <em>last</em> in such an iteration, then this operator will "wrap around" and set this to the identity.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The class <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt; supports the preincrement operator; currently this means that <em>dim</em> must be at most 6.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is named inc() since Python does not support the increment operator. Unlike other Regina classes, here inc() wraps the preincrement operator (not the postincrement operator), since the postincrement operator is significantly more expensive. To avoid confusion, the python inc() function returns <code>None</code> (not this isomorphism).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism after the increment. </dd></dl>

</div>
</div>
<a id="a1ef21c9bb34621a0b17b450da31c8b55" name="a1ef21c9bb34621a0b17b450da31c8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef21c9bb34621a0b17b450da31c8b55">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A postincrement operator that changes this to be the next isomorphism in an iteration through all possible isomorphisms of this size. </p>
<p>The order of iteration is lexicographical, by the sequence of simplex images and then by the sequence of facet permutations. Facet permutations, in turn, are ordered by their indices in the array <a class="el" href="classregina_1_1Perm.html#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;dim&gt;::Sn</a>.</p>
<p>In particular, the identity isomorphism is the first in such an iteration. If this isomorphism is the <em>last</em> in such an iteration, then this operator will "wrap around" and set this to the identity.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since the postincrement operator returns an isomorphism by value, it is significantly more expensive than the preincrement operator (since it involves a deep copy of a large object). You should use the preincrement operator unless you actually need a copy of the old value of this isomorphism.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The class <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt; supports the preincrement operator; currently this means that <em>dim</em> must be at most 6.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. The preincrement operator is present in Python as the member function inc(). (Note that this is different from other Regina classes, where inc() typically wraps the postincrement operator instead. See the preincrement documentation for details.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this isomorphism before the increment took place. </dd></dl>

</div>
</div>
<a id="aadbdfca99e94446a343b101ec6331f77" name="aadbdfca99e94446a343b101ec6331f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbdfca99e94446a343b101ec6331f77">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the given isomorphism into this isomorphism. </p>
<p>It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p>This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="a0a4812ece221766e1dfd2cca99f007f5" name="a0a4812ece221766e1dfd2cca99f007f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4812ece221766e1dfd2cca99f007f5">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this isomorphism. </p>
<p>This is a fast (constant time) operation.</p>
<p>It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p>The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="a368f8ed113d2bc0f2d10b3697309c494" name="a368f8ed113d2bc0f2d10b3697309c494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368f8ed113d2bc0f2d10b3697309c494">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given isomorphism are identical. </p>
<p>Two isomorphisms are considered <em>identical</em> if they act on the same number of top-dimensional simplices, and all destination simplex numbers and facet permutations are the same for both isomorphisms.</p>
<p>In particular it is only the simplex, facet and vertex <em>labels</em> that matter: an isomorphism does not refer to a specific triangulation, and there is no sense in which the two isomorphisms need to act on the same triangulations and/or point to the same destination Simplex objects.</p>
<p>It is safe to compare isomorphisms of different sizes (in which case this routine will return <code>false</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the isomorphism to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given isomorphism are identical. </dd></dl>

</div>
</div>
<a id="af6b5f3b813d309d8e0b91e347635e163" name="af6b5f3b813d309d8e0b91e347635e163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b5f3b813d309d8e0b91e347635e163">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex facet under this isomorphism. </p>
<p>This operator returns by value: it cannot be used to alter the isomorphism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the given source simplex facet; this must be one of the (<em>dim</em> + 1) facets of one of the <a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> simplices in the source triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of the source simplex facet under this isomorphism. </dd></dl>

</div>
</div>
<a id="abb293fe603065ae43cbfb9432b9048a6" name="abb293fe603065ae43cbfb9432b9048a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb293fe603065ae43cbfb9432b9048a6">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::random </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>even</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random isomorphism for the given number of simplices. </p>
<p>This isomorphism will reorder simplices 0 to <code>nSimplices-1</code> in a random fashion, and for each simplex a random permutation of its (<em>dim</em> + 1) vertices will be selected.</p>
<p>All possible isomorphisms for the given number of simplices are equally likely.</p>
<p>This routine is thread-safe, and uses <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> for its random number generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
    <tr><td class="paramname">even</td><td>if <code>true</code>, then every simplex will have its vertices permuted with an even permutation. This means that, if the random isomorphism is applied to an oriented triangulation, it will preserve the orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new random isomorphism. </dd></dl>

</div>
</div>
<a id="af68080c46920e8e102f0dd0a72b63fdc" name="af68080c46920e8e102f0dd0a72b63fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68080c46920e8e102f0dd0a72b63fdc">&#9670;&#160;</a></span>setFacetPerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::setFacetPerm </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;</td>          <td class="paramname"><span class="paramname"><em>perm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only routine that sets the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p>Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to facet <code>perm[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<p>If the dimension <em>dim</em> is 2 or 3, then you can also set this permutation through the dimension-specific alias setEdgePerm() or setFacePerm() respectively.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="#ab88d67222559aeac9d1dbd93a18b171a" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a> is used for both reading and writing: just write <code>facetPerm(sourceSimp) = perm</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
    <tr><td class="paramname">perm</td><td>the new permutation that should be applied to the facets of the source simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c0479919ce5f18f7bee47caed5b78c9" name="a0c0479919ce5f18f7bee47caed5b78c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0479919ce5f18f7bee47caed5b78c9">&#9670;&#160;</a></span>setSimpImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::setSimpImage </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t</td>          <td class="paramname"><span class="paramname"><em>image</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only routine that sets the image of the given source simplex to the given value under this isomorphism. </p>
<p>If the dimension <em>dim</em> is 2, 3 or 4, then you can also set this image through the dimension-specific alias setTriImage(), setTetImage() or setPentImage() respectively.</p>
<p>Simplex images are stored using type <code>ssize_t</code>, not <code>size_t</code>, and so you can safely use the special value -1 as a marker for an image that is unknown or not yet initialised.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="#ac37b1d0c51871819f5c8a9cfcb1285c4" title="Returns a read-write reference to the image of the given source simplex under this isomorphism.">simpImage()</a> is used for both reading and writing: just write <code>simpImage(sourceSimp) = image</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
    <tr><td class="paramname">image</td><td>the index of the new destination simplex that the source simplex should map to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37b1d0c51871819f5c8a9cfcb1285c4" name="ac37b1d0c51871819f5c8a9cfcb1285c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37b1d0c51871819f5c8a9cfcb1285c4">&#9670;&#160;</a></span>simpImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the image of the given source simplex under this isomorphism. </p>
<p>If the dimension <em>dim</em> is 2, 3 or 4, then you can also access this image through the dimension-specific alias triImage(), tetImage() or pentImage() respectively.</p>
<p>This image is stored using type <code>ssize_t</code>, not <code>size_t</code>, and so you can safely use the special value -1 as a marker for an image that is unknown or not yet initialised.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="#ac37b1d0c51871819f5c8a9cfcb1285c4" title="Returns a read-write reference to the image of the given source simplex under this isomorphism.">simpImage()</a> is a read-only function that returns by value. To edit the isomorphism, use the Python-only routine <a class="el" href="#a0c0479919ce5f18f7bee47caed5b78c9" title="Python-only routine that sets the image of the given source simplex to the given value under this iso...">setSimpImage()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="a93e1af908613357cfb4b0fd9a1d87a9f" name="a93e1af908613357cfb4b0fd9a1d87a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e1af908613357cfb4b0fd9a1d87a9f">&#9670;&#160;</a></span>simpImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSimp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex under this isomorphism. </p>
<p>If the dimension <em>dim</em> is 2, 3 or 4, then you can also access this image through the dimension-specific alias triImage(), tetImage() or pentImage() respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="#a77d931b107736175dd59b4463be7beb4" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="a77d931b107736175dd59b4463be7beb4" name="a77d931b107736175dd59b4463be7beb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d931b107736175dd59b4463be7beb4">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of simplices in the source triangulation associated with this isomorphism. </p>
<p>Note that this is always less than or equal to the number of simplices in the destination triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>This is also used to implement the Python special method <b>len</b>().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices in the source triangulation. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="add60c472f78f9fbabaa4990bcea77d4b" name="add60c472f78f9fbabaa4990bcea77d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add60c472f78f9fbabaa4990bcea77d4b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given isomorphism. </p>
<p>It does not matter if this and the given isomorphism use different numbers of simplices; if so then they will be adjusted accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the isomorphism whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad39b1a791c06935238f56d243b4685dc" name="ad39b1a791c06935238f56d243b4685dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39b1a791c06935238f56d243b4685dc">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an isomorphism from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of an isomorphism on <em>dim</em>-dimensional triangulations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for an isomorphism on <em>dim</em>-dimensional triangulations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a5ae0f834bdc1cf66270c383626ff3801" name="a5ae0f834bdc1cf66270c383626ff3801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae0f834bdc1cf66270c383626ff3801">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this isomorphism to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="abce6b558d467de401dbdd5d1bc1e339a" name="abce6b558d467de401dbdd5d1bc1e339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce6b558d467de401dbdd5d1bc1e339a">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1b944c2c93b301727c302ca5d7ae8c" name="a3e1b944c2c93b301727c302ca5d7ae8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b944c2c93b301727c302ca5d7ae8c">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa3f8449939cf548ae66b62b0853d269c" name="aa3f8449939cf548ae66b62b0853d269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f8449939cf548ae66b62b0853d269c">&#9670;&#160;</a></span>facetPerm_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt;* <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The permutation applied to the facets of each source simplex. </p>
<p>This array has size size_. </p>

</div>
</div>
<a id="abc00909c11fbb045f331b2d8e2b8f7ed" name="abc00909c11fbb045f331b2d8e2b8f7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc00909c11fbb045f331b2d8e2b8f7ed">&#9670;&#160;</a></span>simpImage_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t* <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to. </p>
<p>This array has size size_. </p>

</div>
</div>
<a id="a6cb90d8b4eb9ea70fdc100ea025ff3f0" name="a6cb90d8b4eb9ea70fdc100ea025ff3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb90d8b4eb9ea70fdc100ea025ff3f0">&#9670;&#160;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices in the source triangulation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>triangulation/<a class="el" href="cut_8h.html">cut.h</a></li>
<li>triangulation/<a class="el" href="forward_8h.html">forward.h</a></li>
<li>triangulation/generic/<a class="el" href="generic_2isomorphism_8h.html">isomorphism.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
