<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::Perm&lt; n &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Perm.html">Perm</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Perm-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Perm&lt; n &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a permutation of {0,1,...,<em>n</em>-1}.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;maths/perm.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a38f1992a9c0b96ec211abf2e4cfc5ee7" id="r_a38f1992a9c0b96ec211abf2e4cfc5ee7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a> = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;<a class="el" href="#a4269d01e17426bef1f0c12faa2e18253">imageBits</a> * n&gt;::type</td></tr>
<tr class="memdesc:a38f1992a9c0b96ec211abf2e4cfc5ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes a native signed integer type large enough to count all permutations on <em>n</em> elements.  <br /></td></tr>
<tr class="separator:a38f1992a9c0b96ec211abf2e4cfc5ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2a33aeeb3fb5c702d6d7f80b216227" id="r_a8a2a33aeeb3fb5c702d6d7f80b216227"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a> = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;<a class="el" href="#a4269d01e17426bef1f0c12faa2e18253">imageBits</a> * n&gt;::utype</td></tr>
<tr class="memdesc:a8a2a33aeeb3fb5c702d6d7f80b216227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the native unsigned integer type used to store a single image pack.  <br /></td></tr>
<tr class="separator:a8a2a33aeeb3fb5c702d6d7f80b216227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e4563b2e2d277b2c284bbb5abdc09" id="r_a8c7e4563b2e2d277b2c284bbb5abdc09"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> = <a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a></td></tr>
<tr class="memdesc:a8c7e4563b2e2d277b2c284bbb5abdc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the native unsigned integer type used to store the internal permutation code.  <br /></td></tr>
<tr class="separator:a8c7e4563b2e2d277b2c284bbb5abdc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d6f626ed4864924dde033384b6a5bc5" id="r_a1d6f626ed4864924dde033384b6a5bc5"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6f626ed4864924dde033384b6a5bc5">Perm</a> ()</td></tr>
<tr class="memdesc:a1d6f626ed4864924dde033384b6a5bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the identity permutation.  <br /></td></tr>
<tr class="separator:a1d6f626ed4864924dde033384b6a5bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ea9c2cda7a4e67af9c43a3f702a325" id="r_a64ea9c2cda7a4e67af9c43a3f702a325"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ea9c2cda7a4e67af9c43a3f702a325">Perm</a> (int a, int b)</td></tr>
<tr class="memdesc:a64ea9c2cda7a4e67af9c43a3f702a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the transposition of <em>a</em> and <em>b</em>.  <br /></td></tr>
<tr class="separator:a64ea9c2cda7a4e67af9c43a3f702a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed9c99ab994ba45a970184cb9c3fd8d" id="r_a1ed9c99ab994ba45a970184cb9c3fd8d"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ed9c99ab994ba45a970184cb9c3fd8d">Perm</a> (const std::array&lt; int, n &gt; &amp;image)</td></tr>
<tr class="memdesc:a1ed9c99ab994ba45a970184cb9c3fd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a permutation mapping <em>i</em> to <em>image</em>[<em>i</em>] for each 0 ≤ <em>i</em> &lt; <em>n</em>.  <br /></td></tr>
<tr class="separator:a1ed9c99ab994ba45a970184cb9c3fd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d60f078c54732cda64aa632df208bd0" id="r_a9d60f078c54732cda64aa632df208bd0"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d60f078c54732cda64aa632df208bd0">Perm</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;)=default</td></tr>
<tr class="memdesc:a9d60f078c54732cda64aa632df208bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a permutation that is a clone of the given permutation.  <br /></td></tr>
<tr class="separator:a9d60f078c54732cda64aa632df208bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2441b248d28aed6a7775c6515d3ee91d" id="r_a2441b248d28aed6a7775c6515d3ee91d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2441b248d28aed6a7775c6515d3ee91d">permCode</a> () const</td></tr>
<tr class="memdesc:a2441b248d28aed6a7775c6515d3ee91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal code representing this permutation.  <br /></td></tr>
<tr class="separator:a2441b248d28aed6a7775c6515d3ee91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236437a3c6f1aee07ab6ff0386994efe" id="r_a236437a3c6f1aee07ab6ff0386994efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a236437a3c6f1aee07ab6ff0386994efe">setPermCode</a> (<a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> code)</td></tr>
<tr class="memdesc:a236437a3c6f1aee07ab6ff0386994efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this permutation to that represented by the given internal code.  <br /></td></tr>
<tr class="separator:a236437a3c6f1aee07ab6ff0386994efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad633944eec40e663b281ec3e4303465e" id="r_ad633944eec40e663b281ec3e4303465e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad633944eec40e663b281ec3e4303465e">imagePack</a> () const</td></tr>
<tr class="memdesc:ad633944eec40e663b281ec3e4303465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the image pack that represents this permutation.  <br /></td></tr>
<tr class="separator:ad633944eec40e663b281ec3e4303465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913d2027ee4033fab6fc29c4f318e2a4" id="r_a913d2027ee4033fab6fc29c4f318e2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a913d2027ee4033fab6fc29c4f318e2a4">operator=</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:a913d2027ee4033fab6fc29c4f318e2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this permutation to be equal to the given permutation.  <br /></td></tr>
<tr class="separator:a913d2027ee4033fab6fc29c4f318e2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8768ecf24f06255eea6e3c448b449843" id="r_a8768ecf24f06255eea6e3c448b449843"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8768ecf24f06255eea6e3c448b449843">operator*</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;q) const</td></tr>
<tr class="memdesc:a8768ecf24f06255eea6e3c448b449843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of this permutation with the given permutation.  <br /></td></tr>
<tr class="separator:a8768ecf24f06255eea6e3c448b449843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933651038ffc99dfd7c2113420fcd58f" id="r_a933651038ffc99dfd7c2113420fcd58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a933651038ffc99dfd7c2113420fcd58f">cachedComp</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;q) const</td></tr>
<tr class="memdesc:a933651038ffc99dfd7c2113420fcd58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the composition operator, provided to assist with writing generic code.  <br /></td></tr>
<tr class="separator:a933651038ffc99dfd7c2113420fcd58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d110a498b16c93c19306b0ae721914" id="r_af5d110a498b16c93c19306b0ae721914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d110a498b16c93c19306b0ae721914">cachedComp</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;q, const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;r) const</td></tr>
<tr class="memdesc:af5d110a498b16c93c19306b0ae721914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for using the composition operator twice, provided to assist with writing generic code.  <br /></td></tr>
<tr class="separator:af5d110a498b16c93c19306b0ae721914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e2a1e73bae1eabf78c5ea5c0328299" id="r_af6e2a1e73bae1eabf78c5ea5c0328299"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6e2a1e73bae1eabf78c5ea5c0328299">conjugate</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;q) const</td></tr>
<tr class="memdesc:af6e2a1e73bae1eabf78c5ea5c0328299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjugate of this permutation by <em>q</em>.  <br /></td></tr>
<tr class="separator:af6e2a1e73bae1eabf78c5ea5c0328299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2d8084921853b7aceafdd8ec49d87" id="r_a17e2d8084921853b7aceafdd8ec49d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17e2d8084921853b7aceafdd8ec49d87">cachedConjugate</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;q) const</td></tr>
<tr class="memdesc:a17e2d8084921853b7aceafdd8ec49d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="#af6e2a1e73bae1eabf78c5ea5c0328299" title="Computes the conjugate of this permutation by q.">conjugate()</a>, provided to assist with writing generic code.  <br /></td></tr>
<tr class="separator:a17e2d8084921853b7aceafdd8ec49d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37db8b08dfb1cccaece75d84da8ccb3" id="r_ad37db8b08dfb1cccaece75d84da8ccb3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad37db8b08dfb1cccaece75d84da8ccb3">inverse</a> () const</td></tr>
<tr class="memdesc:ad37db8b08dfb1cccaece75d84da8ccb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse of this permutation.  <br /></td></tr>
<tr class="separator:ad37db8b08dfb1cccaece75d84da8ccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acdb4b01aa1b2fe4467e225db79a714" id="r_a3acdb4b01aa1b2fe4467e225db79a714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714">cachedInverse</a> () const</td></tr>
<tr class="memdesc:a3acdb4b01aa1b2fe4467e225db79a714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the inverse of this permutation, optimised using precomputed "partial lookup tables".  <br /></td></tr>
<tr class="separator:a3acdb4b01aa1b2fe4467e225db79a714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97501c225d57fe52eba2f16753ba1e47" id="r_a97501c225d57fe52eba2f16753ba1e47"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97501c225d57fe52eba2f16753ba1e47">pow</a> (long exp) const</td></tr>
<tr class="memdesc:a97501c225d57fe52eba2f16753ba1e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the given power of this permutation.  <br /></td></tr>
<tr class="separator:a97501c225d57fe52eba2f16753ba1e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b07bef48b84255836357de3754bb35" id="r_a81b07bef48b84255836357de3754bb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b07bef48b84255836357de3754bb35">cachedPow</a> (long exp) const</td></tr>
<tr class="memdesc:a81b07bef48b84255836357de3754bb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="#a97501c225d57fe52eba2f16753ba1e47" title="Computes the given power of this permutation.">pow()</a>, provided to assist with writing generic code.  <br /></td></tr>
<tr class="separator:a81b07bef48b84255836357de3754bb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb094647d577fd89d7bf4b9218ced5a0" id="r_abb094647d577fd89d7bf4b9218ced5a0"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb094647d577fd89d7bf4b9218ced5a0">order</a> () const</td></tr>
<tr class="memdesc:abb094647d577fd89d7bf4b9218ced5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the order of this permutation.  <br /></td></tr>
<tr class="separator:abb094647d577fd89d7bf4b9218ced5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020e101860b8740aa6dfac5025fb9e40" id="r_a020e101860b8740aa6dfac5025fb9e40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a020e101860b8740aa6dfac5025fb9e40">cachedOrder</a> () const</td></tr>
<tr class="memdesc:a020e101860b8740aa6dfac5025fb9e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="#abb094647d577fd89d7bf4b9218ced5a0" title="Returns the order of this permutation.">order()</a>, provided to assist with writing generic code.  <br /></td></tr>
<tr class="separator:a020e101860b8740aa6dfac5025fb9e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b3244ac72c2578b28ad3b03be5c2bf" id="r_a05b3244ac72c2578b28ad3b03be5c2bf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b3244ac72c2578b28ad3b03be5c2bf">reverse</a> () const</td></tr>
<tr class="memdesc:a05b3244ac72c2578b28ad3b03be5c2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the reverse of this permutation.  <br /></td></tr>
<tr class="separator:a05b3244ac72c2578b28ad3b03be5c2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e223024f54c92a1f331f5339ab108a" id="r_a33e223024f54c92a1f331f5339ab108a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e223024f54c92a1f331f5339ab108a">sign</a> () const</td></tr>
<tr class="memdesc:a33e223024f54c92a1f331f5339ab108a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the sign of this permutation.  <br /></td></tr>
<tr class="separator:a33e223024f54c92a1f331f5339ab108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3270b6cf9a20e249ac4ae28166896c36" id="r_a3270b6cf9a20e249ac4ae28166896c36"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3270b6cf9a20e249ac4ae28166896c36">operator[]</a> (int source) const</td></tr>
<tr class="memdesc:a3270b6cf9a20e249ac4ae28166896c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given integer under this permutation.  <br /></td></tr>
<tr class="separator:a3270b6cf9a20e249ac4ae28166896c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc9d7577fe1d11ec1463c378d243da0" id="r_a0bc9d7577fe1d11ec1463c378d243da0"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc9d7577fe1d11ec1463c378d243da0">pre</a> (int image) const</td></tr>
<tr class="memdesc:a0bc9d7577fe1d11ec1463c378d243da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the preimage of the given integer under this permutation.  <br /></td></tr>
<tr class="separator:a0bc9d7577fe1d11ec1463c378d243da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b5b08408450a849064a4fdf364af6d" id="r_ab8b5b08408450a849064a4fdf364af6d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b5b08408450a849064a4fdf364af6d">operator==</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;) const =default</td></tr>
<tr class="memdesc:ab8b5b08408450a849064a4fdf364af6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is equal to the given permutation.  <br /></td></tr>
<tr class="separator:ab8b5b08408450a849064a4fdf364af6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e7d012ee954069cf30d9732c68905a" id="r_ae7e7d012ee954069cf30d9732c68905a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e7d012ee954069cf30d9732c68905a">compareWith</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;other) const</td></tr>
<tr class="memdesc:ae7e7d012ee954069cf30d9732c68905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the images of (0,1,...,<em>n-1</em>) under this and the given permutation.  <br /></td></tr>
<tr class="separator:ae7e7d012ee954069cf30d9732c68905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357cb8ad15a7fff471dfa943aa964612" id="r_a357cb8ad15a7fff471dfa943aa964612"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a357cb8ad15a7fff471dfa943aa964612">isIdentity</a> () const</td></tr>
<tr class="memdesc:a357cb8ad15a7fff471dfa943aa964612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is the identity permutation.  <br /></td></tr>
<tr class="separator:a357cb8ad15a7fff471dfa943aa964612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9add8dd475d4279d83393bf0bd73fa2" id="r_ac9add8dd475d4279d83393bf0bd73fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9add8dd475d4279d83393bf0bd73fa2">operator++</a> ()</td></tr>
<tr class="memdesc:ac9add8dd475d4279d83393bf0bd73fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A preincrement operator that changes this to be the next permutation in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>.  <br /></td></tr>
<tr class="separator:ac9add8dd475d4279d83393bf0bd73fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9a7d14565eb4f1e8ace5fbf74d5a8" id="r_a33d9a7d14565eb4f1e8ace5fbf74d5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d9a7d14565eb4f1e8ace5fbf74d5a8">operator++</a> (int)</td></tr>
<tr class="memdesc:a33d9a7d14565eb4f1e8ace5fbf74d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A postincrement operator that changes this to be the next permutation in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>.  <br /></td></tr>
<tr class="separator:a33d9a7d14565eb4f1e8ace5fbf74d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446028a8ef1045d7bb6776accd509a26" id="r_a446028a8ef1045d7bb6776accd509a26"><td class="memItemLeft" align="right" valign="top">constexpr std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446028a8ef1045d7bb6776accd509a26">operator&lt;=&gt;</a> (const <a class="el" href="classregina_1_1Perm.html">Perm</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a446028a8ef1045d7bb6776accd509a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two permutations according to which appears earlier in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>.  <br /></td></tr>
<tr class="separator:a446028a8ef1045d7bb6776accd509a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9735dd0921cdf0214d31c2397798a1ae" id="r_a9735dd0921cdf0214d31c2397798a1ae"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9735dd0921cdf0214d31c2397798a1ae">SnIndex</a> () const</td></tr>
<tr class="memdesc:a9735dd0921cdf0214d31c2397798a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of this permutation in the <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a> array.  <br /></td></tr>
<tr class="separator:a9735dd0921cdf0214d31c2397798a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eae6c523c56cd6725445139b32b1a2" id="r_ab6eae6c523c56cd6725445139b32b1a2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6eae6c523c56cd6725445139b32b1a2">orderedSnIndex</a> () const</td></tr>
<tr class="memdesc:ab6eae6c523c56cd6725445139b32b1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lexicographical index of this permutation.  <br /></td></tr>
<tr class="separator:ab6eae6c523c56cd6725445139b32b1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200afccebbd4ea0d74d02c7d5ab18d4" id="r_a4200afccebbd4ea0d74d02c7d5ab18d4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4200afccebbd4ea0d74d02c7d5ab18d4">str</a> () const</td></tr>
<tr class="memdesc:a4200afccebbd4ea0d74d02c7d5ab18d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this permutation.  <br /></td></tr>
<tr class="separator:a4200afccebbd4ea0d74d02c7d5ab18d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557d8ec860c30e283aae73839e7c4cfb" id="r_a557d8ec860c30e283aae73839e7c4cfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a557d8ec860c30e283aae73839e7c4cfb">trunc</a> (int len) const</td></tr>
<tr class="memdesc:a557d8ec860c30e283aae73839e7c4cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a prefix of the string representation of this permutation, containing only the images of the first <em>len</em> integers.  <br /></td></tr>
<tr class="separator:a557d8ec860c30e283aae73839e7c4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718101dd1d0a2565ff9c1341c6855c56" id="r_a718101dd1d0a2565ff9c1341c6855c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718101dd1d0a2565ff9c1341c6855c56">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a718101dd1d0a2565ff9c1341c6855c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this permutation to the given output stream.  <br /></td></tr>
<tr class="separator:a718101dd1d0a2565ff9c1341c6855c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffcbbe103c24ab0f55728845ef4b3ba" id="r_a5ffcbbe103c24ab0f55728845ef4b3ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ffcbbe103c24ab0f55728845ef4b3ba">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a5ffcbbe103c24ab0f55728845ef4b3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this permutation.  <br /></td></tr>
<tr class="separator:a5ffcbbe103c24ab0f55728845ef4b3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf7862f029702723f6701359921662" id="r_afcdf7862f029702723f6701359921662"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcdf7862f029702723f6701359921662">hash</a> () const</td></tr>
<tr class="memdesc:afcdf7862f029702723f6701359921662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this permutation to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:afcdf7862f029702723f6701359921662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90b5059d347cc624292d102c58886e1" id="r_aa90b5059d347cc624292d102c58886e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa90b5059d347cc624292d102c58886e1">clear</a> (unsigned from)</td></tr>
<tr class="memdesc:aa90b5059d347cc624292d102c58886e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the images of all integers from <em>from</em> onwards to the identity map.  <br /></td></tr>
<tr class="separator:aa90b5059d347cc624292d102c58886e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22e858285445d65377dd206dcd4c221" id="r_ac22e858285445d65377dd206dcd4c221"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac22e858285445d65377dd206dcd4c221">isConjugacyMinimal</a> () const</td></tr>
<tr class="memdesc:ac22e858285445d65377dd206dcd4c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this permutation minimal in its conjugacy class?  <br /></td></tr>
<tr class="separator:ac22e858285445d65377dd206dcd4c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a90eb879e7ec2bc1fd4dd9269a632fbc6" id="r_a90eb879e7ec2bc1fd4dd9269a632fbc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6">precompute</a> ()</td></tr>
<tr class="memdesc:a90eb879e7ec2bc1fd4dd9269a632fbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the precomputation necessary for using the optimised <a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">cachedInverse()</a> routine.  <br /></td></tr>
<tr class="separator:a90eb879e7ec2bc1fd4dd9269a632fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed9840350bcd33b5793c83dc1081c7b" id="r_a5ed9840350bcd33b5793c83dc1081c7b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed9840350bcd33b5793c83dc1081c7b">fromPermCode</a> (<a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> code)</td></tr>
<tr class="memdesc:a5ed9840350bcd33b5793c83dc1081c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a permutation from the given internal code.  <br /></td></tr>
<tr class="separator:a5ed9840350bcd33b5793c83dc1081c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7538182b08b4bf5818281bd8d8cca393" id="r_a7538182b08b4bf5818281bd8d8cca393"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7538182b08b4bf5818281bd8d8cca393">isPermCode</a> (<a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> code)</td></tr>
<tr class="memdesc:a7538182b08b4bf5818281bd8d8cca393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given integer is a valid internal permutation code.  <br /></td></tr>
<tr class="separator:a7538182b08b4bf5818281bd8d8cca393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5671b70535311aaf1952c837688283d" id="r_ad5671b70535311aaf1952c837688283d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5671b70535311aaf1952c837688283d">fromImagePack</a> (<a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a> pack)</td></tr>
<tr class="memdesc:ad5671b70535311aaf1952c837688283d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a permutation from the given image pack.  <br /></td></tr>
<tr class="separator:ad5671b70535311aaf1952c837688283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b60d08482ee67193658579757cfb1" id="r_ac85b60d08482ee67193658579757cfb1"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85b60d08482ee67193658579757cfb1">isImagePack</a> (<a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a> pack)</td></tr>
<tr class="memdesc:ac85b60d08482ee67193658579757cfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given argument is the image pack of some <em>n</em>-element permutation.  <br /></td></tr>
<tr class="separator:ac85b60d08482ee67193658579757cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdd6540933f4f6443a47cf420922b1e" id="r_a4bdd6540933f4f6443a47cf420922b1e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bdd6540933f4f6443a47cf420922b1e">rot</a> (int i)</td></tr>
<tr class="memdesc:a4bdd6540933f4f6443a47cf420922b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>i</em>th rotation.  <br /></td></tr>
<tr class="separator:a4bdd6540933f4f6443a47cf420922b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e17c130b5c30be0a35b7e3ff622d3ee" id="r_a9e17c130b5c30be0a35b7e3ff622d3ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e17c130b5c30be0a35b7e3ff622d3ee">rand</a> (bool even=false)</td></tr>
<tr class="memdesc:a9e17c130b5c30be0a35b7e3ff622d3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random permutation on <em>n</em> elements.  <br /></td></tr>
<tr class="separator:a9e17c130b5c30be0a35b7e3ff622d3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e12551e8dc16b28b69b64a0aaca6dd" id="r_ae7e12551e8dc16b28b69b64a0aaca6dd"><td class="memTemplParams" colspan="2">template&lt;class URBG &gt; </td></tr>
<tr class="memitem:ae7e12551e8dc16b28b69b64a0aaca6dd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7e12551e8dc16b28b69b64a0aaca6dd">rand</a> (URBG &amp;&amp;gen, bool even=false)</td></tr>
<tr class="memdesc:ae7e12551e8dc16b28b69b64a0aaca6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random permutation on <em>n</em> elements, using the given uniform random bit generator.  <br /></td></tr>
<tr class="separator:ae7e12551e8dc16b28b69b64a0aaca6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423625cc4777b3a9492b883c449b76f5" id="r_a423625cc4777b3a9492b883c449b76f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a423625cc4777b3a9492b883c449b76f5">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a423625cc4777b3a9492b883c449b76f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a permutation from its given tight encoding.  <br /></td></tr>
<tr class="separator:a423625cc4777b3a9492b883c449b76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150feb97a183e3cfc2be6f13fa3a4e80" id="r_a150feb97a183e3cfc2be6f13fa3a4e80"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a150feb97a183e3cfc2be6f13fa3a4e80">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a150feb97a183e3cfc2be6f13fa3a4e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a permutation from its given tight encoding.  <br /></td></tr>
<tr class="separator:a150feb97a183e3cfc2be6f13fa3a4e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214fc67b707a093ad90e37647f51859e" id="r_a214fc67b707a093ad90e37647f51859e"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a214fc67b707a093ad90e37647f51859e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a214fc67b707a093ad90e37647f51859e">extend</a> (<a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; k &gt; p)</td></tr>
<tr class="memdesc:a214fc67b707a093ad90e37647f51859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends a <em>k</em>-element permutation to an <em>n</em>-element permutation, where 2 ≤ <em>k</em> &lt; <em>n</em>.  <br /></td></tr>
<tr class="separator:a214fc67b707a093ad90e37647f51859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e96137c0fe11eb477b2f97a530a04a9" id="r_a2e96137c0fe11eb477b2f97a530a04a9"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:a2e96137c0fe11eb477b2f97a530a04a9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e96137c0fe11eb477b2f97a530a04a9">contract</a> (<a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; k &gt; p)</td></tr>
<tr class="memdesc:a2e96137c0fe11eb477b2f97a530a04a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts a <em>k</em>-element permutation to an <em>n</em>-element permutation, where <em>k</em> &gt; <em>n</em>.  <br /></td></tr>
<tr class="separator:a2e96137c0fe11eb477b2f97a530a04a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afdb2969d64d3e2c97f941c134f42ddca" id="r_afdb2969d64d3e2c97f941c134f42ddca"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdb2969d64d3e2c97f941c134f42ddca">degree</a> = n</td></tr>
<tr class="memdesc:afdb2969d64d3e2c97f941c134f42ddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degree of the underlying symmetric group; that is, the template parameter <em>n</em>.  <br /></td></tr>
<tr class="separator:afdb2969d64d3e2c97f941c134f42ddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4269d01e17426bef1f0c12faa2e18253" id="r_a4269d01e17426bef1f0c12faa2e18253"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4269d01e17426bef1f0c12faa2e18253">imageBits</a> = <a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a>(n)</td></tr>
<tr class="memdesc:a4269d01e17426bef1f0c12faa2e18253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the number of bits used in an image pack to store the image of a single integer.  <br /></td></tr>
<tr class="separator:a4269d01e17426bef1f0c12faa2e18253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705435f13150fb21e341c207d2c4374d" id="r_a705435f13150fb21e341c207d2c4374d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705435f13150fb21e341c207d2c4374d">imageMask</a></td></tr>
<tr class="memdesc:a705435f13150fb21e341c207d2c4374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask whose lowest <em>imageBits</em> bits are 1, and whose remaining higher order bits are all 0.  <br /></td></tr>
<tr class="separator:a705435f13150fb21e341c207d2c4374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6fa6a6e2c773ecaff1229fee7c9dd1" id="r_a8f6fa6a6e2c773ecaff1229fee7c9dd1"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__maths.html#gae8090c7366267fc9deefd4927be21476">PermCodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f6fa6a6e2c773ecaff1229fee7c9dd1">codeType</a> = <a class="el" href="group__maths.html#ggae8090c7366267fc9deefd4927be21476afff0d600f8a0b5e19e88bfb821dd1157">PermCodeType::Images</a></td></tr>
<tr class="memdesc:a8f6fa6a6e2c773ecaff1229fee7c9dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates what type of internal permutation code is used by this instance of the <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> class template.  <br /></td></tr>
<tr class="separator:a8f6fa6a6e2c773ecaff1229fee7c9dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8c75842dde9c8228db63cf4254cfd9" id="r_ade8c75842dde9c8228db63cf4254cfd9"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade8c75842dde9c8228db63cf4254cfd9">nPerms</a> = <a class="el" href="group__maths.html#gae6de79415ac9f777d8015d05df88d0af">factorial</a>(n)</td></tr>
<tr class="memdesc:ade8c75842dde9c8228db63cf4254cfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of permutations on <em>n</em> elements.  <br /></td></tr>
<tr class="separator:ade8c75842dde9c8228db63cf4254cfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0132be0a9a6eac91fc0c612458af31" id="r_abd0132be0a9a6eac91fc0c612458af31"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd0132be0a9a6eac91fc0c612458af31">nPerms_1</a> = <a class="el" href="group__maths.html#gae6de79415ac9f777d8015d05df88d0af">factorial</a>(n-1)</td></tr>
<tr class="memdesc:abd0132be0a9a6eac91fc0c612458af31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated constant holding the total number of permutations on <code>n-1</code> elements.  <br /></td></tr>
<tr class="separator:abd0132be0a9a6eac91fc0c612458af31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18af91fda1ca58dd161b7fcee3a869b" id="r_af18af91fda1ca58dd161b7fcee3a869b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structregina_1_1PermSn.html">PermSn</a>&lt; n, <a class="el" href="namespaceregina.html#a2eaf86448196c96ea0869bb64aa9ef8ea31c6b3fdfaaa80dba2dbf92a4600524c">PermOrder::Sign</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b">Sn</a> {}</td></tr>
<tr class="memdesc:af18af91fda1ca58dd161b7fcee3a869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to all possible permutations of <em>n</em> elements in a sign-based order, with support for both array-like indexing and iteration.  <br /></td></tr>
<tr class="separator:af18af91fda1ca58dd161b7fcee3a869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee687a5695955828c8944c9d82f91f1c" id="r_aee687a5695955828c8944c9d82f91f1c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structregina_1_1PermSn.html">PermSn</a>&lt; n, <a class="el" href="namespaceregina.html#a2eaf86448196c96ea0869bb64aa9ef8ea976472a144efa6a4b849b24ac6b18867">PermOrder::Lex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee687a5695955828c8944c9d82f91f1c">orderedSn</a> {}</td></tr>
<tr class="memdesc:aee687a5695955828c8944c9d82f91f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to all possible permutations of <em>n</em> elements in lexicographical order, with support for both array-like indexing and iteration.  <br /></td></tr>
<tr class="separator:aee687a5695955828c8944c9d82f91f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af7872643bd1d26b2553b1ce7956ba121" id="r_af7872643bd1d26b2553b1ce7956ba121"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7872643bd1d26b2553b1ce7956ba121">Perm</a> (<a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> code)</td></tr>
<tr class="memdesc:af7872643bd1d26b2553b1ce7956ba121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a permutation from the given internal code.  <br /></td></tr>
<tr class="separator:af7872643bd1d26b2553b1ce7956ba121"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a51d6ca530254232fd73d45477d89baa9" id="r_a51d6ca530254232fd73d45477d89baa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51d6ca530254232fd73d45477d89baa9">code_</a></td></tr>
<tr class="memdesc:a51d6ca530254232fd73d45477d89baa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal code representing this permutation.  <br /></td></tr>
<tr class="separator:a51d6ca530254232fd73d45477d89baa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeeb5924020c18cc7238e2425ba76a12b" id="r_aeeb5924020c18cc7238e2425ba76a12b"><td class="memItemLeft" align="right" valign="top"><a id="aeeb5924020c18cc7238e2425ba76a12b" name="aeeb5924020c18cc7238e2425ba76a12b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PermSn&lt; n, PermOrder::Sign &gt;</b></td></tr>
<tr class="separator:aeeb5924020c18cc7238e2425ba76a12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952f92de4a5d9d60c5c3a298670df7cd" id="r_a952f92de4a5d9d60c5c3a298670df7cd"><td class="memItemLeft" align="right" valign="top"><a id="a952f92de4a5d9d60c5c3a298670df7cd" name="a952f92de4a5d9d60c5c3a298670df7cd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PermSn&lt; n, PermOrder::Lex &gt;</b></td></tr>
<tr class="separator:a952f92de4a5d9d60c5c3a298670df7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int n&gt;<br />
class regina::Perm&lt; n &gt;</div><p>Represents a permutation of {0,1,...,<em>n</em>-1}. </p>
<p>Amongst other things, such permutations are used to describe simplex gluings in (<em>n</em>-1)-manifold triangulations.</p>
<p><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> objects are small enough to pass by value and swap with std::swap(), with no need to use references, specialised move operations or custom swap functions. The trade-off is that, for this to be possible, the <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> template class can only work with <em>n</em> ≤ 16.</p>
<p>Each permutation has an internal code, which is a single native integer that is sufficient to reconstruct the entire permutation. Thus the internal code may be a useful means for passing permutation objects to and from the engine. These codes are constructed as follows:</p>
<ul>
<li>For 8 ≤ <em>n</em> ≤ 16, the code is an <em>image pack</em>: essentially a packed array that holds the images of 0,...,<em>n</em>-1 in a single native integer type. More precisely, this is an unsigned integer of type <em>ImagePack</em>, whose lowest <em>imageBits</em> bits represent the image of 0, whose next lowest <em>imageBits</em> bits represent the image of 1, and so on. This scheme is consistent with the old first-generation codes for <em>n</em> = 4,...,7, which are still supported but no longer used internally.</li>
<li>For <em>n</em> ≤ 7, the code is an index into a hard-coded list of all possible permutations; more precisely, an index into the symmetric group <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>. The ordering of <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a> is "almost lexicographic", in that we swap some pairs of indices (2<em>k</em>, 2<em>k</em>+1) to ensure that the even permutations are precisely those with even indices.</li>
</ul>
<p>For <em>n</em> = 2,...,5 (which appear throughout 2-, 3- and 4-manifold triangulations), this template is specialised: the code is highly optimised and also offers some extra functionality. For <em>n</em> = 6,7, this template is again specialised and highly optimised, and it offers some extra functionality but not as much as <a class="el" href="classregina_1_1Perm_3_015_01_4.html" title="Represents a permutation of {0,1,2,3,4}.">Perm&lt;5&gt;</a> and below. For <em>n</em> ≥ 8, this template is generic and most operations require more time (in particular, there are no harded-coded lookup tables).</p>
<p>You can iterate through all permutations using a range-based <code>for</code> loop over <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n&gt;::Sn</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : <a class="code hl_class" href="classregina_1_1Perm.html">Perm</a>&lt;n&gt;::<a class="code hl_variable" href="#af18af91fda1ca58dd161b7fcee3a869b">Sn</a>) { ... }</div>
<div class="ttc" id="aclassregina_1_1Perm_html"><div class="ttname"><a href="classregina_1_1Perm.html">regina::Perm</a></div><div class="ttdoc">Represents a permutation of {0,1,...,n-1}.</div><div class="ttdef"><b>Definition</b> cut.h:56</div></div>
<div class="ttc" id="aclassregina_1_1Perm_html_af18af91fda1ca58dd161b7fcee3a869b"><div class="ttname"><a href="#af18af91fda1ca58dd161b7fcee3a869b">regina::Perm::Sn</a></div><div class="ttdeci">static constexpr PermSn&lt; n, PermOrder::Sign &gt; Sn</div><div class="ttdoc">Gives access to all possible permutations of n elements in a sign-based order, with support for both ...</div><div class="ttdef"><b>Definition</b> perm.h:482</div></div>
</div><!-- fragment --><p>For the optimised permutation classes <em>n</em> ≤ 7, this iteration will be extremely fast in both C++ and Python. For the larger permutation classes <em>n</em> ≥ 8, this will still be reasonably fast in C++ (since it uses the increment operator internally), but it will be slower in Python (since it reconstructs <code>Sn[i]</code> for each integer <em>i</em>). If you are in Python and you need to iterate over all permutations for <em>n</em> ≥ 8, you may wish to implement a loop using <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n&gt;.inc()</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. For each <em>n</em> = 2,...,16, this class is available in Python under the corresponding name Perm2, Perm3, ..., Perm16.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of objects being permuted. This must be between 2 and 16 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8c7e4563b2e2d277b2c284bbb5abdc09" name="a8c7e4563b2e2d277b2c284bbb5abdc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7e4563b2e2d277b2c284bbb5abdc09">&#9670;&#160;</a></span>Code</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Code = <a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the native unsigned integer type used to store the internal permutation code. </p>
<p>This type alias is present for most values of <em>n</em>, though its precise size depends on how the permutation code is constructed. However, for <em>n</em> = 4,...,7 it is replaced by two type aliases <em>Code1</em> and <em>Code2</em>, which describe the older first-generation and newer second-generation permutation codes respectively. </p>

</div>
</div>
<a id="a8a2a33aeeb3fb5c702d6d7f80b216227" name="a8a2a33aeeb3fb5c702d6d7f80b216227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2a33aeeb3fb5c702d6d7f80b216227">&#9670;&#160;</a></span>ImagePack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::ImagePack = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;<a class="el" href="#a4269d01e17426bef1f0c12faa2e18253">imageBits</a> * n&gt;::utype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the native unsigned integer type used to store a single image pack. </p>
<p>See the class notes for more information on image packs, and how they are used as permutation codes for <em>n</em> ≥ 8. </p>

</div>
</div>
<a id="a38f1992a9c0b96ec211abf2e4cfc5ee7" name="a38f1992a9c0b96ec211abf2e4cfc5ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Index = typename <a class="el" href="group__utilities.html#gaeaace3588e085eb84080296034ae7a42">IntOfMinBits</a>&lt;<a class="el" href="#a4269d01e17426bef1f0c12faa2e18253">imageBits</a> * n&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denotes a native signed integer type large enough to count all permutations on <em>n</em> elements. </p>
<p>In other words, this is a native signed integer type large enough to store (<em>n</em>!).</p>
<dl class="section note"><dt>Note</dt><dd>This type is not hyper-optimised: for very small <em>n</em> where Index is hard-coded this is just an <code>int</code>, and for larger <em>n</em> where Index is derived it is actually large enough to hold an entire image pack. If at any stage there are plans to optimise this type, be careful of the special case of <em>n</em> = 8, where (8!) can be stored in an <em>unsigned</em> 16-bit type but not a signed 16-bit type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d6f626ed4864924dde033384b6a5bc5" name="a1d6f626ed4864924dde033384b6a5bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6f626ed4864924dde033384b6a5bc5">&#9670;&#160;</a></span>Perm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Perm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the identity permutation. </p>

</div>
</div>
<a id="a64ea9c2cda7a4e67af9c43a3f702a325" name="a64ea9c2cda7a4e67af9c43a3f702a325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ea9c2cda7a4e67af9c43a3f702a325">&#9670;&#160;</a></span>Perm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Perm </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the transposition of <em>a</em> and <em>b</em>. </p>
<p>Note that <em>a</em> and <em>b</em> need not be distinct.</p>
<dl class="section pre"><dt>Precondition</dt><dd>0 ≤ <em>a</em>,<em>b</em> &lt; <em>n</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the element to switch with <em>b</em>. </td></tr>
    <tr><td class="paramname">b</td><td>the element to switch with <em>a</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ed9c99ab994ba45a970184cb9c3fd8d" name="a1ed9c99ab994ba45a970184cb9c3fd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed9c99ab994ba45a970184cb9c3fd8d">&#9670;&#160;</a></span>Perm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Perm </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; int, n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a permutation mapping <em>i</em> to <em>image</em>[<em>i</em>] for each 0 ≤ <em>i</em> &lt; <em>n</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The elements of <em>image</em> are 0,...,<em>n</em>-1 in some order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the array of images. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d60f078c54732cda64aa632df208bd0" name="a9d60f078c54732cda64aa632df208bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d60f078c54732cda64aa632df208bd0">&#9670;&#160;</a></span>Perm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Perm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a permutation that is a clone of the given permutation. </p>

</div>
</div>
<a id="af7872643bd1d26b2553b1ce7956ba121" name="af7872643bd1d26b2553b1ce7956ba121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7872643bd1d26b2553b1ce7956ba121">&#9670;&#160;</a></span>Perm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Perm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a></td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a permutation from the given internal code. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the given code is a valid permutation code; see <a class="el" href="#a7538182b08b4bf5818281bd8d8cca393" title="Determines whether the given integer is a valid internal permutation code.">isPermCode()</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the internal code from which the new permutation will be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a933651038ffc99dfd7c2113420fcd58f" name="a933651038ffc99dfd7c2113420fcd58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933651038ffc99dfd7c2113420fcd58f">&#9670;&#160;</a></span>cachedComp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedComp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for the composition operator, provided to assist with writing generic code. </p>
<p>This generic Perm&lt;n&gt; class does not use precomputation to compute compositions. The only point of having <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a> in this generic Perm&lt;n&gt; class is to make it easier to write generic code that works with Perm&lt;n&gt; for any <em>n</em>.</p>
<ul>
<li>If you know you are only working with the generic Perm&lt;n&gt;, you should just use the composition operator instead.</li>
<li>If you are writing generic code, you <em>must</em> remember to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before using <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a>.</li>
</ul>
<p>The permutation that is returned is the same as you would obtain by calling <code>(*this) * q</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before calling <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a>. For generic Perm&lt;n&gt;, <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> does not affect compositions; however, for other Perm&lt;n&gt; classes a failure to do this will almost certainly crash your program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the permutation to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both permutations. </dd></dl>

</div>
</div>
<a id="af5d110a498b16c93c19306b0ae721914" name="af5d110a498b16c93c19306b0ae721914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d110a498b16c93c19306b0ae721914">&#9670;&#160;</a></span>cachedComp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedComp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for using the composition operator twice, provided to assist with writing generic code. </p>
<p>The permutation that is returned is the same as you would obtain by calling <code>(*this) * q * r</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated</a></b></dt><dd>The three-way <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a> was originally written to support conjugation. If you are indeed conjugating, then call <a class="el" href="#a17e2d8084921853b7aceafdd8ec49d87" title="An alias for conjugate(), provided to assist with writing generic code.">cachedConjugate()</a> instead; otherwise just call the two-way <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a> twice.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before calling <a class="el" href="#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">cachedComp()</a>. For generic Perm&lt;n&gt;, <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> does not affect compositions; however, for other Perm&lt;n&gt; classes a failure to do this will almost certainly crash your program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the first permutation to compose this with. </td></tr>
    <tr><td class="paramname">r</td><td>the second permutation to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both permutations. </dd></dl>

</div>
</div>
<a id="a17e2d8084921853b7aceafdd8ec49d87" name="a17e2d8084921853b7aceafdd8ec49d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e2d8084921853b7aceafdd8ec49d87">&#9670;&#160;</a></span>cachedConjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedConjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="#af6e2a1e73bae1eabf78c5ea5c0328299" title="Computes the conjugate of this permutation by q.">conjugate()</a>, provided to assist with writing generic code. </p>
<p>This generic Perm&lt;n&gt; class does not use precomputation to compute conjugates. The only point of having <a class="el" href="#a17e2d8084921853b7aceafdd8ec49d87" title="An alias for conjugate(), provided to assist with writing generic code.">cachedConjugate()</a> in this generic Perm&lt;n&gt; class is to make it easier to write generic code that works with Perm&lt;n&gt; for any <em>n</em>.</p>
<ul>
<li>If you know you are only working with the generic Perm&lt;n&gt;, you should just call <a class="el" href="#af6e2a1e73bae1eabf78c5ea5c0328299" title="Computes the conjugate of this permutation by q.">conjugate()</a> instead.</li>
<li>If you are writing generic code, you <em>must</em> remember to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before using <a class="el" href="#a17e2d8084921853b7aceafdd8ec49d87" title="An alias for conjugate(), provided to assist with writing generic code.">cachedConjugate()</a>.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before calling <a class="el" href="#a17e2d8084921853b7aceafdd8ec49d87" title="An alias for conjugate(), provided to assist with writing generic code.">cachedConjugate()</a>. For generic Perm&lt;n&gt;, <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> does not affect conjugate computations; however, for other Perm&lt;n&gt; classes a failure to do this will almost certainly crash your program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the permutation to conjugate this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conjugate of this permutation by <em>q</em>. </dd></dl>

</div>
</div>
<a id="a3acdb4b01aa1b2fe4467e225db79a714" name="a3acdb4b01aa1b2fe4467e225db79a714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acdb4b01aa1b2fe4467e225db79a714">&#9670;&#160;</a></span>cachedInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedInverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the inverse of this permutation, optimised using precomputed "partial lookup tables". </p>
<p>The advantage of this routine is speed: calling <a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">cachedInverse()</a> involves two table lookups and some simple arithmetic to combine the results, whereas <a class="el" href="#ad37db8b08dfb1cccaece75d84da8ccb3" title="Finds the inverse of this permutation.">inverse()</a> requires time linear in <em>n</em>.</p>
<p>The disadvantages of this routine are that (1) you must remember to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> in advance, and (2) the precomputed lookup tables will consume additional memory for the lifetime of your program. See <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> for details on just how much memory these tables will consume for each <em>n</em>.</p>
<p>The permutation that is returned is the same as you would obtain by calling <a class="el" href="#ad37db8b08dfb1cccaece75d84da8ccb3" title="Finds the inverse of this permutation.">inverse()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called the routine <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of the program before using <a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">cachedInverse()</a>. Otherwise this routine will almost certainly crash your program.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this permutation. </dd></dl>

</div>
</div>
<a id="a020e101860b8740aa6dfac5025fb9e40" name="a020e101860b8740aa6dfac5025fb9e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020e101860b8740aa6dfac5025fb9e40">&#9670;&#160;</a></span>cachedOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedOrder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="#abb094647d577fd89d7bf4b9218ced5a0" title="Returns the order of this permutation.">order()</a>, provided to assist with writing generic code. </p>
<p>This specialised Perm&lt;n&gt; class does not use precomputation to compute orders. The only point of having <a class="el" href="#a020e101860b8740aa6dfac5025fb9e40" title="An alias for order(), provided to assist with writing generic code.">cachedOrder()</a> in this generic Perm&lt;n&gt; class is to make it easier to write generic code that works with Perm&lt;n&gt; for any <em>n</em>.</p>
<ul>
<li>If you know you are only working with the generic Perm&lt;n&gt;, you should just call <a class="el" href="#abb094647d577fd89d7bf4b9218ced5a0" title="Returns the order of this permutation.">order()</a> instead.</li>
<li>If you are writing generic code, you <em>must</em> remember to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before using <a class="el" href="#a020e101860b8740aa6dfac5025fb9e40" title="An alias for order(), provided to assist with writing generic code.">cachedOrder()</a>.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before calling <a class="el" href="#a020e101860b8740aa6dfac5025fb9e40" title="An alias for order(), provided to assist with writing generic code.">cachedOrder()</a>. For generic Perm&lt;n&gt;, <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> does not affect order computations; however, for other Perm&lt;n&gt; classes a failure to do this will almost certainly crash your program.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the order of this permutation. </dd></dl>

</div>
</div>
<a id="a81b07bef48b84255836357de3754bb35" name="a81b07bef48b84255836357de3754bb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b07bef48b84255836357de3754bb35">&#9670;&#160;</a></span>cachedPow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::cachedPow </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for <a class="el" href="#a97501c225d57fe52eba2f16753ba1e47" title="Computes the given power of this permutation.">pow()</a>, provided to assist with writing generic code. </p>
<p>This specialised Perm&lt;n&gt; class does not use precomputation to compute powers. The only point of having <a class="el" href="#a81b07bef48b84255836357de3754bb35" title="An alias for pow(), provided to assist with writing generic code.">cachedPow()</a> in this generic Perm&lt;n&gt; class is to make it easier to write generic code that works with Perm&lt;n&gt; for any <em>n</em>.</p>
<ul>
<li>If you know you are only working with the generic Perm&lt;n&gt;, you should just call <a class="el" href="#a97501c225d57fe52eba2f16753ba1e47" title="Computes the given power of this permutation.">pow()</a> instead.</li>
<li>If you are writing generic code, you <em>must</em> remember to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before using <a class="el" href="#a81b07bef48b84255836357de3754bb35" title="An alias for pow(), provided to assist with writing generic code.">cachedPow()</a>.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>You <em>must</em> have called <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> at least once in the lifetime of this program before calling <a class="el" href="#a81b07bef48b84255836357de3754bb35" title="An alias for pow(), provided to assist with writing generic code.">cachedPow()</a>. For generic Perm&lt;n&gt;, <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> does not affect powers; however, for other Perm&lt;n&gt; classes a failure to do this will almost certainly crash your program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>the exponent; this may be positive, zero or negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this permutation raised to the power of <em>exp</em>. </dd></dl>

</div>
</div>
<a id="aa90b5059d347cc624292d102c58886e1" name="aa90b5059d347cc624292d102c58886e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90b5059d347cc624292d102c58886e1">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the images of all integers from <em>from</em> onwards to the identity map. </p>
<p>Specifically, for each <em>i</em> in the range <em>from</em>,...,<em>n</em>-1, this routine will ensure that <code>image[i] == i</code>. The images of 0,1,...,<em>from</em>-1 will not be altered.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The images of <em>from</em>,...,<em>n</em>-1 are exactly <em>from</em>,...,<em>n</em>-1, but possibly in a different order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first integer whose image should be reset. This must be between 0 and <em>n</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e7d012ee954069cf30d9732c68905a" name="ae7e7d012ee954069cf30d9732c68905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e7d012ee954069cf30d9732c68905a">&#9670;&#160;</a></span>compareWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::compareWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares the images of (0,1,...,<em>n-1</em>) under this and the given permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the permutation with which to compare this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if this permutation produces a smaller image, 0 if the permutations are equal, and 1 if this permutation produces a greater image. </dd></dl>

</div>
</div>
<a id="af6e2a1e73bae1eabf78c5ea5c0328299" name="af6e2a1e73bae1eabf78c5ea5c0328299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e2a1e73bae1eabf78c5ea5c0328299">&#9670;&#160;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::conjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the conjugate of this permutation by <em>q</em>. </p>
<p>Specifically, calling <code>p.conjugate(q)</code> is equivalent to computing <code>q * p * q.inverse()</code>. The resulting permutation will have the same cycle structure as <em>p</em>, but with the cycle elements translated according to <em>q</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the permutation to conjugate this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conjugate of this permutation by <em>q</em>. </dd></dl>

</div>
</div>
<a id="a2e96137c0fe11eb477b2f97a530a04a9" name="a2e96137c0fe11eb477b2f97a530a04a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e96137c0fe11eb477b2f97a530a04a9">&#9670;&#160;</a></span>contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; k &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts a <em>k</em>-element permutation to an <em>n</em>-element permutation, where <em>k</em> &gt; <em>n</em>. </p>
<p>The resulting permutation will map 0,...,<em>n</em>-1 to their respective images under <em>p</em>, and will ignore the "unused" images <em>p</em>[<em>n</em>],...,<em>p</em>[<em>k</em>-1].</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given permutation maps 0,...,<em>n</em>-1 to 0,...,<em>n</em>-1 in some order.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the number of elements for the input permutation; this must be strictly greater than <em>n</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a permutation on <em>k</em> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same permutation restricted to a permutation on <em>n</em> elements. </dd></dl>

</div>
</div>
<a id="a214fc67b707a093ad90e37647f51859e" name="a214fc67b707a093ad90e37647f51859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214fc67b707a093ad90e37647f51859e">&#9670;&#160;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classregina_1_1Perm.html">Perm</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; k &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends a <em>k</em>-element permutation to an <em>n</em>-element permutation, where 2 ≤ <em>k</em> &lt; <em>n</em>. </p>
<p>The resulting permutation will map 0,...,<em>k</em>-1 to their respective images under <em>p</em>, and will map the "unused" elements <em>k</em>,...,<em>n</em>-1 to themselves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the number of elements for the input permutation; this must be at least 2, and strictly less than <em>n</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a permutation on <em>k</em> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same permutation expressed as a permutation on <em>n</em> elements. </dd></dl>

</div>
</div>
<a id="ad5671b70535311aaf1952c837688283d" name="ad5671b70535311aaf1952c837688283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5671b70535311aaf1952c837688283d">&#9670;&#160;</a></span>fromImagePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::fromImagePack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a></td>          <td class="paramname"><span class="paramname"><em>pack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a permutation from the given image pack. </p>
<p>See the class notes for more information on image packs, and how they are used to build permutation codes.</p>
<p>For <em>n</em> ≥ 8, this routine is identical to <a class="el" href="#a5ed9840350bcd33b5793c83dc1081c7b" title="Creates a permutation from the given internal code.">fromPermCode()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>pack</em> is a valid image pack; see <a class="el" href="#ac85b60d08482ee67193658579757cfb1" title="Determines whether the given argument is the image pack of some n-element permutation.">isImagePack()</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>an image pack that describes a permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation represented by the given image pack. </dd></dl>

</div>
</div>
<a id="a5ed9840350bcd33b5793c83dc1081c7b" name="a5ed9840350bcd33b5793c83dc1081c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed9840350bcd33b5793c83dc1081c7b">&#9670;&#160;</a></span>fromPermCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::fromPermCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a></td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a permutation from the given internal code. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the given code is a valid permutation code; see <a class="el" href="#a7538182b08b4bf5818281bd8d8cca393" title="Determines whether the given integer is a valid internal permutation code.">isPermCode()</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the internal code for the new permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation reprsented by the given internal code. </dd></dl>

</div>
</div>
<a id="afcdf7862f029702723f6701359921662" name="afcdf7862f029702723f6701359921662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf7862f029702723f6701359921662">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this permutation to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>The implementation currently returns the internal permutation code, truncated to a <code>size_t</code> where necessary. For the larger permutation classes (<em>n</em> ≥ 8), this is almost certainly a bad choice of hash function (since permutation codes are image packs, which have enormous "holes" across their overall integer range). This implementation (and therefore the specific hash values obtained) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows permutations to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this permutation. </dd></dl>

</div>
</div>
<a id="ad633944eec40e663b281ec3e4303465e" name="ad633944eec40e663b281ec3e4303465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad633944eec40e663b281ec3e4303465e">&#9670;&#160;</a></span>imagePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;<a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">::ImagePack</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::imagePack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the image pack that represents this permutation. </p>
<p>See the class notes for more information on image packs, and how they are used to build permutation codes.</p>
<p>For <em>n</em> ≥ 8, this routine is identical to <a class="el" href="#a2441b248d28aed6a7775c6515d3ee91d" title="Returns the internal code representing this permutation.">permCode()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the image pack for this permutation. </dd></dl>

</div>
</div>
<a id="ad37db8b08dfb1cccaece75d84da8ccb3" name="ad37db8b08dfb1cccaece75d84da8ccb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37db8b08dfb1cccaece75d84da8ccb3">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the inverse of this permutation. </p>
<p>For permutations of seven and fewer objects, inversion is extremely fast because it uses hard-coded lookup tables. However, for this generic Perm&lt;n&gt; class, inversion cannot use these lookup tables (for multiple reasons), and so <a class="el" href="#ad37db8b08dfb1cccaece75d84da8ccb3" title="Finds the inverse of this permutation.">inverse()</a> takes time linear in <em>n</em>.</p>
<p>If you are going to make significant use of the generic Perm&lt;n&gt; class for some particular value of <em>n</em>, you should instead:</p>
<ul>
<li>call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> to precompute some "partial lookup tables" in advance (see <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> for details on how much memory they will consume); and then</li>
<li>call <a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">cachedInverse()</a> instead of <a class="el" href="#ad37db8b08dfb1cccaece75d84da8ccb3" title="Finds the inverse of this permutation.">inverse()</a> to compute your inverses.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this permutation. </dd></dl>

</div>
</div>
<a id="ac22e858285445d65377dd206dcd4c221" name="ac22e858285445d65377dd206dcd4c221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22e858285445d65377dd206dcd4c221">&#9670;&#160;</a></span>isConjugacyMinimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::isConjugacyMinimal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this permutation minimal in its conjugacy class? </p>
<p>Here "minimal" means that, amongst all its conjugates, this permutation has the smallest index in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>.</p>
<p>See Sn for further information on how permutations are indexed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this permutation is minimal in its conjugacy class. </dd></dl>

</div>
</div>
<a id="a357cb8ad15a7fff471dfa943aa964612" name="a357cb8ad15a7fff471dfa943aa964612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357cb8ad15a7fff471dfa943aa964612">&#9670;&#160;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is the identity permutation. </p>
<p>This is true if and only if every integer 0 ≤ <em>i</em> &lt; <em>n</em> is mapped to itself.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the identity permutation. </dd></dl>

</div>
</div>
<a id="ac85b60d08482ee67193658579757cfb1" name="ac85b60d08482ee67193658579757cfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85b60d08482ee67193658579757cfb1">&#9670;&#160;</a></span>isImagePack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::isImagePack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a></td>          <td class="paramname"><span class="paramname"><em>pack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given argument is the image pack of some <em>n</em>-element permutation. </p>
<p>See the class notes for more information on image packs, and how they are used to build permutation codes.</p>
<p>For <em>n</em> ≥ 8, this routine is identical to <a class="el" href="#a7538182b08b4bf5818281bd8d8cca393" title="Determines whether the given integer is a valid internal permutation code.">isPermCode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>the candidate image pack to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>pack</em> is a valid image pack. </dd></dl>

</div>
</div>
<a id="a7538182b08b4bf5818281bd8d8cca393" name="a7538182b08b4bf5818281bd8d8cca393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7538182b08b4bf5818281bd8d8cca393">&#9670;&#160;</a></span>isPermCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::isPermCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a></td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given integer is a valid internal permutation code. </p>
<p>Valid permutation codes can be passed to <a class="el" href="#a236437a3c6f1aee07ab6ff0386994efe" title="Sets this permutation to that represented by the given internal code.">setPermCode()</a> or <a class="el" href="#a5ed9840350bcd33b5793c83dc1081c7b" title="Creates a permutation from the given internal code.">fromPermCode()</a>, and are returned by <a class="el" href="#a2441b248d28aed6a7775c6515d3ee91d" title="Returns the internal code representing this permutation.">permCode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the permutation code to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given code is a valid internal permutation code. </dd></dl>

</div>
</div>
<a id="a8768ecf24f06255eea6e3c448b449843" name="a8768ecf24f06255eea6e3c448b449843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8768ecf24f06255eea6e3c448b449843">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the composition of this permutation with the given permutation. </p>
<p>If this permutation is <em>p</em>, the resulting permutation will be <em>p</em>∘<em>q</em>, and will satisfy <code>(p*q)[x] == p[q[x]]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the permutation to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both permutations. </dd></dl>

</div>
</div>
<a id="ac9add8dd475d4279d83393bf0bd73fa2" name="ac9add8dd475d4279d83393bf0bd73fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9add8dd475d4279d83393bf0bd73fa2">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a> &amp; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A preincrement operator that changes this to be the next permutation in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>. </p>
<p>If this is the last such permutation then this will wrap around to become the first permutation in <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>, which is the identity.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. The postincrement operator is present in Python as the member function inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this permutation after the increment. </dd></dl>

</div>
</div>
<a id="a33d9a7d14565eb4f1e8ace5fbf74d5a8" name="a33d9a7d14565eb4f1e8ace5fbf74d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9a7d14565eb4f1e8ace5fbf74d5a8">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A postincrement operator that changes this to be the next permutation in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>. </p>
<p>If this is the last such permutation then this will wrap around to become the first permutation in <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>, which is the identity.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is named inc() since python does not support the increment operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this permutation before the increment took place. </dd></dl>

</div>
</div>
<a id="a446028a8ef1045d7bb6776accd509a26" name="a446028a8ef1045d7bb6776accd509a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446028a8ef1045d7bb6776accd509a26">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two permutations according to which appears earlier in the array <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>. </p>
<p>Note that this is <em>not</em> the same ordering of permutations as the ordering implied by <a class="el" href="#ae7e7d012ee954069cf30d9732c68905a" title="Lexicographically compares the images of (0,1,...,n-1) under this and the given permutation.">compareWith()</a>. This ordering is, however, consistent with the ordering implied by the ++ operators.</p>
<p>Unlike the smaller permutation classes that use <em>Sn</em> indices as internal permutation codes, for this generic <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> class the ordering defined here is <em>slower</em> to compute than <a class="el" href="#ae7e7d012ee954069cf30d9732c68905a" title="Lexicographically compares the images of (0,1,...,n-1) under this and the given permutation.">compareWith()</a>. It is recommended that, unless you specifically need to align your ordering with <em>Sn</em> indices, you either (i) use <a class="el" href="#ae7e7d012ee954069cf30d9732c68905a" title="Lexicographically compares the images of (0,1,...,n-1) under this and the given permutation.">compareWith()</a> for lexicographical ordering (which is a little faster), or else (ii) just compare permutation codes if you are happy with an arbitrary ordering (which will be <em>much</em> faster).</p>
<p>This generates all of the usual comparison operators, including <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This spaceship operator <code>x &lt;=&gt; y</code> is not available, but the other comparison operators that it generates <em>are</em> available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the permutation to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result that indicates which permutation appears earlier in <em>Sn</em>. </dd></dl>

</div>
</div>
<a id="a913d2027ee4033fab6fc29c4f318e2a4" name="a913d2027ee4033fab6fc29c4f318e2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913d2027ee4033fab6fc29c4f318e2a4">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a> &amp; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cloneMe</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this permutation to be equal to the given permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the permutation whose value will be assigned to this permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this permutation. </dd></dl>

</div>
</div>
<a id="ab8b5b08408450a849064a4fdf364af6d" name="ab8b5b08408450a849064a4fdf364af6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b5b08408450a849064a4fdf364af6d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is equal to the given permutation. </p>
<p>This is true if and only if both permutations have the same images for all 0 ≤ <em>i</em> &lt; <em>n</em>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given permutation are equal. </dd></dl>

</div>
</div>
<a id="a3270b6cf9a20e249ac4ae28166896c36" name="a3270b6cf9a20e249ac4ae28166896c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3270b6cf9a20e249ac4ae28166896c36">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given integer under this permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the integer whose image we wish to find. This should be between 0 and <em>n</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of <em>source</em>. </dd></dl>

</div>
</div>
<a id="abb094647d577fd89d7bf4b9218ced5a0" name="abb094647d577fd89d7bf4b9218ced5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb094647d577fd89d7bf4b9218ced5a0">&#9670;&#160;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::order </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the order of this permutation. </p>
<p>In other words; this routine returns the smallest positive integer <em>k</em> for which the <em>k</em>th power of this permutation is the identity.</p>
<p>Note that the largest possible order for the largest supported <em>n</em> (<em>n</em> = 16) is 140. See OEIS sequence A000793 for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the order of this permutation. </dd></dl>

</div>
</div>
<a id="ab6eae6c523c56cd6725445139b32b1a2" name="ab6eae6c523c56cd6725445139b32b1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eae6c523c56cd6725445139b32b1a2">&#9670;&#160;</a></span>orderedSnIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;<a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">::Index</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::orderedSnIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lexicographical index of this permutation. </p>
<p>This will be the index of this permutation in the <a class="el" href="#aee687a5695955828c8944c9d82f91f1c" title="Gives access to all possible permutations of n elements in lexicographical order, with support for bo...">Perm&lt;n&gt;::orderedSn</a> array.</p>
<p>See orderedSn for further information on lexicographical ordering.</p>
<dl class="section return"><dt>Returns</dt><dd>the lexicographical index of this permutation. This will be between 0 and <em>n</em>!-1 inclusive. </dd></dl>

</div>
</div>
<a id="a2441b248d28aed6a7775c6515d3ee91d" name="a2441b248d28aed6a7775c6515d3ee91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2441b248d28aed6a7775c6515d3ee91d">&#9670;&#160;</a></span>permCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;<a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">::Code</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::permCode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal code representing this permutation. </p>
<p>Note that the internal code is sufficient to reproduce the entire permutation.</p>
<p>The code returned will be a valid permutation code as determined by <a class="el" href="#a7538182b08b4bf5818281bd8d8cca393" title="Determines whether the given integer is a valid internal permutation code.">isPermCode()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the internal code. </dd></dl>

</div>
</div>
<a id="a97501c225d57fe52eba2f16753ba1e47" name="a97501c225d57fe52eba2f16753ba1e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97501c225d57fe52eba2f16753ba1e47">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::pow </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the given power of this permutation. </p>
<p>This routine runs in time linear in <em>n</em> (in particular, the running time does not depend upon the given exponent).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>the exponent; this may be positive, zero or negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this permutation raised to the power of <em>exp</em>. </dd></dl>

</div>
</div>
<a id="a0bc9d7577fe1d11ec1463c378d243da0" name="a0bc9d7577fe1d11ec1463c378d243da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc9d7577fe1d11ec1463c378d243da0">&#9670;&#160;</a></span>pre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::pre </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the preimage of the given integer under this permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the integer whose preimage we wish to find. This should be between 0 and <em>n</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the preimage of <em>image</em>. </dd></dl>

</div>
</div>
<a id="a90eb879e7ec2bc1fd4dd9269a632fbc6" name="a90eb879e7ec2bc1fd4dd9269a632fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eb879e7ec2bc1fd4dd9269a632fbc6">&#9670;&#160;</a></span>precompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::precompute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the precomputation necessary for using the optimised <a class="el" href="#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">cachedInverse()</a> routine. </p>
<p>This <em>must</em> be called before using <em>any</em> of the optimised <code>cachedXXX()</code> functions.</p>
<p>This only needs to be done once in the lifetime of the program. If you do try to call <a class="el" href="#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">precompute()</a> a second time then it will do nothing and return immediately.</p>
<p>The precomputed tables will consume roughly:</p>
<ul>
<li>33 kB for <em>n</em> = 8;</li>
<li>8.9 MB for <em>n</em> = 9;</li>
<li>17 MB for <em>n</em> = 10;</li>
<li>143 MB for <em>n</em> = 11;</li>
<li>268 MB for <em>n</em> = 12;</li>
<li>2.3 GB for <em>n</em> = 13;</li>
<li>4.3 GB for <em>n</em> = 14;</li>
<li>37 GB for <em>n</em> = 15;</li>
<li>69 GB for <em>n</em> = 16.</li>
</ul>
<p>In particular, a 32-bit machine will not be able to store these tables for <em>n</em> ≥ 13, a 24-bit machine will not be these tables for <em>n</em> ≥ 9, and a 16-bit machine will not be able to store these tables for any <em>n</em> ≥ 8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There is enough memory available to store the precomputed tables; see above for the estimated space requirements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>There was not enough memory to available to store the precomputed tables.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is thread-safe. </p>

</div>
</div>
<a id="a9e17c130b5c30be0a35b7e3ff622d3ee" name="a9e17c130b5c30be0a35b7e3ff622d3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e17c130b5c30be0a35b7e3ff622d3ee">&#9670;&#160;</a></span>rand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::rand </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>even</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random permutation on <em>n</em> elements. </p>
<p>All permutations are returned with equal probability.</p>
<p>This routine is thread-safe, and uses <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> for its random number generation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is expensive, since it locks and unlocks the mutex protecting Regina's global uniform random bit generator. If you are calling this many times in quick succession, consider creating a single <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> object yourself and then calling <code>rand(randomEngine.engine(), even)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">even</td><td>if <code>true</code>, then the resulting permutation is guaranteed to be even (and again all even permutations are returned with equal probability). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random permutation. </dd></dl>

</div>
</div>
<a id="ae7e12551e8dc16b28b69b64a0aaca6dd" name="ae7e12551e8dc16b28b69b64a0aaca6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e12551e8dc16b28b69b64a0aaca6dd">&#9670;&#160;</a></span>rand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<div class="memtemplate">
template&lt;class URBG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Perm.html">Perm</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::rand </td>
          <td>(</td>
          <td class="paramtype">URBG &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>even</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random permutation on <em>n</em> elements, using the given uniform random bit generator. </p>
<p>All permutations are returned with equal probability.</p>
<p>The thread safety of this routine is of course dependent on the thread safety of your uniform random bit generator <em>gen</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">URBG</td><td>A type which, once any references are removed, must adhere to the C++ <em>UniformRandomBitGenerator</em> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Python users are still able to use the non-thread-safe variant without the <em>gen</em> argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>the source of randomness to use (e.g., one of the many options provided in the C++ standard <code>random</code> header). </td></tr>
    <tr><td class="paramname">even</td><td>if <code>true</code>, then the resulting permutation is guaranteed to be even (and again all even permutations are returned with equal probability). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a random permutation. </dd></dl>

</div>
</div>
<a id="a05b3244ac72c2578b28ad3b03be5c2bf" name="a05b3244ac72c2578b28ad3b03be5c2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b3244ac72c2578b28ad3b03be5c2bf">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the reverse of this permutation. </p>
<p>Here <em>reverse</em> means that we reverse the images of 0,...,<em>n</em>-1. In other words, if permutation <em>q</em> is the reverse of <em>p</em>, then <code>p[i] == q[n - 1 - i]</code> for all <em>i</em>. </p>

</div>
</div>
<a id="a4bdd6540933f4f6443a47cf420922b1e" name="a4bdd6540933f4f6443a47cf420922b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdd6540933f4f6443a47cf420922b1e">&#9670;&#160;</a></span>rot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::rot </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <em>i</em>th rotation. </p>
<p>This maps <em>k</em> to <em>k</em> + <em>i</em> (mod <em>n</em>) for all <em>k</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the image of 0; this must be between 0 and <em>n</em>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>i</em>th rotation. </dd></dl>

</div>
</div>
<a id="a236437a3c6f1aee07ab6ff0386994efe" name="a236437a3c6f1aee07ab6ff0386994efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236437a3c6f1aee07ab6ff0386994efe">&#9670;&#160;</a></span>setPermCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::setPermCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a></td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this permutation to that represented by the given internal code. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the given code is a valid permutation code; see <a class="el" href="#a7538182b08b4bf5818281bd8d8cca393" title="Determines whether the given integer is a valid internal permutation code.">isPermCode()</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the internal code that will determine the new value of this permutation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e223024f54c92a1f331f5339ab108a" name="a33e223024f54c92a1f331f5339ab108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e223024f54c92a1f331f5339ab108a">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::sign </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the sign of this permutation. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if this permutation is even, or -1 if this permutation is odd. </dd></dl>

</div>
</div>
<a id="a9735dd0921cdf0214d31c2397798a1ae" name="a9735dd0921cdf0214d31c2397798a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9735dd0921cdf0214d31c2397798a1ae">&#9670;&#160;</a></span>SnIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;<a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">::Index</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::SnIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of this permutation in the <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a> array. </p>
<p>See Sn for further information on how these permutations are indexed.</p>
<dl class="section return"><dt>Returns</dt><dd>the index <em>i</em> for which this permutation is equal to <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>[i]. This will be between 0 and <em>n</em>!-1 inclusive. </dd></dl>

</div>
</div>
<a id="a4200afccebbd4ea0d74d02c7d5ab18d4" name="a4200afccebbd4ea0d74d02c7d5ab18d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4200afccebbd4ea0d74d02c7d5ab18d4">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of this permutation. </p>
<p>The representation will consist of <em>n</em> adjacent digits representing the images of 0,...,<em>n</em>-1 respectively. If <em>n</em> &gt; 10, then lower-case hexadecimal digits will be used.</p>
<p>An example of a string representation for <em>n</em> = 5 is <code>30421</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this permutation. </dd></dl>

</div>
</div>
<a id="a150feb97a183e3cfc2be6f13fa3a4e80" name="a150feb97a183e3cfc2be6f13fa3a4e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150feb97a183e3cfc2be6f13fa3a4e80">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a permutation from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<p>Tight encodings are fast to work with for small permutation classes (<em>n</em> ≤ 7), but slower for larger permutation classes (8 ≤ <em>n</em> ≤ 16). See <a class="el" href="#a5ffcbbe103c24ab0f55728845ef4b3ba" title="Returns the tight encoding of this permutation.">tightEncoding()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of an <em>n</em>-element permutation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#a423625cc4777b3a9492b883c449b76f5" title="Reconstructs a permutation from its given tight encoding.">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for an <em>n</em>-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a423625cc4777b3a9492b883c449b76f5" name="a423625cc4777b3a9492b883c449b76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423625cc4777b3a9492b883c449b76f5">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a permutation from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<p>Tight encodings are fast to work with for small permutation classes (<em>n</em> ≤ 7), but slower for larger permutation classes (8 ≤ <em>n</em> ≤ 16). See <a class="el" href="#a5ffcbbe103c24ab0f55728845ef4b3ba" title="Returns the tight encoding of this permutation.">tightEncoding()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an <em>n</em>-element permutation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an <em>n</em>-element permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a718101dd1d0a2565ff9c1341c6855c56" name="a718101dd1d0a2565ff9c1341c6855c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718101dd1d0a2565ff9c1341c6855c56">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this permutation to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>For all permutation classes Perm&lt;n&gt;, the tight encoding is based on the index into the full permutation group <em>S_n</em>. For smaller permutation classes (<em>n</em> ≤ 7), such encodings are very fast to work with since the <em>S_n</em> index is used as the internal permutation code. For larger permutation classes however (8 ≤ <em>n</em> ≤ 16), the <em>S_n</em> index requires some non-trivial work to compute.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#a5ffcbbe103c24ab0f55728845ef4b3ba" title="Returns the tight encoding of this permutation.">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ffcbbe103c24ab0f55728845ef4b3ba" name="a5ffcbbe103c24ab0f55728845ef4b3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffcbbe103c24ab0f55728845ef4b3ba">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tight encoding of this permutation. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>For all permutation classes Perm&lt;n&gt;, the tight encoding is based on the index into the full permutation group <em>S_n</em>. For smaller permutation classes (<em>n</em> ≤ 7), such encodings are very fast to work with since the <em>S_n</em> index is used as the internal permutation code. For larger permutation classes however (8 ≤ <em>n</em> ≤ 16), the <em>S_n</em> index requires some non-trivial work to compute.</p>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a557d8ec860c30e283aae73839e7c4cfb" name="a557d8ec860c30e283aae73839e7c4cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557d8ec860c30e283aae73839e7c4cfb">&#9670;&#160;</a></span>trunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::trunc </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a prefix of the string representation of this permutation, containing only the images of the first <em>len</em> integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the length of the prefix required; this must be between 0 and <em>n</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding prefix of the string representation of this permutation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a51d6ca530254232fd73d45477d89baa9" name="a51d6ca530254232fd73d45477d89baa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d6ca530254232fd73d45477d89baa9">&#9670;&#160;</a></span>code_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8c7e4563b2e2d277b2c284bbb5abdc09">Code</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::code_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal code representing this permutation. </p>

</div>
</div>
<a id="a8f6fa6a6e2c773ecaff1229fee7c9dd1" name="a8f6fa6a6e2c773ecaff1229fee7c9dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6fa6a6e2c773ecaff1229fee7c9dd1">&#9670;&#160;</a></span>codeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gae8090c7366267fc9deefd4927be21476">PermCodeType</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::codeType = <a class="el" href="group__maths.html#ggae8090c7366267fc9deefd4927be21476afff0d600f8a0b5e19e88bfb821dd1157">PermCodeType::Images</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates what type of internal permutation code is used by this instance of the <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> class template. </p>

</div>
</div>
<a id="afdb2969d64d3e2c97f941c134f42ddca" name="afdb2969d64d3e2c97f941c134f42ddca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb2969d64d3e2c97f941c134f42ddca">&#9670;&#160;</a></span>degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::degree = n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The degree of the underlying symmetric group; that is, the template parameter <em>n</em>. </p>
<p>This compile-time constant allows the programmer to extract <em>n</em> from the type (e.g., when writing templated code). </p>

</div>
</div>
<a id="a4269d01e17426bef1f0c12faa2e18253" name="a4269d01e17426bef1f0c12faa2e18253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4269d01e17426bef1f0c12faa2e18253">&#9670;&#160;</a></span>imageBits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::imageBits = <a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a>(n)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the number of bits used in an image pack to store the image of a single integer. </p>
<p>A full image pack combines <em>n</em> such images together, and so uses <em>n</em> * <em>imageBits</em> bits in total. </p>

</div>
</div>
<a id="a705435f13150fb21e341c207d2c4374d" name="a705435f13150fb21e341c207d2c4374d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705435f13150fb21e341c207d2c4374d">&#9670;&#160;</a></span>imageMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::imageMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            (<span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="#a8a2a33aeeb3fb5c702d6d7f80b216227">ImagePack</a><span class="keyword">&gt;</span>(1) &lt;&lt; <a class="code hl_variable" href="#a4269d01e17426bef1f0c12faa2e18253">Perm&lt;n&gt;::imageBits</a>) - 1</div>
<div class="ttc" id="aclassregina_1_1Perm_html_a4269d01e17426bef1f0c12faa2e18253"><div class="ttname"><a href="#a4269d01e17426bef1f0c12faa2e18253">regina::Perm::imageBits</a></div><div class="ttdeci">static constexpr int imageBits</div><div class="ttdoc">Indicates the number of bits used in an image pack to store the image of a single integer.</div><div class="ttdef"><b>Definition</b> perm.h:342</div></div>
<div class="ttc" id="aclassregina_1_1Perm_html_a8a2a33aeeb3fb5c702d6d7f80b216227"><div class="ttname"><a href="#a8a2a33aeeb3fb5c702d6d7f80b216227">regina::Perm::ImagePack</a></div><div class="ttdeci">typename IntOfMinBits&lt; imageBits *n &gt;::utype ImagePack</div><div class="ttdoc">Indicates the native unsigned integer type used to store a single image pack.</div><div class="ttdef"><b>Definition</b> perm.h:364</div></div>
</div><!-- fragment -->
<p>A bitmask whose lowest <em>imageBits</em> bits are 1, and whose remaining higher order bits are all 0. </p>
<p>This may be useful when creating or analysing image packs. </p>

</div>
</div>
<a id="ade8c75842dde9c8228db63cf4254cfd9" name="ade8c75842dde9c8228db63cf4254cfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8c75842dde9c8228db63cf4254cfd9">&#9670;&#160;</a></span>nPerms</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::nPerms = <a class="el" href="group__maths.html#gae6de79415ac9f777d8015d05df88d0af">factorial</a>(n)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of permutations on <em>n</em> elements. </p>
<p>This is the size of the symmetric group <em>S<sub>n</sub></em>. </p>

</div>
</div>
<a id="abd0132be0a9a6eac91fc0c612458af31" name="abd0132be0a9a6eac91fc0c612458af31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0132be0a9a6eac91fc0c612458af31">&#9670;&#160;</a></span>nPerms_1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38f1992a9c0b96ec211abf2e4cfc5ee7">Index</a> <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::nPerms_1 = <a class="el" href="group__maths.html#gae6de79415ac9f777d8015d05df88d0af">factorial</a>(n-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated constant holding the total number of permutations on <code>n-1</code> elements. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated</a></b></dt><dd>Just use <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n-1&gt;::nPerms</code> instead. </dd></dl>

</div>
</div>
<a id="aee687a5695955828c8944c9d82f91f1c" name="aee687a5695955828c8944c9d82f91f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee687a5695955828c8944c9d82f91f1c">&#9670;&#160;</a></span>orderedSn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1PermSn.html">PermSn</a>&lt;n, <a class="el" href="namespaceregina.html#a2eaf86448196c96ea0869bb64aa9ef8ea976472a144efa6a4b849b24ac6b18867">PermOrder::Lex</a>&gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::orderedSn {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives access to all possible permutations of <em>n</em> elements in lexicographical order, with support for both array-like indexing and iteration. </p>
<p>To access the permutation at index <em>i</em>, you simply use the square bracket operator: <code>orderedSn[i]</code>. The index <em>i</em> must be between 0 and <code>n!-1</code> inclusive.</p>
<p>You can also iterate over all permutations in <em>orderedSn</em> using a range-based <code>for</code> loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : <a class="code hl_class" href="classregina_1_1Perm.html">Perm</a>&lt;n&gt;::<a class="code hl_variable" href="#aee687a5695955828c8944c9d82f91f1c">orderedSn</a>) { ... }</div>
<div class="ttc" id="aclassregina_1_1Perm_html_aee687a5695955828c8944c9d82f91f1c"><div class="ttname"><a href="#aee687a5695955828c8944c9d82f91f1c">regina::Perm::orderedSn</a></div><div class="ttdeci">static constexpr PermSn&lt; n, PermOrder::Lex &gt; orderedSn</div><div class="ttdoc">Gives access to all possible permutations of n elements in lexicographical order, with support for bo...</div><div class="ttdef"><b>Definition</b> perm.h:514</div></div>
</div><!-- fragment --><p>Lexicographical ordering treats each permutation <em>p</em> as the <em>n</em>-tuple <code>(p[0], p[1], ..., p[n-1])</code>.</p>
<p>This array is different from <a class="el" href="#af18af91fda1ca58dd161b7fcee3a869b" title="Gives access to all possible permutations of n elements in a sign-based order, with support for both ...">Perm&lt;n&gt;::Sn</a>, since <em>orderedSn</em> accesses permutations in lexicographical order, whereas <em>Sn</em> alternates between even and odd permutations.</p>
<p>This is a lightweight object, and it is defined in the headers only. In particular, you cannot make a reference to it (but it is cheap to make a copy).</p>
<p>See the <a class="el" href="structregina_1_1PermSn.html" title="A lightweight array-like object that supports fast lookup and iteration for permutations on n objects...">PermSn</a> documentation for further details, including time complexity of lookup and iteration. </p>

</div>
</div>
<a id="af18af91fda1ca58dd161b7fcee3a869b" name="af18af91fda1ca58dd161b7fcee3a869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18af91fda1ca58dd161b7fcee3a869b">&#9670;&#160;</a></span>Sn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1PermSn.html">PermSn</a>&lt;n, <a class="el" href="namespaceregina.html#a2eaf86448196c96ea0869bb64aa9ef8ea31c6b3fdfaaa80dba2dbf92a4600524c">PermOrder::Sign</a>&gt; <a class="el" href="classregina_1_1Perm.html">regina::Perm</a>&lt; n &gt;::Sn {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives access to all possible permutations of <em>n</em> elements in a sign-based order, with support for both array-like indexing and iteration. </p>
<p>To access the permutation at index <em>i</em>, you simply use the square bracket operator: <code>Sn[i]</code>. The index <em>i</em> must be between 0 and <code>n!-1</code> inclusive.</p>
<p>You can also iterate over all permutations in <em>Sn</em> using a range-based <code>for</code> loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : <a class="code hl_class" href="classregina_1_1Perm.html">Perm</a>&lt;n&gt;::<a class="code hl_variable" href="#af18af91fda1ca58dd161b7fcee3a869b">Sn</a>) { ... }</div>
</div><!-- fragment --><p>The permutations with even indices in the array are the even permutations, and those with odd indices in the array are the odd permutations. The first permutation (at index 0) is the identity.</p>
<p>This array is different from <a class="el" href="#aee687a5695955828c8944c9d82f91f1c" title="Gives access to all possible permutations of n elements in lexicographical order, with support for bo...">Perm&lt;n&gt;::orderedSn</a>, since <em>Sn</em> alternates between even and odd permutations, whereas <em>orderedSn</em> accesses permutations in lexicographical order.</p>
<p>This is a lightweight object, and it is defined in the headers only. In particular, you cannot make a reference to it (but it is cheap to make a copy).</p>
<p>See the <a class="el" href="structregina_1_1PermSn.html" title="A lightweight array-like object that supports fast lookup and iteration for permutations on n objects...">PermSn</a> documentation for further details, including time complexity of lookup and iteration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>maths/<a class="el" href="perm_8h.html">perm.h</a></li>
<li>maths/<a class="el" href="permsn_8h.html">permsn.h</a></li>
<li>triangulation/alias/<a class="el" href="alias_2face_8h.html">face.h</a></li>
<li>triangulation/alias/<a class="el" href="alias_2isomorphism_8h.html">isomorphism.h</a></li>
<li>triangulation/<a class="el" href="cut_8h.html">cut.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
