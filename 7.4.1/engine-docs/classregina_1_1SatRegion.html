<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::SatRegion Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1SatRegion-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SatRegion Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A large saturated region in a Seifert fibred space formed by joining together saturated blocks.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;subcomplex/satregion.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SatRegion:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SatRegion.png" usemap="#regina::SatRegion_map" alt=""/>
  <map id="regina::SatRegion_map" name="regina::SatRegion_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SatRegion &gt;" shape="rect" coords="0,0,172,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a575e2b386bf715799faf544410dfa08e" id="r_a575e2b386bf715799faf544410dfa08e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a575e2b386bf715799faf544410dfa08e">SatRegion</a> (const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;src)</td></tr>
<tr class="memdesc:a575e2b386bf715799faf544410dfa08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given region.  <br /></td></tr>
<tr class="separator:a575e2b386bf715799faf544410dfa08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18fba481052279875291df667870579" id="r_aa18fba481052279875291df667870579"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18fba481052279875291df667870579">SatRegion</a> (<a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aa18fba481052279875291df667870579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given region into this new region.  <br /></td></tr>
<tr class="separator:aa18fba481052279875291df667870579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa559e0a732acce49a3ce77cd77e0df8" id="r_afa559e0a732acce49a3ce77cd77e0df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa559e0a732acce49a3ce77cd77e0df8">operator=</a> (const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;src)</td></tr>
<tr class="memdesc:afa559e0a732acce49a3ce77cd77e0df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given region.  <br /></td></tr>
<tr class="separator:afa559e0a732acce49a3ce77cd77e0df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989a5cf6774ace0e9d3cf6e157b55c8" id="r_a2989a5cf6774ace0e9d3cf6e157b55c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2989a5cf6774ace0e9d3cf6e157b55c8">operator=</a> (<a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a2989a5cf6774ace0e9d3cf6e157b55c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given region into this region.  <br /></td></tr>
<tr class="separator:a2989a5cf6774ace0e9d3cf6e157b55c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126fabcb11030f0eae27c717984c82de" id="r_a126fabcb11030f0eae27c717984c82de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a126fabcb11030f0eae27c717984c82de">swap</a> (<a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a126fabcb11030f0eae27c717984c82de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given region.  <br /></td></tr>
<tr class="separator:a126fabcb11030f0eae27c717984c82de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4c4f5ee3dfdef6e1d0de12725a2d19" id="r_a1e4c4f5ee3dfdef6e1d0de12725a2d19"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e4c4f5ee3dfdef6e1d0de12725a2d19">countBlocks</a> () const</td></tr>
<tr class="memdesc:a1e4c4f5ee3dfdef6e1d0de12725a2d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of saturated blocks that come together to form this saturated region.  <br /></td></tr>
<tr class="separator:a1e4c4f5ee3dfdef6e1d0de12725a2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255538ba46d95a9b30006a2c3bce74d" id="r_a4255538ba46d95a9b30006a2c3bce74d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4255538ba46d95a9b30006a2c3bce74d">block</a> (size_t which) const</td></tr>
<tr class="memdesc:a4255538ba46d95a9b30006a2c3bce74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the requested saturated block within this region.  <br /></td></tr>
<tr class="separator:a4255538ba46d95a9b30006a2c3bce74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ef8dd460a89b382fc69595f8c9a63d" id="r_a59ef8dd460a89b382fc69595f8c9a63d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59ef8dd460a89b382fc69595f8c9a63d">blockIndex</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *<a class="el" href="#a4255538ba46d95a9b30006a2c3bce74d">block</a>) const</td></tr>
<tr class="memdesc:a59ef8dd460a89b382fc69595f8c9a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the given block within this region.  <br /></td></tr>
<tr class="separator:a59ef8dd460a89b382fc69595f8c9a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734993f78119277480e8fcc82a9defd" id="r_af734993f78119277480e8fcc82a9defd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af734993f78119277480e8fcc82a9defd">countBoundaryAnnuli</a> () const</td></tr>
<tr class="memdesc:af734993f78119277480e8fcc82a9defd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of saturated annuli that together form the boundary components of this region.  <br /></td></tr>
<tr class="separator:af734993f78119277480e8fcc82a9defd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4fcceb646e963b369096c9a108851" id="r_aceb4fcceb646e963b369096c9a108851"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *, size_t, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceb4fcceb646e963b369096c9a108851">boundaryAnnulus</a> (size_t which) const</td></tr>
<tr class="memdesc:aceb4fcceb646e963b369096c9a108851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the requested saturated annulus on the boundary of this region.  <br /></td></tr>
<tr class="separator:aceb4fcceb646e963b369096c9a108851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d1cf944081420c47b3c5389b132120" id="r_ac6d1cf944081420c47b3c5389b132120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d1cf944081420c47b3c5389b132120">operator==</a> (const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;other) const</td></tr>
<tr class="memdesc:ac6d1cf944081420c47b3c5389b132120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object represent the same combinatorial presentation of a saturated region.  <br /></td></tr>
<tr class="separator:ac6d1cf944081420c47b3c5389b132120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e87092117407fb4886baac70d0da6" id="r_a170e87092117407fb4886baac70d0da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a170e87092117407fb4886baac70d0da6">createSFS</a> (bool reflect) const</td></tr>
<tr class="memdesc:a170e87092117407fb4886baac70d0da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the Seifert fibred space represented by this region.  <br /></td></tr>
<tr class="separator:a170e87092117407fb4886baac70d0da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140658983545f956f34dfd7ae276cc70" id="r_a140658983545f956f34dfd7ae276cc70"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a140658983545f956f34dfd7ae276cc70">blockAbbrs</a> (bool tex=false) const</td></tr>
<tr class="memdesc:a140658983545f956f34dfd7ae276cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an abbreviated list of blocks within this region in string format.  <br /></td></tr>
<tr class="separator:a140658983545f956f34dfd7ae276cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d512dd41181f4bb0394281d7623fa" id="r_aa09d512dd41181f4bb0394281d7623fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09d512dd41181f4bb0394281d7623fa">writeBlockAbbrs</a> (std::ostream &amp;out, bool tex=false) const</td></tr>
<tr class="memdesc:aa09d512dd41181f4bb0394281d7623fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated list of blocks within this region to the given output stream.  <br /></td></tr>
<tr class="separator:aa09d512dd41181f4bb0394281d7623fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913963357b5660ea996226a70ce91a0" id="r_a0913963357b5660ea996226a70ce91a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0913963357b5660ea996226a70ce91a0">writeDetail</a> (std::ostream &amp;out, const std::string &amp;title) const</td></tr>
<tr class="memdesc:a0913963357b5660ea996226a70ce91a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the composition of this region to the given output stream.  <br /></td></tr>
<tr class="separator:a0913963357b5660ea996226a70ce91a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a1ced4a7a188ecc761e6f12f068cf" id="r_a556a1ced4a7a188ecc761e6f12f068cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556a1ced4a7a188ecc761e6f12f068cf">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a556a1ced4a7a188ecc761e6f12f068cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a556a1ced4a7a188ecc761e6f12f068cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad76b1305eb7d9115e0aac71432b983" id="r_a0ad76b1305eb7d9115e0aac71432b983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ad76b1305eb7d9115e0aac71432b983">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a0ad76b1305eb7d9115e0aac71432b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a0ad76b1305eb7d9115e0aac71432b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a66bab1cf32794ee382e0b1e02feffeb5" id="r_a66bab1cf32794ee382e0b1e02feffeb5"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a66bab1cf32794ee382e0b1e02feffeb5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66bab1cf32794ee382e0b1e02feffeb5">find</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, bool mustBeComplete, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a66bab1cf32794ee382e0b1e02feffeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a search for every isomorphic embedding of every starter block from the global SatBlockStarterSet within the given triangulation.  <br /></td></tr>
<tr class="separator:a66bab1cf32794ee382e0b1e02feffeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c815a51f3020812c3f1f0eabf30fd" id="r_a4f9c815a51f3020812c3f1f0eabf30fd"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f9c815a51f3020812c3f1f0eabf30fd">beginsRegion</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;annulus, <a class="el" href="classregina_1_1SatBlock.html#a1f6a621c1f4970f8968c4d7aee186274">SatBlock::TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:a4f9c815a51f3020812c3f1f0eabf30fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is in fact a boundary annulus for a saturated region.  <br /></td></tr>
<tr class="separator:a4f9c815a51f3020812c3f1f0eabf30fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A large saturated region in a Seifert fibred space formed by joining together saturated blocks. </p>
<p>Like a saturated block (described in the class <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a>), a saturated region is a connected set of tetrahedra built from a subset of fibres. Unlike a saturated block however, a saturated region has no constraints on its boundary - it may have several boundary components or it may have none. For instance, a saturated region might be an entire closed Seifert fibred space, or it might describe a Seifert fibred component of a JSJ decomposition.</p>
<p>A saturated region is formed from a collection of saturated blocks by joining the boundary annuli of these blocks together in pairs. The joins must be made so that the fibres are consistent, though it is allowable to reverse the directions of the fibres. There is no problem with joining two boundary annuli from the same block to each other.</p>
<p>Any boundary annulus of a block that is not joined to some other boundary annulus of a block becomes a boundary annulus of the entire region. In this way, each boundary component of the region (if there are any at all) is formed from a ring of boundary annuli, in the same way that the boundary of a block is. Note that the routine <a class="el" href="classregina_1_1SatBlock.html#a6de3ed22be2495ce0c08e46eb4f9632c" title="Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part ...">SatBlock::nextBoundaryAnnulus()</a> can be used to trace around a region boundary. Like block boundaries, the boundary of a saturated region need not be part of the boundary of the larger triangulation (i.e., there may be adjacent tetrahedra that are not recognised as part of this saturated structure).</p>
<p>The <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> class stores a list of its constituent blocks, but it does not directly store which block boundary annuli are joined to which. This adjacency information is stored within the blocks themselves; see the notes regarding adjacency in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class description.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. Note, however, that the only way to create objects of this class (aside from copying or moving) is via the static search functions, such as <a class="el" href="#a66bab1cf32794ee382e0b1e02feffeb5" title="Runs a search for every isomorphic embedding of every starter block from the global SatBlockStarterSe...">find()</a> or <a class="el" href="#a4f9c815a51f3020812c3f1f0eabf30fd" title="Determines whether the given annulus is in fact a boundary annulus for a saturated region.">beginsRegion()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is crucial that the adjacency information stored in the blocks is consistent with the region containing them. All this requires is that the blocks are not manipulated externally (e.g., SatBlock::setAdjacent() is not called on any of the blocks), but instead all adjacency information is managed by this class.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo</a></b></dt><dd><em>Feature:</em> Have this class track the boundary components properly, with annuli grouped and oriented according to the region boundaries (as opposed to individual block boundaries).</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a575e2b386bf715799faf544410dfa08e" name="a575e2b386bf715799faf544410dfa08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575e2b386bf715799faf544410dfa08e">&#9670;&#160;</a></span>SatRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatRegion::SatRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the region to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa18fba481052279875291df667870579" name="aa18fba481052279875291df667870579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18fba481052279875291df667870579">&#9670;&#160;</a></span>SatRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatRegion::SatRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given region into this new region. </p>
<p>This is a fast (constant time) operation.</p>
<p>The region that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f9c815a51f3020812c3f1f0eabf30fd" name="a4f9c815a51f3020812c3f1f0eabf30fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9c815a51f3020812c3f1f0eabf30fd">&#9670;&#160;</a></span>beginsRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &gt; regina::SatRegion::beginsRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>annulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html#a1f6a621c1f4970f8968c4d7aee186274">SatBlock::TetList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>avoidTets</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is in fact a boundary annulus for a saturated region. </p>
<p>The annulus should be represented from the inside of the proposed saturated region.</p>
<p>All tetrahedra in the given list <em>avoidTets</em> will be ignored by this routine, and so if a region is found then it is guaranteed not to include any of them. As a consequence, if the given annulus uses any of these tetrahedra then <code>null</code> will be returned.</p>
<p>If a region is found, it will be expanded as far as possible, and all of the tetrahedra within it will be added to the list <em>avoidTets</em>. Moreover, it is guaranteed that the given annulus will be listed as annulus number 0 in the block that contains it, without any horizontal or vertical reflection.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either the given annulus lies on the boundary of the triangulation, or else the (one or two) tetrahedra attached to the other side of it are already in the list <em>avoidTets</em>. This is necessary to ensure that the saturated region does not expand through the annulus to the other side.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated region. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated region if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="a4255538ba46d95a9b30006a2c3bce74d" name="a4255538ba46d95a9b30006a2c3bce74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255538ba46d95a9b30006a2c3bce74d">&#9670;&#160;</a></span>block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp; regina::SatRegion::block </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the requested saturated block within this region. </p>
<p>The information will returned will include structural information for the block, along with details of how the block is aligned (e.g., reflected vertically or horizontally) within the larger region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the constituent blocks should be returned; this must be between 0 and <a class="el" href="#a1e4c4f5ee3dfdef6e1d0de12725a2d19" title="Returns the number of saturated blocks that come together to form this saturated region.">countBlocks()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested saturated block. </dd></dl>

</div>
</div>
<a id="a140658983545f956f34dfd7ae276cc70" name="a140658983545f956f34dfd7ae276cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140658983545f956f34dfd7ae276cc70">&#9670;&#160;</a></span>blockAbbrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SatRegion::blockAbbrs </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an abbreviated list of blocks within this region in string format. </p>
<p>The string that is returned will consist of the abbreviated names of all blocks in this region, separated by commas and spaces. See <a class="el" href="classregina_1_1SatBlock.html#a7192ac0dfb2fd6c156ab9aa48d2c9570" title="Returns an abbreviated name or symbol for this block.">SatBlock::abbr()</a> for further details.</p>
<p>The blocks within this region will be sorted before their abbreviated names are output. The particular method of sorting is an arbitrary aesthetic decision on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the abbreviated list of all blocks. </dd></dl>

</div>
</div>
<a id="a59ef8dd460a89b382fc69595f8c9a63d" name="a59ef8dd460a89b382fc69595f8c9a63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ef8dd460a89b382fc69595f8c9a63d">&#9670;&#160;</a></span>blockIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SatRegion::blockIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the given block within this region. </p>
<p>This index corresponds to the integer parameter that is passed to the routine <a class="el" href="#a4255538ba46d95a9b30006a2c3bce74d" title="Returns details of the requested saturated block within this region.">block()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, since it simply scans through the blocks in this region one by one until the given block is found (or until all blocks are exhausted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given block (as an integer between 0 and <a class="el" href="#a1e4c4f5ee3dfdef6e1d0de12725a2d19" title="Returns the number of saturated blocks that come together to form this saturated region.">countBlocks()</a>-1 inclusive), or -1 if the block is not part of this region. </dd></dl>

</div>
</div>
<a id="aceb4fcceb646e963b369096c9a108851" name="aceb4fcceb646e963b369096c9a108851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb4fcceb646e963b369096c9a108851">&#9670;&#160;</a></span>boundaryAnnulus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *, size_t, bool, bool &gt; regina::SatRegion::boundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns details of the requested saturated annulus on the boundary of this region. </p>
<p>The saturated annuli that together form the boundary components of this region are numbered from 0 to <a class="el" href="#af734993f78119277480e8fcc82a9defd" title="Returns the number of saturated annuli that together form the boundary components of this region.">countBoundaryAnnuli()</a>-1 inclusive. The argument <em>which</em> specifies which one of these annuli should be returned.</p>
<p>Currently the annuli are numbered lexicographically by block and then by annulus number within the block, although this ordering is subject to change in future versions of Regina. In particular, the annuli are <em>not</em> necessarily numbered in order around the region boundaries, and each region boundary component might not even be given a consecutive range of numbers.</p>
<p>It is guaranteed however that, if the starter block passed to the <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> constructor provides any boundary annuli for the overall region, then the first such annulus in the starter block will be numbered 0 here.</p>
<p>Be aware that the block containing the requested annulus might be reflected horizontally and/or vertically within the overall region, as discussed in the <a class="el" href="classregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> class notes. This will affect how the annulus is positioned as part of the overall region boundary (e.g., the annulus might be positioned upside-down in the overall region boundary, or it might be positioned with its second triangle appearing before its first triangle as one walks around the boundary). To account for this, the return value will include two booleans <em>refVert</em> and <em>refHoriz</em> to indicate if and how the block is reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is quite slow, since it currently scans through every annulus of every saturated block. Use it sparingly!</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The argument <em>which</em> was not between 0 and <a class="el" href="#af734993f78119277480e8fcc82a9defd" title="Returns the number of saturated annuli that together form the boundary components of this region.">countBoundaryAnnuli()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which boundary annulus of this region to return; this must be between 0 and <a class="el" href="#af734993f78119277480e8fcc82a9defd" title="Returns the number of saturated annuli that together form the boundary components of this region.">countBoundaryAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple (<em>block</em>, annulus, refVert, refHoriz), where: <em>block</em> is a pointer to the the particular saturated block containing the requested annulus; <em>annulus</em> indicates which annulus number in the returned block is the requested annulus, as an integer between 0 and block-&gt;countAnnuli()-1 inclusive; <em>refVert</em> is <code>true</code> if and only if the block containing the requested annulus is vertically reflected within this region; and <em>refHoriz</em> is <code>true</code> if and only if the block containing the requested annulus is horizontally reflected within this region. See <a class="el" href="classregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for further details on these reflections. </dd></dl>

</div>
</div>
<a id="a1e4c4f5ee3dfdef6e1d0de12725a2d19" name="a1e4c4f5ee3dfdef6e1d0de12725a2d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4c4f5ee3dfdef6e1d0de12725a2d19">&#9670;&#160;</a></span>countBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SatRegion::countBlocks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of saturated blocks that come together to form this saturated region. </p>
<dl class="section return"><dt>Returns</dt><dd>the total number of blocks. </dd></dl>

</div>
</div>
<a id="af734993f78119277480e8fcc82a9defd" name="af734993f78119277480e8fcc82a9defd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af734993f78119277480e8fcc82a9defd">&#9670;&#160;</a></span>countBoundaryAnnuli()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SatRegion::countBoundaryAnnuli </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of saturated annuli that together form the boundary components of this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a id="a170e87092117407fb4886baac70d0da6" name="a170e87092117407fb4886baac70d0da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170e87092117407fb4886baac70d0da6">&#9670;&#160;</a></span>createSFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> regina::SatRegion::createSFS </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reflect</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns details of the Seifert fibred space represented by this region. </p>
<p>Each boundary component of this region will be formed from a ring of saturated annuli, which together form a torus or a Klein bottle. For torus boundary components, the oriented curves representing the fibres and base orbifold on the boundary (see <a class="el" href="sfsnotation.html">Notation for Seifert fibred spaces</a>) will be as follows.</p>
<ul>
<li>Consider the 0/1/2 markings on the first and second triangles of each saturated annulus, as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes.</li>
<li>The fibres are represented by the oriented edge joining markings 1 and 0 on the first triangle (or 0 and 1 on the second triangle). This is reversed if the block containing the boundary annulus is vertically reflected.</li>
<li>The curve representing the base orbifold run along the oriented edge joining markings 0 and 2 on the first triangle (or 2 and 0 on the second triangle). This is reversed if the block containing the boundary annulus is horizontally reflected.</li>
<li>See the <a class="el" href="classregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> overview for descriptions of horizontal and vertical reflection.</li>
</ul>
<p>If the argument <em>reflect</em> is <code>true</code>, the Seifert fibred space will be created as though the entire region had been reflected. In particular, each twist or exceptional fibre will be negated before being added to the Seifert structure.</p>
<p>For Klein bottle boundary components, these curves must (for now) be analysed by hand.</p>
<p>There are situations in which Regina is not (yet) capable of determining the Seifert fibred space precisely. This can only happen if the Seifert fibred space is closed, non-orientable, belongs to the class <code>n3</code> or <code>n4</code>, and has sufficiently large base orbifold genus. In such situations this routine will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This is one of the closed non-orientable cases where Regina cannot distinguish between classes <code>n3</code> and <code>n4</code>, as described above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflect</td><td><code>true</code> if this region is to be reflected as the Seifert fibred space is created, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the structure of the underlying Seifert fibred space. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a66bab1cf32794ee382e0b1e02feffeb5" name="a66bab1cf32794ee382e0b1e02feffeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bab1cf32794ee382e0b1e02feffeb5">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatRegion::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mustBeComplete</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a search for every isomorphic embedding of every starter block from the global SatBlockStarterSet within the given triangulation. </p>
<p>Each time an embedding of a starter block is discovered, the block will be wrapped in a new <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> which describes how the block appears within the given triangulation. The region will be expanded to encompass as many saturated blocks as possible, and then passed to <em>action</em>, which must be a function or some other callable object.</p>
<ul>
<li>The first argument to <em>action</em> must be of type std::unique_ptr&lt;SatRegion&gt;; this will be the newly constructed and expanded region that contains the starter block that was found. As expected from std::unique_ptr, this function will have relinquished all ownership of the region, and your action can do what it likes with it.</li>
<li>The second argument to <em>action</em> must be of type <a class="el" href="classregina_1_1SatBlock.html#a1f6a621c1f4970f8968c4d7aee186274" title="The data structure used to store a list of tetrahedra that should not be examined when searching for ...">SatBlock::TetList</a>&amp;. This list will contain all tetrahedra currently used by the region, and <em>action</em> is welcome to modify the list as it pleases. This function will clear and reuse the list after <em>action</em> returns.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that the search for starter blocks should continue, and a return value of <code>true</code> indicates that the search should terminate immediately.</li>
</ul>
<p>Note that different embeddings of the same starter block within <em>tri</em> will result in the action being called multiple times (with different containing regions).</p>
<p>If you are searching for a region that fills an entire triangulation component (i.e., every boundary annulus of the region in fact forms part of the boundary of the triangulation), then you should pass <em>mustBeComplete</em> as <code>true</code>. If a region expansion does not fill the entire component, then it will be discarded and <em>action</em> will not be called for that particular embeddeding of that particular starter block.</p>
<dl class="section user"><dt>Headers</dt><dd>The implementation of this template function is contained in a separate header (satregion-impl.h), which is not included automatically by this file. If you wish to use this function in your own code, you will need to include satregion-impl.h.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> must take only one argument: the newly constructed <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> (i.e., the first argument in the description above). The <a class="el" href="classregina_1_1SatBlock.html#a1f6a621c1f4970f8968c4d7aee186274" title="The data structure used to store a list of tetrahedra that should not be examined when searching for ...">SatBlock::TetList</a>&amp; argument will <em>not</em> be passed, and there can be no additional argument list <em>args</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which to search for starter blocks. </td></tr>
    <tr><td class="paramname">mustBeComplete</td><td><code>true</code> if you are searching for a region that fills an entire triangulation component, as described above. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each embedding of a starter block that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial region and tetrahedron list arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="afa559e0a732acce49a3ce77cd77e0df8" name="afa559e0a732acce49a3ce77cd77e0df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa559e0a732acce49a3ce77cd77e0df8">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::SatRegion::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the region to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this region. </dd></dl>

</div>
</div>
<a id="a2989a5cf6774ace0e9d3cf6e157b55c8" name="a2989a5cf6774ace0e9d3cf6e157b55c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989a5cf6774ace0e9d3cf6e157b55c8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::SatRegion::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given region into this region. </p>
<p>This is a fast (constant time) operation.</p>
<p>The region that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this region. </dd></dl>

</div>
</div>
<a id="ac6d1cf944081420c47b3c5389b132120" name="ac6d1cf944081420c47b3c5389b132120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d1cf944081420c47b3c5389b132120">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatRegion::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object represent the same combinatorial presentation of a saturated region. </p>
<p>Specifically, in order to compare as equal, two saturated regions must be formed from saturated blocks with the same combinatorial parameters (as returned by the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> comparison operators), and these blocks must be presented in the same order with the same horizontal/vertical reflections and joined together in the same way.</p>
<p>Like the comparison operators for most parameterised subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>, it does not matter how the constituent tetrahedra and/or their vertices are numbered. However, this test is more specific than combinatorial isomorphism of the underlying subcomplex of the triangulation, since it does not account for the many symmetries in how the same saturated region can be presented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the saturated region to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object represent the same combinatorial presentation of a saturated region. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a126fabcb11030f0eae27c717984c82de" name="a126fabcb11030f0eae27c717984c82de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126fabcb11030f0eae27c717984c82de">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the region whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa09d512dd41181f4bb0394281d7623fa" name="aa09d512dd41181f4bb0394281d7623fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09d512dd41181f4bb0394281d7623fa">&#9670;&#160;</a></span>writeBlockAbbrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeBlockAbbrs </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an abbreviated list of blocks within this region to the given output stream. </p>
<p>Blocks will be written using their abbreviated names, and these names will be separated by commas and spaces. See <a class="el" href="classregina_1_1SatBlock.html#ab81d8335c3999dfea5665b9d2b21134f" title="Writes an abbreviated name or symbol for this block to the given output stream.">SatBlock::writeAbbr()</a> for further details.</p>
<p>The blocks within this region will be sorted before their abbreviated names are output. The particular method of sorting is an arbitrary aesthetic decision on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a140658983545f956f34dfd7ae276cc70" title="Returns an abbreviated list of blocks within this region in string format.">blockAbbrs()</a> that returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0913963357b5660ea996226a70ce91a0" name="a0913963357b5660ea996226a70ce91a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0913963357b5660ea996226a70ce91a0">&#9670;&#160;</a></span>writeDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeDetail </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes details of the composition of this region to the given output stream. </p>
<p>The output will consist of several lines. The first line will contain the title string (passed as a separate argument to this routine), followed by a colon. Following this will be a number of lines describing the individual blocks that make up this region and the various adjacencies between them.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use detail(), which returns the same detailed information in string form (but without the option of using a custom title).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">title</td><td>the name of this region, to be written on the first line of output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ad76b1305eb7d9115e0aac71432b983" name="a0ad76b1305eb7d9115e0aac71432b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad76b1305eb7d9115e0aac71432b983">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a556a1ced4a7a188ecc761e6f12f068cf" name="a556a1ced4a7a188ecc761e6f12f068cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556a1ced4a7a188ecc761e6f12f068cf">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="satregion_8h.html">satregion.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
