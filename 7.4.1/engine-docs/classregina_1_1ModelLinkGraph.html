<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::ModelLinkGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1ModelLinkGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::ModelLinkGraph Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;link/modellinkgraph.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::ModelLinkGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1ModelLinkGraph.png" usemap="#regina::ModelLinkGraph_map" alt=""/>
  <map id="regina::ModelLinkGraph_map" name="regina::ModelLinkGraph_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; ModelLinkGraph &gt;" shape="rect" coords="0,0,258,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; ModelLinkGraph &gt;" shape="rect" coords="268,0,526,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe9bd8331a5d5de03e0ce35c0ee669a0" id="r_abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe9bd8331a5d5de03e0ce35c0ee669a0">ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty graph.  <br /></td></tr>
<tr class="separator:abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfbf94e1751c9f17efb659cf1b7328e" id="r_a2dfbf94e1751c9f17efb659cf1b7328e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dfbf94e1751c9f17efb659cf1b7328e">ModelLinkGraph</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link)</td></tr>
<tr class="memdesc:a2dfbf94e1751c9f17efb659cf1b7328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the graph that models the given link.  <br /></td></tr>
<tr class="separator:a2dfbf94e1751c9f17efb659cf1b7328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8824307f9623abdf194742ad462890" id="r_a9a8824307f9623abdf194742ad462890"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8824307f9623abdf194742ad462890">ModelLinkGraph</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;copy)</td></tr>
<tr class="memdesc:a9a8824307f9623abdf194742ad462890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given graph.  <br /></td></tr>
<tr class="separator:a9a8824307f9623abdf194742ad462890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ca6920f24e108cf28c0965de1e2e1" id="r_abd4ca6920f24e108cf28c0965de1e2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4ca6920f24e108cf28c0965de1e2e1">ModelLinkGraph</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:abd4ca6920f24e108cf28c0965de1e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given graph into this new graph.  <br /></td></tr>
<tr class="separator:abd4ca6920f24e108cf28c0965de1e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2af9ed4c9bfc002fe2dd533d9e6013b" id="r_ac2af9ed4c9bfc002fe2dd533d9e6013b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2af9ed4c9bfc002fe2dd533d9e6013b">ModelLinkGraph</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:ac2af9ed4c9bfc002fe2dd533d9e6013b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a 4-valent graph with embedding.  <br /></td></tr>
<tr class="separator:ac2af9ed4c9bfc002fe2dd533d9e6013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a6e5615cb448d21f99332ba6ffcbe1" id="r_ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a6e5615cb448d21f99332ba6ffcbe1">~ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this graph.  <br /></td></tr>
<tr class="separator:ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae830ab12408759e526ae15d16e0be5" id="r_a8ae830ab12408759e526ae15d16e0be5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ae830ab12408759e526ae15d16e0be5">size</a> () const</td></tr>
<tr class="memdesc:a8ae830ab12408759e526ae15d16e0be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in this graph.  <br /></td></tr>
<tr class="separator:a8ae830ab12408759e526ae15d16e0be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048a87ceec2ad22663abef7c677f30e" id="r_aa048a87ceec2ad22663abef7c677f30e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa048a87ceec2ad22663abef7c677f30e">isEmpty</a> () const</td></tr>
<tr class="memdesc:aa048a87ceec2ad22663abef7c677f30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this graph is empty.  <br /></td></tr>
<tr class="separator:aa048a87ceec2ad22663abef7c677f30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa78efffd47a0d6d277302008ed4d4b" id="r_a4aa78efffd47a0d6d277302008ed4d4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aa78efffd47a0d6d277302008ed4d4b">countComponents</a> () const</td></tr>
<tr class="memdesc:a4aa78efffd47a0d6d277302008ed4d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in this graph.  <br /></td></tr>
<tr class="separator:a4aa78efffd47a0d6d277302008ed4d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b23da2671ddcac75622018eed0b27c" id="r_ae2b23da2671ddcac75622018eed0b27c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2b23da2671ddcac75622018eed0b27c">countTraversals</a> () const</td></tr>
<tr class="memdesc:ae2b23da2671ddcac75622018eed0b27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of traversals in this graph.  <br /></td></tr>
<tr class="separator:ae2b23da2671ddcac75622018eed0b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32048d7c0d574234df71c03cf8afcb33" id="r_a32048d7c0d574234df71c03cf8afcb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32048d7c0d574234df71c03cf8afcb33">node</a> (size_t index) const</td></tr>
<tr class="memdesc:a32048d7c0d574234df71c03cf8afcb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node at the given index within this graph.  <br /></td></tr>
<tr class="separator:a32048d7c0d574234df71c03cf8afcb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6491eff8e0ab206c0d750bc7bed6abd1" id="r_a6491eff8e0ab206c0d750bc7bed6abd1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6491eff8e0ab206c0d750bc7bed6abd1">nodes</a> () const</td></tr>
<tr class="memdesc:a6491eff8e0ab206c0d750bc7bed6abd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all nodes in this graph.  <br /></td></tr>
<tr class="separator:a6491eff8e0ab206c0d750bc7bed6abd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc89ae4b81f1415856e3812e48f8dd" id="r_a8cdc89ae4b81f1415856e3812e48f8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cdc89ae4b81f1415856e3812e48f8dd">operator=</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;src)</td></tr>
<tr class="memdesc:a8cdc89ae4b81f1415856e3812e48f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given graph.  <br /></td></tr>
<tr class="separator:a8cdc89ae4b81f1415856e3812e48f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec906b2e6ce954c638dfe21c4b3d49bc" id="r_aec906b2e6ce954c638dfe21c4b3d49bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec906b2e6ce954c638dfe21c4b3d49bc">operator=</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aec906b2e6ce954c638dfe21c4b3d49bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given graph into this graph.  <br /></td></tr>
<tr class="separator:aec906b2e6ce954c638dfe21c4b3d49bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28801826ec5d301697db8576eded1f10" id="r_a28801826ec5d301697db8576eded1f10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28801826ec5d301697db8576eded1f10">swap</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a28801826ec5d301697db8576eded1f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given graph.  <br /></td></tr>
<tr class="separator:a28801826ec5d301697db8576eded1f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fce4c3cf6c90a2a8ff2e4823a9b8cb" id="r_af8fce4c3cf6c90a2a8ff2e4823a9b8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8fce4c3cf6c90a2a8ff2e4823a9b8cb">insertGraph</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;source)</td></tr>
<tr class="memdesc:af8fce4c3cf6c90a2a8ff2e4823a9b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given graph into this graph.  <br /></td></tr>
<tr class="separator:af8fce4c3cf6c90a2a8ff2e4823a9b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf3b183759686c8acf0329e6fb6692e" id="r_a1cf3b183759686c8acf0329e6fb6692e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cf3b183759686c8acf0329e6fb6692e">insertGraph</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:a1cf3b183759686c8acf0329e6fb6692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given graph into this graph.  <br /></td></tr>
<tr class="separator:a1cf3b183759686c8acf0329e6fb6692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48404aa3bc1c6061d968cc7526b5ad9" id="r_ab48404aa3bc1c6061d968cc7526b5ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab48404aa3bc1c6061d968cc7526b5ad9">moveContentsTo</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;dest)</td></tr>
<tr class="memdesc:ab48404aa3bc1c6061d968cc7526b5ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this graph into the given destination graph, leaving this graph empty but otherwise usable.  <br /></td></tr>
<tr class="separator:ab48404aa3bc1c6061d968cc7526b5ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2238ea1d3a224c1737ec6c66bdfd5d5" id="r_ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2238ea1d3a224c1737ec6c66bdfd5d5">operator==</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other) const</td></tr>
<tr class="memdesc:ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this graph is combinatorially identical to the given graph.  <br /></td></tr>
<tr class="separator:ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89a103eeda5359e83684d10b5f3444d" id="r_ad89a103eeda5359e83684d10b5f3444d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad89a103eeda5359e83684d10b5f3444d">reflect</a> ()</td></tr>
<tr class="memdesc:ad89a103eeda5359e83684d10b5f3444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this graph into its reflection.  <br /></td></tr>
<tr class="separator:ad89a103eeda5359e83684d10b5f3444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b314d226abfebfe9ba4ed26bfaf6b23" id="r_a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b314d226abfebfe9ba4ed26bfaf6b23">cells</a> () const</td></tr>
<tr class="memdesc:a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cellular decomposition of the closed orientable surface in which this graph embeds.  <br /></td></tr>
<tr class="separator:a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2545252542893d425c305061876822c4" id="r_a2545252542893d425c305061876822c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2545252542893d425c305061876822c4">isConnected</a> () const</td></tr>
<tr class="memdesc:a2545252542893d425c305061876822c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether this graph is connected.  <br /></td></tr>
<tr class="separator:a2545252542893d425c305061876822c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ad50b1ba35adf33bd0052712a69318" id="r_a39ad50b1ba35adf33bd0052712a69318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ad50b1ba35adf33bd0052712a69318">isSimple</a> () const</td></tr>
<tr class="memdesc:a39ad50b1ba35adf33bd0052712a69318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether this graph is simple; that is, has no loops or multiple edges.  <br /></td></tr>
<tr class="separator:a39ad50b1ba35adf33bd0052712a69318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a94d5ab9a2ffac8245dbdb52097cac7" id="r_a0a94d5ab9a2ffac8245dbdb52097cac7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a94d5ab9a2ffac8245dbdb52097cac7">genus</a> () const</td></tr>
<tr class="memdesc:a0a94d5ab9a2ffac8245dbdb52097cac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the genus of the closed orientable surface in which this graph embeds.  <br /></td></tr>
<tr class="separator:a0a94d5ab9a2ffac8245dbdb52097cac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cd0091a0f179ac81be4c981b97b458" id="r_ae3cd0091a0f179ac81be4c981b97b458"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3cd0091a0f179ac81be4c981b97b458">findFlype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:ae3cd0091a0f179ac81be4c981b97b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the smallest flype that can be performed on this graph from the given starting location.  <br /></td></tr>
<tr class="separator:ae3cd0091a0f179ac81be4c981b97b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae854058768363de2cc893d24c20ea" id="r_a2eae854058768363de2cc893d24c20ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eae854058768363de2cc893d24c20ea">flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;left, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;right) const</td></tr>
<tr class="memdesc:a2eae854058768363de2cc893d24c20ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a flype on this graph at the given location.  <br /></td></tr>
<tr class="separator:a2eae854058768363de2cc893d24c20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac565266fea843b1ee7d9f344eddf0c4b" id="r_ac565266fea843b1ee7d9f344eddf0c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac565266fea843b1ee7d9f344eddf0c4b">flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:ac565266fea843b1ee7d9f344eddf0c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the smallest possible flype on this graph from the given starting location.  <br /></td></tr>
<tr class="separator:ac565266fea843b1ee7d9f344eddf0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e89dfdbc8ce49dce922f672275566" id="r_aa71e89dfdbc8ce49dce922f672275566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71e89dfdbc8ce49dce922f672275566">generateAnyLink</a> () const</td></tr>
<tr class="memdesc:aa71e89dfdbc8ce49dce922f672275566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an arbitrary link diagram that is modelled by this graph.  <br /></td></tr>
<tr class="separator:aa71e89dfdbc8ce49dce922f672275566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eebfc992fb1fb0e11a5ba620d88db0a" id="r_a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7eebfc992fb1fb0e11a5ba620d88db0a">generateMinimalLinks</a> (Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exhaustively generates potentially-minimal link diagrams that are modelled by this graph.  <br /></td></tr>
<tr class="separator:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365f250111716159b0b93c995ac7572f" id="r_a365f250111716159b0b93c995ac7572f"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a365f250111716159b0b93c995ac7572f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a365f250111716159b0b93c995ac7572f">generateAllLinks</a> (Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a365f250111716159b0b93c995ac7572f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exhaustively generates all link diagrams that are modelled by this graph, up to reversal of individual link components.  <br /></td></tr>
<tr class="separator:a365f250111716159b0b93c995ac7572f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911f466ef4000bc3c4e39cd614b9f3a3" id="r_a911f466ef4000bc3c4e39cd614b9f3a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a911f466ef4000bc3c4e39cd614b9f3a3">canonical</a> (bool allowReflection=true) const</td></tr>
<tr class="memdesc:a911f466ef4000bc3c4e39cd614b9f3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical relabelling of this graph.  <br /></td></tr>
<tr class="separator:a911f466ef4000bc3c4e39cd614b9f3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf57c2c0c301ac98f9220b596b7405" id="r_ad7bf57c2c0c301ac98f9220b596b7405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7bf57c2c0c301ac98f9220b596b7405">randomise</a> ()</td></tr>
<tr class="memdesc:ad7bf57c2c0c301ac98f9220b596b7405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly relabels this graph in an orientation-preserving manner.  <br /></td></tr>
<tr class="separator:ad7bf57c2c0c301ac98f9220b596b7405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b794563bcc89728bf2dab6f6952a5c5" id="r_a3b794563bcc89728bf2dab6f6952a5c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5">plantri</a> () const</td></tr>
<tr class="memdesc:a3b794563bcc89728bf2dab6f6952a5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this graph in a variant of the ASCII text format used by <em>plantri</em>.  <br /></td></tr>
<tr class="separator:a3b794563bcc89728bf2dab6f6952a5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad551e61efb56e41d63d6fb4d454c56fb" id="r_ad551e61efb56e41d63d6fb4d454c56fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb">canonicalPlantri</a> (bool allowReflection=true, bool tight=false) const</td></tr>
<tr class="memdesc:ad551e61efb56e41d63d6fb4d454c56fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text representation of this graph in a variant of the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression.  <br /></td></tr>
<tr class="separator:ad551e61efb56e41d63d6fb4d454c56fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e558636cf8c2cd8beab3f6a2df054a" id="r_ad8e558636cf8c2cd8beab3f6a2df054a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a">extendedPlantri</a> () const</td></tr>
<tr class="memdesc:ad8e558636cf8c2cd8beab3f6a2df054a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this graph using Regina's extended variant of the <em>plantri</em> text format, which is better suited for non-planar graphs.  <br /></td></tr>
<tr class="separator:ad8e558636cf8c2cd8beab3f6a2df054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae243881e366ab1b18294363708b5b4d3" id="r_ae243881e366ab1b18294363708b5b4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae243881e366ab1b18294363708b5b4d3">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ae243881e366ab1b18294363708b5b4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this graph to the given output stream.  <br /></td></tr>
<tr class="separator:ae243881e366ab1b18294363708b5b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4b88c8eb92b6c9abe6f557c3221486" id="r_aab4b88c8eb92b6c9abe6f557c3221486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab4b88c8eb92b6c9abe6f557c3221486">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aab4b88c8eb92b6c9abe6f557c3221486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this graph to the given output stream.  <br /></td></tr>
<tr class="separator:aab4b88c8eb92b6c9abe6f557c3221486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89355292f9354c4d8bfc7d5468ee26f5" id="r_a89355292f9354c4d8bfc7d5468ee26f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89355292f9354c4d8bfc7d5468ee26f5">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a89355292f9354c4d8bfc7d5468ee26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this graph to the given output stream.  <br /></td></tr>
<tr class="separator:a89355292f9354c4d8bfc7d5468ee26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51197dbd112bb60b7893cc51a09003" id="r_a2c51197dbd112bb60b7893cc51a09003"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a2c51197dbd112bb60b7893cc51a09003">hash</a> () const</td></tr>
<tr class="memdesc:a2c51197dbd112bb60b7893cc51a09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:a2c51197dbd112bb60b7893cc51a09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e6323f9f0617daa1b538b266420c204" id="r_a3e6323f9f0617daa1b538b266420c204"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a3e6323f9f0617daa1b538b266420c204"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e6323f9f0617daa1b538b266420c204">generateAllEmbeddings</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;pairing, bool allowReflection, <a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__link.html#gababe6c5698577c7d7d2b32df7efd996d">GraphConstraint</a> &gt; constraints, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3e6323f9f0617daa1b538b266420c204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible local embeddings of the given 4-valent graph into some closed orientable surface.  <br /></td></tr>
<tr class="separator:a3e6323f9f0617daa1b538b266420c204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806a72e571ad5c1f2c3e8c79bdbf7af1" id="r_a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1">fromPlantri</a> (const std::string &amp;<a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5">plantri</a>)</td></tr>
<tr class="memdesc:a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a graph from a line of <em>plantri</em> output, using Regina's variant of the <em>plantri</em> ASCII format.  <br /></td></tr>
<tr class="separator:a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029894928ded381ae679c9a08f4e26d" id="r_a2029894928ded381ae679c9a08f4e26d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2029894928ded381ae679c9a08f4e26d">fromExtendedPlantri</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:a2029894928ded381ae679c9a08f4e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a graph from a text representation using Regina's extended variant of the <em>plantri</em> format, which is better suited for non-planar graphs.  <br /></td></tr>
<tr class="separator:a2029894928ded381ae679c9a08f4e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb26d0d8723c46c4693d5a2d524c1c4" id="r_a1cb26d0d8723c46c4693d5a2d524c1c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb26d0d8723c46c4693d5a2d524c1c4">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a1cb26d0d8723c46c4693d5a2d524c1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a graph from its given tight encoding.  <br /></td></tr>
<tr class="separator:a1cb26d0d8723c46c4693d5a2d524c1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface. </p>
<p>This class only stores the graph and a local description of the embedding (i.e., a cyclic ordering of arcs around each node). It does not store the surface explicitly, though the surface is implied from the embedding - if you need it you can always access a full description of the surface by calling <a class="el" href="#a4b314d226abfebfe9ba4ed26bfaf6b23" title="Returns the cellular decomposition of the closed orientable surface in which this graph embeds.">cells()</a>.</p>
<p>In particular, the surface is assumed to be the minimal genus surface in which the graph embeds. Each connected component of the graph is embedded in a separate connected component of the surface, and each component of the surface is formed from a collection of discs (or <em>cells</em>) whose boundaries follow the nodes and arcs of the graph according to the local embedding.</p>
<p>Regina uses graphs like these as model graphs for classical or virtual link diagrams, where each node of the graph becomes a classical crossing. If the surface is a collection of 2-spheres, then the graph is planar and models a <em>classical</em> link diagram. If the surface has genus, then the graph is non-planar and instead models a <em>virtual</em> link diagram.</p>
<p>Currently this class does not support circular graph components (which, in a link diagram, would correspond to zero-crossing unknot components of the link).</p>
<p>For Boost users: if you wish to study the underlying graph of an existing link, you do not need to create a <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> - instead you can include link/graph.h and then use <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> directly as a directed graph type with the Boost Graph Library.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe9bd8331a5d5de03e0ce35c0ee669a0" name="abe9bd8331a5d5de03e0ce35c0ee669a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9bd8331a5d5de03e0ce35c0ee669a0">&#9670;&#160;</a></span>ModelLinkGraph() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty graph. </p>

</div>
</div>
<a id="a2dfbf94e1751c9f17efb659cf1b7328e" name="a2dfbf94e1751c9f17efb659cf1b7328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfbf94e1751c9f17efb659cf1b7328e">&#9670;&#160;</a></span>ModelLinkGraph() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>link</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the graph that models the given link. </p>
<p>Any zero-component unknot components of the link will be ignored.</p>
<p>The nodes of this graph will be numbered in the same way as the crossings of <em>link</em>. For each node, arc 0 will represent the outgoing lower strand of the corresponding crossing.</p>
<p>Using this constructor is identical to calling <a class="el" href="classregina_1_1Link.html#a980602d950e89b20aba2ba16ebc86521" title="Returns the 4-valent graph that models this link diagram, along with the local embedding of the graph...">Link::graph()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link that this new graph will model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8824307f9623abdf194742ad462890" name="a9a8824307f9623abdf194742ad462890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8824307f9623abdf194742ad462890">&#9670;&#160;</a></span>ModelLinkGraph() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the graph to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4ca6920f24e108cf28c0965de1e2e1" name="abd4ca6920f24e108cf28c0965de1e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4ca6920f24e108cf28c0965de1e2e1">&#9670;&#160;</a></span>ModelLinkGraph() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given graph into this new graph. </p>
<p>This is a fast (constant time) operation.</p>
<p>All nodes and cells that belong to <em>src</em> will be moved into this graph, and so any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> or <a class="el" href="classregina_1_1ModelLinkGraphCells.html" title="Describes the cellular decomposition of a closed orientable surface induced by a 4-valent graph embed...">ModelLinkGraphCells</a> pointers or references will remain valid.</p>
<p>The graph that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2af9ed4c9bfc002fe2dd533d9e6013b" name="ac2af9ed4c9bfc002fe2dd533d9e6013b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2af9ed4c9bfc002fe2dd533d9e6013b">&#9670;&#160;</a></span>ModelLinkGraph() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>description</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a 4-valent graph with embedding. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>Regina's variants of the <em>plantri</em> format, including the default format as well as the tight and extended variants, as produced by <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a>, <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> and <a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a>.</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Regina could not interpret the given string as representing a graph using any of the supported string types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a 4-valent graph with embedding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9a6e5615cb448d21f99332ba6ffcbe1" name="ac9a6e5615cb448d21f99332ba6ffcbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a6e5615cb448d21f99332ba6ffcbe1">&#9670;&#160;</a></span>~ModelLinkGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::~ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this graph. </p>
<p>The <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> objects contained in this graph will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a911f466ef4000bc3c4e39cd614b9f3a3" name="a911f466ef4000bc3c4e39cd614b9f3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911f466ef4000bc3c4e39cd614b9f3a3">&#9670;&#160;</a></span>canonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::canonical </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReflection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical relabelling of this graph. </p>
<p>Here "relabelling" allows for any combination of:</p>
<ul>
<li>a relabelling of the nodes;</li>
<li>a relabelling of the arcs around each node, whilst preserving the cyclic order;</li>
<li>if <em>allowReflection</em> is <code>true</code>, a reversal of the cyclic order of the arcs around <em>every</em> node (i.e., a reflection of the surface in which the graph embeds).</li>
</ul>
<p>Two graphs are related under such a relabelling if and only if their canonical relabellings are identical.</p>
<p>There is no promise that this will be the same canonical labelling as used by <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a>.</p>
<p>The running time for this routine is quadratic in the size of the graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowReflection</td><td><code>true</code> if we allow reflection of the surface in which the graph embeds; that is, a graph and its reflection should produce the same canonical relabelling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the canonical relabelling of this graph. </dd></dl>

</div>
</div>
<a id="ad551e61efb56e41d63d6fb4d454c56fb" name="ad551e61efb56e41d63d6fb4d454c56fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad551e61efb56e41d63d6fb4d454c56fb">&#9670;&#160;</a></span>canonicalPlantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::canonicalPlantri </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReflection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text representation of this graph in a variant of the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression. </p>
<p>This routine is similar to <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a>, but with two significant differences:</p>
<ul>
<li>This routine uses a canonical relabelling of the graph. Specifically, two graphs will have the same <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> output if and only if they are related under some combination of: (i) relabelling nodes; (ii) relabelling the arcs around each node whilst preserving their cyclic order; and (iii) if <em>allowReflection</em> is <code>true</code>, optionally reversing the cyclic order of the arcs around <em>every</em> node. This corresponds to a homeomorphism between the surfaces in which the graphs embed that maps one graph to the other; the argument <em>allowReflection</em> indicates whether this homeomorphism is allowed to reverse orientation. While this has a similar aim to <a class="el" href="#a911f466ef4000bc3c4e39cd614b9f3a3" title="Returns the canonical relabelling of this graph.">canonical()</a>, there is no promise that both routines will use the same "canonical
  relabelling".</li>
<li>If the argument <em>tight</em> is <code>true</code>, then this routine uses an abbreviated output format. The resulting compression is only trivial (it reduces the length by roughly 40%), but the resulting string is still human-parseable (though with a little more effort required). This compression will simply remove the commas, and for each node it will suppress the destination of the first arc (since this can be deduced from the canonical labelling).</li>
</ul>
<p>Regardless of whether <em>tight</em> is <code>true</code> or <code>false</code>, the resulting string can be parsed by <a class="el" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a> to reconstruct the original graph. Note however that, due to the canonical labelling, the resulting graph might be a relabelling of the original (and might even be a reflection of the original, if <em>allowReflection</em> was passed as <code>true</code>).</p>
<p>See <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> for further details on the ASCII format itself, including how Regina's implementation differs from <em>plantri</em>'s for graphs with more than 26 nodes.</p>
<p>The running time for this routine is quadratic in the size of the graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected. </dd>
<dd>
This graph has between 1 and 52 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the surface in which it embeds; see <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> for a discussion on why this condition is needed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph is empty or has more than 52 nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowReflection</td><td><code>true</code> if a graph and its reflection should be considered the same (i.e., produce the same canonical output), or <code>false</code> if they should be considered different. Of course, if a graph is symmetric under reflection then the graph and its reflection will produce the same canonical output regardless of this parameter. </td></tr>
    <tr><td class="paramname">tight</td><td><code>false</code> if the usual <em>plantri</em> ASCII format should be used (as described by <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>), or <code>true</code> if the abbreviated format should be used as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optionally compressed <em>plantri</em> ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="a4b314d226abfebfe9ba4ed26bfaf6b23" name="a4b314d226abfebfe9ba4ed26bfaf6b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b314d226abfebfe9ba4ed26bfaf6b23">&#9670;&#160;</a></span>cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp; regina::ModelLinkGraph::cells </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cellular decomposition of the closed orientable surface in which this graph embeds. </p>
<p>This will be the decomposition induced by this graph; in particular, it will be formed from discs bounded by the nodes and arcs of this graph.</p>
<p>This cellular decomposition will only be computed on demand. This means that the first call to this function will take linear time (as the decomposition is computed), but subsequent calls will be constant time (since the decomposition is cached).</p>
<p>Note that, as of Regina 7.4, you can call this routine even if the graph is non-planar and/or disconnected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is not thread-safe.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>This graph induces more cells than should ever be possible. This should never occur unless the graph is malformed in some way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the induced cellular decomposition of the surface in which this graph embeds. </dd></dl>

</div>
</div>
<a id="a4aa78efffd47a0d6d277302008ed4d4b" name="a4aa78efffd47a0d6d277302008ed4d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa78efffd47a0d6d277302008ed4d4b">&#9670;&#160;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::countComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of connected components in this graph. </p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is not thread-safe, since it caches the number of components after computing it for the first time.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>These are components in the graph theoretical sense, not link components. So, for example, the graph that models the Hopf link is considered to be connected with just one component.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a id="ae2b23da2671ddcac75622018eed0b27c" name="ae2b23da2671ddcac75622018eed0b27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b23da2671ddcac75622018eed0b27c">&#9670;&#160;</a></span>countTraversals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::countTraversals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of traversals in this graph. </p>
<p>A <em>traversal</em> is a closed path through the graph that always enters and exits a node through opposite arcs. If this graph models a diagram for some link <em>L</em>, then the number of traversals in this graph will be precisely the number of link components in <em>L</em>.</p>
<p>This routine runs in linear time (and the result is not cached).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of traversals. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ad8e558636cf8c2cd8beab3f6a2df054a" name="ad8e558636cf8c2cd8beab3f6a2df054a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e558636cf8c2cd8beab3f6a2df054a">&#9670;&#160;</a></span>extendedPlantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::extendedPlantri </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this graph using Regina's extended variant of the <em>plantri</em> text format, which is better suited for non-planar graphs. </p>
<p>See <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> for a discussion of the <em>plantri</em> text format. A limitation of the <em>plantri</em> format is that it requires the graph to be dual to a <em>simple</em> quadrangulation of the surface in which it embeds. This is a reasonable requirement for planar graphs, but not so for non-planar graphs (which, in particular, are used to model virtual link diagrams).</p>
<p>This routine extends the <em>plantri</em> format to more explicitly encode the embedding of the graph, which means we can remove the problematic requirement on the dual quadrangulation. The format is Regina's own (i.e., it is not compatible with the Brinkmann-McKay <em>plantri</em> software).</p>
<p>The output will be a comma-separated sequence of alphanumeric strings. The <em>i</em>th such string will consist of four letter-number pairs, encoding the endpoints of the four edges in clockwise order that leave node <em>i</em>. The letters represent nodes (with <code>a..zA..Z</code> representing nodes 0 to 51 respectively). The numbers represent arcs (with <code>0..3</code> representing the four arcs around each node in clockwise order). An example of such a string (describing a genus one graph that models the virtual trefoil) is:</p>
<pre class="fragment">b3b2b0b1,a2a3a1a0
</pre><p>This routine is an inverse to <a class="el" href="#a2029894928ded381ae679c9a08f4e26d" title="Builds a graph from a text representation using Regina&#39;s extended variant of the plantri format,...">fromExtendedPlantri()</a>. That is, for any graph <em>g</em> of a supported size, <code>fromExtendedPlantri(g.extendedPlantri())</code> will be identical to <em>g</em>. Likewise, for any string <em>s</em> that satisfies the preconditions for <a class="el" href="#a2029894928ded381ae679c9a08f4e26d" title="Builds a graph from a text representation using Regina&#39;s extended variant of the plantri format,...">fromExtendedPlantri()</a>, calling <code>fromExtendedPlantri(s).<a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a></code> will recover the original string <em>s</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph has between 1 and 52 nodes inclusive.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph is empty or has more than 52 nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a representation of this graph in the extended <em>plantri</em> format. </dd></dl>

</div>
</div>
<a id="ae3cd0091a0f179ac81be4c981b97b458" name="ae3cd0091a0f179ac81be4c981b97b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cd0091a0f179ac81be4c981b97b458">&#9670;&#160;</a></span>findFlype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &gt; regina::ModelLinkGraph::findFlype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the smallest flype that can be performed on this graph from the given starting location. </p>
<p>Here we use the same notation as in the three-argument <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function, where you perform a flype by passing three arcs <em>from</em>, <em>left</em> and <em>right</em>. Read the <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> documentation now if you have not done so already; this includes a full description of the flype operation as well as diagrams with the arcs <em>from</em>, <em>left</em> and <em>right</em> clearly marked.</p>
<p>The given arc <em>from</em> identifies the node to the left of the flype disc. The aim of this routine is to identify two suitable arcs <em>left</em> and <em>right</em> that exit through the right of the flype disc. Together, these three arcs uniquely identify the entire flype disc, and therefore prescribe the operation precisely.</p>
<p>Here, by "suitable arcs", we mean a pair of arcs (<em>left</em>, <em>right</em>) for which the three arcs (<em>from</em>, <em>left</em>, <em>right</em>) together satisfy the preconditions for the <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> routine.</p>
<p>There are several possible outcomes:</p>
<ul>
<li>It is possible that there are <em>no</em> suitable arcs <em>left</em> and <em>right</em>. In this case, this routine returns a pair of null arcs.</li>
<li>It is possible that there is exactly one pair of suitable arcs (<em>left</em>, <em>right</em>). In this case, this pair will be returned.</li>
<li>It is possible that there are <em>many</em> pairs of suitable arcs. In this case, it can be shown that the suitable pairs have an ordering <em>P_1</em>, ..., <em>P_k</em> in which the flype disc for <em>P_i</em> is completely contained within the flype disc for <em>P_j</em> whenever <em>i</em> &lt; <em>j</em>. In this case, this routine returns the <em>smallest</em> pair <em>P_1</em>; that is, the pair (<em>left</em>, <em>right</em>) that gives the smallest possible flype disc.</li>
</ul>
<p>It should be noted that choosing only the smallest flype is not a serious restriction: assuming the graph does not model a composition of non-trivial knot diagrams, <em>any</em> suitable flype can be expressed as a composition of minimal flypes in this sense.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is planar.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the arc that indicates where the flype disc should begin. This is the arc labelled <em>from</em> in the diagrams for the three-argument <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function: it is the lower of the two arcs that enter the flype disc from the node <em>X</em> to the left of the disc. This should be presented as an arc of the node <em>X</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pair (<em>left</em>, <em>right</em>) representing the smallest suitable flype beginning at <em>from</em>, or a pair of null arcs if there are no suitable pairs (<em>left</em>, <em>right</em>). </dd></dl>

</div>
</div>
<a id="ac565266fea843b1ee7d9f344eddf0c4b" name="ac565266fea843b1ee7d9f344eddf0c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac565266fea843b1ee7d9f344eddf0c4b">&#9670;&#160;</a></span>flype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the smallest possible flype on this graph from the given starting location. </p>
<p>This is a convenience routine that simply calls <a class="el" href="#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> to identify the smallest possible flype from the given starting location, and then calls the three-argument <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> to actually perform it. If there is no possible flype from the given starting location then this routine throws an exception.</p>
<p>See the documentation for the three-argument <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> for further details on the flype operation, and see <a class="el" href="#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> for a discussion on what is meant by "smallest possible".</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is planar.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>There is no suitable flype on this graph from the given starting location (that is, <a class="el" href="#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> returns a pair of null arcs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the arc that indicates where the flype disc should begin. This is the arc labelled <em>from</em> in the diagrams for the three-argument <a class="el" href="#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function: it is the lower of the two arcs that enter the flype disc from the node <em>X</em> to the left of the disc. This should be presented as an arc of the node <em>X</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph obtained by performing the flype. </dd></dl>

</div>
</div>
<a id="a2eae854058768363de2cc893d24c20ea" name="a2eae854058768363de2cc893d24c20ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae854058768363de2cc893d24c20ea">&#9670;&#160;</a></span>flype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a flype on this graph at the given location. </p>
<p>A <em>flype</em> is an operation on a disc in the plane. The boundary of the disc must cut through four arcs of the graph (and otherwise must not meet the graph at all), as indicated in the diagram below. Moreover, the two arcs that exit the disc on the left must meet at a common node just outside the disc. (The punctuation symbols drawn inside the disc are just to help illustrate how the transformation works.)</p>
<pre class="fragment">         ______                       ______
        /      \                     /      \
__   __| ##  ** |_______     _______| ::  &lt;&gt; |__   __
  \ /  |        |                   |        |  \ /
   X   |  Disc  |        ==&gt;        |        |   X
__/ \__|        |_______     _______|        |__/ \__
       | ::  &lt;&gt; |                   | ##  ** |
        \______/                     \______/
</pre><p>The operation involves:</p>
<ul>
<li>reflecting this disc in a horizontal axis (so the two arcs on the left switch places, and the two arcs on the right switch places);</li>
<li>removing the node outside the disc on the left, where the two arcs meet;</li>
<li>introducing a new node on the right instead, where the two arcs on the right will now meet.</li>
</ul>
<p>The equivalent operation on a knot diagram involves twisting the entire region inside the disc about a horizontal axis, in a way that undoes the crossing on the left but introduces a new crossing on the right instead.</p>
<p>You will need to pass arguments to indicate where the flype should take place. For this, we will label some of the features of the initial diagram (before the move takes place): see the diagram below. Here the labels <em>from</em>, <em>left</em> and <em>right</em> all refer to arcs. The labels <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> all refer to dual 2-cells in the plane; these are not passed as arguments, but they do appear in the list of preconditions for this routine.</p>
<pre class="fragment">                 ______
Cell A          /      \
__   __________|        |_________ left
  \ /          |        |
   X   Cell B  |        |  Cell D
__/ \__________|        |_________ right
         from  |        |
Cell C          \______/
</pre><p>The arc <em>from</em> must be given as an arc of the node <em>outside</em> the disc (i.e., the node to the left of cell <em>B</em>). The arcs <em>left</em> and <em>right</em> must be given as arcs of their respective nodes <em>inside</em> the disc.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is planar.</dd>
<dd>
The arcs <em>from</em>, <em>left</em> and <em>right</em> are laid out as in the diagram above. In particular: <em>from</em> and <em>right</em> have the same cell to their right (cell <em>C</em>); <em>left</em> and the arc to the left of <em>from</em> have the same cell to their left (cell <em>A</em>); and <em>left</em> and <em>right</em> have the same cell between them (cell <em>D</em>).</dd>
<dd>
Neither of the arcs <em>left</em> or <em>right</em>, when followed in the direction away from the disc, end back at the node on the left of the diagram. That is, neither <code>left.traverse().<a class="el" href="#a32048d7c0d574234df71c03cf8afcb33" title="Returns the node at the given index within this graph.">node()</a></code> nor <code>right.traverse().<a class="el" href="#a32048d7c0d574234df71c03cf8afcb33" title="Returns the node at the given index within this graph.">node()</a></code> is equal to <code>from.node()</code>. (If this fails, then either the flype simply reflects the entire graph, or else the graph models a composition of two non-trivial knot diagrams.)</dd>
<dd>
Cells <em>A</em> and <em>C</em> are distinct (that is, the node on the left of the diagram is not a cut-vertex of the graph).</dd>
<dd>
Cells <em>B</em> and <em>D</em> are distinct (that is, the disc actually contains one or more nodes, and the graph does not model a composition of two non-trivial knot diagrams).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>One or more of the preconditions above fails to hold. Be warned that the connectivity and planarity preconditions will not be checked - these are the user's responsibility - but all other preconditions <em>will</em> be checked, and an exception will be thrown if any of them fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node outside the disc, to the left. </td></tr>
    <tr><td class="paramname">left</td><td>the second arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node that it meets inside the disc. </td></tr>
    <tr><td class="paramname">right</td><td>the third arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node that it meets inside the disc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph obtained by performing the flype. </dd></dl>

</div>
</div>
<a id="a2029894928ded381ae679c9a08f4e26d" name="a2029894928ded381ae679c9a08f4e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029894928ded381ae679c9a08f4e26d">&#9670;&#160;</a></span>fromExtendedPlantri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::fromExtendedPlantri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a graph from a text representation using Regina's extended variant of the <em>plantri</em> format, which is better suited for non-planar graphs. </p>
<p>See <a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a> for a detailed description of Regina's extended <em>plantri</em> text format. In essence, this extends the original Brinkmann-McKay <em>plantri</em> format to more explicitly encode the embedding of the graph, thereby removing the original <em>plantri</em> requirement that the graph be dual to a simple quadrangulation of the surface in which it embeds. Removing this requirement is important for non-planar graphs (which are used to model virtual link diagrams).</p>
<p>As an example, the string below is the extended <em>plantri</em> representation of a genus one graph that models the virtual trefoil:</p>
<pre class="fragment">b3b2b0b1,a2a3a1a0
</pre><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid representation of a graph using Regina's extended <em>plantri</em> format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the representation of a graph using Regina's extended <em>plantri</em> format, as described in <a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting graph. </dd></dl>

</div>
</div>
<a id="a806a72e571ad5c1f2c3e8c79bdbf7af1" name="a806a72e571ad5c1f2c3e8c79bdbf7af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806a72e571ad5c1f2c3e8c79bdbf7af1">&#9670;&#160;</a></span>fromPlantri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::fromPlantri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>plantri</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a graph from a line of <em>plantri</em> output, using Regina's variant of the <em>plantri</em> ASCII format. </p>
<p>The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine converts a piece of output from <em>plantri</em>, or the encoding of a graph using Regina's more general <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> or <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> functions, into a <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> object that Regina can work with directly.</p>
<p>Graphs encoded using Regina's <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> or <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> functions may be disconnected and/or non-planar. However, such a graph must be dual to a simple quadrangulation of the surface in which it embeds - otherwise the <em>plantri</em> format does not contain enough information to recover the embedding of the graph. This in particular is a problem for non-planar graphs (which model virtual links). If this is an issue for you, you can use Regina's extended <em>plantri</em> format instead; see <a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a> and <a class="el" href="#a2029894928ded381ae679c9a08f4e26d" title="Builds a graph from a text representation using Regina&#39;s extended variant of the plantri format,...">fromExtendedPlantri()</a>.</p>
<p>If you are working with output directly from the software <em>plantri</em>, this output must be in ASCII format, and must likewise be the dual graph of a simple quadrangulation of the sphere. The flags that must be passed to <em>plantri</em> to obtain such output are <code>-adq</code> (although you may wish to pass additional flags to expand or restrict the classes of graphs that <em>plantri</em> builds).</p>
<p>When run with these flags, <em>plantri</em> produces output in the following form:</p>
<pre class="fragment">6 bbcd,adca,abee,affb,cffc,deed
6 bcdd,aeec,abfd,acfa,bffb,ceed
6 bcde,affc,abfd,acee,addf,becb
</pre><p>Each line consists of an integer (the number of nodes in the graph), followed by a comma-separated sequence of alphabetical strings that encode the edges leaving each node.</p>
<p>This function <em>only</em> takes the comma-separated sequence of alphabetical strings. So, for example, to construct the graph corresponding to the second line of output above, you could call:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1">fromPlantri</a>(<span class="stringliteral">&quot;bcdd,aeec,abfd,acfa,bffb,ceed&quot;</span>);</div>
<div class="ttc" id="aclassregina_1_1ModelLinkGraph_html_a806a72e571ad5c1f2c3e8c79bdbf7af1"><div class="ttname"><a href="#a806a72e571ad5c1f2c3e8c79bdbf7af1">regina::ModelLinkGraph::fromPlantri</a></div><div class="ttdeci">static ModelLinkGraph fromPlantri(const std::string &amp;plantri)</div><div class="ttdoc">Builds a graph from a line of plantri output, using Regina's variant of the plantri ASCII format.</div></div>
</div><!-- fragment --><p>Regina uses its own variant of <em>plantri</em>'s output format, which is identical for smaller graphs but which differs from <em>plantri</em>'s own output format for larger graphs. In particular:</p>
<ul>
<li>For graphs with 26 nodes, Regina and <em>plantri</em> use identical formats. Here Regina can happily recognise the output from <em>plantri</em> as described above, as well as the output from Regina's own <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> functions.</li>
<li>For graphs with 27-52 nodes, Regina's and <em>plantri</em>'s formats differ: whereas <em>plantri</em> uses punctuation for higher-index nodes, Regina uses the upper-case letters <code>A,...,Z</code>. For these larger graphs, Regina can only recognise Regina's own <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> output, not <em>plantri</em>'s punctuation-based encodings.</li>
<li>For graphs with 53 nodes or more, Regina cannot encode or decode such graphs using <em>plantri</em> format at all.</li>
</ul>
<p>Note that, whilst the software <em>plantri</em> always outputs graphs using a particular canonical labelling, this function has no such restriction: it can accept an arbitrary ordering of nodes and arcs - in particular, it can accept the string <code>g.plantri()</code> for any graph <em>g</em> that meets the preconditions below.</p>
<p>This routine can also interpret the "tight" format that is optionally produced by the member function <a class="el" href="#ad551e61efb56e41d63d6fb4d454c56fb" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> (even though such output would certainly <em>not</em> be produced by the software <em>plantri</em>). Note that, by design, the tight format can only represented connected graphs.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some basic error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test that the graph is dual to a simple quadrangulation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph being described is dual to a <em>simple</em> quadrangulation of the surface in which it embeds; see <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> for further discussion on why this condition is needed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid representation of a graph using the <em>plantri</em> output format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plantri</td><td>a string containing the comma-separated sequence of alphabetical strings in <em>plantri</em> format, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting graph. </dd></dl>

</div>
</div>
<a id="a3e6323f9f0617daa1b538b266420c204" name="a3e6323f9f0617daa1b538b266420c204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6323f9f0617daa1b538b266420c204">&#9670;&#160;</a></span>generateAllEmbeddings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::ModelLinkGraph::generateAllEmbeddings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReflection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Flags.html">Flags</a>&lt; <a class="el" href="group__link.html#gababe6c5698577c7d7d2b32df7efd996d">GraphConstraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible local embeddings of the given 4-valent graph into some closed orientable surface. </p>
<p>The input 4-valent graph (which does <em>not</em> contain any embedding data) should be presented as a closed 3-dimensional facet pairing (since these can be generated efficiently using Regina).</p>
<p>This routine will, up to canonical relabelling, generate all local embeddings of the given graph into a closed orientable surface (i.e., all <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> objects corresponding to the input graph), each exactly once.</p>
<p>The graphs that are generated will be labelled canonically as described by <a class="el" href="#a911f466ef4000bc3c4e39cd614b9f3a3" title="Returns the canonical relabelling of this graph.">canonical()</a>. This means that the nodes of the graph might use a different labelling from the simplices of the given facet pairing. The argument <em>allowReflection</em> will be passed through to <a class="el" href="#a911f466ef4000bc3c4e39cd614b9f3a3" title="Returns the canonical relabelling of this graph.">canonical()</a>.</p>
<p>This routine is a work in progress. Currently it is <em>very</em> inefficient and memory-hungry; the algorithm will be improved over time if/when it becomes important to do so.</p>
<p>If <em>allowReflection</em> is <code>false</code>, then if we run all possible facet pairings through this routine, the combined results should be precisely those graphs described by OEIS sequence A292206. If <em>allowReflection</em> is <code>true</code>, then (once we reach three nodes or more) the output set should be smaller.</p>
<p>For each graph that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument passed to <em>action</em> will be the graph that was generated (of type <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a>). This will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, and is also closed (i.e., has no unmatched facets).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the argument <em>args</em> is removed, so you simply call it as <code>generateAllEmbeddings(pairing, allowReflection, action)</code>. Moreover, <em>action</em> must take exactly one argument (the graph).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given pairing is disconnected and/or has unmatched facets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the 4-valent graph for which we wish to produce local embeddings. </td></tr>
    <tr><td class="paramname">allowReflection</td><td><code>true</code> if we consider a reflection of the surface in which the graph embeds to produce the same embedding. </td></tr>
    <tr><td class="paramname">constraints</td><td>indicates any constraints that the embeddings that we generate must satisfy. This should be a bitwise OR of constants from the GraphConstraint enumeration, or else <code><a class="el" href="group__link.html#ggababe6c5698577c7d7d2b32df7efd996dab1c94ca2fbc3e78fc30069c8d0f01680" title="Indicates that all graph embeddings should be generated.">GraphConstraint::All</a></code> (or just empty braces <code>{}</code>) if we should generate every possible embedding. If several constraints are ORed together, then only embeddings that satisfy <em>all</em> of the these constraints will be produced. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each graph that is generated. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial graph argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a365f250111716159b0b93c995ac7572f" name="a365f250111716159b0b93c995ac7572f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365f250111716159b0b93c995ac7572f">&#9670;&#160;</a></span>generateAllLinks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::generateAllLinks </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exhaustively generates all link diagrams that are modelled by this graph, up to reversal of individual link components. </p>
<p>If this graph has <em>n</em> nodes, then there will be <code>2^n</code> link diagrams generated in total.</p>
<p>This routine is provided mainly to help with exhaustive testing. If you are not interested in "obviously" non-minimal link diagrams, then you should call <a class="el" href="#a7eebfc992fb1fb0e11a5ba620d88db0a" title="Exhaustively generates potentially-minimal link diagrams that are modelled by this graph.">generateMinimalLinks()</a> instead.</p>
<p>Labelled diagrams are only generated once up to reversal of each component. Specifically, this routine will fix the orientation of each link component (always following the smallest numbered available arc away from the smallest index graph node in each link component).</p>
<p>In each link diagram that is generated, crossing <em>k</em> will always correspond to node <em>k</em> of this graph. If this graph is non-planar, then the resulting link diagrams will all be virtual.</p>
<p>For each link diagram that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument passed to <em>action</em> will be the link diagram that was generated (of type <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>). This will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the argument <em>args</em> is removed, so you simply call it as generateAllLinks(action). Moreover, <em>action</em> must take exactly one argument (the link diagram).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each link diagram that is generated. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial link diagram argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa71e89dfdbc8ce49dce922f672275566" name="aa71e89dfdbc8ce49dce922f672275566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71e89dfdbc8ce49dce922f672275566">&#9670;&#160;</a></span>generateAnyLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::ModelLinkGraph::generateAnyLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an arbitrary link diagram that is modelled by this graph. </p>
<p>All link diagrams modelled by this graph are identical up to switching of individual crossings and/or reversal of individual link components. This routine will generate just one of these many possible link diagrams. If you wish to generate <em>all</em> such diagrams, consider whether <a class="el" href="#a7eebfc992fb1fb0e11a5ba620d88db0a" title="Exhaustively generates potentially-minimal link diagrams that are modelled by this graph.">generateMinimalLinks()</a> might be more appropriate for what you need.</p>
<p>Unlike <a class="el" href="#a7eebfc992fb1fb0e11a5ba620d88db0a" title="Exhaustively generates potentially-minimal link diagrams that are modelled by this graph.">generateMinimalLinks()</a>, there is no guarantee that the diagram produced by this routine is minimal or even locally minimal in any sense. For example, it is entirely possible that the link diagram returned by this routine will have a reducing Reidemeister move.</p>
<p>In the link diagram that is generated, crossing <em>k</em> will always correspond to node <em>k</em> of this graph. If this graph is non-planar, then the resulting link diagram will be virtual. </p>

</div>
</div>
<a id="a7eebfc992fb1fb0e11a5ba620d88db0a" name="a7eebfc992fb1fb0e11a5ba620d88db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eebfc992fb1fb0e11a5ba620d88db0a">&#9670;&#160;</a></span>generateMinimalLinks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::generateMinimalLinks </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exhaustively generates potentially-minimal link diagrams that are modelled by this graph. </p>
<p>Here <em>potentially-minimal</em> means there are no "obvious" simplification moves (such as a simplifying type II Reidemeister move, for example). The list of "obvious" moves considered here is subject to change in future versions of Regina.</p>
<p>By <em>exhaustive</em>, we mean:</p>
<ul>
<li>Every minimal link diagram modelled by this graph will be generated by this routine, up to reflection and/or reversal (as explained below).</li>
<li>If a link diagram is non-minimal and modelled by this graph, it <em>might</em> still be generated by this routine.</li>
</ul>
<p>In other words, this routine will generate all minimal link diagrams modelled by this graph, but there is no promise that all of the diagrams generated are minimal.</p>
<p>Labelled diagrams are only generated once up to reflection of the diagram and/or reversal of each component. Here "reflection" corresponds to the function <a class="el" href="classregina_1_1Link.html#a0546dc7f2bde7b63c31f3e057a8c04db" title="Switches the upper and lower strands of every crossing in the diagram.">Link::changeAll()</a>, which reflects the link diagram in the surface that contains it. Specifically, this routine will fix the orientation of each link component (always following the smallest numbered available arc away from the smallest index graph node in each link component), and it will fix the upper and lower strands at node 0 so that the corresponding crossing is always positive.</p>
<p>In each link diagram that is generated, crossing <em>k</em> will always correspond to node <em>k</em> of this graph. If this graph is non-planar, then the resulting link diagrams will all be virtual.</p>
<p>For each link diagram that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument passed to <em>action</em> will be the link diagram that was generated (of type <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>). This will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The cell decomposition induced by this graph has no 1-gons (which, in any link diagram that the graph models, would yield a reducing type I Reidemeister move).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the argument <em>args</em> is removed, so you simply call it as generateMinimalLinks(action). Moreover, <em>action</em> must take exactly one argument (the link diagram).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>There is a 1-gon in the cell decomposition induced by this graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each link diagram that is generated. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial link diagram argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a94d5ab9a2ffac8245dbdb52097cac7" name="a0a94d5ab9a2ffac8245dbdb52097cac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a94d5ab9a2ffac8245dbdb52097cac7">&#9670;&#160;</a></span>genus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::genus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the genus of the closed orientable surface in which this graph embeds. </p>
<p>As described in the class notes, this surface is chosen to have the smallest possible genus: it is built from a collection of discs whose boundaries follow the nodes and arcs of this graph according to the local embedding.</p>
<p>If this graph is disconnected (and therefore the surface is also disconnected), then this routine will return the sum of the genus over all components.</p>
<dl class="section return"><dt>Returns</dt><dd>the genus of the surface in which this graph embeds. </dd></dl>

</div>
</div>
<a id="a2c51197dbd112bb60b7893cc51a09003" name="a2c51197dbd112bb60b7893cc51a09003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51197dbd112bb60b7893cc51a09003">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>This hash function makes use of Regina's tight encodings. In particular, any two objects with the same tight encoding will have equal hashes. This implementation (and therefore the specific hash value for each object) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows objects of this type to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this object. </dd></dl>

</div>
</div>
<a id="af8fce4c3cf6c90a2a8ff2e4823a9b8cb" name="af8fce4c3cf6c90a2a8ff2e4823a9b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fce4c3cf6c90a2a8ff2e4823a9b8cb">&#9670;&#160;</a></span>insertGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::insertGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given graph into this graph. </p>
<p>The nodes of <em>source</em> will be copied into this graph, and placed after any pre-existing nodes. Specifically, if the original number of nodes in this graph was <em>N</em>, then node <em>i</em> of <em>source</em> will be copied to a new node <code>N+i</code> of this graph.</p>
<p>This routine behaves correctly when <em>source</em> is this graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the graph whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cf3b183759686c8acf0329e6fb6692e" name="a1cf3b183759686c8acf0329e6fb6692e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf3b183759686c8acf0329e6fb6692e">&#9670;&#160;</a></span>insertGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::insertGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given graph into this graph. </p>
<p>The nodes of <em>source</em> will be moved directly into this graph, and placed after any pre-existing nodes. Specifically, if the original number of nodes in this graph was <em>N</em>, then node <em>i</em> of <em>source</em> will become node <code>N+i</code> of this graph.</p>
<p>As is normal for an rvalue reference, after calling this function <em>source</em> will be unusable. Any arc references or node pointers that referred to either this graph or <em>source</em> will remain valid (and will all now refer to this graph), though if they originally referred to <em>source</em> then they will now return different numerical node indices.</p>
<p>Calling <code>graph.insertGraph(source)</code> (where <em>source</em> is an rvalue reference) is similar to calling <code>source.moveContentsTo(graph)</code>, but it is a little faster since it does not need to leave <em>source</em> in a usable state.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>source</em> is not this graph.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Only the copying version of this function is available (i.e., the version that takes <em>source</em> as a const reference). If you want a fast move operation, call <code>source.moveContentsTo(this)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the graph whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2545252542893d425c305061876822c4" name="a2545252542893d425c305061876822c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2545252542893d425c305061876822c4">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies whether this graph is connected. </p>
<p>For the purposes of this routine, an empty graph is considered to be connected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is not thread-safe, since it caches the number of components after computing it for the first time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this graph is connected. </dd></dl>

</div>
</div>
<a id="aa048a87ceec2ad22663abef7c677f30e" name="aa048a87ceec2ad22663abef7c677f30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa048a87ceec2ad22663abef7c677f30e">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this graph is empty. </p>
<p>An empty graph is one with no nodes at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this graph is empty. </dd></dl>

</div>
</div>
<a id="a39ad50b1ba35adf33bd0052712a69318" name="a39ad50b1ba35adf33bd0052712a69318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ad50b1ba35adf33bd0052712a69318">&#9670;&#160;</a></span>isSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::isSimple </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies whether this graph is simple; that is, has no loops or multiple edges. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this graph is simple. </dd></dl>

</div>
</div>
<a id="ab48404aa3bc1c6061d968cc7526b5ad9" name="ab48404aa3bc1c6061d968cc7526b5ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48404aa3bc1c6061d968cc7526b5ad9">&#9670;&#160;</a></span>moveContentsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of this graph into the given destination graph, leaving this graph empty but otherwise usable. </p>
<p>The nodes of this graph will be moved directly into <em>dest</em>, and placed after any pre-existing nodes. Specifically, if the original number of nodes in <em>dest</em> was <em>N</em>, then node <em>i</em> of this graph will become node <code>N+i</code> of <em>dest</em>.</p>
<p>This graph will become empty as a result, but it will otherwise remain a valid and usable <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> object. Any arc references or node pointers that referred to either this graph or <em>dest</em> will remain valid (and will all now refer to <em>dest</em>), though if they originally referred to this graph then they will now return different numerical node indices.</p>
<p>Calling <code>graph.moveContentsTo(dest)</code> is similar to calling <code>dest.insertGraph(std::move(graph))</code>; it is a little slower but it comes with the benefit of leaving this graph in a usable state.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the graph into which the contents of this graph should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32048d7c0d574234df71c03cf8afcb33" name="a32048d7c0d574234df71c03cf8afcb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32048d7c0d574234df71c03cf8afcb33">&#9670;&#160;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> * regina::ModelLinkGraph::node </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node at the given index within this graph. </p>
<p>For a graph with <em>n</em> nodes, the nodes are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some nodes are added or removed then the indices of other nodes might change. If you wish to track a particular node through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested node. This must be between 0 and <a class="el" href="#a8ae830ab12408759e526ae15d16e0be5" title="Returns the number of nodes in this graph.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node at the given index. </dd></dl>

</div>
</div>
<a id="a6491eff8e0ab206c0d750bc7bed6abd1" name="a6491eff8e0ab206c0d750bc7bed6abd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6491eff8e0ab206c0d750bc7bed6abd1">&#9670;&#160;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::ModelLinkGraph::nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all nodes in this graph. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a>* n : graph.<a class="code hl_function" href="#a6491eff8e0ab206c0d750bc7bed6abd1">nodes</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1ModelLinkGraphNode_html"><div class="ttname"><a href="classregina_1_1ModelLinkGraphNode.html">regina::ModelLinkGraphNode</a></div><div class="ttdoc">Represents a single node in a model graph for a knot or link.</div><div class="ttdef"><b>Definition</b> modellinkgraph.h:410</div></div>
<div class="ttc" id="aclassregina_1_1ModelLinkGraph_html_a6491eff8e0ab206c0d750bc7bed6abd1"><div class="ttname"><a href="#a6491eff8e0ab206c0d750bc7bed6abd1">regina::ModelLinkGraph::nodes</a></div><div class="ttdeci">auto nodes() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all nodes in this graph.</div><div class="ttdef"><b>Definition</b> modellinkgraph.h:2332</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the graph exists: even if nodes are added and/or removed, it will always reflect the nodes that are currently in the graph. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="#a6491eff8e0ab206c0d750bc7bed6abd1" title="Returns an object that allows iteration through and random access to all nodes in this graph.">nodes()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all nodes. </dd></dl>

</div>
</div>
<a id="a8cdc89ae4b81f1415856e3812e48f8dd" name="a8cdc89ae4b81f1415856e3812e48f8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdc89ae4b81f1415856e3812e48f8dd">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp; regina::ModelLinkGraph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this graph. </dd></dl>

</div>
</div>
<a id="aec906b2e6ce954c638dfe21c4b3d49bc" name="aec906b2e6ce954c638dfe21c4b3d49bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec906b2e6ce954c638dfe21c4b3d49bc">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp; regina::ModelLinkGraph::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given graph into this graph. </p>
<p>This is a fast (constant time) operation.</p>
<p>All nodes and cells that belong to <em>src</em> will be moved into this graph, and so any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> or <a class="el" href="classregina_1_1ModelLinkGraphCells.html" title="Describes the cellular decomposition of a closed orientable surface induced by a 4-valent graph embed...">ModelLinkGraphCells</a> pointers or references will remain valid.</p>
<p>The graph that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this graph. </dd></dl>

</div>
</div>
<a id="ae2238ea1d3a224c1737ec6c66bdfd5d5" name="ae2238ea1d3a224c1737ec6c66bdfd5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2238ea1d3a224c1737ec6c66bdfd5d5">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this graph is combinatorially identical to the given graph. </p>
<p>Here "identical" means that both graphs have the same number of nodes, and in both graphs the same pairs of outgoing arcs of numbered nodes are connected by edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two graphs are combinatorially identical. </dd></dl>

</div>
</div>
<a id="a3b794563bcc89728bf2dab6f6952a5c5" name="a3b794563bcc89728bf2dab6f6952a5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b794563bcc89728bf2dab6f6952a5c5">&#9670;&#160;</a></span>plantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::plantri </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this graph in a variant of the ASCII text format used by <em>plantri</em>. </p>
<p>The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine outputs this graph in a format that mimics <em>plantri</em>'s own dual ASCII format (i.e., the format that <em>plantri</em> outputs when run with the flags <code>-adq</code>).</p>
<p>Specifically, the output will be a comma-separated sequence of alphabetical strings. The <em>i</em>th such string will consist of four letters, encoding the endpoints of the four edges in clockwise order that leave node <em>i</em>. The lower-case letters <code>a</code>,<code>b</code>,...,<code>z</code> represent nodes 0,1,...,25 respectively, and the upper-case letters <code>A</code>,<code>B</code>,...,<code>Z</code> represent nodes 26,27,...,51 respectively. An example of such a string is:</p>
<pre class="fragment">bcdd,aeec,abfd,acfa,bffb,ceed
</pre><p>For graphs with at most 26 nodes, this is identical to <em>plantri</em>'s own dual ASCII format. For larger graphs, this format differs: <em>plantri</em> uses punctuation to represent higher-index nodes, whereas Regina uses upper-case letters.</p>
<p>Although <em>plantri</em> is designed to work with graphs that are connected and planar, this routine will happily produce output for disconnected and/or non-planar graphs. However, there remains an unavoidable requirement: the graph must be dual to a <em>simple</em> quadrangulation. In detail:</p>
<ul>
<li>The dual to this 4-valent graph will be a quadrangulation of the surface in which it embeds. The <em>plantri</em> format inherently requires that this quadrangulation is <em>simple</em>: that is, the dual must have no loops or parallel edges.</li>
<li>This requirement exists because, if the dual is <em>not</em> simple, the embedding of the original graph cannot be uniquely reconstructed from its <em>plantri</em> output. In particular, the embedding becomes ambiguous around parallel edges in the original 4-valent graph.</li>
<li>For <em>planar</em> graphs, this requirement is relatively harmless: a parity condition shows that loops in the dual are impossible, and parallel edges in the dual mean that any link diagram that this graph models is an "obvious" connected sum.</li>
<li>For <em>non-planar</em> graphs, this requirement is more problematic. For example, consider the graph that models the virtual trefoil: the dual quadrangulation of the torus contains both loops and parallel edges. This makes the <em>plantri</em> format unusable in practice for graps that model virtual links.</li>
</ul>
<p>If this constraint is too onerous (e.g., you are working with virtual links), you could use <a class="el" href="#ad8e558636cf8c2cd8beab3f6a2df054a" title="Outputs this graph using Regina&#39;s extended variant of the plantri text format, which is better suited...">extendedPlantri()</a> instead, which is not compatible with the Brinkmann-McKay <em>plantri</em> software but which removes this requirement for the dual quadrangulation to be simple.</p>
<p>For graphs that the <em>plantri</em> format <em>does</em> support, this routine is an inverse to <a class="el" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>. That is, for any graph <em>g</em> that satisfies the preconditions below, <code>fromPlantri(g.plantri())</code> is identical to <em>g</em>. Likewise, for any string <em>s</em> that satisfies the preconditions for <a class="el" href="#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>, calling <code>fromPlantri(s).<a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a></code> will recover the original string <em>s</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The output of this function might not correspond to any possible output from the program <em>plantri</em> itself, even if the graph is connected and planar, the dual quadrangulation is simple, and only lower-case letters are used. This is because <em>plantri</em> only outputs graphs with a certain canonical labelling. In contrast, <a class="el" href="#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> can be called on any graph that satisfies the preconditions below, and it will preserve the labels of the nodes and the order of the arcs around each node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph has between 1 and 52 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the surface in which it embeds.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph is empty or has more than 52 nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <em>plantri</em> format ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="ad7bf57c2c0c301ac98f9220b596b7405" name="ad7bf57c2c0c301ac98f9220b596b7405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf57c2c0c301ac98f9220b596b7405">&#9670;&#160;</a></span>randomise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::randomise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly relabels this graph in an orientation-preserving manner. </p>
<p>The nodes will be relabelled arbitrarily. Around each node, the four outgoing arcs will be relabelled in a random way that preserves their cyclic order (thereby preserving the local embedding of the graph, without reflection).</p>
<p>This routine is thread-safe, and uses <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> for its random number generation. </p>

</div>
</div>
<a id="ad89a103eeda5359e83684d10b5f3444d" name="ad89a103eeda5359e83684d10b5f3444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89a103eeda5359e83684d10b5f3444d">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::reflect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this graph into its reflection. </p>
<p>This routine simply reverses (and also cycles) the order of outgoing arcs around every node. </p>

</div>
</div>
<a id="a8ae830ab12408759e526ae15d16e0be5" name="a8ae830ab12408759e526ae15d16e0be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae830ab12408759e526ae15d16e0be5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in this graph. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a28801826ec5d301697db8576eded1f10" name="a28801826ec5d301697db8576eded1f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28801826ec5d301697db8576eded1f10">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given graph. </p>
<p>All nodes that belong to this graph will be moved to <em>other</em>, and all nodes that belong to <em>other</em> will be moved to this graph.</p>
<p>In particular, any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> pointers or references and any <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb26d0d8723c46c4693d5a2d524c1c4" name="a1cb26d0d8723c46c4693d5a2d524c1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb26d0d8723c46c4693d5a2d524c1c4">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a graph from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ae243881e366ab1b18294363708b5b4d3" name="ae243881e366ab1b18294363708b5b4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae243881e366ab1b18294363708b5b4d3">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this graph to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a89355292f9354c4d8bfc7d5468ee26f5" name="a89355292f9354c4d8bfc7d5468ee26f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89355292f9354c4d8bfc7d5468ee26f5">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4b88c8eb92b6c9abe6f557c3221486" name="aab4b88c8eb92b6c9abe6f557c3221486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4b88c8eb92b6c9abe6f557c3221486">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="modellinkgraph_8h.html">modellinkgraph.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
