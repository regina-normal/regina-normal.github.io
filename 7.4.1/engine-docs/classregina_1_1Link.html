<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.4.1 Calculation Engine: regina::Link Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.4.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Link.html">Link</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1Link-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Link Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a combinatorial diagram of a directed knot or link.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;link/link.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Link:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Link.png" usemap="#regina::Link_map" alt=""/>
  <map id="regina::Link_map" name="regina::Link_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; Link &gt;" shape="rect" coords="0,0,188,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Link &gt;" shape="rect" coords="198,0,386,24"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; Link &gt;" shape="rect" coords="396,0,584,24"/>
<area href="classregina_1_1TopologyLockable.html" title="A base class for objects that support topology locks, such as triangulations or links." alt="regina::TopologyLockable" shape="rect" coords="594,0,782,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d10f79dd6c4de1c8b90b77ab0953d9c" id="r_a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a0d10f79dd6c4de1c8b90b77ab0953d9c">PacketChangeGroup</a></td></tr>
<tr class="memdesc:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.  <br /></td></tr>
<tr class="separator:a0d10f79dd6c4de1c8b90b77ab0953d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247" id="r_ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88" id="r_a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1" id="r_ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c51197dbd112bb60b7893cc51a09003" id="r_a2c51197dbd112bb60b7893cc51a09003"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a2c51197dbd112bb60b7893cc51a09003">hash</a> () const</td></tr>
<tr class="memdesc:a2c51197dbd112bb60b7893cc51a09003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables.  <br /></td></tr>
<tr class="separator:a2c51197dbd112bb60b7893cc51a09003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:aff4dc84be20b66314534c2dcc7466324" id="r_aff4dc84be20b66314534c2dcc7466324"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff4dc84be20b66314534c2dcc7466324">Link</a> ()</td></tr>
<tr class="memdesc:aff4dc84be20b66314534c2dcc7466324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty link.  <br /></td></tr>
<tr class="separator:aff4dc84be20b66314534c2dcc7466324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b717f99561f93f6b09118cdf770803" id="r_aa6b717f99561f93f6b09118cdf770803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b717f99561f93f6b09118cdf770803">Link</a> (size_t unknots)</td></tr>
<tr class="memdesc:aa6b717f99561f93f6b09118cdf770803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the unlink with the given number of components.  <br /></td></tr>
<tr class="separator:aa6b717f99561f93f6b09118cdf770803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359918be5fb86081d1122cc2f2260a5f" id="r_a359918be5fb86081d1122cc2f2260a5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359918be5fb86081d1122cc2f2260a5f">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy)</td></tr>
<tr class="memdesc:a359918be5fb86081d1122cc2f2260a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link.  <br /></td></tr>
<tr class="separator:a359918be5fb86081d1122cc2f2260a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef22c9d7355dc008bfc0282c1f99e4b" id="r_aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaef22c9d7355dc008bfc0282c1f99e4b">Link</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also.  <br /></td></tr>
<tr class="separator:aaef22c9d7355dc008bfc0282c1f99e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2b893b338cbcc1556db7f7e54dfe9" id="r_a75a2b893b338cbcc1556db7f7e54dfe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a2b893b338cbcc1556db7f7e54dfe9">Link</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a75a2b893b338cbcc1556db7f7e54dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given link into this new link.  <br /></td></tr>
<tr class="separator:a75a2b893b338cbcc1556db7f7e54dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b233fb32a24925705b616b5dc23b219" id="r_a9b233fb32a24925705b616b5dc23b219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b233fb32a24925705b616b5dc23b219">Link</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a9b233fb32a24925705b616b5dc23b219"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a link.  <br /></td></tr>
<tr class="separator:a9b233fb32a24925705b616b5dc23b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93be82c5a263db9e3dc28a928fb4ba" id="r_aca93be82c5a263db9e3dc28a928fb4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca93be82c5a263db9e3dc28a928fb4ba">~Link</a> ()</td></tr>
<tr class="memdesc:aca93be82c5a263db9e3dc28a928fb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this link.  <br /></td></tr>
<tr class="separator:aca93be82c5a263db9e3dc28a928fb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Crossings and Components</div></td></tr>
<tr class="memitem:ad12a7e69700971494486e299bbc39c57" id="r_ad12a7e69700971494486e299bbc39c57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12a7e69700971494486e299bbc39c57">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad12a7e69700971494486e299bbc39c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link is empty.  <br /></td></tr>
<tr class="separator:ad12a7e69700971494486e299bbc39c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c6f34794cc62574fcfca388f3f66d9" id="r_a32c6f34794cc62574fcfca388f3f66d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c6f34794cc62574fcfca388f3f66d9">size</a> () const</td></tr>
<tr class="memdesc:a32c6f34794cc62574fcfca388f3f66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of crossings in this link.  <br /></td></tr>
<tr class="separator:a32c6f34794cc62574fcfca388f3f66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb9a0932d786dfca9eef2f6e45ec60" id="r_ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60">countComponents</a> () const</td></tr>
<tr class="memdesc:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of components in this link.  <br /></td></tr>
<tr class="separator:ab4fb9a0932d786dfca9eef2f6e45ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47712bc419c15659a634ae6ea97b91" id="r_a2b47712bc419c15659a634ae6ea97b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:a2b47712bc419c15659a634ae6ea97b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the crossing at the given index within this link.  <br /></td></tr>
<tr class="separator:a2b47712bc419c15659a634ae6ea97b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c13af7dff2e92401ff388f3a2eec26" id="r_a25c13af7dff2e92401ff388f3a2eec26"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c13af7dff2e92401ff388f3a2eec26">crossings</a> () const</td></tr>
<tr class="memdesc:a25c13af7dff2e92401ff388f3a2eec26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all crossings within this link.  <br /></td></tr>
<tr class="separator:a25c13af7dff2e92401ff388f3a2eec26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3425a2a6994fbc87baf890e9b429ef6f" id="r_a3425a2a6994fbc87baf890e9b429ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f">component</a> (size_t index) const</td></tr>
<tr class="memdesc:a3425a2a6994fbc87baf890e9b429ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a strand in the given component of this link.  <br /></td></tr>
<tr class="separator:a3425a2a6994fbc87baf890e9b429ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ed4ff764fe10462582631b9798d6e" id="r_a550ed4ff764fe10462582631b9798d6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a550ed4ff764fe10462582631b9798d6e">components</a> () const</td></tr>
<tr class="memdesc:a550ed4ff764fe10462582631b9798d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all components of this link.  <br /></td></tr>
<tr class="separator:a550ed4ff764fe10462582631b9798d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0b3f667c9968cc0fbd3b8a2ac4b9a4" id="r_aad0b3f667c9968cc0fbd3b8a2ac4b9a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad0b3f667c9968cc0fbd3b8a2ac4b9a4">countTrivialComponents</a> () const</td></tr>
<tr class="memdesc:aad0b3f667c9968cc0fbd3b8a2ac4b9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of zero-crossing unknot components in this link.  <br /></td></tr>
<tr class="separator:aad0b3f667c9968cc0fbd3b8a2ac4b9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12bbb367ccd77109bb49e53aacf501" id="r_a6f12bbb367ccd77109bb49e53aacf501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f12bbb367ccd77109bb49e53aacf501">component</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;s) const</td></tr>
<tr class="memdesc:a6f12bbb367ccd77109bb49e53aacf501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting strand for the link component containing the given strand.  <br /></td></tr>
<tr class="separator:a6f12bbb367ccd77109bb49e53aacf501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5338200b51df9d368711c7bf3954d" id="r_aadb5338200b51df9d368711c7bf3954d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadb5338200b51df9d368711c7bf3954d">strand</a> (ssize_t id) const</td></tr>
<tr class="memdesc:aadb5338200b51df9d368711c7bf3954d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strand in the link with the given integer ID.  <br /></td></tr>
<tr class="separator:aadb5338200b51df9d368711c7bf3954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf8c32905d7885d8634dead720e0fe" id="r_aa8cf8c32905d7885d8634dead720e0fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8cf8c32905d7885d8634dead720e0fe">componentsByStrand</a> () const</td></tr>
<tr class="memdesc:aa8cf8c32905d7885d8634dead720e0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence that maps strand IDs to link component numbers.  <br /></td></tr>
<tr class="separator:aa8cf8c32905d7885d8634dead720e0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b897dacf987697c6afd8a77f1e434b5" id="r_a0b897dacf987697c6afd8a77f1e434b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b897dacf987697c6afd8a77f1e434b5">translate</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *other) const</td></tr>
<tr class="memdesc:a0b897dacf987697c6afd8a77f1e434b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a crossing from some other link into the corresponding crossing in this link.  <br /></td></tr>
<tr class="separator:a0b897dacf987697c6afd8a77f1e434b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e4637efe2ed81e2c9588aaa76591" id="r_aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d5e4637efe2ed81e2c9588aaa76591">translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference from some other link into the corresponding strand reference from this link.  <br /></td></tr>
<tr class="separator:aa4d5e4637efe2ed81e2c9588aaa76591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef4e2484c8c9c8c995ed709a43acfb" id="r_abaef4e2484c8c9c8c995ed709a43acfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb">isConnected</a> () const</td></tr>
<tr class="memdesc:abaef4e2484c8c9c8c995ed709a43acfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.  <br /></td></tr>
<tr class="separator:abaef4e2484c8c9c8c995ed709a43acfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc783777826fcf17af86d21a343118d5" id="r_abc783777826fcf17af86d21a343118d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc783777826fcf17af86d21a343118d5">connected</a> (const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *a, const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *b) const</td></tr>
<tr class="memdesc:abc783777826fcf17af86d21a343118d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given crossings are connected in the link diagram, if we treat each crossing as a 4-way intersection.  <br /></td></tr>
<tr class="separator:abc783777826fcf17af86d21a343118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ffadefd563c6a4787d984c7c39ca3" id="r_aa13ffadefd563c6a4787d984c7c39ca3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3">diagramComponents</a> () const</td></tr>
<tr class="memdesc:aa13ffadefd563c6a4787d984c7c39ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected components of this link diagram as individual standalone links.  <br /></td></tr>
<tr class="separator:aa13ffadefd563c6a4787d984c7c39ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1cff257b0e1ac3dce82146c476e3a8" id="r_a9c1cff257b0e1ac3dce82146c476e3a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c1cff257b0e1ac3dce82146c476e3a8">countDiagramComponents</a> () const</td></tr>
<tr class="memdesc:a9c1cff257b0e1ac3dce82146c476e3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of connected diagram components.  <br /></td></tr>
<tr class="separator:a9c1cff257b0e1ac3dce82146c476e3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae377b51c110e629e00158be74d50f1fe" id="r_ae377b51c110e629e00158be74d50f1fe"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1FixedArray.html">FixedArray</a>&lt; size_t &gt;, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae377b51c110e629e00158be74d50f1fe">diagramComponentIndices</a> () const</td></tr>
<tr class="memdesc:ae377b51c110e629e00158be74d50f1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array that maps crossing numbers to connected diagram components.  <br /></td></tr>
<tr class="separator:ae377b51c110e629e00158be74d50f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e1c3af83699d65c033fe591b4e8554" id="r_ae8e1c3af83699d65c033fe591b4e8554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e1c3af83699d65c033fe591b4e8554">overForComponent</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f">component</a>) const</td></tr>
<tr class="memdesc:ae8e1c3af83699d65c033fe591b4e8554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates an over-crossing within the same link component as the given strand.  <br /></td></tr>
<tr class="separator:ae8e1c3af83699d65c033fe591b4e8554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1707701b8c7697c63b0f15914542c5af" id="r_a1707701b8c7697c63b0f15914542c5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1707701b8c7697c63b0f15914542c5af">underForComponent</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f">component</a>) const</td></tr>
<tr class="memdesc:a1707701b8c7697c63b0f15914542c5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates an under-crossing within the same link component as the given strand.  <br /></td></tr>
<tr class="separator:a1707701b8c7697c63b0f15914542c5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca68202fe7b9672c314b5c7f214e9f" id="r_aa7ca68202fe7b9672c314b5c7f214e9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ca68202fe7b9672c314b5c7f214e9f">operator==</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other) const</td></tr>
<tr class="memdesc:aa7ca68202fe7b9672c314b5c7f214e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this link diagram is combinatorially identical to the given link diagram.  <br /></td></tr>
<tr class="separator:aa7ca68202fe7b9672c314b5c7f214e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980602d950e89b20aba2ba16ebc86521" id="r_a980602d950e89b20aba2ba16ebc86521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a980602d950e89b20aba2ba16ebc86521">graph</a> () const</td></tr>
<tr class="memdesc:a980602d950e89b20aba2ba16ebc86521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4-valent graph that models this link diagram, along with the local embedding of the graph into the surface that contains the diagram.  <br /></td></tr>
<tr class="separator:a980602d950e89b20aba2ba16ebc86521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Editing</div></td></tr>
<tr class="memitem:af70fd8c81eeca7fdee7af7b16b144b94" id="r_af70fd8c81eeca7fdee7af7b16b144b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af70fd8c81eeca7fdee7af7b16b144b94">operator=</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;src)</td></tr>
<tr class="memdesc:af70fd8c81eeca7fdee7af7b16b144b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given link.  <br /></td></tr>
<tr class="separator:af70fd8c81eeca7fdee7af7b16b144b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3fb09880c2f7984d19fc944a3b4b50" id="r_a7e3fb09880c2f7984d19fc944a3b4b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e3fb09880c2f7984d19fc944a3b4b50">operator=</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a7e3fb09880c2f7984d19fc944a3b4b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given link into this link.  <br /></td></tr>
<tr class="separator:a7e3fb09880c2f7984d19fc944a3b4b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48595553c44333292ad1948caed0ae" id="r_aeb48595553c44333292ad1948caed0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb48595553c44333292ad1948caed0ae">swap</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:aeb48595553c44333292ad1948caed0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given link.  <br /></td></tr>
<tr class="separator:aeb48595553c44333292ad1948caed0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba467ea1ca812832b4ff15d6fbe23654" id="r_aba467ea1ca812832b4ff15d6fbe23654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba467ea1ca812832b4ff15d6fbe23654">insertLink</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;<a class="el" href="#a53fbcb99b3014ab278782289b092403c">source</a>)</td></tr>
<tr class="memdesc:aba467ea1ca812832b4ff15d6fbe23654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given link into this link.  <br /></td></tr>
<tr class="separator:aba467ea1ca812832b4ff15d6fbe23654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ac53ae9a6ba97098bea021daf80035" id="r_a29ac53ae9a6ba97098bea021daf80035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29ac53ae9a6ba97098bea021daf80035">insertLink</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;<a class="el" href="#a53fbcb99b3014ab278782289b092403c">source</a>)</td></tr>
<tr class="memdesc:a29ac53ae9a6ba97098bea021daf80035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given link into this link.  <br /></td></tr>
<tr class="separator:a29ac53ae9a6ba97098bea021daf80035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e483730179d76b3e17635b9e0d9f30" id="r_a45e483730179d76b3e17635b9e0d9f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e483730179d76b3e17635b9e0d9f30">moveContentsTo</a> (<a class="el" href="classregina_1_1Link.html">Link</a> &amp;dest)</td></tr>
<tr class="memdesc:a45e483730179d76b3e17635b9e0d9f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this link into the given destination link, leaving this link empty but otherwise usable.  <br /></td></tr>
<tr class="separator:a45e483730179d76b3e17635b9e0d9f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d386bea941e436ae6548aa8663a005b" id="r_a0d386bea941e436ae6548aa8663a005b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d386bea941e436ae6548aa8663a005b">change</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a0d386bea941e436ae6548aa8663a005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of the given crossing.  <br /></td></tr>
<tr class="separator:a0d386bea941e436ae6548aa8663a005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546dc7f2bde7b63c31f3e057a8c04db" id="r_a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0546dc7f2bde7b63c31f3e057a8c04db">changeAll</a> ()</td></tr>
<tr class="memdesc:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the diagram.  <br /></td></tr>
<tr class="separator:a0546dc7f2bde7b63c31f3e057a8c04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da54fa7f3352392989e34629c314a91" id="r_a6da54fa7f3352392989e34629c314a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da54fa7f3352392989e34629c314a91">resolve</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *c)</td></tr>
<tr class="memdesc:a6da54fa7f3352392989e34629c314a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the given crossing.  <br /></td></tr>
<tr class="separator:a6da54fa7f3352392989e34629c314a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25abd1f1f1a4ed85dc4d3e69a4ccd01" id="r_aa25abd1f1f1a4ed85dc4d3e69a4ccd01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25abd1f1f1a4ed85dc4d3e69a4ccd01">makeVirtual</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>)</td></tr>
<tr class="memdesc:aa25abd1f1f1a4ed85dc4d3e69a4ccd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given classical crossing into a virtual crossing.  <br /></td></tr>
<tr class="separator:aa25abd1f1f1a4ed85dc4d3e69a4ccd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2753c171099f2c2063080eebd78a1e1d" id="r_a2753c171099f2c2063080eebd78a1e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2753c171099f2c2063080eebd78a1e1d">graft</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> first, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> second)</td></tr>
<tr class="memdesc:a2753c171099f2c2063080eebd78a1e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grafts the two given arcs of this link together, possibly making this a virtual link in the process.  <br /></td></tr>
<tr class="separator:a2753c171099f2c2063080eebd78a1e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4396c9fcb99dbb3bb4ba7176b859c4" id="r_a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4396c9fcb99dbb3bb4ba7176b859c4">reflect</a> ()</td></tr>
<tr class="memdesc:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this link into its reflection.  <br /></td></tr>
<tr class="separator:a8b4396c9fcb99dbb3bb4ba7176b859c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b8f0dd10461df6f5b535fb3991bce" id="r_a078b8f0dd10461df6f5b535fb3991bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078b8f0dd10461df6f5b535fb3991bce">rotate</a> ()</td></tr>
<tr class="memdesc:a078b8f0dd10461df6f5b535fb3991bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this link diagram, effectively flipping the surface that contains it "upside-down".  <br /></td></tr>
<tr class="separator:a078b8f0dd10461df6f5b535fb3991bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326a4e30a7cfb373020c4c6084775fc" id="r_a9326a4e30a7cfb373020c4c6084775fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9326a4e30a7cfb373020c4c6084775fc">reverse</a> ()</td></tr>
<tr class="memdesc:a9326a4e30a7cfb373020c4c6084775fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of every component of this link.  <br /></td></tr>
<tr class="separator:a9326a4e30a7cfb373020c4c6084775fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267e0436a8d5c13d120fe9a24d25dc6" id="r_a2267e0436a8d5c13d120fe9a24d25dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2267e0436a8d5c13d120fe9a24d25dc6">reverse</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f">component</a>)</td></tr>
<tr class="memdesc:a2267e0436a8d5c13d120fe9a24d25dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the orientation of just the link component that contains the given strand.  <br /></td></tr>
<tr class="separator:a2267e0436a8d5c13d120fe9a24d25dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c7e8a7048b0bf1e00f8eb5c942a224" id="r_a36c7e8a7048b0bf1e00f8eb5c942a224"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36c7e8a7048b0bf1e00f8eb5c942a224">makeAlternating</a> ()</td></tr>
<tr class="memdesc:a36c7e8a7048b0bf1e00f8eb5c942a224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a subset of crossings to convert this into an alternating link diagram.  <br /></td></tr>
<tr class="separator:a36c7e8a7048b0bf1e00f8eb5c942a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae2550f08ceb1a86346ef855841b3c0" id="r_a7ae2550f08ceb1a86346ef855841b3c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0">r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>)</td></tr>
<tr class="memdesc:a7ae2550f08ceb1a86346ef855841b3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type I Reidemeister move to remove a crossing at the given location.  <br /></td></tr>
<tr class="separator:a7ae2550f08ceb1a86346ef855841b3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2f9c488b1371df1cd94a1c325f201b" id="r_a8d2f9c488b1371df1cd94a1c325f201b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b">r1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign)</td></tr>
<tr class="memdesc:a8d2f9c488b1371df1cd94a1c325f201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type I Reidemeister move to add a new crossing at the given location.  <br /></td></tr>
<tr class="separator:a8d2f9c488b1371df1cd94a1c325f201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e19cade08a16bf715144c8ff936588" id="r_a45e19cade08a16bf715144c8ff936588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e19cade08a16bf715144c8ff936588">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc)</td></tr>
<tr class="memdesc:a45e19cade08a16bf715144c8ff936588"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type II Reidemeister move to remove two crossings at the given location.  <br /></td></tr>
<tr class="separator:a45e19cade08a16bf715144c8ff936588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db0094a1e976219e5b0591dc097b4f4" id="r_a7db0094a1e976219e5b0591dc097b4f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4">r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>)</td></tr>
<tr class="memdesc:a7db0094a1e976219e5b0591dc097b4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type II Reidemeister move to remove two crossings at the given location.  <br /></td></tr>
<tr class="separator:a7db0094a1e976219e5b0591dc097b4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee1e216fdf92f6e6a1a6d1102b93e5" id="r_a57ee1e216fdf92f6e6a1a6d1102b93e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide)</td></tr>
<tr class="memdesc:a57ee1e216fdf92f6e6a1a6d1102b93e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:a57ee1e216fdf92f6e6a1a6d1102b93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1060d281ec2528f588c68574d3898b6" id="r_aa1060d281ec2528f588c68574d3898b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1060d281ec2528f588c68574d3898b6">r2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide)</td></tr>
<tr class="memdesc:aa1060d281ec2528f588c68574d3898b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:aa1060d281ec2528f588c68574d3898b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea62146d69fc238e33607bc8a5b1625" id="r_acea62146d69fc238e33607bc8a5b1625"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea62146d69fc238e33607bc8a5b1625">r2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int firstSide, int firstStrand)</td></tr>
<tr class="memdesc:acea62146d69fc238e33607bc8a5b1625"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing the same strand over itself from opposite sides.  <br /></td></tr>
<tr class="separator:acea62146d69fc238e33607bc8a5b1625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f1ba6a75e2ed768d2a2fcbc31ae659" id="r_a96f1ba6a75e2ed768d2a2fcbc31ae659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659">r3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side)</td></tr>
<tr class="memdesc:a96f1ba6a75e2ed768d2a2fcbc31ae659"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:a96f1ba6a75e2ed768d2a2fcbc31ae659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18378f79ad72d46190b554a17ba1939" id="r_ae18378f79ad72d46190b554a17ba1939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18378f79ad72d46190b554a17ba1939">r3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side)</td></tr>
<tr class="memdesc:ae18378f79ad72d46190b554a17ba1939"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, performs a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:ae18378f79ad72d46190b554a17ba1939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6330cab75e59e6a004881950bda21" id="r_adfc6330cab75e59e6a004881950bda21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfc6330cab75e59e6a004881950bda21">hasR1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>) const</td></tr>
<tr class="memdesc:adfc6330cab75e59e6a004881950bda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type I Reidemeister move at the given location to remove a crossing.  <br /></td></tr>
<tr class="separator:adfc6330cab75e59e6a004881950bda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8894af24677e11354d2cb016cb5a8c" id="r_a8c8894af24677e11354d2cb016cb5a8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c8894af24677e11354d2cb016cb5a8c">hasR1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign) const</td></tr>
<tr class="memdesc:a8c8894af24677e11354d2cb016cb5a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type I Reidemeister move at the given location to add a new crossing.  <br /></td></tr>
<tr class="separator:a8c8894af24677e11354d2cb016cb5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161b736f83359e024d846150cdf055ae" id="r_a161b736f83359e024d846150cdf055ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a161b736f83359e024d846150cdf055ae">hasR2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc) const</td></tr>
<tr class="memdesc:a161b736f83359e024d846150cdf055ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type II Reidemeister move at the given location to remove two crossings.  <br /></td></tr>
<tr class="separator:a161b736f83359e024d846150cdf055ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2675d20037ea641fb1de848f29b080" id="r_a1a2675d20037ea641fb1de848f29b080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2675d20037ea641fb1de848f29b080">hasR2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>) const</td></tr>
<tr class="memdesc:a1a2675d20037ea641fb1de848f29b080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type II Reidemeister move at the given location to remove two crossings.  <br /></td></tr>
<tr class="separator:a1a2675d20037ea641fb1de848f29b080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1415e0c84f6fc38f23c937c14f531267" id="r_a1415e0c84f6fc38f23c937c14f531267"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1415e0c84f6fc38f23c937c14f531267">hasR2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide) const</td></tr>
<tr class="memdesc:a1415e0c84f6fc38f23c937c14f531267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a classical type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:a1415e0c84f6fc38f23c937c14f531267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48519e0f98023bf0bc876a0f9a843e28" id="r_a48519e0f98023bf0bc876a0f9a843e28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48519e0f98023bf0bc876a0f9a843e28">hasR2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide) const</td></tr>
<tr class="memdesc:a48519e0f98023bf0bc876a0f9a843e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a virtual type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:a48519e0f98023bf0bc876a0f9a843e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb56e9f8c7c2522315a46c174683637c" id="r_afb56e9f8c7c2522315a46c174683637c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb56e9f8c7c2522315a46c174683637c">hasR2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int firstSide, int firstStrand) const</td></tr>
<tr class="memdesc:afb56e9f8c7c2522315a46c174683637c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a virtual type II Reidemeister move at the given location to add two new crossings by pushing the same strand over itself from opposite sides.  <br /></td></tr>
<tr class="separator:afb56e9f8c7c2522315a46c174683637c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16752ca1a1b0efb69c577d62d3a41cd2" id="r_a16752ca1a1b0efb69c577d62d3a41cd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16752ca1a1b0efb69c577d62d3a41cd2">hasR3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side) const</td></tr>
<tr class="memdesc:a16752ca1a1b0efb69c577d62d3a41cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:a16752ca1a1b0efb69c577d62d3a41cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cd07a5c9e2777dcec94c99f7f5324a" id="r_a83cd07a5c9e2777dcec94c99f7f5324a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83cd07a5c9e2777dcec94c99f7f5324a">hasR3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side) const</td></tr>
<tr class="memdesc:a83cd07a5c9e2777dcec94c99f7f5324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether it is possible to perform a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:a83cd07a5c9e2777dcec94c99f7f5324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca0c0d2925871a768af0002340230af" id="r_acca0c0d2925871a768af0002340230af"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acca0c0d2925871a768af0002340230af">withR1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>) const</td></tr>
<tr class="memdesc:acca0c0d2925871a768af0002340230af"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type I Reidemeister move at the given location to remove a crossing.  <br /></td></tr>
<tr class="separator:acca0c0d2925871a768af0002340230af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af183bb609a8b0b57d2e873d4d954c241" id="r_af183bb609a8b0b57d2e873d4d954c241"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af183bb609a8b0b57d2e873d4d954c241">withR1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign) const</td></tr>
<tr class="memdesc:af183bb609a8b0b57d2e873d4d954c241"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type I Reidemeister move at the given location to add a new crossing.  <br /></td></tr>
<tr class="separator:af183bb609a8b0b57d2e873d4d954c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd7545786a707faa8fa2065e4d40526" id="r_a9bd7545786a707faa8fa2065e4d40526"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bd7545786a707faa8fa2065e4d40526">withR2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc) const</td></tr>
<tr class="memdesc:a9bd7545786a707faa8fa2065e4d40526"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type II Reidemeister move at the given location to remove two crossings.  <br /></td></tr>
<tr class="separator:a9bd7545786a707faa8fa2065e4d40526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5011e93c3f785d127db6d5d89e96f83" id="r_ac5011e93c3f785d127db6d5d89e96f83"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5011e93c3f785d127db6d5d89e96f83">withR2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>) const</td></tr>
<tr class="memdesc:ac5011e93c3f785d127db6d5d89e96f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type II Reidemeister move at the given location to remove two crossings.  <br /></td></tr>
<tr class="separator:ac5011e93c3f785d127db6d5d89e96f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d60fa28fe84aeadaaeb28f508dcaa" id="r_a386d60fa28fe84aeadaaeb28f508dcaa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a386d60fa28fe84aeadaaeb28f508dcaa">withR2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide) const</td></tr>
<tr class="memdesc:a386d60fa28fe84aeadaaeb28f508dcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a classical type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:a386d60fa28fe84aeadaaeb28f508dcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bca178eb78184eacf31be5ef98baed0" id="r_a0bca178eb78184eacf31be5ef98baed0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bca178eb78184eacf31be5ef98baed0">withR2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide) const</td></tr>
<tr class="memdesc:a0bca178eb78184eacf31be5ef98baed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a virtual type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:a0bca178eb78184eacf31be5ef98baed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c677ecb4b8c2f76e4d495e4f951d1b" id="r_ad8c677ecb4b8c2f76e4d495e4f951d1b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c677ecb4b8c2f76e4d495e4f951d1b">withR2Virtual</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int firstSide, int firstStrand) const</td></tr>
<tr class="memdesc:ad8c677ecb4b8c2f76e4d495e4f951d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a virtual type II Reidemeister move at the given location to add two new crossings by pushing the same strand over itself from opposite sides.  <br /></td></tr>
<tr class="separator:ad8c677ecb4b8c2f76e4d495e4f951d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431227a92748747e60dde1f7b7ecbc9a" id="r_a431227a92748747e60dde1f7b7ecbc9a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431227a92748747e60dde1f7b7ecbc9a">withR3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side) const</td></tr>
<tr class="memdesc:a431227a92748747e60dde1f7b7ecbc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:a431227a92748747e60dde1f7b7ecbc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966de1bbc0821c23a408a038cc5f6d0a" id="r_a966de1bbc0821c23a408a038cc5f6d0a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a966de1bbc0821c23a408a038cc5f6d0a">withR3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side) const</td></tr>
<tr class="memdesc:a966de1bbc0821c23a408a038cc5f6d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If possible, returns the diagram obtained by performing a type III Reidemeister move at the given location.  <br /></td></tr>
<tr class="separator:a966de1bbc0821c23a408a038cc5f6d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c37f31a7ce0214b319288bd16f27a28" id="r_a5c37f31a7ce0214b319288bd16f27a28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c37f31a7ce0214b319288bd16f27a28">r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a5c37f31a7ce0214b319288bd16f27a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type I Reidemeister move to remove a crossing.  <br /></td></tr>
<tr class="separator:a5c37f31a7ce0214b319288bd16f27a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ae0e05e8d6791167c3ae7ab149f97" id="r_a831ae0e05e8d6791167c3ae7ab149f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831ae0e05e8d6791167c3ae7ab149f97">r1</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, int sign, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a831ae0e05e8d6791167c3ae7ab149f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type I Reidemeister move to add a new crossing.  <br /></td></tr>
<tr class="separator:a831ae0e05e8d6791167c3ae7ab149f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272a63d07cd7762af9fe45c12dad620" id="r_ac272a63d07cd7762af9fe45c12dad620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac272a63d07cd7762af9fe45c12dad620">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:ac272a63d07cd7762af9fe45c12dad620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type II Reidemeister move to remove two crossings.  <br /></td></tr>
<tr class="separator:ac272a63d07cd7762af9fe45c12dad620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55c416469fc53af9b34bedfa7f1cdce" id="r_ac55c416469fc53af9b34bedfa7f1cdce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac55c416469fc53af9b34bedfa7f1cdce">r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:ac55c416469fc53af9b34bedfa7f1cdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type II Reidemeister move to remove two crossings.  <br /></td></tr>
<tr class="separator:ac55c416469fc53af9b34bedfa7f1cdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c10fe8c35fed9d165063161f40e0c3" id="r_aa9c10fe8c35fed9d165063161f40e0c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c10fe8c35fed9d165063161f40e0c3">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> upperArc, int upperSide, <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> lowerArc, int lowerSide, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:aa9c10fe8c35fed9d165063161f40e0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a classical type II Reidemeister move to add two new crossings by pushing two different strands over one another.  <br /></td></tr>
<tr class="separator:aa9c10fe8c35fed9d165063161f40e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de29a853ab4cbecdc5e8bffa4d8c631" id="r_a3de29a853ab4cbecdc5e8bffa4d8c631"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de29a853ab4cbecdc5e8bffa4d8c631">r3</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, int side, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a3de29a853ab4cbecdc5e8bffa4d8c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type III Reidemeister move.  <br /></td></tr>
<tr class="separator:a3de29a853ab4cbecdc5e8bffa4d8c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d5618df71eb7b586cdf12cbdbe5ce" id="r_a095d5618df71eb7b586cdf12cbdbe5ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a095d5618df71eb7b586cdf12cbdbe5ce">r3</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="#a2b47712bc419c15659a634ae6ea97b91">crossing</a>, int side, bool ignored, bool perform=true)</td></tr>
<tr class="memdesc:a095d5618df71eb7b586cdf12cbdbe5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that tests for and optionally performs a type III Reidemeister move.  <br /></td></tr>
<tr class="separator:a095d5618df71eb7b586cdf12cbdbe5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6293eb60b5477b5cac84363c43286a" id="r_acb6293eb60b5477b5cac84363c43286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb6293eb60b5477b5cac84363c43286a">hasReducingPass</a> () const</td></tr>
<tr class="memdesc:acb6293eb60b5477b5cac84363c43286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this classical link has a pass move that will reduce the number of crossings.  <br /></td></tr>
<tr class="separator:acb6293eb60b5477b5cac84363c43286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8dae4e7fb5347ac969b3e07f07c96b" id="r_a1c8dae4e7fb5347ac969b3e07f07c96b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8dae4e7fb5347ac969b3e07f07c96b">selfFrame</a> ()</td></tr>
<tr class="memdesc:a1c8dae4e7fb5347ac969b3e07f07c96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds trivial twists to this link to ensure that each component has zero writhe.  <br /></td></tr>
<tr class="separator:a1c8dae4e7fb5347ac969b3e07f07c96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae2d7740007b145ca98a0c8e4f4d2d9" id="r_a0ae2d7740007b145ca98a0c8e4f4d2d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a> ()</td></tr>
<tr class="memdesc:a0ae2d7740007b145ca98a0c8e4f4d2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.  <br /></td></tr>
<tr class="separator:a0ae2d7740007b145ca98a0c8e4f4d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc961ba707da75f2b71d3585c994cc9" id="r_a5fc961ba707da75f2b71d3585c994cc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fc961ba707da75f2b71d3585c994cc9">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:a5fc961ba707da75f2b71d3585c994cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a>, which attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.  <br /></td></tr>
<tr class="separator:a5fc961ba707da75f2b71d3585c994cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf6c87c3dc80de018d659e686b48ef" id="r_a3adf6c87c3dc80de018d659e686b48ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3adf6c87c3dc80de018d659e686b48ef">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:a3adf6c87c3dc80de018d659e686b48ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings.  <br /></td></tr>
<tr class="separator:a3adf6c87c3dc80de018d659e686b48ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348fb1c73d7db51376811fe090129a27" id="r_a348fb1c73d7db51376811fe090129a27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a348fb1c73d7db51376811fe090129a27">simplifyExhaustive</a> (int height=1, int threads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a348fb1c73d7db51376811fe090129a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister graph.  <br /></td></tr>
<tr class="separator:a348fb1c73d7db51376811fe090129a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba30ef9cfbb6a6064faade1c4c00bf" id="r_ae5ba30ef9cfbb6a6064faade1c4c00bf"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ae5ba30ef9cfbb6a6064faade1c4c00bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf">rewrite</a> (int height, int threads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ae5ba30ef9cfbb6a6064faade1c4c00bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all link diagrams that can be reached from this via classical Reidemeister moves, without exceeding a given number of additional crossings.  <br /></td></tr>
<tr class="separator:ae5ba30ef9cfbb6a6064faade1c4c00bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf25646ce19fa74f829555a00c686e3d" id="r_adf25646ce19fa74f829555a00c686e3d"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:adf25646ce19fa74f829555a00c686e3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf25646ce19fa74f829555a00c686e3d">rewriteVirtual</a> (int height, int threads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:adf25646ce19fa74f829555a00c686e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all link diagrams that can be reached from this via classical and/or virtual Reidemeister moves, without exceeding a given number of additional crossings.  <br /></td></tr>
<tr class="separator:adf25646ce19fa74f829555a00c686e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28355f40d08c312c5f2e6cceb68bc1b4" id="r_a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28355f40d08c312c5f2e6cceb68bc1b4">composeWith</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;other)</td></tr>
<tr class="memdesc:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the composition of this with the given link.  <br /></td></tr>
<tr class="separator:a28355f40d08c312c5f2e6cceb68bc1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Links</div></td></tr>
<tr class="memitem:a805821d3da773fdd9a69f75916dbd90e" id="r_a805821d3da773fdd9a69f75916dbd90e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a805821d3da773fdd9a69f75916dbd90e">brief</a> () const</td></tr>
<tr class="memdesc:a805821d3da773fdd9a69f75916dbd90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this link in Regina's own brief write-only format.  <br /></td></tr>
<tr class="separator:a805821d3da773fdd9a69f75916dbd90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af770913610307338a7a319f38628981c" id="r_af770913610307338a7a319f38628981c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af770913610307338a7a319f38628981c">brief</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af770913610307338a7a319f38628981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this link in Regina's own brief format to the given output stream.  <br /></td></tr>
<tr class="separator:af770913610307338a7a319f38628981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05b65401950517d86be107268233b09" id="r_ac05b65401950517d86be107268233b09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac05b65401950517d86be107268233b09">gauss</a> () const</td></tr>
<tr class="memdesc:ac05b65401950517d86be107268233b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a classical Gauss code for this knot, presented as a string.  <br /></td></tr>
<tr class="separator:ac05b65401950517d86be107268233b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb54431be1dd0e3295ef9ac07ecb739" id="r_a6fb54431be1dd0e3295ef9ac07ecb739"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb54431be1dd0e3295ef9ac07ecb739">gaussData</a> () const</td></tr>
<tr class="memdesc:a6fb54431be1dd0e3295ef9ac07ecb739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a classical Gauss code for this knot, presented as a vector of integers.  <br /></td></tr>
<tr class="separator:a6fb54431be1dd0e3295ef9ac07ecb739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8c0d2be78044e3fc4108e092d086a5" id="r_a5d8c0d2be78044e3fc4108e092d086a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d8c0d2be78044e3fc4108e092d086a5">gauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5d8c0d2be78044e3fc4108e092d086a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a classical Gauss code for this knot to the given output stream.  <br /></td></tr>
<tr class="separator:a5d8c0d2be78044e3fc4108e092d086a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d81af83901af217da0bee17b6bf120" id="r_ab8d81af83901af217da0bee17b6bf120"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8d81af83901af217da0bee17b6bf120">orientedGauss</a> () const</td></tr>
<tr class="memdesc:ab8d81af83901af217da0bee17b6bf120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an oriented Gauss code for this knot, presented as a string.  <br /></td></tr>
<tr class="separator:ab8d81af83901af217da0bee17b6bf120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c104bb3fa0b1cf4a73d85be984eac46" id="r_a5c104bb3fa0b1cf4a73d85be984eac46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c104bb3fa0b1cf4a73d85be984eac46">orientedGaussData</a> () const</td></tr>
<tr class="memdesc:a5c104bb3fa0b1cf4a73d85be984eac46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an oriented Gauss code for this knot, presented as a vector of string tokens.  <br /></td></tr>
<tr class="separator:a5c104bb3fa0b1cf4a73d85be984eac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eaa9351a071dc7ddcf8e4d1101d584" id="r_a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21eaa9351a071dc7ddcf8e4d1101d584">orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this knot to the given output stream.  <br /></td></tr>
<tr class="separator:a21eaa9351a071dc7ddcf8e4d1101d584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e194d012a863db3a04924a418636ec7" id="r_a5e194d012a863db3a04924a418636ec7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e194d012a863db3a04924a418636ec7">signedGauss</a> () const</td></tr>
<tr class="memdesc:a5e194d012a863db3a04924a418636ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signed Gauss code for this knot, presented as a string.  <br /></td></tr>
<tr class="separator:a5e194d012a863db3a04924a418636ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a8987f90620d980eb23783090081b2" id="r_a82a8987f90620d980eb23783090081b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a8987f90620d980eb23783090081b2">signedGaussData</a> () const</td></tr>
<tr class="memdesc:a82a8987f90620d980eb23783090081b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signed Gauss code for this knot, presented as a vector of string tokens.  <br /></td></tr>
<tr class="separator:a82a8987f90620d980eb23783090081b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a204839898248a5caaf5e18119eeb0" id="r_ac4a204839898248a5caaf5e18119eeb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a204839898248a5caaf5e18119eeb0">signedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac4a204839898248a5caaf5e18119eeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a signed Gauss code for this knot to the given output stream.  <br /></td></tr>
<tr class="separator:ac4a204839898248a5caaf5e18119eeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f84f5ad2fb28ab1a0da34aa69d8a8" id="r_a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8">jenkins</a> () const</td></tr>
<tr class="memdesc:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link using Bob Jenkins' text format, returning a single string.  <br /></td></tr>
<tr class="separator:a194f84f5ad2fb28ab1a0da34aa69d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2e96eaaf8284a8f6afc0094ccd793" id="r_a73f2e96eaaf8284a8f6afc0094ccd793"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f2e96eaaf8284a8f6afc0094ccd793">jenkinsData</a> () const</td></tr>
<tr class="memdesc:a73f2e96eaaf8284a8f6afc0094ccd793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link using Bob Jenkins' text format, returning a vector of integers.  <br /></td></tr>
<tr class="separator:a73f2e96eaaf8284a8f6afc0094ccd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6509ca2eaf2920bf4dc7e69eb5f5f499" id="r_a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6509ca2eaf2920bf4dc7e69eb5f5f499">jenkins</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this link to the given output stream using Bob Jenkins' text format.  <br /></td></tr>
<tr class="separator:a6509ca2eaf2920bf4dc7e69eb5f5f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7394cd7aa9cb8d14cb4d7d39f9d96478" id="r_a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7394cd7aa9cb8d14cb4d7d39f9d96478">dt</a> (bool alpha=false) const</td></tr>
<tr class="memdesc:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this classical knot in either numerical or alphabetical Dowker-Thistlethwaite notation, returning a string.  <br /></td></tr>
<tr class="separator:a7394cd7aa9cb8d14cb4d7d39f9d96478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d3896af6c9aa96a53ab1ad68db95ab" id="r_a05d3896af6c9aa96a53ab1ad68db95ab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05d3896af6c9aa96a53ab1ad68db95ab">dtData</a> () const</td></tr>
<tr class="memdesc:a05d3896af6c9aa96a53ab1ad68db95ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers.  <br /></td></tr>
<tr class="separator:a05d3896af6c9aa96a53ab1ad68db95ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48b3891b1ec16cff1190f781e3ebd0" id="r_a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e48b3891b1ec16cff1190f781e3ebd0">dt</a> (std::ostream &amp;out, bool alpha=false) const</td></tr>
<tr class="memdesc:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this classical knot to the given output stream using Dowker-Thistlethwaite notation.  <br /></td></tr>
<tr class="separator:a6e48b3891b1ec16cff1190f781e3ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64e5e12c443073dda93c1a23d1be9e" id="r_aab64e5e12c443073dda93c1a23d1be9e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e">pd</a> () const</td></tr>
<tr class="memdesc:aab64e5e12c443073dda93c1a23d1be9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a planar diagram code for this link, presented as a string.  <br /></td></tr>
<tr class="separator:aab64e5e12c443073dda93c1a23d1be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf406224f5959aeab3bbe877f2498b0" id="r_abaf406224f5959aeab3bbe877f2498b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; int, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf406224f5959aeab3bbe877f2498b0">pdData</a> () const</td></tr>
<tr class="memdesc:abaf406224f5959aeab3bbe877f2498b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a planar diagram code for this link, presented as vector of 4-tuples.  <br /></td></tr>
<tr class="separator:abaf406224f5959aeab3bbe877f2498b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4429732bcfb4c8a26a69e06caa217413" id="r_a4429732bcfb4c8a26a69e06caa217413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4429732bcfb4c8a26a69e06caa217413">pd</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a4429732bcfb4c8a26a69e06caa217413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a planar diagram code for this link to the given output stream.  <br /></td></tr>
<tr class="separator:a4429732bcfb4c8a26a69e06caa217413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2297928a0d1eb98c2f53c1edbee344" id="r_a9d2297928a0d1eb98c2f53c1edbee344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2297928a0d1eb98c2f53c1edbee344">pdAmbiguous</a> () const</td></tr>
<tr class="memdesc:a9d2297928a0d1eb98c2f53c1edbee344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link has any components whose orientations cannot be recovered from a planar diagram code.  <br /></td></tr>
<tr class="separator:a9d2297928a0d1eb98c2f53c1edbee344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f682deb7aeb5c9e3b06c8db4aec3b92" id="r_a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f682deb7aeb5c9e3b06c8db4aec3b92">writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the underlying 4-valent multigraph for this link diagram using the PACE text format.  <br /></td></tr>
<tr class="separator:a8f682deb7aeb5c9e3b06c8db4aec3b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b21aaa8020908478576e1f9325d4f91" id="r_a6b21aaa8020908478576e1f9325d4f91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b21aaa8020908478576e1f9325d4f91">pace</a> () const</td></tr>
<tr class="memdesc:a6b21aaa8020908478576e1f9325d4f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a text representation of the underlying 4-valent multigraph for this link diagram, using the PACE text format.  <br /></td></tr>
<tr class="separator:a6b21aaa8020908478576e1f9325d4f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fbcb99b3014ab278782289b092403c" id="r_a53fbcb99b3014ab278782289b092403c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53fbcb99b3014ab278782289b092403c">source</a> (<a class="el" href="group__engine.html#ga4042b3d9832af20a99be34899e313442">Language</a> language=<a class="el" href="group__engine.html#gga4042b3d9832af20a99be34899e313442a222a267cc5778206b253be35ee3ddab5">Language::Current</a>) const</td></tr>
<tr class="memdesc:a53fbcb99b3014ab278782289b092403c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C++ or Python source code that can be used to reconstruct this link.  <br /></td></tr>
<tr class="separator:a53fbcb99b3014ab278782289b092403c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718258433d47de780e6905585a00bd29" id="r_a718258433d47de780e6905585a00bd29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718258433d47de780e6905585a00bd29">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:a718258433d47de780e6905585a00bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns C++ code to reconstruct this link.  <br /></td></tr>
<tr class="separator:a718258433d47de780e6905585a00bd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690bcf5d0ded7fae75c63af1bf67c326" id="r_a690bcf5d0ded7fae75c63af1bf67c326"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326">sig</a> (bool allowReflection=true, bool allowReversal=true, bool allowRotation=true) const</td></tr>
<tr class="memdesc:a690bcf5d0ded7fae75c63af1bf67c326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <em>signature</em> for this knot or link diagram.  <br /></td></tr>
<tr class="separator:a690bcf5d0ded7fae75c63af1bf67c326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff04fa3e747640d374fd95f9d54ac3d" id="r_a4ff04fa3e747640d374fd95f9d54ac3d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff04fa3e747640d374fd95f9d54ac3d">knotSig</a> (bool allowReflection=true, bool allowReversal=true, bool allowRotation=true) const</td></tr>
<tr class="memdesc:a4ff04fa3e747640d374fd95f9d54ac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a>, which constructs the signature for this knot or link diagram.  <br /></td></tr>
<tr class="separator:a4ff04fa3e747640d374fd95f9d54ac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31d64de793d9791c85f7ce04ae903f8" id="r_ae31d64de793d9791c85f7ce04ae903f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae31d64de793d9791c85f7ce04ae903f8">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ae31d64de793d9791c85f7ce04ae903f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this link to the given output stream.  <br /></td></tr>
<tr class="separator:ae31d64de793d9791c85f7ce04ae903f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228ed6330752dc62de8a611075e05280" id="r_a228ed6330752dc62de8a611075e05280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a228ed6330752dc62de8a611075e05280">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a228ed6330752dc62de8a611075e05280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this link to the given output stream.  <br /></td></tr>
<tr class="separator:a228ed6330752dc62de8a611075e05280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075bf4f759b540961ee47b1e5364b492" id="r_a075bf4f759b540961ee47b1e5364b492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075bf4f759b540961ee47b1e5364b492">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a075bf4f759b540961ee47b1e5364b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this link to the given output stream.  <br /></td></tr>
<tr class="separator:a075bf4f759b540961ee47b1e5364b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab12d1934a6010781108fe8b5ece0ac2d" id="r_ab12d1934a6010781108fe8b5ece0ac2d"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab12d1934a6010781108fe8b5ece0ac2d">alexanderVar</a> = &quot;t&quot;</td></tr>
<tr class="memdesc:ab12d1934a6010781108fe8b5ece0ac2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Alexander polynomial, as returned by <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a>.  <br /></td></tr>
<tr class="separator:ab12d1934a6010781108fe8b5ece0ac2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365f08df3a98992ccc0c2c22f23958c6" id="r_a365f08df3a98992ccc0c2c22f23958c6"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365f08df3a98992ccc0c2c22f23958c6">jonesVar</a> = &quot;\u221At&quot;</td></tr>
<tr class="memdesc:a365f08df3a98992ccc0c2c22f23958c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Jones polynomial, as returned by <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>.  <br /></td></tr>
<tr class="separator:a365f08df3a98992ccc0c2c22f23958c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa36436fbc04ca5eca7330083fb089aa" id="r_aaa36436fbc04ca5eca7330083fb089aa"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa36436fbc04ca5eca7330083fb089aa">bracketVar</a> = &quot;A&quot;</td></tr>
<tr class="memdesc:aaa36436fbc04ca5eca7330083fb089aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the Kauffman bracket, as returned by <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a>.  <br /></td></tr>
<tr class="separator:aaa36436fbc04ca5eca7330083fb089aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f761ba1c3d1badabc9638c27192db" id="r_ad65f761ba1c3d1badabc9638c27192db"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a> = &quot;\u03B1&quot;</td></tr>
<tr class="memdesc:ad65f761ba1c3d1badabc9638c27192db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a>.  <br /></td></tr>
<tr class="separator:ad65f761ba1c3d1badabc9638c27192db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acb282c9b668b106d63b5180e34f7f2" id="r_a7acb282c9b668b106d63b5180e34f7f2"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a> = &quot;z&quot;</td></tr>
<tr class="memdesc:a7acb282c9b668b106d63b5180e34f7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a>.  <br /></td></tr>
<tr class="separator:a7acb282c9b668b106d63b5180e34f7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce5812b285b56f767c8b3863c13b0c" id="r_af9ce5812b285b56f767c8b3863c13b0c"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ce5812b285b56f767c8b3863c13b0c">homflyLMVarX</a> = &quot;\U0001D4C1&quot;</td></tr>
<tr class="memdesc:af9ce5812b285b56f767c8b3863c13b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a>.  <br /></td></tr>
<tr class="separator:af9ce5812b285b56f767c8b3863c13b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73f30e80276f03658f7d733827631d3" id="r_af73f30e80276f03658f7d733827631d3"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af73f30e80276f03658f7d733827631d3">homflyLMVarY</a> = &quot;m&quot;</td></tr>
<tr class="memdesc:af73f30e80276f03658f7d733827631d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a>.  <br /></td></tr>
<tr class="separator:af73f30e80276f03658f7d733827631d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0447b2d9ec84403a4e07f09198c0d3" id="r_a6b0447b2d9ec84403a4e07f09198c0d3"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0447b2d9ec84403a4e07f09198c0d3">homflyVarX</a> = <a class="el" href="#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a></td></tr>
<tr class="memdesc:a6b0447b2d9ec84403a4e07f09198c0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a>.  <br /></td></tr>
<tr class="separator:a6b0447b2d9ec84403a4e07f09198c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e77ac33d5598dac3aeca46abc71cde" id="r_ae3e77ac33d5598dac3aeca46abc71cde"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e77ac33d5598dac3aeca46abc71cde">homflyVarY</a> = <a class="el" href="#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a></td></tr>
<tr class="memdesc:ae3e77ac33d5598dac3aeca46abc71cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a>.  <br /></td></tr>
<tr class="separator:ae3e77ac33d5598dac3aeca46abc71cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1372a5ee63aa57d809b4ac581f58c08" id="r_ad1372a5ee63aa57d809b4ac581f58c08"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1372a5ee63aa57d809b4ac581f58c08">affineIndexVar</a> = &quot;t&quot;</td></tr>
<tr class="memdesc:ad1372a5ee63aa57d809b4ac581f58c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the variable used in the affine index polynomial, as returned by <a class="el" href="#a7cb66a5de5c06536f6b2161ee8ed8334" title="Returns the affine index polynomial of this knot.">affineIndex()</a>.  <br /></td></tr>
<tr class="separator:ad1372a5ee63aa57d809b4ac581f58c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5857fcc6d1187bc8d72b900fef3161d6" id="r_a5857fcc6d1187bc8d72b900fef3161d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TopologyLockable.html#a5857fcc6d1187bc8d72b900fef3161d6">topologyLocked</a> () const</td></tr>
<tr class="memdesc:a5857fcc6d1187bc8d72b900fef3161d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not there are any topology locks currently held on this object.  <br /></td></tr>
<tr class="separator:a5857fcc6d1187bc8d72b900fef3161d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b" id="r_a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f83f8f5e9df2281cb7b65b1d46bd4c" id="r_a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TopologyLockable.html#a11f83f8f5e9df2281cb7b65b1d46bd4c">topologyLock_</a> { 0 }</td></tr>
<tr class="memdesc:a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of topology locks currently held on this object.  <br /></td></tr>
<tr class="separator:a11f83f8f5e9df2281cb7b65b1d46bd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Links</h2></td></tr>
<tr class="memitem:a152f80ab20cfd6daa9bb33498700957f" id="r_a152f80ab20cfd6daa9bb33498700957f"><td class="memItemLeft" align="right" valign="top"><a id="a152f80ab20cfd6daa9bb33498700957f" name="a152f80ab20cfd6daa9bb33498700957f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ModelLinkGraph</b></td></tr>
<tr class="separator:a152f80ab20cfd6daa9bb33498700957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0f99129b1f0437af4889ff9e1bd486" id="r_a5b0f99129b1f0437af4889ff9e1bd486"><td class="memItemLeft" align="right" valign="top"><a id="a5b0f99129b1f0437af4889ff9e1bd486" name="a5b0f99129b1f0437af4889ff9e1bd486"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Tangle</b></td></tr>
<tr class="separator:a5b0f99129b1f0437af4889ff9e1bd486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427ed4036a7fdf0f108da0bbf1ca863" id="r_ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memItemLeft" align="right" valign="top"><a id="ac427ed4036a7fdf0f108da0bbf1ca863" name="ac427ed4036a7fdf0f108da0bbf1ca863"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkCrossingsReader</b></td></tr>
<tr class="separator:ac427ed4036a7fdf0f108da0bbf1ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3f892e9d18731f9bee8f2a197e904" id="r_acab3f892e9d18731f9bee8f2a197e904"><td class="memItemLeft" align="right" valign="top"><a id="acab3f892e9d18731f9bee8f2a197e904" name="acab3f892e9d18731f9bee8f2a197e904"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLinkComponentsReader</b></td></tr>
<tr class="separator:acab3f892e9d18731f9bee8f2a197e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af7ff9e26b814bb897bfcea95afabe" id="r_a10af7ff9e26b814bb897bfcea95afabe"><td class="memItemLeft" align="right" valign="top"><a id="a10af7ff9e26b814bb897bfcea95afabe" name="a10af7ff9e26b814bb897bfcea95afabe"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLWriter&lt; Link &gt;</b></td></tr>
<tr class="separator:a10af7ff9e26b814bb897bfcea95afabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d6d31315c7b000cb653901a0a711c" id="r_aa11d6d31315c7b000cb653901a0a711c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa11d6d31315c7b000cb653901a0a711c">insertTorusLink</a> (int p, int q, bool positive=true)</td></tr>
<tr class="memdesc:aa11d6d31315c7b000cb653901a0a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new (<em>p</em>, <em>q</em>) torus link into this link.  <br /></td></tr>
<tr class="separator:aa11d6d31315c7b000cb653901a0a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f44d669e5b4139ad6bc8955ef9f5ce" id="r_a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13f44d669e5b4139ad6bc8955ef9f5ce">fromData</a> (std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... <a class="el" href="#a550ed4ff764fe10462582631b9798d6e">components</a>)</td></tr>
<tr class="memdesc:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from hard-coded information about its crossings and components.  <br /></td></tr>
<tr class="separator:a13f44d669e5b4139ad6bc8955ef9f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fd529b5fc4e76b2e0ee3acbef8968" id="r_a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memTemplParams" colspan="2">template&lt;typename SignIterator , typename ComponentIterator &gt; </td></tr>
<tr class="memitem:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d9fd529b5fc4e76b2e0ee3acbef8968">fromData</a> (SignIterator beginSigns, SignIterator endSigns, ComponentIterator beginComponents, ComponentIterator endComponents)</td></tr>
<tr class="memdesc:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from information about its crossings and components.  <br /></td></tr>
<tr class="separator:a9d9fd529b5fc4e76b2e0ee3acbef8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953fcb3a718b0460c02da8dd210403c8" id="r_a953fcb3a718b0460c02da8dd210403c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a953fcb3a718b0460c02da8dd210403c8">fromSig</a> (const std::string &amp;<a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326">sig</a>)</td></tr>
<tr class="memdesc:a953fcb3a718b0460c02da8dd210403c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a classical or virtual link diagram from its knot/link signature.  <br /></td></tr>
<tr class="separator:a953fcb3a718b0460c02da8dd210403c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef65e60726e56ea16fb943864f53cf3" id="r_a9ef65e60726e56ea16fb943864f53cf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef65e60726e56ea16fb943864f53cf3">fromKnotSig</a> (const std::string &amp;<a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326">sig</a>)</td></tr>
<tr class="memdesc:a9ef65e60726e56ea16fb943864f53cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a>, to recover a classical or virtual link diagram from its knot/link signature.  <br /></td></tr>
<tr class="separator:a9ef65e60726e56ea16fb943864f53cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac540c07f819bf0c967867bf04463cafc" id="r_ac540c07f819bf0c967867bf04463cafc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac540c07f819bf0c967867bf04463cafc">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:ac540c07f819bf0c967867bf04463cafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a classical or virtual link from its given tight encoding.  <br /></td></tr>
<tr class="separator:ac540c07f819bf0c967867bf04463cafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a3be3af017e42c2230fb8f847bf4d1" id="r_ab6a3be3af017e42c2230fb8f847bf4d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6a3be3af017e42c2230fb8f847bf4d1">fromGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ab6a3be3af017e42c2230fb8f847bf4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical knot from a classical Gauss code, presented as a string.  <br /></td></tr>
<tr class="separator:ab6a3be3af017e42c2230fb8f847bf4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a00fb45e8afa12a93a62a6f032479" id="r_a3c6a00fb45e8afa12a93a62a6f032479"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3c6a00fb45e8afa12a93a62a6f032479"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c6a00fb45e8afa12a93a62a6f032479">fromGauss</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a3c6a00fb45e8afa12a93a62a6f032479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical knot from a classical Gauss code, presented as an integer sequence.  <br /></td></tr>
<tr class="separator:a3c6a00fb45e8afa12a93a62a6f032479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb0b58804ab890b9de49ee36380d31" id="r_a0efb0b58804ab890b9de49ee36380d31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0efb0b58804ab890b9de49ee36380d31">fromOrientedGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a0efb0b58804ab890b9de49ee36380d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual knot from an "oriented" variant of the Gauss code, presented as string.  <br /></td></tr>
<tr class="separator:a0efb0b58804ab890b9de49ee36380d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641fd85222a55dfbf35c696e53a4ebbd" id="r_a641fd85222a55dfbf35c696e53a4ebbd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a641fd85222a55dfbf35c696e53a4ebbd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a641fd85222a55dfbf35c696e53a4ebbd">fromOrientedGauss</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a641fd85222a55dfbf35c696e53a4ebbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual knot from an "oriented" variant of the Gauss code, presented as a sequence of string tokens.  <br /></td></tr>
<tr class="separator:a641fd85222a55dfbf35c696e53a4ebbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad40609372ea6a1b1ae54550460e03" id="r_a4fad40609372ea6a1b1ae54550460e03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fad40609372ea6a1b1ae54550460e03">fromSignedGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a4fad40609372ea6a1b1ae54550460e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual knot from a "signed" variant of the Gauss code, presented as string.  <br /></td></tr>
<tr class="separator:a4fad40609372ea6a1b1ae54550460e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad13b0404b88f4953522178fa41c4c0d" id="r_aad13b0404b88f4953522178fa41c4c0d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aad13b0404b88f4953522178fa41c4c0d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad13b0404b88f4953522178fa41c4c0d">fromSignedGauss</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aad13b0404b88f4953522178fa41c4c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual knot from a "signed" variant of the Gauss code, presented as a sequence of string tokens.  <br /></td></tr>
<tr class="separator:aad13b0404b88f4953522178fa41c4c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39ba67b388f3b69f28c00fdb7c54a5" id="r_a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5">fromJenkins</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from Bob Jenkins' format, presented as a string.  <br /></td></tr>
<tr class="separator:a9b39ba67b388f3b69f28c00fdb7c54a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632cc9fb94359bb3f2f9c10d6a500208" id="r_a632cc9fb94359bb3f2f9c10d6a500208"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a632cc9fb94359bb3f2f9c10d6a500208">fromJenkins</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a632cc9fb94359bb3f2f9c10d6a500208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from Bob Jenkins' format, read directly from an input stream.  <br /></td></tr>
<tr class="separator:a632cc9fb94359bb3f2f9c10d6a500208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f11ca592dda9f6ac900e9bf09fd65" id="r_a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b1f11ca592dda9f6ac900e9bf09fd65">fromJenkins</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from Bob Jenkins' format, presented as an integer sequence.  <br /></td></tr>
<tr class="separator:a6b1f11ca592dda9f6ac900e9bf09fd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24bdd53db84c7fcbb4c40a51180111f" id="r_ae24bdd53db84c7fcbb4c40a51180111f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f">fromDT</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:ae24bdd53db84c7fcbb4c40a51180111f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation, presented as a string.  <br /></td></tr>
<tr class="separator:ae24bdd53db84c7fcbb4c40a51180111f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523518b438fc7884f28075a76851515a" id="r_a523518b438fc7884f28075a76851515a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a523518b438fc7884f28075a76851515a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a523518b438fc7884f28075a76851515a">fromDT</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a523518b438fc7884f28075a76851515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical knot from numerical Dowker-Thistlethwaite notation, presented as an integer sequence.  <br /></td></tr>
<tr class="separator:a523518b438fc7884f28075a76851515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a67c18fe7de681acb6cec84a6e922" id="r_a9a9a67c18fe7de681acb6cec84a6e922"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a9a67c18fe7de681acb6cec84a6e922">fromPD</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a9a9a67c18fe7de681acb6cec84a6e922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from a planar diagram code, presented as a string.  <br /></td></tr>
<tr class="separator:a9a9a67c18fe7de681acb6cec84a6e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb770fccc62c80b32d751d8c45b1c113" id="r_acb770fccc62c80b32d751d8c45b1c113"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:acb770fccc62c80b32d751d8c45b1c113"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb770fccc62c80b32d751d8c45b1c113">fromPD</a> (Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:acb770fccc62c80b32d751d8c45b1c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new classical or virtual link from a planar diagram code, presented as a sequence of 4-tuples.  <br /></td></tr>
<tr class="separator:acb770fccc62c80b32d751d8c45b1c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Invariants and Related Properties</h2></td></tr>
<tr class="memitem:a821a3c1d060bdc5f3807ee1a64064775" id="r_a821a3c1d060bdc5f3807ee1a64064775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a821a3c1d060bdc5f3807ee1a64064775">isAlternating</a> () const</td></tr>
<tr class="memdesc:a821a3c1d060bdc5f3807ee1a64064775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this link diagram is alternating.  <br /></td></tr>
<tr class="separator:a821a3c1d060bdc5f3807ee1a64064775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdacd0939c10de129dcf4c9a72f209c" id="r_a8cdacd0939c10de129dcf4c9a72f209c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cdacd0939c10de129dcf4c9a72f209c">linking</a> () const</td></tr>
<tr class="memdesc:a8cdacd0939c10de129dcf4c9a72f209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linking number of this link, or throws an exception if it is not an integer.  <br /></td></tr>
<tr class="separator:a8cdacd0939c10de129dcf4c9a72f209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13e27c0b1cbca7df9c541df3f567ea8" id="r_ab13e27c0b1cbca7df9c541df3f567ea8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab13e27c0b1cbca7df9c541df3f567ea8">linking2</a> () const</td></tr>
<tr class="memdesc:ab13e27c0b1cbca7df9c541df3f567ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns twice the linking number of this link, which is always an integer for both classical and virtual links.  <br /></td></tr>
<tr class="separator:ab13e27c0b1cbca7df9c541df3f567ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e5a318a8fdab39ebea49912074d19" id="r_aed6e5a318a8fdab39ebea49912074d19"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed6e5a318a8fdab39ebea49912074d19">writhe</a> () const</td></tr>
<tr class="memdesc:aed6e5a318a8fdab39ebea49912074d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of this link diagram.  <br /></td></tr>
<tr class="separator:aed6e5a318a8fdab39ebea49912074d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a069ee95598f2e1f27ab15a9de07dc" id="r_a93a069ee95598f2e1f27ab15a9de07dc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93a069ee95598f2e1f27ab15a9de07dc">writheOfComponent</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f">component</a>) const</td></tr>
<tr class="memdesc:a93a069ee95598f2e1f27ab15a9de07dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of a single component of this link diagram.  <br /></td></tr>
<tr class="separator:a93a069ee95598f2e1f27ab15a9de07dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe822e89589e9d9295299dd95d53e8" id="r_aa8fe822e89589e9d9295299dd95d53e8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8fe822e89589e9d9295299dd95d53e8">writheOfComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:aa8fe822e89589e9d9295299dd95d53e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the writhe of a single component of this link diagram.  <br /></td></tr>
<tr class="separator:aa8fe822e89589e9d9295299dd95d53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ef06ea5acfb81b4dd9f357988f1108" id="r_ae7ef06ea5acfb81b4dd9f357988f1108"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ef06ea5acfb81b4dd9f357988f1108">oddWrithe</a> () const</td></tr>
<tr class="memdesc:ae7ef06ea5acfb81b4dd9f357988f1108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the odd writhe, or self-linking number, of this knot.  <br /></td></tr>
<tr class="separator:ae7ef06ea5acfb81b4dd9f357988f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef04100b89965f3d9215ccd3b45c068d" id="r_aef04100b89965f3d9215ccd3b45c068d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef04100b89965f3d9215ccd3b45c068d">isClassical</a> () const</td></tr>
<tr class="memdesc:aef04100b89965f3d9215ccd3b45c068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this link diagram is classical (that is, planar).  <br /></td></tr>
<tr class="separator:aef04100b89965f3d9215ccd3b45c068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac664dc51d245b364d16e03cabf71b716" id="r_ac664dc51d245b364d16e03cabf71b716"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac664dc51d245b364d16e03cabf71b716">virtualGenus</a> () const</td></tr>
<tr class="memdesc:ac664dc51d245b364d16e03cabf71b716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the virtual genus of this link diagram.  <br /></td></tr>
<tr class="separator:ac664dc51d245b364d16e03cabf71b716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6035efd5fde17e1d4dd3b4e4c698859d" id="r_a6035efd5fde17e1d4dd3b4e4c698859d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6035efd5fde17e1d4dd3b4e4c698859d">seifertCircles</a> () const</td></tr>
<tr class="memdesc:a6035efd5fde17e1d4dd3b4e4c698859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Seifert circles for this link diagram.  <br /></td></tr>
<tr class="separator:a6035efd5fde17e1d4dd3b4e4c698859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac532f70e281f305bafaceb8c627b94" id="r_a7ac532f70e281f305bafaceb8c627b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac532f70e281f305bafaceb8c627b94">complement</a> (bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:a7ac532f70e281f305bafaceb8c627b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ideal triangulation of the complement of this link diagram.  <br /></td></tr>
<tr class="separator:a7ac532f70e281f305bafaceb8c627b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7e7a62ac8738aa49db49c497cd5327" id="r_acb7e7a62ac8738aa49db49c497cd5327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb7e7a62ac8738aa49db49c497cd5327">longComplement</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> breakOpen={}, bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:acb7e7a62ac8738aa49db49c497cd5327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats this as a long knot, and returns a triangulation of the complement with mixed real/ideal boundary.  <br /></td></tr>
<tr class="separator:acb7e7a62ac8738aa49db49c497cd5327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27dd16fa8758d69382f0ea271eff7c1" id="r_ac27dd16fa8758d69382f0ea271eff7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac27dd16fa8758d69382f0ea271eff7c1">whiteheadDouble</a> (bool positive=true) const</td></tr>
<tr class="memdesc:ac27dd16fa8758d69382f0ea271eff7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the untwisted positive or negative Whitehead double of this knot.  <br /></td></tr>
<tr class="separator:ac27dd16fa8758d69382f0ea271eff7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c585fbf369ed220bc601e883497ab7c" id="r_a0c585fbf369ed220bc601e883497ab7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c585fbf369ed220bc601e883497ab7c">parallel</a> (int k, <a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a> framing=<a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa8d625b7e64184d5e45d1c2d58acf8d5f">Framing::Seifert</a>) const</td></tr>
<tr class="memdesc:a0c585fbf369ed220bc601e883497ab7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>k</em> cables of this link, all parallel to each other using the given framing.  <br /></td></tr>
<tr class="separator:a0c585fbf369ed220bc601e883497ab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9fc5b699e15f90ef6d90e2d987dbf3" id="r_a2f9fc5b699e15f90ef6d90e2d987dbf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3">alexander</a> () const</td></tr>
<tr class="memdesc:a2f9fc5b699e15f90ef6d90e2d987dbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Alexander polynomial of this classical knot.  <br /></td></tr>
<tr class="separator:a2f9fc5b699e15f90ef6d90e2d987dbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b4072bfb8aa015ca5d5816f6b405cc" id="r_a62b4072bfb8aa015ca5d5816f6b405cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b4072bfb8aa015ca5d5816f6b405cc">knowsAlexander</a> () const</td></tr>
<tr class="memdesc:a62b4072bfb8aa015ca5d5816f6b405cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Alexander polynomial of this knot already known? See <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a> for further details.  <br /></td></tr>
<tr class="separator:a62b4072bfb8aa015ca5d5816f6b405cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e43244712152cd695098010c9a2149" id="r_a69e43244712152cd695098010c9a2149"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e43244712152cd695098010c9a2149">bracket</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, int threads=1, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a69e43244712152cd695098010c9a2149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Kauffman bracket polynomial of this link diagram.  <br /></td></tr>
<tr class="separator:a69e43244712152cd695098010c9a2149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fa6b8b0f452654edb2d0267a19cac3" id="r_a26fa6b8b0f452654edb2d0267a19cac3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26fa6b8b0f452654edb2d0267a19cac3">bracket</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker) const</td></tr>
<tr class="memdesc:a26fa6b8b0f452654edb2d0267a19cac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the Kauffman bracket polynomial of this link diagram, using a single thread and an explicit progress tracker.  <br /></td></tr>
<tr class="separator:a26fa6b8b0f452654edb2d0267a19cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a432a4f3024e537920770c0eb60d2e2" id="r_a6a432a4f3024e537920770c0eb60d2e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a432a4f3024e537920770c0eb60d2e2">knowsBracket</a> () const</td></tr>
<tr class="memdesc:a6a432a4f3024e537920770c0eb60d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details.  <br /></td></tr>
<tr class="separator:a6a432a4f3024e537920770c0eb60d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4fa2ccffd5c8744f0eb02a5ac4bdb" id="r_a82d4fa2ccffd5c8744f0eb02a5ac4bdb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb">jones</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, int threads=1, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a82d4fa2ccffd5c8744f0eb02a5ac4bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jones polynomial of this link, but with all exponents doubled.  <br /></td></tr>
<tr class="separator:a82d4fa2ccffd5c8744f0eb02a5ac4bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b6c7c6a93fbec91c28282238c7465" id="r_abb8b6c7c6a93fbec91c28282238c7465"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8b6c7c6a93fbec91c28282238c7465">jones</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker) const</td></tr>
<tr class="memdesc:abb8b6c7c6a93fbec91c28282238c7465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the Jones polynomial of this link with all exponents doubled, using a single thread and an explicit progress tracker.  <br /></td></tr>
<tr class="separator:abb8b6c7c6a93fbec91c28282238c7465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2acb5efa330841a89e91d28e5d64a" id="r_a13a2acb5efa330841a89e91d28e5d64a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13a2acb5efa330841a89e91d28e5d64a">knowsJones</a> () const</td></tr>
<tr class="memdesc:a13a2acb5efa330841a89e91d28e5d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the Jones polynomial of this link already known? See <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details.  <br /></td></tr>
<tr class="separator:a13a2acb5efa330841a89e91d28e5d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88368c61fae199e0a3dfa48b09ef46a" id="r_aa88368c61fae199e0a3dfa48b09ef46a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a">homflyAZ</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:aa88368c61fae199e0a3dfa48b09ef46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>alpha</em> and <em>z</em>.  <br /></td></tr>
<tr class="separator:aa88368c61fae199e0a3dfa48b09ef46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee829fa01ddd45f97fa2fed002d950e" id="r_a7ee829fa01ddd45f97fa2fed002d950e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e">homflyLM</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a7ee829fa01ddd45f97fa2fed002d950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>l</em> and <em>m</em>.  <br /></td></tr>
<tr class="separator:a7ee829fa01ddd45f97fa2fed002d950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7556a53360868c1cf7b15f101707451d" id="r_a7556a53360868c1cf7b15f101707451d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7556a53360868c1cf7b15f101707451d">homfly</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:a7556a53360868c1cf7b15f101707451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>alpha</em> and <em>z</em>.  <br /></td></tr>
<tr class="separator:a7556a53360868c1cf7b15f101707451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7100ef279d1f9a4ed7a739e76d5c5d4" id="r_ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7100ef279d1f9a4ed7a739e76d5c5d4">knowsHomfly</a> () const</td></tr>
<tr class="memdesc:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the HOMFLY-PT polynomial of this link already known? See <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> for further details.  <br /></td></tr>
<tr class="separator:ae7100ef279d1f9a4ed7a739e76d5c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cba955bad42df796502635a382bdd1" id="r_ac6cba955bad42df796502635a382bdd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6cba955bad42df796502635a382bdd1">arrow</a> (<a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a>, int threads=1, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:ac6cba955bad42df796502635a382bdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normalised arrow polynomial of this link.  <br /></td></tr>
<tr class="separator:ac6cba955bad42df796502635a382bdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f59083d93e72fff367b267164137b8d" id="r_a4f59083d93e72fff367b267164137b8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f59083d93e72fff367b267164137b8d">knowsArrow</a> () const</td></tr>
<tr class="memdesc:a4f59083d93e72fff367b267164137b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the normalised arrow polynomial of this link already known? See <a class="el" href="#ac6cba955bad42df796502635a382bdd1" title="Returns the normalised arrow polynomial of this link.">arrow()</a> for further details.  <br /></td></tr>
<tr class="separator:a4f59083d93e72fff367b267164137b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb66a5de5c06536f6b2161ee8ed8334" id="r_a7cb66a5de5c06536f6b2161ee8ed8334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cb66a5de5c06536f6b2161ee8ed8334">affineIndex</a> () const</td></tr>
<tr class="memdesc:a7cb66a5de5c06536f6b2161ee8ed8334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine index polynomial of this knot.  <br /></td></tr>
<tr class="separator:a7cb66a5de5c06536f6b2161ee8ed8334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b29f281cb385e01ca2310d9ca8ad4" id="r_a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b1b29f281cb385e01ca2310d9ca8ad4">group</a> (bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the link group, as constructed from the Wirtinger presentation.  <br /></td></tr>
<tr class="separator:a5b1b29f281cb385e01ca2310d9ca8ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488090ef7d89ed662e503174ec9856d3" id="r_a488090ef7d89ed662e503174ec9856d3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488090ef7d89ed662e503174ec9856d3">groups</a> (bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:a488090ef7d89ed662e503174ec9856d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the two groups constructed from the Wirtinger presentation for this link and its mirror image.  <br /></td></tr>
<tr class="separator:a488090ef7d89ed662e503174ec9856d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493cc4e770dfc84ca2b6a3b73312b5fd" id="r_a493cc4e770dfc84ca2b6a3b73312b5fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a493cc4e770dfc84ca2b6a3b73312b5fd">extendedGroup</a> (bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:a493cc4e770dfc84ca2b6a3b73312b5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extended group of this link, as defined by Silver and Williams.  <br /></td></tr>
<tr class="separator:a493cc4e770dfc84ca2b6a3b73312b5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa9757fe33abff27f03371d20111ef" id="r_a28aa9757fe33abff27f03371d20111ef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28aa9757fe33abff27f03371d20111ef">extendedGroups</a> (bool <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">simplify</a>=true) const</td></tr>
<tr class="memdesc:a28aa9757fe33abff27f03371d20111ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extended groups of this link and its mirror image.  <br /></td></tr>
<tr class="separator:a28aa9757fe33abff27f03371d20111ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9867163e5b6defa9aa85d9bd8d9963" id="r_adf9867163e5b6defa9aa85d9bd8d9963"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf9867163e5b6defa9aa85d9bd8d9963">niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:adf9867163e5b6defa9aa85d9bd8d9963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nice tree decomposition of the 4-valent multigraph formed by this link diagram.  <br /></td></tr>
<tr class="separator:adf9867163e5b6defa9aa85d9bd8d9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e380e04a7b375d081aeafab5d05eb51" id="r_a0e380e04a7b375d081aeafab5d05eb51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e380e04a7b375d081aeafab5d05eb51">useTreeDecomposition</a> (<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> td)</td></tr>
<tr class="memdesc:a0e380e04a7b375d081aeafab5d05eb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link.  <br /></td></tr>
<tr class="separator:a0e380e04a7b375d081aeafab5d05eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923494c241213368b6e58ec528fa1abd" id="r_a923494c241213368b6e58ec528fa1abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923494c241213368b6e58ec528fa1abd">improveTreewidth</a> (ssize_t maxAttempts=1000, int height=1, int threads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a923494c241213368b6e58ec528fa1abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to rewrite this link diagram to become one with a smaller width tree decomposition.  <br /></td></tr>
<tr class="separator:a923494c241213368b6e58ec528fa1abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf01ac5bd43984ba0530b5548e24755" id="r_a3cf01ac5bd43984ba0530b5548e24755"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cf01ac5bd43984ba0530b5548e24755">homflyAZtoLM</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a">homflyAZ</a>)</td></tr>
<tr class="memdesc:a3cf01ac5bd43984ba0530b5548e24755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between the (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) representations of the HOMFLY-PT polynomial.  <br /></td></tr>
<tr class="separator:a3cf01ac5bd43984ba0530b5548e24755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a combinatorial diagram of a directed knot or link. </p>
<p>Regina uses the word <em>link</em> to refer to links with any number of components, including knots (which have exactly one component) and the empty link (which has no components at all).</p>
<p>Since Regina 7.4, this class supports both classical and virtual links:</p>
<ul>
<li>A <em>classical</em> link is a link in the 3-sphere (i.e., the type of link that one might typically read about in an undergraduate topology course). Classical links are considered equivalent under ambient isotopy.</li>
<li>A <em>virtual</em> link is a link in some thickened orientable surface <em>S</em>. Virtual links are considered equivalent under ambient isotopy, orientation-preserving homeomorphisms of <em>S</em>, and the addition and/or removal of empty handles from <em>S</em>.</li>
</ul>
<p>This class stores a purely combinatorial representation of a 2-dimensional link diagram, using just the combinatorics of the classical crossings and the connections between them. In particular:</p>
<ul>
<li>The <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class does not store any geometric information about the specific placement of strands or crossings in the ambient 3-dimensional space.</li>
<li>For classical links, you can visualise a link using the <a class="el" href="classregina_1_1SpatialLink.html" title="Represents a specific embedding of a directed knot or link in real 3-dimensional space.">SpatialLink</a> class, which stores a specific embedding of the link in 3-dimensional Euclidean space, but which is based on floating-point arithmetic (and is therefore susceptible to floating-point errors). For most mathematical purposes however, you should use this <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class, which has a rich set of mathematical features and uses exact discrete algorithms.</li>
<li>For virtual links, some authors like to use diagrams in the plane with "virtual crossings". Regina does not use virtual crossings at all; instead it stores only the classical crossings in the thickened surface (where one strand passes over another). Regina also does not store the surface itself; instead it uses the (unique) surface of smallest possible genus in which this diagram embeds (i.e., the surface in which the diagram embeds with no empty handles). Put differently: Regina treats the crossings and strands of this diagram as defining a local embedding of the 1-skeleton of some polygonal decomposition of the surface; the 2-cells of this decomposition are then assumed to be topological discs.</li>
</ul>
<p>This <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class supports links with any number of components (including zero), and it also supports components with no crossings (which form additional unknot components of the overall link).</p>
<p>Since Regina 7.0, this is no longer a "packet type" that can be inserted directly into the packet tree. Instead a <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include a <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> in the packet tree, you must create a new PacketOf&lt;Link&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>, and so inherits the full <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> interface.</li>
</ul>
<p>If you are adding new functions to this class that edit the internal data structures of the link, you must remember to surround these changes with a ChangeAndClearSpan. This manages bookkeeping such as clearing computed properties, and (if this link <em>does</em> belong to a packet) firing packet change events.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0d10f79dd6c4de1c8b90b77ab0953d9c" name="a0d10f79dd6c4de1c8b90b77ab0953d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10f79dd6c4de1c8b90b77ab0953d9c">&#9670;&#160;</a></span>PacketChangeGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::PacketChangeGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes. </p>
<p>This type alias is used in the same way as <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a>: it is purely for the benefit of the human reader, used to indicate that an event span is present purely for optimisation (and in particular, that the code would still be correct without it).</p>
<p>See <a class="el" href="classregina_1_1Packet.html#a0896e6dcce0a5e2815cfb64f6d0501b9" title="A type alias for PacketChangeSpan, used when a span is being used purely for optimisation purposes.">Packet::PacketChangeGroup</a> for further details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aff4dc84be20b66314534c2dcc7466324" name="aff4dc84be20b66314534c2dcc7466324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4dc84be20b66314534c2dcc7466324">&#9670;&#160;</a></span>Link() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty link. </p>
<p>This will have zero components. </p>

</div>
</div>
<a id="aa6b717f99561f93f6b09118cdf770803" name="aa6b717f99561f93f6b09118cdf770803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b717f99561f93f6b09118cdf770803">&#9670;&#160;</a></span>Link() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>unknots</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the unlink with the given number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unknots</td><td>the number of (unknotted) components in the new unlink. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359918be5fb86081d1122cc2f2260a5f" name="a359918be5fb86081d1122cc2f2260a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359918be5fb86081d1122cc2f2260a5f">&#9670;&#160;</a></span>Link() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>copy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link. </p>
<p>This will clone any computed properties (such as Jones polynomial and so on) of the given link also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef22c9d7355dc008bfc0282c1f99e4b" name="aaef22c9d7355dc008bfc0282c1f99e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef22c9d7355dc008bfc0282c1f99e4b">&#9670;&#160;</a></span>Link() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>copy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cloneProps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given link, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the link to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given link (such as Jones polynomial and so on), or <code>false</code> if the new link should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75a2b893b338cbcc1556db7f7e54dfe9" name="a75a2b893b338cbcc1556db7f7e54dfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a2b893b338cbcc1556db7f7e54dfe9">&#9670;&#160;</a></span>Link() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given link into this new link. </p>
<p>This is a fast (constant time) operation.</p>
<p>All crossings that belong to <em>src</em> will be moved into this link, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this link.</p>
<p>The link that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this link is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b233fb32a24925705b616b5dc23b219" name="a9b233fb32a24925705b616b5dc23b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b233fb32a24925705b616b5dc23b219">&#9670;&#160;</a></span>Link() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::Link </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>description</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a link. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>knot/link signatures, as used by <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a>;</li>
<li>oriented Gauss codes, as used by <a class="el" href="#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new classical or virtual knot from an &quot;oriented&quot; variant of the Gauss code,...">fromOrientedGauss()</a>;</li>
<li>signed Gauss codes, as used by <a class="el" href="#a4fad40609372ea6a1b1ae54550460e03" title="Creates a new classical or virtual knot from a &quot;signed&quot; variant of the Gauss code,...">fromSignedGauss()</a>;</li>
<li>classical Gauss codes, as used by <a class="el" href="#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new classical knot from a classical Gauss code, presented as a string.">fromGauss()</a>;</li>
<li>numeric or alphabetical Dowker-Thistlethwaite strings, as used by <a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a>;</li>
<li>planar diagram codes, as used by <a class="el" href="#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new classical or virtual link from a planar diagram code, presented as a string.">fromPD()</a>.</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Regina could not interpret the given string as representing a link using any of the supported string types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a knot or link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca93be82c5a263db9e3dc28a928fb4ba" name="aca93be82c5a263db9e3dc28a928fb4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca93be82c5a263db9e3dc28a928fb4ba">&#9670;&#160;</a></span>~Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Link::~Link </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this link. </p>
<p>The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this link will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cb66a5de5c06536f6b2161ee8ed8334" name="a7cb66a5de5c06536f6b2161ee8ed8334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb66a5de5c06536f6b2161ee8ed8334">&#9670;&#160;</a></span>affineIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; regina::Link::affineIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the affine index polynomial of this knot. </p>
<p>This polynomial invariant is described in L.H. Kauffman, "An affine index polynomial
invariant of virtual knots", J. Knot Theory Ramifications 22 (2013), no. 4, 1340007.</p>
<p>At present, Regina only computes affine index polynomials for knots, not multiple-component links. Virtual knots are supported (and indeed are the only meaningful case, since the affine index polynomial of a classical knot is always zero). If this link is empty or has more than one component, then this routine will throw an exception.</p>
<p>To pretty-print the affine index polynomial for human consumption, you can call <code>Laurent::str(Link::affineIndexVar)</code>.</p>
<p>Unlike most polynomial invariants, computing the affine index polynomial is extremely fast, and so this polynomial is not cached.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has exactly one component (i.e., it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the affine index polynomial. </dd></dl>

</div>
</div>
<a id="a2f9fc5b699e15f90ef6d90e2d987dbf3" name="a2f9fc5b699e15f90ef6d90e2d987dbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9fc5b699e15f90ef6d90e2d987dbf3">&#9670;&#160;</a></span>alexander()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Polynomial.html">Polynomial</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::alexander </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Alexander polynomial of this classical knot. </p>
<p>At present, Regina only computes Alexander polynomials for classical knots, not multiple-component links or virtual knots. If this link is empty, has more than one component, or uses a virtual diagram, then this routine will throw an exception.</p>
<p>To pretty-print the Alexander polynomial for human consumption, you can call <code>Polynomial::str(Link::alexanderVar)</code>.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a> should be called again; this will be instantaneous if the Alexander polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be instantaneous (since it just returns the previously computed result).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link diagram is classical (not virtual), and has exactly one component (i.e., it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty, has multiple components, and/or uses a virtual (not classical) link diagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Alexander polynomial of this knot. </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&#160;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::anonID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p>This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p>The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p>These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="ac6cba955bad42df796502635a382bdd1" name="ac6cba955bad42df796502635a382bdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cba955bad42df796502635a382bdd1">&#9670;&#160;</a></span>arrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Arrow.html">Arrow</a> &amp; regina::Link::arrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the normalised arrow polynomial of this link. </p>
<p>The arrow polynomial is a generalisation of the Kauffman bracket for virtual knots and links. The polynomial will be normalised using the writhe of the diagram to obtain a virtual link invariant, in a similar way to how the Kauffman bracket can be normalised to obtain the Jones polynomial. Regina follows the description in H.A. Dye and L.H. Kauffman, "Virtual crossing number and the arrow polynomial", J. Knot Theory Ramifications 18 (2009), no. 10, 1335-1357.</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#ac6cba955bad42df796502635a382bdd1" title="Returns the normalised arrow polynomial of this link.">arrow()</a> should be called again; this will be instantaneous if the arrow polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently at most 63). If you pass <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> is a slow algorithm that computes the arrow polynomial by resolving all crossings in all possible ways, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the computation will run single-threaded. Currently only the naive algorithm supports multithreading; if you use the treewidth-based algorithm then it will run single-threaded regardless of the value of <em>threads</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normalised arrow polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a26fa6b8b0f452654edb2d0267a19cac3" name="a26fa6b8b0f452654edb2d0267a19cac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fa6b8b0f452654edb2d0267a19cac3">&#9670;&#160;</a></span>bracket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::bracket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the Kauffman bracket polynomial of this link diagram, using a single thread and an explicit progress tracker. </p>
<p>This routine is provided for backward compatibility: its only purpose is to offer a syntax that was supported in old versions of Regina but is not consistent with the new form of <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> that supports multithreading.</p>
<p>See bracket(Algorithm, int, ProgressTracker*) for further details on what this routine does and relevant warnings that you should be aware of.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated</a></b></dt><dd>If you need to use this form of <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> (i.e., single-threaded with an explicit progress tracker), you should call <code>bracket(alg, 1, tracker)</code> instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bracket polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a69e43244712152cd695098010c9a2149" name="a69e43244712152cd695098010c9a2149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e43244712152cd695098010c9a2149">&#9670;&#160;</a></span>bracket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::bracket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Kauffman bracket polynomial of this link diagram. </p>
<p>Note that the bracket polynomial is not an invariant - it is preserved under Reidemeister moves II and III, but not I.</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent::str(Link::bracketVar)</code>.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> should be called again; this will be instantaneous if the bracket polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p>Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently at most 63). If you pass <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the computation will run single-threaded. Currently only the naive algorithm supports multithreading; if you use the treewidth-based algorithm then it will run single-threaded regardless of the value of <em>threads</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bracket polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a805821d3da773fdd9a69f75916dbd90e" name="a805821d3da773fdd9a69f75916dbd90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805821d3da773fdd9a69f75916dbd90e">&#9670;&#160;</a></span>brief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::brief </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this link in Regina's own brief write-only format. </p>
<p>This format is concise, but contains enough information to manually reconstruct the complete link diagram.</p>
<p>This format cannot (yet) be used to read links back into Regina, and so it is not good for external storage, or for passing links between different programs (or even different instances of Regina). It was originally designed for use with the test suite, where it was used to ensure that links with being created and/or manipulated correctly.</p>
<p>The output will contain the following elements, separated by single spaces:</p>
<ul>
<li>a sequence of signs (<code>+</code> or <code>-</code>), concatenated together, giving the signs of the crossings in order from crossing 0 to crossing <a class="el" href="#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1;</li>
<li>a description of each component of the link, in order from component 0 to component <a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1. Each component will be written in the form <code>( a b c ... )</code>, indicating the crossings that are encountered as we follow the component in the forward direction from its starting strand. Each element <em>a</em>, <em>b</em>, <em>c</em> and so on will be written in the format used by the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> class: either <code>^n</code> when passing over crossing <em>n</em>, or <code>_n</code> when passing under crossing <em>n</em>.</li>
</ul>
<p>For example, the Whitehead link as returned by <a class="el" href="classregina_1_1ExampleLink.html#aa2cc05e6f13c8d1d77ecfcce2bd4a72e" title="Returns a five-crossing diagram of the Whitehead link.">ExampleLink.whitehead()</a> will give the following brief output:</p>
<pre class="fragment">--++- ( ^0 _1 ^4 _3 ^2 _4 ) ( _0 ^1 _2 ^3 )
</pre><p>As a special case, if the link contains no crossings, then the output will not begin with a space; instead it will simply be a sequence of the form <code>( ) ( ) ... ( )</code>.</p>
<p>The string will not end in a newline.</p>
<p>There is also a variant of <a class="el" href="#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link in Regina's brief format. </dd></dl>

</div>
</div>
<a id="af770913610307338a7a319f38628981c" name="af770913610307338a7a319f38628981c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af770913610307338a7a319f38628981c">&#9670;&#160;</a></span>brief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::brief </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this link in Regina's own brief format to the given output stream. </p>
<p>See <a class="el" href="#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> for a full description of Regina's brief format, as well as its limitations.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a>. In particular, the output does not contain any newlines.</p>
<p>See also <a class="el" href="#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a>, which returns the brief format as a string.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a805821d3da773fdd9a69f75916dbd90e" title="Outputs this link in Regina&#39;s own brief write-only format.">brief()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d386bea941e436ae6548aa8663a005b" name="a0d386bea941e436ae6548aa8663a005b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d386bea941e436ae6548aa8663a005b">&#9670;&#160;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of the given crossing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0546dc7f2bde7b63c31f3e057a8c04db" name="a0546dc7f2bde7b63c31f3e057a8c04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546dc7f2bde7b63c31f3e057a8c04db">&#9670;&#160;</a></span>changeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::changeAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the diagram. </p>
<p>As a result, the sign of every crossing will also change.</p>
<p>This operation corresponds to reflecting the link diagram through the surface on which it is drawn.</p>
<p>In the language of Jeremy Green's virtual knot tables, this operation is a <em>vertical</em> mirror image. </p>

</div>
</div>
<a id="a7ac532f70e281f305bafaceb8c627b94" name="a7ac532f70e281f305bafaceb8c627b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac532f70e281f305bafaceb8c627b94">&#9670;&#160;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::Link::complement </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an ideal triangulation of the complement of this link diagram. </p>
<p>The triangulation will have one ideal vertex for each link component.</p>
<p>If this is a classical link diagram:</p>
<ul>
<li>The triangulation will represent the complement of this link in the 3-sphere. If the link diagram is disconnected, then the resulting 3-manifold will be the connected sum of the complements of each connected diagram component.</li>
</ul>
<p>If this is a virtual (non-classical) diagram:</p>
<ul>
<li>A virtual link diagram is embedded in some closed orientable surface <em>S</em> with positive genus. The triangulation that is returned will represent the complement of this link diagram in the thickened surface <code>S  I</code>. There will be two additional ideal vertices, one for each copy of <em>S</em> on the boundary. If the link diagram is disconnected, then the surface <em>S</em> that is used will be the connected sum of the individual closed orientable surfaces that host each connected diagram component (i.e., the resulting triangulation will be connected).</li>
</ul>
<p>Note that for classical links, the complement is a topological invariant of the link; however, for virtual (non-classical) links, the complement (and indeed the genus of the surface <em>S</em>) is a property of the specific link diagram.</p>
<p>Assuming you pass <em>simplify</em> as <code>true</code> (the default), the resulting triangulation will typically have no internal vertices; however, this is not guaranteed.</p>
<p>Initially, each tetrahedron will be oriented according to a right-hand rule: the thumb of the right hand points from vertices 0 to 1, and the fingers curl around to point from vertices 2 to 3. If you pass <em>simplify</em> as <code>true</code>, then Regina will attempt to simplify the triangulation to as few tetrahedra as possible: this may relabel the tetrahedra, though their orientations will be preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if and only if the triangulation of the complement should be simplified to use as few tetrahedra as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complement of this link diagram. </dd></dl>

</div>
</div>
<a id="a6f12bbb367ccd77109bb49e53aacf501" name="a6f12bbb367ccd77109bb49e53aacf501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12bbb367ccd77109bb49e53aacf501">&#9670;&#160;</a></span>component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the starting strand for the link component containing the given strand. </p>
<p>By the <em>starting strand</em> for a link component, we mean the strand that is returned by <code>component(i)</code> for the appropriate index <em>i</em>, or equivalently the strand representing that component in the list <code><a class="el" href="#a550ed4ff764fe10462582631b9798d6e" title="Returns an object that allows iteration through and random access to all components of this link.">components()</a></code>. In particular:</p>
<ul>
<li>If <em>s</em> and <em>t</em> are two strands of the same link component, then <code>component(s)</code> and <code>component(t)</code> will always be equal.</li>
<li>If <em>s</em> and <em>t</em> come from different link components, and at least one of them is not a null strand reference, then <code>component(s)</code> and <code>component(t)</code> will be different.</li>
<li>If <em>s</em> is a null strand reference and this link diagram contains one or more zero-crossing unknot components, then <code>component(s)</code> will return a null strand reference to indicate this.</li>
</ul>
<p>If the strand <em>s</em> does not belong to this link diagram at all (including the case where <em>s</em> is a null reference but this link diagram has no zero-crossing unknot components), then <code>component(s)</code> will thrown an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NoSolution.html" title="An exception thrown when Regina has certified that a mathematical problem has no solution.">NoSolution</a></td><td>The given strand <em>s</em> does not belong to this link diagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the strand to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the starting strand for the link component containing <em>s</em>. </dd></dl>

</div>
</div>
<a id="a3425a2a6994fbc87baf890e9b429ef6f" name="a3425a2a6994fbc87baf890e9b429ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3425a2a6994fbc87baf890e9b429ef6f">&#9670;&#160;</a></span>component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::component </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a strand in the given component of this link. </p>
<p>Components are individual circles embedded in the ambient 3-manifold (they have nothing to do with the connectivity of the link diagram). So, for example, the Hopf link has two components.</p>
<p>For each component of the link, this routine returns a "starting strand". You can traverse the entire component by beginning at this starting strand and repeatedly incrementing it through a routine such as <a class="el" href="classregina_1_1StrandRef.html#aca9f21431143267c5f4d7142f604559f" title="Moves this reference forward along the direction of the link until it reaches the next crossing.">StrandRef::operator++</a> or <a class="el" href="classregina_1_1StrandRef.html#a0f3ce62d47997b0e320735c7e32fd54a" title="Returns the crossing reference that comes immediately after this when walking forward along the direc...">StrandRef::next()</a>.</p>
<p>If a component has no crossings (which means it must be a separate unknot component), then this routine will return a null reference (i.e., <a class="el" href="classregina_1_1StrandRef.html#abe5e3028eaf7ee815e082000d17154ad" title="The crossing that this reference points to.">StrandRef::crossing()</a> will return <code>null</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a "starting strand" for traversing the component at the given index, or a null reference if the requested component has no crossings. </dd></dl>

</div>
</div>
<a id="a550ed4ff764fe10462582631b9798d6e" name="a550ed4ff764fe10462582631b9798d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ed4ff764fe10462582631b9798d6e">&#9670;&#160;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Link::components </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all components of this link. </p>
<p>Components are individual circles embedded in the ambient 3-manifold (they have nothing to do with the connectivity of the link diagram). So, for example, the Hopf link has two components.</p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Each element of the list will be a starting strand for some component; more precisely, iterating through this list is equivalent to calling <code>component(0)</code>, <code>component(1)</code>, ..., <code>component(<a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1)</code> in turn. As an example, your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classregina_1_1StrandRef.html">StrandRef</a>&amp; c : link.<a class="code hl_function" href="#a550ed4ff764fe10462582631b9798d6e">components</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Link_html_a550ed4ff764fe10462582631b9798d6e"><div class="ttname"><a href="#a550ed4ff764fe10462582631b9798d6e">regina::Link::components</a></div><div class="ttdeci">auto components() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all components of this link.</div><div class="ttdef"><b>Definition</b> link.h:7496</div></div>
<div class="ttc" id="aclassregina_1_1StrandRef_html"><div class="ttname"><a href="classregina_1_1StrandRef.html">regina::StrandRef</a></div><div class="ttdoc">A reference to one of the two strands of a link that pass each other at a crossing.</div><div class="ttdef"><b>Definition</b> link.h:173</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the link exists: even as components are added and/or removed, it will always reflect the components that are currently in the link. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="#a550ed4ff764fe10462582631b9798d6e" title="Returns an object that allows iteration through and random access to all components of this link.">components()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all components. </dd></dl>

</div>
</div>
<a id="aa8cf8c32905d7885d8634dead720e0fe" name="aa8cf8c32905d7885d8634dead720e0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cf8c32905d7885d8634dead720e0fe">&#9670;&#160;</a></span>componentsByStrand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Link::componentsByStrand </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sequence that maps strand IDs to link component numbers. </p>
<p>This sequence will have length <code>2n</code>, where <em>n</em> is the number of crossings in this link diagram. If <em>strand</em> is a non-null strand reference, <em>map</em> is the sequence that is returned, and <code>map[strand.id()] == c</code>, then this indicates that <em>strand</em> is part of the link component defined by <code>component(c)</code>.</p>
<p>Null strand references are not handled by this map: they have a negative ID (which means calling <code>map[strand.id()]</code> is an error), and they could refer to any 0-crossing unknot component (so the specific component might not be uniquely determined).</p>
<p>The return type is deliberately not specified here. It is guaranteed to be a container whose elements have type <code>size_t</code>, with value semantics, fast move construction and swap operations, an array index operator, and random access iterators. It is <em>not</em> guaranteed to have a copy assignment operator (but it will support fast move assignment). At present the specific implementation returns <code><a class="el" href="classregina_1_1FixedArray.html" title="A lightweight fixed-size random-access array whose size can be provided at runtime.">FixedArray</a>&lt;size_t&gt;</code>, though this is subject to change in future versions of Regina and so end user code should always use <code>auto</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine will return a Python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence mapping strand IDs to component numbers. </dd></dl>

</div>
</div>
<a id="a28355f40d08c312c5f2e6cceb68bc1b4" name="a28355f40d08c312c5f2e6cceb68bc1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28355f40d08c312c5f2e6cceb68bc1b4">&#9670;&#160;</a></span>composeWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::composeWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the composition of this with the given link. </p>
<p>This link will be altered directly, and the given link will be left unchanged.</p>
<p>Specifically, this routine will insert a copy of the given link into this link, and will graft its first component into the first component of this link in a way that preserves orientations and crossing signs. If either this and/or the given link has more than one component, then any additional components will be left alone (i.e., they will remain as different components in the final result).</p>
<p>If either link is empty (i.e., contains no components at all), then the result will simply be a clone of the other link (with no composition operation performed).</p>
<dl class="section note"><dt>Note</dt><dd>If you need to specify which components of the two links to graft together, or if you need to choose the specific arcs at which the graft takes place (which is important when working with <em>virtual</em> links), you should use <a class="el" href="#a2753c171099f2c2063080eebd78a1e1d" title="Grafts the two given arcs of this link together, possibly making this a virtual link in the process.">graft()</a> instead. Note that <a class="el" href="#a2753c171099f2c2063080eebd78a1e1d" title="Grafts the two given arcs of this link together, possibly making this a virtual link in the process.">graft()</a> assumes that both components being grafted together already belong to this link; you can use <a class="el" href="#aba467ea1ca812832b4ff15d6fbe23654" title="Inserts a copy of the given link into this link.">insertLink()</a> to arrange this.</dd></dl>
<p>It is allowed to pass this link as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link with which this should be composed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc783777826fcf17af86d21a343118d5" name="abc783777826fcf17af86d21a343118d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc783777826fcf17af86d21a343118d5">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given crossings are connected in the link diagram, if we treat each crossing as a 4-way intersection. </p>
<p>This tests whether it is possible to travel between the two given crossings by:</p>
<ul>
<li>following the link around its components, and/or;</li>
<li>jumping between upper and lower strands at crossings.</li>
</ul>
<p>In particular, two crossings may be connected in the diagram even if they involve entirely different components of the link.</p>
<p>See <a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb" title="Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.">isConnected()</a> for further discussion on the connectivity of link diagrams.</p>
<p>In general this routine requires time linear in the link size (though it is constant time for knots and empty links). If you are planning to call this routine frequently, you might wish to consider using <a class="el" href="#ae377b51c110e629e00158be74d50f1fe" title="Returns an array that maps crossing numbers to connected diagram components.">diagramComponentIndices()</a> instead. That routine returns a lookup table with which you can then test pairwise connectivity via constant-time lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first of the two crossings to examine. </td></tr>
    <tr><td class="paramname">b</td><td>the second of the two crossings to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two given crossings are connected. </dd></dl>

</div>
</div>
<a id="ab4fb9a0932d786dfca9eef2f6e45ec60" name="ab4fb9a0932d786dfca9eef2f6e45ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb9a0932d786dfca9eef2f6e45ec60">&#9670;&#160;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of components in this link. </p>
<p>This is the number of circles embedded in the ambient 3-manifold (it has nothing to do with the connectivity of the link diagram). So, for example, the number of components in the Hopf link is two.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="a9c1cff257b0e1ac3dce82146c476e3a8" name="a9c1cff257b0e1ac3dce82146c476e3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1cff257b0e1ac3dce82146c476e3a8">&#9670;&#160;</a></span>countDiagramComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countDiagramComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of connected diagram components. </p>
<p>As with <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a>, this routine is interested in connected components of the link diagram (i.e., components that are connected in the graph theoretical sense if we treat each crossing as a 4-way intersection). See <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a> for further discussion on this.</p>
<p>This routine simply computes the total number of connected components (including trivial zero-crossing components).</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of connected diagram components. </dd></dl>

</div>
</div>
<a id="aad0b3f667c9968cc0fbd3b8a2ac4b9a4" name="aad0b3f667c9968cc0fbd3b8a2ac4b9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0b3f667c9968cc0fbd3b8a2ac4b9a4">&#9670;&#160;</a></span>countTrivialComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::countTrivialComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of zero-crossing unknot components in this link. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of zero-crossing unknot components. </dd></dl>

</div>
</div>
<a id="a2b47712bc419c15659a634ae6ea97b91" name="a2b47712bc419c15659a634ae6ea97b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47712bc419c15659a634ae6ea97b91">&#9670;&#160;</a></span>crossing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Link::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the crossing at the given index within this link. </p>
<p>For a link with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="a25c13af7dff2e92401ff388f3a2eec26" name="a25c13af7dff2e92401ff388f3a2eec26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c13af7dff2e92401ff388f3a2eec26">&#9670;&#160;</a></span>crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Link::crossings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all crossings within this link. </p>
<p>The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p>The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1Crossing.html">Crossing</a>* c : link.<a class="code hl_function" href="#a25c13af7dff2e92401ff388f3a2eec26">crossings</a>()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Crossing_html"><div class="ttname"><a href="classregina_1_1Crossing.html">regina::Crossing</a></div><div class="ttdoc">Represents a single crossing in a link diagram.</div><div class="ttdef"><b>Definition</b> link.h:451</div></div>
<div class="ttc" id="aclassregina_1_1Link_html_a25c13af7dff2e92401ff388f3a2eec26"><div class="ttname"><a href="#a25c13af7dff2e92401ff388f3a2eec26">regina::Link::crossings</a></div><div class="ttdeci">auto crossings() const</div><div class="ttdoc">Returns an object that allows iteration through and random access to all crossings within this link.</div><div class="ttdef"><b>Definition</b> link.h:7488</div></div>
</div><!-- fragment --><p>The object that is returned will remain up-to-date and valid for as long as the link exists: even as crossings are added and/or removed, it will always reflect the crossings that are currently in the link. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="#a25c13af7dff2e92401ff388f3a2eec26" title="Returns an object that allows iteration through and random access to all crossings within this link.">crossings()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all crossings. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ae377b51c110e629e00158be74d50f1fe" name="ae377b51c110e629e00158be74d50f1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae377b51c110e629e00158be74d50f1fe">&#9670;&#160;</a></span>diagramComponentIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1FixedArray.html">FixedArray</a>&lt; size_t &gt;, size_t &gt; regina::Link::diagramComponentIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array that maps crossing numbers to connected diagram components. </p>
<p>This routine performs a similar function to <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a>, but returns its results as just a list of numbers (not a list of links), and thereby involves less overhead. This could (for example) be useful as a part of some larger algorithm that needs access to a lookup table for testing pairwise connectivity between crossings.</p>
<p>As with <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a>, this routine is interested in connected components of the link diagram (i.e., components that are connected in the graph theoretical sense if we treat each crossing as a 4-way intersection). See <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a> for further discussion on this.</p>
<p>This routine returns a mapping from crossing indices to diagram components, where both are represented by integer indices. For crossings we use the usual crossing index; for diagram components, we number the diagram components from 0 upwards and ignore trivial (zero-crossing) components entirely.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is possible that the data type used for the array will change in a subsequent version of Regina. C++ users should use <code>auto</code> to collect the return value from this routine. (For Python users, the array will be converted into a Python list.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing (i) the array as described above; and (ii) the total number of non-trivial diagram components (so again, ignoring zero-crossing components). Note that this latter number may be different from <a class="el" href="#a9c1cff257b0e1ac3dce82146c476e3a8" title="Returns the total number of connected diagram components.">countDiagramComponents()</a>, which counts <em>all</em> diagram components (including the trivial ones). </dd></dl>

</div>
</div>
<a id="aa13ffadefd563c6a4787d984c7c39ca3" name="aa13ffadefd563c6a4787d984c7c39ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13ffadefd563c6a4787d984c7c39ca3">&#9670;&#160;</a></span>diagramComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::diagramComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connected components of this link diagram as individual standalone links. </p>
<p>Here <em>connected components</em> are not the same as <em>link components</em>. A connected component means a portion of the link diagram that is connected when we treat each crossing as a 4-way intersection. In other words, one can travel around the connected component by following the link around, and/or jumping between upper and lower strands at crossings. A single connected component of the diagram may contain multiple link components, and will always describe a sublink for which <a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb" title="Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.">isConnected()</a> returns <code>true</code>.</p>
<p>The connected components are a property of the diagram, not an invariant of the link itself, since the locations of the crossings matter. In particular:</p>
<ul>
<li>a diagram with multiple connected components <em>must</em> describe a splittable link;</li>
<li>a splittable link, however, could be represented by a diagram with multiple connected components or with just one connected component.</li>
</ul>
<p>The connected components that are returned will be cloned from this link (so even if this diagram is connected and there is just one connected component, a deep copy will still take place). The total number of crossings across all of the links that are returned will equal <a class="el" href="#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a>, and the total number of <em>link</em> components across all of the links that are returned will equal <a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>.</p>
<p>In the list that is returned, any zero-crossing diagram components will all appear at the end, after all of the components that do involve crossings.</p>
<p>If you do not need a collection of fully-formed link objects, you could instead try one of the lightweight variants of this routine:</p>
<ul>
<li><a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb" title="Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.">isConnected()</a> simply tests whether or not there are multiple diagram components;</li>
<li><a class="el" href="#a9c1cff257b0e1ac3dce82146c476e3a8" title="Returns the total number of connected diagram components.">countDiagramComponents()</a> returns the total number of diagram components;</li>
<li><a class="el" href="#ae377b51c110e629e00158be74d50f1fe" title="Returns an array that maps crossing numbers to connected diagram components.">diagramComponentIndices()</a> returns a table of integers indicating which crossings belong to which diagram components.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a list containing the individual connected components of this link diagram. </dd></dl>

</div>
</div>
<a id="a7394cd7aa9cb8d14cb4d7d39f9d96478" name="a7394cd7aa9cb8d14cb4d7d39f9d96478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7394cd7aa9cb8d14cb4d7d39f9d96478">&#9670;&#160;</a></span>dt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this classical knot in either numerical or alphabetical Dowker-Thistlethwaite notation, returning a string. </p>
<p>Like classical Gauss codes, Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not the particular embedding in the plane. It comes with major restrictions:</p>
<ul>
<li>It relies on parity properties that only hold for classical knots. As a result, Dowker-Thistlethwaite notation cannot be used with virtual knots at all.</li>
<li>Even for classical knots, it does not carry enough information to uniquely reconstruct a knot. For instance, both a knot and its reflection can be described by the same Dowker-Thistlethwaite notation; moreover, for <em>composite</em> knots, the same notation can describe inequivalent knots even when allowing for reflections.</li>
<li>Parsing Dowker-Thistlethwaite notation to reconstruct a classical knot is complex, since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</li>
</ul>
<p>If you need a code that specifies the knot uniquely, and/or is fast to parse, and/or can work with both classical and virtual knots, you should use the <em>oriented</em> Gauss code instead, which resolves all of these issues.</p>
<p>For an <em>n</em>-crossing knot, Regina supports two variants of Dowker-Thistlethwaite notation:</p>
<ul>
<li>a <em>numerical</em> variant (the default), which is a sequence of <em>n</em> even signed integers as described (amongst other places) in Section 2.2 of C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994;</li>
<li>an <em>alphabetical</em> variant, which transforms the numerical notation into a sequence of letters by replacing positive integers (2,4,6,...) with lower-case letters (<code>a</code>,<code>b</code>,<code>c</code>,...), and replacing negative integers (-2,-4,-6,...) with upper-case letters (<code>A</code>,<code>B</code>,<code>C</code>,...). This alphabetical variant can only be used for knots with 26 crossings or fewer; for larger knots this routine will throw an exception if the alphabetical variant is requested.</li>
</ul>
<p>As an example, you can describe the trefoil using numerical Dowker-Thistlethwaite notation as:</p>
<pre class="fragment">4 6 2
</pre><p>In alphabetical Dowker-Thistlethwaite notation, this becomes:</p>
<pre class="fragment">bca
</pre><p>Currently Regina only supports Dowker-Thistlethwaite codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Dowker-Thistlethwaite codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p>For numerical Dowker-Thistlethwaite notation, this routine will format the list of integers as a string. The integers will be separated by single spaces, and there will be no newlines. For alphabetical Dowker-Thistlethwaite notation, the string that is returned will not contain any whitespace at all.</p>
<p>For the numerical variant, the routine <a class="el" href="#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of intege...">dtData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="#a7394cd7aa9cb8d14cb4d7d39f9d96478" title="Exports this classical knot in either numerical or alphabetical Dowker-Thistlethwaite notation,...">dt()</a> that can write either the numerical or the alphabetical variant directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this link is empty or has multiple components, or this is a virtual (not classical) link diagram, or <em>alpha</em> is true and this link diagram has more than 26 crossings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Dowker-Thistlethwaite notation for this knot diagram. </dd></dl>

</div>
</div>
<a id="a6e48b3891b1ec16cff1190f781e3ebd0" name="a6e48b3891b1ec16cff1190f781e3ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e48b3891b1ec16cff1190f781e3ebd0">&#9670;&#160;</a></span>dt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::dt </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this classical knot to the given output stream using Dowker-Thistlethwaite notation. </p>
<p>See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p>This routine can write either numerical or alphabetical Dowker-Thistlethwaite notation, as indicated by the optional argument <em>alpha</em>.</p>
<p>The output from this routine is precisely the string that would be returned by dt(bool). In particular, the output does not contain any newlines.</p>
<p>For a function that <em>returns</em> the Dowker-Thistlethwaite notation (as opposed to writing it to an output stream), you could use dt(bool) (which returns the Dowker-Thistlethwaite notation as a human-readable string), or <a class="el" href="#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of intege...">dtData()</a> (which returns the numerical Dowker-Thistlethwaite notation as a machine-readable sequence of integers).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this link is empty or has multiple components, or this is a virtual (not classical) link diagram, or <em>alpha</em> is true and this link diagram has more than 26 crossings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants dt(bool) or <a class="el" href="#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of intege...">dtData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">alpha</td><td><code>true</code> to use alphabetical notation, or <code>false</code> (the default) to use numerical notation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05d3896af6c9aa96a53ab1ad68db95ab" name="a05d3896af6c9aa96a53ab1ad68db95ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d3896af6c9aa96a53ab1ad68db95ab">&#9670;&#160;</a></span>dtData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::dtData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of integers. </p>
<p>See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p>Although Regina can work with both the numerical and alphabetical variants of Dowker-Thistlethwaite notation, this <a class="el" href="#a05d3896af6c9aa96a53ab1ad68db95ab" title="Exports this classical knot in numerical Dowker-Thistlethwaite notation, returning a vector of intege...">dtData()</a> routine exports the numerical variant only. If you wish to export the alphabetical variant, you can call <code>dt(true)</code>.</p>
<p>This routine returns machine-readable data (as a C++ vector); in contrast, calling <code><a class="el" href="#a7394cd7aa9cb8d14cb4d7d39f9d96478" title="Exports this classical knot in either numerical or alphabetical Dowker-Thistlethwaite notation,...">dt()</a></code> returns the same integer sequence in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Either this link is empty or has multiple components, or this is a virtual (not classical) link diagram, or this diagram has so many crossings that the Dowker-Thistlethwaite notation cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numerical Dowker-Thistlethwaite notation in machine-readable form. </dd></dl>

</div>
</div>
<a id="a718258433d47de780e6905585a00bd29" name="a718258433d47de780e6905585a00bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718258433d47de780e6905585a00bd29">&#9670;&#160;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns C++ code to reconstruct this link. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated</a></b></dt><dd>This is equivalent to calling <code>source(Language::Cxx)</code>, for compatibility with older versions of Regina. In particular, it is <em>not</em> equivalent to calling <code><a class="el" href="#a53fbcb99b3014ab278782289b092403c" title="Returns C++ or Python source code that can be used to reconstruct this link.">source()</a></code> (which defaults to the programming language currently being used). See <a class="el" href="#a53fbcb99b3014ab278782289b092403c" title="Returns C++ or Python source code that can be used to reconstruct this link.">source()</a> for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="a493cc4e770dfc84ca2b6a3b73312b5fd" name="a493cc4e770dfc84ca2b6a3b73312b5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493cc4e770dfc84ca2b6a3b73312b5fd">&#9670;&#160;</a></span>extendedGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> regina::Link::extendedGroup </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extended group of this link, as defined by Silver and Williams. </p>
<p>The extended group is defined by Daniel S. Silver and Susan G. Williams in "Crowell's derived group and twisted polynomials", J. Knot Theory Ramifications 15 (2006), no. 8, 1079-1094. It is intended for use with virtual links, where the (ordinary) link group is not a particularly strong invariant. As an invariant, the extended group is stronger, though it also yields more complex group presentations.</p>
<p>As with the ordinary link group, the extended group of a virtual link <em>could</em> change its isomorphism type depending upon whether you view the link from above or below the diagram, and so you may wish to call <a class="el" href="#a28aa9757fe33abff27f03371d20111ef" title="Returns the extended groups of this link and its mirror image.">extendedGroups()</a> instead, which builds both group presentations. Again, as with the ordinary link group, <a class="el" href="classregina_1_1ExampleLink.html#a3dc860955643c0c05fcf6484eaa548f5" title="Returns a four-crossing diagram of the Goussarov-Polyak-Viro virtual knot.">ExampleLink::gpv()</a> provides an example for which these two groups are non-isomorphic.</p>
<p>Note that, regardless of whether your link diagram is classical or virtual, <em>reflecting</em> the diagram (i.e., changing the sign of every crossing but keeping the upper/lower strands the same) will never change the isomorphism type of the extended link group.</p>
<p>If you pass <em>simplify</em> as <code>false</code>, this routine will keep the presentation in the form described by Silver and Williams, and will not try to simplify it further. If you pass <em>simplify</em> as <code>true</code> (the default), this routine will attempt to simplify the group presentation before returning.</p>
<p>This group is <em>not</em> cached; instead it is reconstructed every time this function is called. This behaviour may change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if we should attempt to simplify the group presentation before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extended group of this link. </dd></dl>

</div>
</div>
<a id="a28aa9757fe33abff27f03371d20111ef" name="a28aa9757fe33abff27f03371d20111ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aa9757fe33abff27f03371d20111ef">&#9670;&#160;</a></span>extendedGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &gt; regina::Link::extendedGroups </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extended groups of this link and its mirror image. </p>
<p>The extended group is defined by Silver and Williams for use with virtual links (see <a class="el" href="#a493cc4e770dfc84ca2b6a3b73312b5fd" title="Returns the extended group of this link, as defined by Silver and Williams.">extendedGroup()</a> for details). This routine is provided because viewing a virtual link diagram from below instead of above can change the isomorphism type of the extended group, and so this routine returns <em>both</em> groups. Specifically:</p>
<ul>
<li>In first group that is returned, we use the presentation exactly as described by Silver and Williams. This is the same presentation that is constructed by <a class="el" href="#a493cc4e770dfc84ca2b6a3b73312b5fd" title="Returns the extended group of this link, as defined by Silver and Williams.">extendedGroup()</a>.</li>
<li>In the second group that is returned, we conceptually reflect the link diagram through the surface in which it is embedded (as though we had called <a class="el" href="#a0546dc7f2bde7b63c31f3e057a8c04db" title="Switches the upper and lower strands of every crossing in the diagram.">changeAll()</a>, though this link diagram will not actually be changed).</li>
</ul>
<p>See <a class="el" href="classregina_1_1ExampleLink.html#a3dc860955643c0c05fcf6484eaa548f5" title="Returns a four-crossing diagram of the Goussarov-Polyak-Viro virtual knot.">ExampleLink::gpv()</a> for an example of a virtual knot for which these two extended link groups are not isomorphic.</p>
<p>If you pass <em>simplify</em> as <code>false</code>, this routine will keep both presentations in the form described by Silver and Williams, and will not try to simplify them further. If you pass <em>simplify</em> as <code>true</code> (the default), this routine will attempt to simplify both group presentations before returning.</p>
<p>These groups are <em>not</em> cached; instead they are reconstructed every time this function is called. This behaviour may change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if we should attempt to simplify the group presentations before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the groups of this link obtained by the "native" and "reflected" Silver-Williams presentations, as described above. </dd></dl>

</div>
</div>
<a id="a9d9fd529b5fc4e76b2e0ee3acbef8968" name="a9d9fd529b5fc4e76b2e0ee3acbef8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9fd529b5fc4e76b2e0ee3acbef8968">&#9670;&#160;</a></span>fromData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignIterator , typename ComponentIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">SignIterator</td>          <td class="paramname"><span class="paramname"><em>beginSigns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignIterator</td>          <td class="paramname"><span class="paramname"><em>endSigns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentIterator</td>          <td class="paramname"><span class="paramname"><em>beginComponents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComponentIterator</td>          <td class="paramname"><span class="paramname"><em>endComponents</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from information about its crossings and components. </p>
<p>This routine is an analogue to the variant of <a class="el" href="#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a new classical or virtual link from hard-coded information about its crossings and component...">fromData()</a> that takes C++ initialiser lists; however, here the input data may be constructed at runtime (which makes it accessible to Python, amongst other things).</p>
<p>For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The information that you must pass to this routine is the following:</p>
<ul>
<li>The first iterator range (<em>beginSigns</em>, <em>endSigns</em>) encodes the signs of crossings 1, ..., <em>n</em> in order. Each iterator in this range must dereference to either +1 or -1.</li>
<li>The second iterator range (<em>beginComponents</em>, <em>endComponents</em>) identifies the individual components of the link. Each iterator in this range must dereference to a container that has a <a class="el" href="#a32c6f34794cc62574fcfca388f3f66d9" title="Returns the number of crossings in this link.">size()</a> function and supports range-based <code>for</code> loops (so standard C++ container classes such as std::vector&lt;int&gt; and std::list&lt;int&gt; are fine).</li>
<li>The container for each component must be filled with integers, which identify the crossings you visit in order when traversing the component. A positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>.</li>
<li>To encode a component with no crossings, you may use either an empty container or a container containing the single integer 0.</li>
</ul>
<p>Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, Python users can construct the left-hand trefoil and the Hopf link as follows:</p>
<div class="fragment"><div class="line">trefoil = Link.fromData([ -1, -1, -1 ], [[ 1, -2, 3, -1, 2, -3 ]])</div>
<div class="line">hopf = Link.fromData([ +1, +1 ], [[ 1, -2 ], [ -1, 2 ]])</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>A link could not be reconstructed from the given data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The signs should be passed as a single Python list of integers (not an iterator pair). Likewise, the components should be passed as a Python list of lists of integers (not an iterator pair). In the case of a knot (which has only one component), you are welcome to replace the list of lists <code>[[...]]</code> with a single list <code>[...]</code>; however, be aware that a single empty list <code>[ ]</code> will be interpreted as an empty link (not a zero-crossing unknot).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginSigns</td><td>the beginning of the list of crossing signs. </td></tr>
    <tr><td class="paramname">endSigns</td><td>a past-the-end iterator indicating the end of the list of crossing signs. </td></tr>
    <tr><td class="paramname">beginComponents</td><td>the beginning of the list of containers describing each link component. </td></tr>
    <tr><td class="paramname">endComponents</td><td>a past-the-end iterator indicating the end of the list of link components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a13f44d669e5b4139ad6bc8955ef9f5ce" name="a13f44d669e5b4139ad6bc8955ef9f5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f44d669e5b4139ad6bc8955ef9f5ce">&#9670;&#160;</a></span>fromData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromData </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>crossingSigns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; Args &gt;...</td>          <td class="paramname"><span class="paramname"><em>components</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from hard-coded information about its crossings and components. </p>
<p>This routine takes a series of C++ initialiser lists (each a list of integers), which makes it useful for creating hard-coded examples directly in C++ code.</p>
<p>For the purposes of this routine, we number the crossings 1, 2, ..., <em>n</em>. The lists that you must pass to this routine are as follows:</p>
<ul>
<li>The first list contains the signs of crossings 1, ..., <em>n</em> in order, where each sign is either +1 or -1.</li>
<li>Each subsequent list describes a single component of the link. The list identifies which crossings you visit in order when traversing the component; a positive entry <em>i</em> indicates that you pass over crossing <em>i</em>, and a negative entry -<em>i</em> indicates that you pass under crossing <em>i</em>. Empty lists are allowed (these denote separate unknot components).</li>
<li>If a component has no crossings, then you should pass the list { 0 }, not the empty list. (This is because the C++ compiler cannot deduce the type of an empty list.)</li>
</ul>
<p>Be aware that, once the link has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object numbers its crossings starting from 0).</p>
<p>As an example, you can construct the left-hand trefoil and the Hopf link as follows:</p>
<div class="fragment"><div class="line">trefoil = <a class="code hl_function" href="#a13f44d669e5b4139ad6bc8955ef9f5ce">Link::fromData</a>({ -1, -1, -1 }, { 1, -2, 3, -1, 2, -3 });</div>
<div class="line">hopf = <a class="code hl_function" href="#a13f44d669e5b4139ad6bc8955ef9f5ce">Link::fromData</a>({ +1, +1 }, { 1, -2 }, { -1, 2 });</div>
<div class="ttc" id="aclassregina_1_1Link_html_a13f44d669e5b4139ad6bc8955ef9f5ce"><div class="ttname"><a href="#a13f44d669e5b4139ad6bc8955ef9f5ce">regina::Link::fromData</a></div><div class="ttdeci">static Link fromData(std::initializer_list&lt; int &gt; crossingSigns, std::initializer_list&lt; Args &gt;... components)</div><div class="ttdoc">Creates a new classical or virtual link from hard-coded information about its crossings and component...</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you have an existing link that you would like to hard-code, the routine <a class="el" href="#a53fbcb99b3014ab278782289b092403c" title="Returns C++ or Python source code that can be used to reconstruct this link.">source()</a> will output source code that reconstructs the link by calling this routine.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>A link could not be reconstructed from the given data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the variant of <a class="el" href="#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a new classical or virtual link from hard-coded information about its crossings and component...">fromData()</a> that takes this same data using two Python lists (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossingSigns</td><td>a list containing the signs of the crossings; each sign must be either +1 or -1. </td></tr>
    <tr><td class="paramname">components</td><td>one list for each link component that describes the crossings that are visited along that component, as described in the detailed notes above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="ae24bdd53db84c7fcbb4c40a51180111f" name="ae24bdd53db84c7fcbb4c40a51180111f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24bdd53db84c7fcbb4c40a51180111f">&#9670;&#160;</a></span>fromDT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation, presented as a string. </p>
<p>Dowker-Thistlethwaite notation essentially describes the 4-valent graph of a knot but not its particular embedding in the plane. As a result, there can be topological ambiguities when a classical knot is reconstructed from Dowker-Thistlethwaite notation; these are described in the warnings below. Dowker-Thistlethwaite notation cannot be used with virtual (not classical) knots at all.</p>
<p>Dowker-Thistlethwaite notation comes in two forms: numerical and alphabetical. For an <em>n</em>-crossing knot, the numerical form is a sequence of <em>n</em> even signed integers, and the alphabetical form is a sequence of <em>n</em> case-sensitive letters. As an example, you can construct the trefoil using either of the following strings:</p>
<pre class="fragment">4 6 2
bca
</pre><p>See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, as well as its limitations.</p>
<p>There are two variants of this routine. This variant takes a single string, which is either (i) the alphabetical notation, in which any whitespace within the string will be ignored; or (ii) the numerical notation, in which the integers are combined together and separated by whitespace. The other variant of this routine is only for numerical Dowker-Thistlethwaite notation, and it takes a sequence of integers defined by a pair of iterators.</p>
<p>In this variant (the string variant), the string may contain additional leading or trailing whitespace; moreover, for numerical Dowker-Thistlethwaite notation, the exact form of the whitespace that separates the integers does not matter.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a classical knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid Dowker-Thistlethwaite code for a classical knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>either the alphabetical or numerical Dowker-Thistlethwaite notation for a classical knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a523518b438fc7884f28075a76851515a" name="a523518b438fc7884f28075a76851515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523518b438fc7884f28075a76851515a">&#9670;&#160;</a></span>fromDT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromDT </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical knot from numerical Dowker-Thistlethwaite notation, presented as an integer sequence. </p>
<p>See dt(bool) for a full description of Dowker-Thistlethwaite notation as it is used in Regina, and see <a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs classical knots from such notation.</p>
<p>This routine is a variant of <a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<p>This variant of <a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a> can only work with <em>numerical</em> Dowker-Thistlethwaite notation. Regina does understand alphabetic Dowker-Thistlethwaite notation, but for this you will need to use the string-based variant of <a class="el" href="#ae24bdd53db84c7fcbb4c40a51180111f" title="Creates a new classical knot from either alphabetical or numerical Dowker-Thistlethwaite notation,...">fromDT()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, Dowker-Thistlethwaite notation does not contain enough information to uniquely reconstruct a classical knot. For prime knots, both a knot and its reflection can be described by the same notation; for composite knots, the same notation can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the oriented Gauss code instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid Dowker-Thistlethwaite code for a classical knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for the Dowker-Thistlethwaite notation for a classical knot. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for the Dowker-Thistlethwaite notation for a classical knot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="ab6a3be3af017e42c2230fb8f847bf4d1" name="ab6a3be3af017e42c2230fb8f847bf4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a3be3af017e42c2230fb8f847bf4d1">&#9670;&#160;</a></span>fromGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical knot from a classical Gauss code, presented as a string. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. As a result, there can be topological ambiguities when a classical knot is reconstructed from a Gauss code; these are described in the warnings below. For virtual (not classical) knots, the ambiguities inherent in classical Gauss codes are even more severe, and so Regina will not attempt to reconstruct a virtual knot from its classical Gauss code at all.</p>
<p>The Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers. As an example, you can construct the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p>See <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>Regina imposes the following restrictions when reconstructing a knot from a classical Gauss code:</p>
<ul>
<li>This can only be done for <em>knots</em> (i.e., links with exactly one component), and only for <em>classical</em> knots (not the more general virtual knot diagrams).</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> in some order.</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object numbers its crossings starting from 0).</p>
<p>There are two variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variant takes a sequence of integers, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a classical knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid classical Gauss code for a classical knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a classical Gauss code for a classical knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a3c6a00fb45e8afa12a93a62a6f032479" name="a3c6a00fb45e8afa12a93a62a6f032479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6a00fb45e8afa12a93a62a6f032479">&#9670;&#160;</a></span>fromGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical knot from a classical Gauss code, presented as an integer sequence. </p>
<p>See <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, and see <a class="el" href="#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new classical knot from a classical Gauss code, presented as a string.">fromGauss(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs classical knots from such codes.</p>
<p>This routine is a variant of <a class="el" href="#ab6a3be3af017e42c2230fb8f847bf4d1" title="Creates a new classical knot from a classical Gauss code, presented as a string.">fromGauss(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In general, the classical Gauss code does not contain enough information to uniquely reconstruct a classical knot. For prime knots, both a knot and its reflection can be described by the same Gauss code; for composite knots, the same Gauss code can describe knots that are topologically inequivalent, even when allowing for reflection. If you need to reconstruct a knot uniquely, consider using the <em>oriented</em> Gauss code instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid classical Gauss code for a classical knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Adam Gowty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers for a classical Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers for a classical Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a9b39ba67b388f3b69f28c00fdb7c54a5" name="a9b39ba67b388f3b69f28c00fdb7c54a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39ba67b388f3b69f28c00fdb7c54a5">&#9670;&#160;</a></span>fromJenkins() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from Bob Jenkins' format, presented as a string. </p>
<p>Jenkins' format overcomes the limitations of classical Gauss codes by encoding all of the data needed to quickly and correctly reconstruct a link diagram. It can work with links as well as knots.</p>
<p>In Jenkins' format, a link is described by a sequence of integers. As an example, you could construct the Hopf link using the sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p>See <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format (and in particular, what these integers represent).</p>
<p>There are three variants of this routine. This variant takes a single string, where the integers have been combined together and separated by whitespace. The other variants take (i) a sequence of integers defined by a pair of iterators, or (ii) an input stream from which the integers will be read.</p>
<p>In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid encoding of a classical or virtual link in Jenkins' format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a string describing a link in Jenkins' format, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a6b1f11ca592dda9f6ac900e9bf09fd65" name="a6b1f11ca592dda9f6ac900e9bf09fd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1f11ca592dda9f6ac900e9bf09fd65">&#9670;&#160;</a></span>fromJenkins() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from Bob Jenkins' format, presented as an integer sequence. </p>
<p>See <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Bob Jenkins' format as it is used in Regina, and see <a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new classical or virtual link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from this format.</p>
<p>This routine is a variant of <a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new classical or virtual link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a forward iterator type, and dereferencing such an iterator produces a native C++ integer. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid encoding of a classical or virtual link in Jenkins' format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of integers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of integers that describes a link. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of integers that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a632cc9fb94359bb3f2f9c10d6a500208" name="a632cc9fb94359bb3f2f9c10d6a500208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632cc9fb94359bb3f2f9c10d6a500208">&#9670;&#160;</a></span>fromJenkins() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromJenkins </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from Bob Jenkins' format, read directly from an input stream. </p>
<p>See <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Bob Jenkins' format as it is used in Regina, and see <a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new classical or virtual link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from this format.</p>
<p>This routine is a variant of <a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new classical or virtual link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a> which, instead of taking a string as input, takes an input stream from which the sequence of integers describing the link will be read.</p>
<p>Once this routine reads the integers that describe the link, or as soon as it encounters an error (e.g., invalid input data), it will stop reading and leave the remainder of the input stream untouched. This means that the stream may contain additional material, which can be read by the user after this routine has finished.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given input was not a valid encoding of a classical or virtual link in Jenkins' format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a9b39ba67b388f3b69f28c00fdb7c54a5" title="Creates a new classical or virtual link from Bob Jenkins&#39; format, presented as a string.">fromJenkins(const std::string&amp;)</a>, which takes the input as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that begins with a sequence of integers separated by whitespace that describes a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a9ef65e60726e56ea16fb943864f53cf3" name="a9ef65e60726e56ea16fb943864f53cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef65e60726e56ea16fb943864f53cf3">&#9670;&#160;</a></span>fromKnotSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromKnotSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a>, to recover a classical or virtual link diagram from its knot/link signature. </p>
<p>This alias <a class="el" href="#a9ef65e60726e56ea16fb943864f53cf3" title="Alias for fromSig(), to recover a classical or virtual link diagram from its knot/link signature.">fromKnotSig()</a> has been kept to reflect the fact that, in older versions of Regina, these signatures were only available for single-component knots; moreover the old name "knot signatures" can still be found in the literature. While this routine is not deprecated, it is recommended to use <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a> in new code.</p>
<p>See <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid knot/link signature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the link diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link diagram. </dd></dl>

</div>
</div>
<a id="a0efb0b58804ab890b9de49ee36380d31" name="a0efb0b58804ab890b9de49ee36380d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efb0b58804ab890b9de49ee36380d31">&#9670;&#160;</a></span>fromOrientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual knot from an "oriented" variant of the Gauss code, presented as string. </p>
<p>Oriented gauss codes overcome the limitations of classical Gauss codes by encoding all of the data needed to quickly and correctly reconstruct a knot diagram.</p>
<p>The oriented Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> string tokens. As an example, you can construct the left-hand trefoil using the code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p>See <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina (and in particular, what these tokens represent). Also note that <em>oriented</em> Gauss codes are different from <em>signed</em> Gauss codes: see <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> versus <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> for details.</p>
<p>Regina imposes the following restrictions when reconstructing a knot from an oriented Gauss code:</p>
<ul>
<li>This can only be done for knots (i.e., links with exactly one component). Both classical and virtual knots are supported.</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> in some order.</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object numbers its crossings starting from 0).</p>
<p>There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the exact form of the whitespace does not matter, and additional whitespace at the beginning or end of the string is allowed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid oriented Gauss code for a classical or virtual knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an "oriented" Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a641fd85222a55dfbf35c696e53a4ebbd" name="a641fd85222a55dfbf35c696e53a4ebbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641fd85222a55dfbf35c696e53a4ebbd">&#9670;&#160;</a></span>fromOrientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual knot from an "oriented" variant of the Gauss code, presented as a sequence of string tokens. </p>
<p>See <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, and see <a class="el" href="#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new classical or virtual knot from an &quot;oriented&quot; variant of the Gauss code,...">fromOrientedGauss(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs knots from such codes.</p>
<p>This routine is a variant of <a class="el" href="#a0efb0b58804ab890b9de49ee36380d31" title="Creates a new classical or virtual knot from an &quot;oriented&quot; variant of the Gauss code,...">fromOrientedGauss(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of string tokens. This sequence is given by passing a pair of begin/end iterators.</p>
<p>The tokens in the input sequence should be the individual tokens of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code> that would normally be joined with whitespace to form a complete oriented Gauss code. For example, to describe the left-hand trefoil, the input sequence could be a vector containing the six tokens:</p>
<pre class="fragment">{ "+&gt;1", "-&lt;2", "+&gt;3", "-&lt;1", "+&gt;2", "-&lt;3" }
</pre><p>Each individual token should <em>not</em> contain any whitespace; otherwise this routine may fail to parse the token(s) and could throw an exception as a result.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces a C++-style string (i.e., something that can be cast to <code>const std::string&amp;</code>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid oriented Gauss code for a classical or virtual knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an "oriented" Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an "oriented" Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="a9a9a67c18fe7de681acb6cec84a6e922" name="a9a9a67c18fe7de681acb6cec84a6e922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9a67c18fe7de681acb6cec84a6e922">&#9670;&#160;</a></span>fromPD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromPD </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from a planar diagram code, presented as a string. </p>
<p>Planar diagram codes overcome the limitations of classical Gauss codes by encoding the local information at each crossing, though they do introduce their own (less severe) ambiguities and computational difficulties, as described in the warnings below. They can work with links as well as knots, though they cannot encode zero-crossing unknot components. They can also (despite their name) work with virtual links as well as classical links.</p>
<p>A planar diagram code for an <em>n</em>-crossing link is formed from a sequence of <em>n</em> 4-tuples of integers. An example, you can construct the right-handed trefoil using the sequence:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
</pre><p>See <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes (and in particular, what these integers represent).</p>
<p>Regina imposes the following restrictions when reconstructing a link from a planar diagram code:</p>
<ul>
<li>The integers used in the input sequence (which denote the 2<em>n</em> strands in the link diagram) must be in the range <code>1,2,...,2n</code>, with each of these numbers used exactly twice.</li>
</ul>
<p>When Regina builds the resulting link, it numbers the crossings and components (but not the strands). It will do this as follows:</p>
<ul>
<li>Each 4-tuple in the given sequence represents a single crossing. Regina will number the crossings 0, 1, ..., <em>n</em> in the same order as the corresponding 4-tuples appear in the sequence.</li>
<li>The integers in the given sequence represent strands in the link diagram. The strand numbered 1 will become the starting point of component 0 in the final link. Of the strands not in that component, the lowest numbered strand remaining will become the starting point of component 1, and so on.</li>
<li>In particular be aware that <a class="el" href="classregina_1_1StrandRef.html#a2b631379159b6e14758a932d14d0a090" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> will in general have no relation to the strand numbers used in the planar diagram code.</li>
</ul>
<p>There are two variants of this routine. This variant takes a single string containing all 4<em>n</em> integers (see below for how this string may be formatted). The other variant takes a sequence of 4-tuples of integers, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the integers may be separated by any combination of the following:</p>
<ul>
<li>any whitespace;</li>
<li>commas;</li>
<li>open or close round brackets, square brackets and/or braces;</li>
<li>the special symbols <code>PD</code>, <code>X</code>, <code>Xp</code>, <code>Xm</code> and <code>P</code>, which are used by other sources (such as the Knot Atlas), but which are ignored here.</li>
</ul>
<p>Thus the following strings all describe the same sequence:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
PD[X[1, 5, 2, 4], X[3, 1, 4, 6], X[5, 3, 6, 2]]
1 5 2 4 3 1 4 6 5 3 6 2
</pre><p>The string may containin separators (as defined above) at the beginning and/or the end; these will be ignored.</p>
<p>Note that some sources (again, such as the Knot Atlas) use the special symbols <code>Xp</code>, <code>Xm</code> and <code>P</code> to change the meaning of the tuples. Regina does <em>not</em> attribute any meaning to these symbols, and will treat them as nothing more than separators.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the link contains any components that sit completely above all other link components (in other words, link components that consist entirely of over-crossings), then the orientations of these components might not be reconstructed correctly. This is unavoidable: the planar diagram code simply does not contain this information.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid planar diagram code for a classical or virtual link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a planar diagram code for a link, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="acb770fccc62c80b32d751d8c45b1c113" name="acb770fccc62c80b32d751d8c45b1c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb770fccc62c80b32d751d8c45b1c113">&#9670;&#160;</a></span>fromPD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromPD </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual link from a planar diagram code, presented as a sequence of 4-tuples. </p>
<p>See <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, and see <a class="el" href="#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new classical or virtual link from a planar diagram code, presented as a string.">fromPD(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs links from such codes.</p>
<p>This routine is a variant of <a class="el" href="#a9a9a67c18fe7de681acb6cec84a6e922" title="Creates a new classical or virtual link from a planar diagram code, presented as a string.">fromPD(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of 4-tuples of integers. This sequence is given by passing a pair of begin/end iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
If <em>it</em> is such an iterator, then <code>(*it)[0]</code>, <code>(*it)[1]</code>, <code>(*it)[2]</code> and <code>(*it)[3]</code> will give the elements of the corresponding 4-tuple, which can then be treated as native C++ integers. (The specific native C++ integer type being used will be deduced from the type <em>Iterator</em>.)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the link contains any components that sit completely above all other link components (in other words, link components that consist entirely of over-crossings), then the orientations of these components might not be reconstructed correctly. This is unavoidable: the planar diagram code simply does not contain this information.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid planar diagram code for a classical or virtual link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list. Each element of the list should be convertible to a tuple of integers. In particular, a list of Python lists is fine, and a list of Python tuples is fine also.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of 4-tuples for a planar diagram code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of 4-tuples for a planar diagram code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link. </dd></dl>

</div>
</div>
<a id="a953fcb3a718b0460c02da8dd210403c8" name="a953fcb3a718b0460c02da8dd210403c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953fcb3a718b0460c02da8dd210403c8">&#9670;&#160;</a></span>fromSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a classical or virtual link diagram from its knot/link signature. </p>
<p>See <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a> for more information on these signatures.</p>
<p>Calling <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a> followed by <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a> is not guaranteed to produce an <em>identical</em> link diagram to the original, but it is guaranteed to produce one that is related by zero or more applications of relabelling, and (according to the arguments that were passed to <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a>) reflection of the diagram, rotation of the diagram, and/or reversal of individual link components.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid knot/link signature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature of the link diagram to construct. Note that signatures are case-sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed link diagram. </dd></dl>

</div>
</div>
<a id="a4fad40609372ea6a1b1ae54550460e03" name="a4fad40609372ea6a1b1ae54550460e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fad40609372ea6a1b1ae54550460e03">&#9670;&#160;</a></span>fromSignedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromSignedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual knot from a "signed" variant of the Gauss code, presented as string. </p>
<p>Signed gauss codes overcome the limitations of classical Gauss codes by encoding all of the data needed to quickly and correctly reconstruct a knot diagram.</p>
<p>The signed Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> string tokens, all concatenated together with no internal whitespace. As an example, you can construct the figure eight knot using the code:</p>
<pre class="fragment">U1+O2+U3-O4-U2+O1+U4-O3-
</pre><p>See <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> for a full description of signed Gauss codes as they are used in Regina (and in particular, what these tokens represent). Also note that <em>signed</em> Gauss codes are different from <em>oriented</em> Gauss codes: see <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> versus <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for details.</p>
<p>Regina imposes the following restrictions when reconstructing a knot from a signed Gauss code:</p>
<ul>
<li>This can only be done for knots (i.e., links with exactly one component). Both classical and virtual knots are supported.</li>
<li>The crossings of the knot must be labelled 1, 2, ..., <em>n</em> in some order.</li>
</ul>
<p>Be aware that, once the knot has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object numbers its crossings starting from 0).</p>
<p>There are two variants of this routine. This variant takes a single string, where the tokens have been concatenated together with no internal whitespace. The other variant takes a sequence of 2<em>n</em> individual tokens, defined by a pair of iterators.</p>
<p>In this variant (the string variant), the code should not contain any internal whitespace; however, whitespace at the beginning or end of the string is allowed. The symbols <code>U</code> and <code>O</code> may be either upper-case or lower-case (or you may use some mix of both).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid signed Gauss code for a classical or virtual knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a "signed" Gauss code for a knot, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="aad13b0404b88f4953522178fa41c4c0d" name="aad13b0404b88f4953522178fa41c4c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad13b0404b88f4953522178fa41c4c0d">&#9670;&#160;</a></span>fromSignedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::fromSignedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new classical or virtual knot from a "signed" variant of the Gauss code, presented as a sequence of string tokens. </p>
<p>See <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> for a full description of signed Gauss codes as they are used in Regina, and see <a class="el" href="#a4fad40609372ea6a1b1ae54550460e03" title="Creates a new classical or virtual knot from a &quot;signed&quot; variant of the Gauss code,...">fromSignedGauss(const std::string&amp;)</a> for a detailed discussion of how Regina reconstructs knots from such codes.</p>
<p>This routine is a variant of <a class="el" href="#a4fad40609372ea6a1b1ae54550460e03" title="Creates a new classical or virtual knot from a &quot;signed&quot; variant of the Gauss code,...">fromSignedGauss(const std::string&amp;)</a> which, instead of taking a human-readable string, takes a machine-readable sequence of smaller string tokens (one for each crossing that you pass through when traversing the knot). This sequence is given by passing a pair of begin/end iterators.</p>
<p>The tokens in the input sequence should be the individual tokens of the form <code>Ok+</code>, <code>Ok-</code>, <code>Uk+</code> or <code>Uk-</code> that would normally be concatenated together to form a complete signed Gauss code. For example, to describe the figure eight knot, the input sequence could be a vector containing the eight tokens:</p>
<pre class="fragment">{ "U1+", "O2+", "U3-", "O4-", "U2+", "O1+", "U4-", "O3-" }
</pre><p>None of the tokens should contain any whitespace; otherwise this routine may fail to parse the token(s) and could throw an exception as a result. The symbols <code>U</code> and <code>O</code> that begin each token may be either upper-case or lower-case (or you may use some mix of both).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces a C++-style string (i.e., something that can be cast to <code>const std::string&amp;</code>).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given sequence was not a valid signed Gauss code for a classical or virtual knot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for a "signed" Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for a "signed" Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed knot. </dd></dl>

</div>
</div>
<a id="ac05b65401950517d86be107268233b09" name="ac05b65401950517d86be107268233b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05b65401950517d86be107268233b09">&#9670;&#160;</a></span>gauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::gauss </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a classical Gauss code for this knot, presented as a string. </p>
<p>Classical Gauss codes essentially describe the 4-valent graph of a knot but not the particular embedding in the plane. These codes come with major restrictions:</p>
<ul>
<li>In general, they do not carry enough information to uniquely reconstruct a classical knot. For instance, both a classical knot and its reflection can be described by the same Gauss code; moreover, for <em>composite</em> knots, the same Gauss code can describe inequivalent knots even when allowing for reflections.</li>
<li>Parsing a Gauss code to reconstruct a classical knot is complex, since it requires an embedding to be deduced using some variant of a planarity testing algorithm.</li>
<li>Because Gauss codes rely on planarity, they are not suitable at all for working with virtual knots.</li>
</ul>
<p>If you need a code that specifies the knot uniquely, and/or is fast to parse, and/or can work with both classical and virtual knots, you should use the <em>oriented</em> Gauss code instead, which resolves all of these issues.</p>
<p>The contents of a classical Gauss code are as follows. A Gauss code for an <em>n</em>-crossing knot is described by a sequence of 2<em>n</em> positive and negative integers, representing strands that pass over and under crossings respectively. The code is constructed as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. Whenever you pass crossing <em>k</em>, write the integer <code>k</code> if you pass over the crossing, or <code>-k</code> if you pass under the crossing.</li>
</ul>
<p>As an example, you can represent the trefoil using the code:</p>
<pre class="fragment">1 -2 3 -1 2 -3
</pre><p>Currently Regina only supports Gauss codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Gauss codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p>This routine formats the list of integers as a string. The integers will be separated by single spaces, and there will be no newlines.</p>
<p>The routine <a class="el" href="#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> that writes directly to an output stream.</p>
<p>Although classical Gauss codes do not support virtual knots, if this is a virtual link diagram then <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> will still produce correct output; the problem is simply that too much information is lost, and you cannot <em>reconstruct</em> your virtual link from this output.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code as described above. </dd></dl>

</div>
</div>
<a id="a5d8c0d2be78044e3fc4108e092d086a5" name="a5d8c0d2be78044e3fc4108e092d086a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8c0d2be78044e3fc4108e092d086a5">&#9670;&#160;</a></span>gauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::gauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a classical Gauss code for this knot to the given output stream. </p>
<p>See <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a>. In particular, the output does not contain any newlines.</p>
<p>For a function that <em>returns</em> the Gauss code (as opposed to writing it to an output stream), you could use <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> (which returns the Gauss code as a human-readable string), or <a class="el" href="#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a> (which returns it as a machine-readable sequence of integers).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> or <a class="el" href="#a6fb54431be1dd0e3295ef9ac07ecb739" title="Returns a classical Gauss code for this knot, presented as a vector of integers.">gaussData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb54431be1dd0e3295ef9ac07ecb739" name="a6fb54431be1dd0e3295ef9ac07ecb739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb54431be1dd0e3295ef9ac07ecb739">&#9670;&#160;</a></span>gaussData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::gaussData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a classical Gauss code for this knot, presented as a vector of integers. </p>
<p>See <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> for a full description of classical Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="#ac05b65401950517d86be107268233b09" title="Returns a classical Gauss code for this knot, presented as a string.">gauss()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty, or has multiple components, or has so many crossings that the Gauss code cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a classical Gauss code for this knot in machine-readable form. </dd></dl>

</div>
</div>
<a id="a2753c171099f2c2063080eebd78a1e1d" name="a2753c171099f2c2063080eebd78a1e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2753c171099f2c2063080eebd78a1e1d">&#9670;&#160;</a></span>graft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::graft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grafts the two given arcs of this link together, possibly making this a virtual link in the process. </p>
<p>This routine is intended for use with virtual links and, unlike <a class="el" href="#a28355f40d08c312c5f2e6cceb68bc1b4" title="Forms the composition of this with the given link.">composeWith()</a>, it offers a way to build a composite knot with full control over exactly which arcs are grafted together.</p>
<p>This operation is simple: it reroutes the part of the link that enters along the first arc to exit along the second, and it reroutes the part of the link that enters along the second arc to exit along the first. As a result:</p>
<ul>
<li>If <em>first</em> and <em>second</em> belong to <em>different</em> components of this link then it will effectively combine those two components in an operation akin to knot composition. The main difference is that, if the two components are already part of the same connected diagram component (e.g., they are already linked together), then this operation will make no attempt to separate them beforehand.</li>
<li>If <em>first</em> and <em>second</em> belong to the <em>same</em> component of this link then this operation will effectively split that component into two. It will not make any attempt to separate and/or unlink the two resulting components.</li>
</ul>
<p>The operation will never add or remove any crossings. Therefore, if the two given arcs belong to the same connected component of the diagram but do not bound the same dual 2-cell with the same orientation, this operation may increase the virtual genus.</p>
<p>Regarding the two arguments:</p>
<ul>
<li>It is allowed for <em>first</em> and <em>second</em> to refer to the same arc (in which case this operation will just split off a new zero-crossing component).</li>
<li>It is allowed for either <em>first</em> or <em>second</em> to be a null reference. In this case it will be taken to refer to a zero-crossing component, and so this operation will effectively absorb the zero-crossing component into the other link component.</li>
<li>If <em>first</em> and <em>second</em> are both null references, then they will be assumed to refer to <em>different</em> zero-crossing components.</li>
</ul>
<p>See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Either one of <em>first</em> or <em>second</em> is a null reference but this link does not contain any zero-crossing components, or <em>both</em> <em>first</em> and <em>second</em> are null references but this link does not contain at least two zero-crossing components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first of the two arcs to graft together. </td></tr>
    <tr><td class="paramname">second</td><td>the second of the two arcs to graft together. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980602d950e89b20aba2ba16ebc86521" name="a980602d950e89b20aba2ba16ebc86521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980602d950e89b20aba2ba16ebc86521">&#9670;&#160;</a></span>graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::Link::graph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 4-valent graph that models this link diagram, along with the local embedding of the graph into the surface that contains the diagram. </p>
<p>Any zero-component unknot components of this link will be ignored.</p>
<p>For classical links, the result will be a planar graph with a specific planar embedding. For virtual links, this may be an embedding of the graph into some higher genus closed orientable surface, depending on the virtual genus of the link. See <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> for further discussion on local embeddings.</p>
<p>The nodes of the resulting graph will be numbered in the same way as the crossings of this link. For each node, arc 0 will represent the outgoing lower strand of the corresponding crossing.</p>
<p>Calling <code>link.graph()</code> is identical to creating a graph via <code>ModelLinkGraph(link)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the graph that models this link. </dd></dl>

</div>
</div>
<a id="a5b1b29f281cb385e01ca2310d9ca8ad4" name="a5b1b29f281cb385e01ca2310d9ca8ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1b29f281cb385e01ca2310d9ca8ad4">&#9670;&#160;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> regina::Link::group </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the link group, as constructed from the Wirtinger presentation. </p>
<p>In the Wirtinger presentation, each relation is some variant of the form <code>xy=yz</code>, where <em>y</em> corresponds to the upper strand at some crossing, and <em>x</em> and <em>z</em> correspond to the two sides of the lower strand at that same crossing.</p>
<p>If you are working with virtual links, there are some points to note:</p>
<ul>
<li>The group <em>could</em> change depending upon whether you view the link from above or below the diagram. That is, switching the upper and lower strands at every crossing could yield non-isomorphic groups. As a result, you may wish to call <a class="el" href="#a488090ef7d89ed662e503174ec9856d3" title="Returns the two groups constructed from the Wirtinger presentation for this link and its mirror image...">groups()</a> instead, which builds <em>both</em> group presentations. See the <a class="el" href="#a488090ef7d89ed662e503174ec9856d3" title="Returns the two groups constructed from the Wirtinger presentation for this link and its mirror image...">groups()</a> documentation for further discussion, or <a class="el" href="classregina_1_1ExampleLink.html#a3dc860955643c0c05fcf6484eaa548f5" title="Returns a four-crossing diagram of the Goussarov-Polyak-Viro virtual knot.">ExampleLink::gpv()</a> for an example of a virtual knot for which these two groups are indeed non-isomorphic.</li>
<li>The link group is not a particularly strong invariant for virtual links. You might instead wish to use the <em>extended</em> group, which is stronger (but which yields larger group presentations). See <a class="el" href="#a493cc4e770dfc84ca2b6a3b73312b5fd" title="Returns the extended group of this link, as defined by Silver and Williams.">extendedGroup()</a> and <a class="el" href="#a28aa9757fe33abff27f03371d20111ef" title="Returns the extended groups of this link and its mirror image.">extendedGroups()</a> for further details.</li>
</ul>
<p>For classical links, the link group will always be isomorphic to the fundamental group of the link exterior (and in particular, the isomorphism type will not depend upon whether you view the diagram from above or below).</p>
<p>Note that, regardless of whether your link diagram is classical or virtual, <em>reflecting</em> the diagram (i.e., changing the sign of every crossing but keeping the upper/lower strands the same) will never change the isomorphism type of the link group.</p>
<p>If you pass <em>simplify</em> as <code>false</code>, this routine will keep the Wirtinger presentation and not try to simplify it further. If you pass <em>simplify</em> as <code>true</code> (the default), this routine will attempt to simplify the group presentation before returning.</p>
<dl class="section note"><dt>Note</dt><dd>If you have a classical link and you are finding the resulting group presentation too large even after simplification, you could also try calling <a class="el" href="#a7ac532f70e281f305bafaceb8c627b94" title="Returns an ideal triangulation of the complement of this link diagram.">complement()</a> and computing the fundamental group of the resulting 3-manifold triangulation instead. Sometimes the presentation obtained via the complement is better, and sometimes it is worse.</dd></dl>
<p>This group is <em>not</em> cached; instead it is reconstructed every time this function is called. This behaviour may change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if we should attempt to simplify the group presentation before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group of this link. </dd></dl>

</div>
</div>
<a id="a488090ef7d89ed662e503174ec9856d3" name="a488090ef7d89ed662e503174ec9856d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488090ef7d89ed662e503174ec9856d3">&#9670;&#160;</a></span>groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &gt; regina::Link::groups </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the two groups constructed from the Wirtinger presentation for this link and its mirror image. </p>
<p>This function is intended for use with virtual links, where these two groups might not be isomorphic.</p>
<p>As with <a class="el" href="#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">group()</a>, each Wirtinger presentation builds a group using relations of the form <code>xy=yz</code>:</p>
<ul>
<li>In first group that is returned, <em>y</em> corresponds to the upper strand at some crossing, and <em>x</em> and <em>z</em> correspond to the two sides of the lower strand at that same crossing. This is exactly the same presentation constructed by <a class="el" href="#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">group()</a>.</li>
<li>In the second group that is returned, we conceptually reflect the link diagram through the surface in which it is embedded (as though we had called <a class="el" href="#a0546dc7f2bde7b63c31f3e057a8c04db" title="Switches the upper and lower strands of every crossing in the diagram.">changeAll()</a>, though this link diagram will not actually be changed). This means that <em>y</em> will correspond to the <em>lower</em> strand at some crossing, and <em>x</em> and <em>z</em> correspond to the two sides of the <em>upper</em> strand at that same crossing.</li>
</ul>
<p>For classical links, both groups will always be isomorphic, and so there is little value in calling this function; you should just use <a class="el" href="#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">group()</a> instead.</p>
<p>For virtual links, these groups might <em>not</em> be isomorphic, and so this pair gives more information than you would obtain by just calling <a class="el" href="#a5b1b29f281cb385e01ca2310d9ca8ad4" title="Returns the link group, as constructed from the Wirtinger presentation.">group()</a>. See <a class="el" href="classregina_1_1ExampleLink.html#a3dc860955643c0c05fcf6484eaa548f5" title="Returns a four-crossing diagram of the Goussarov-Polyak-Viro virtual knot.">ExampleLink::gpv()</a> for an example of a virtual knot whose "native" Wirtinger presentation (the first group) gives the trefoil group, but whose "reflected" Wirtinger presentation (the second group) gives the unknot group.</p>
<p>A further note, however: if you are working with virtual links then the link group is not a particularly strong invariant. You might wish to consider using the <em>extended</em> link group instead; see <a class="el" href="#a493cc4e770dfc84ca2b6a3b73312b5fd" title="Returns the extended group of this link, as defined by Silver and Williams.">extendedGroup()</a> and <a class="el" href="#a28aa9757fe33abff27f03371d20111ef" title="Returns the extended groups of this link and its mirror image.">extendedGroups()</a> for further details.</p>
<p>If you pass <em>simplify</em> as <code>false</code>, this routine will keep both Wirtinger presentations and not try to simplify them further. If you pass <em>simplify</em> as <code>true</code> (the default), this routine will attempt to simplify both group presentations before returning.</p>
<p>These groups are <em>not</em> cached; instead they are reconstructed every time this function is called. This behaviour may change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplify</td><td><code>true</code> if we should attempt to simplify the group presentations before returning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the groups of this link obtained by the "native" and "reflected" Wirtinger presentations, as described above. </dd></dl>

</div>
</div>
<a id="a2c51197dbd112bb60b7893cc51a09003" name="a2c51197dbd112bb60b7893cc51a09003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c51197dbd112bb60b7893cc51a09003">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this object to a non-negative integer, allowing it to be used for keys in hash tables. </p>
<p>This hash function makes use of Regina's tight encodings. In particular, any two objects with the same tight encoding will have equal hashes. This implementation (and therefore the specific hash value for each object) is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, this function uses the standard Python name <b>hash</b>(). This allows objects of this type to be used as keys in Python dictionaries and sets.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The integer hash of this object. </dd></dl>

</div>
</div>
<a id="adfc6330cab75e59e6a004881950bda21" name="adfc6330cab75e59e6a004881950bda21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc6330cab75e59e6a004881950bda21">&#9670;&#160;</a></span>hasR1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type I Reidemeister move at the given location to remove a crossing. </p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1(Crossing*)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the candidate crossing to be removed. See <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1(Crossing*)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a8c8894af24677e11354d2cb016cb5a8c" name="a8c8894af24677e11354d2cb016cb5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8894af24677e11354d2cb016cb5a8c">&#9670;&#160;</a></span>hasR1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type I Reidemeister move at the given location to add a new crossing. </p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new candidate twist will be introduced. See <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the candidate twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the candidate twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that would be introduced as part of the candidate twist; this must be +1 or -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a1a2675d20037ea641fb1de848f29b080" name="a1a2675d20037ea641fb1de848f29b080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2675d20037ea641fb1de848f29b080">&#9670;&#160;</a></span>hasR2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type II Reidemeister move at the given location to remove two crossings. </p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this candidate move. See <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a161b736f83359e024d846150cdf055ae" name="a161b736f83359e024d846150cdf055ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161b736f83359e024d846150cdf055ae">&#9670;&#160;</a></span>hasR2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type II Reidemeister move at the given location to remove two crossings. </p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the candidate move will be performed. See <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a1415e0c84f6fc38f23c937c14f531267" name="a1415e0c84f6fc38f23c937c14f531267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1415e0c84f6fc38f23c937c14f531267">&#9670;&#160;</a></span>hasR2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a classical type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another. </p>
<p>For more detail on classical type II moves and when they can be performed, see <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a>. Note that a classical type II move on a classical link diagram will always result in a classical link diagram.</p>
<p>If you are working with virtual links, you may wish to use <a class="el" href="#a48519e0f98023bf0bc876a0f9a843e28" title="Determines whether it is possible to perform a virtual type II Reidemeister move at the given locatio...">hasR2Virtual()</a> instead, which (unlike this routine) allow moves that could change the surface in which the link diagram is embedded, and in particular which could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for classical type II moves is expensive (linear time). This is in contrast to the check for <em>virtual</em> type II moves, which is extremely fast.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies which arc of the link would be passed over another in this candidate move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap would take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap would take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies which arc of the link would be passed beneath another in this candidate move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap would take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap would take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="afb56e9f8c7c2522315a46c174683637c" name="afb56e9f8c7c2522315a46c174683637c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb56e9f8c7c2522315a46c174683637c">&#9670;&#160;</a></span>hasR2Virtual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstStrand</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a virtual type II Reidemeister move at the given location to add two new crossings by pushing the same strand over itself from opposite sides. </p>
<p>For more detail on these kinds of virtual type II moves and when they can be performed, see <a class="el" href="#acea62146d69fc238e33607bc8a5b1625" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing the sam...">r2Virtual(StrandRef, int, int)</a>. Note that a virtual type II move could potentially change the virtual genus of the link diagram; in particular, it could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies which arc of the link would be passed over itself in this candidate move. See r2(StrandRef, int, int) for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">firstSide</td><td>0 if the first portion of the arc would push out to the left of the arc (when walking along the arc in the forward direction), or 1 if the first portion would push out to the right of the arc. </td></tr>
    <tr><td class="paramname">firstStrand</td><td>0 if the first portion of the arc would be pushed under the second, or 1 if the first portion would be pushed over the second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a48519e0f98023bf0bc876a0f9a843e28" name="a48519e0f98023bf0bc876a0f9a843e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48519e0f98023bf0bc876a0f9a843e28">&#9670;&#160;</a></span>hasR2Virtual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a virtual type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another. </p>
<p>For more detail on these kinds of virtual type II moves and when they can be performed, see <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual(StrandRef, int, StrandRef, int)</a>. Note that a virtual type II move could potentially change the virtual genus of the link diagram; in particular, it could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<p>The check for virtual type II moves is extremely fast (as opposed to <em>classical</em> type II moves, where the check takes linear time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies which arc of the link would be passed over another in this candidate move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap would take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap would take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies which arc of the link would be passed beneath another in this candidate move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap would take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap would take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a83cd07a5c9e2777dcec94c99f7f5324a" name="a83cd07a5c9e2777dcec94c99f7f5324a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cd07a5c9e2777dcec94c99f7f5324a">&#9670;&#160;</a></span>hasR3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type III Reidemeister move at the given location. </p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this candidate move. See <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="a16752ca1a1b0efb69c577d62d3a41cd2" name="a16752ca1a1b0efb69c577d62d3a41cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16752ca1a1b0efb69c577d62d3a41cd2">&#9670;&#160;</a></span>hasR3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasR3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether it is possible to perform a type III Reidemeister move at the given location. </p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the candidate move would be performed. See <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move can be performed. </dd></dl>

</div>
</div>
<a id="acb6293eb60b5477b5cac84363c43286a" name="acb6293eb60b5477b5cac84363c43286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6293eb60b5477b5cac84363c43286a">&#9670;&#160;</a></span>hasReducingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::hasReducingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether this classical link has a pass move that will reduce the number of crossings. </p>
<p>A <em>pass</em> move involves taking a section of some link component that involves only over-crossings (or only under-crossings), and then lifting that section above (or beneath respectively) the plane of the diagram and placing it back again in a different location. In particular, this routine searches for a different location that will involve fewer crossings than the original location.</p>
<p>In Regina, pass moves can only be used with classical links, not the more general setting of virtual link diagrams.</p>
<p>This routine does not actually <em>perform</em> the pass move; it simply determines whether one exists.</p>
<p>The running time is cubic in the number of crossings.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link diagram is classical (not virtual).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This is a virtual (not classical) link diagram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is a pass move that reduces the number of crossings. </dd></dl>

</div>
</div>
<a id="a7556a53360868c1cf7b15f101707451d" name="a7556a53360868c1cf7b15f101707451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7556a53360868c1cf7b15f101707451d">&#9670;&#160;</a></span>homfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::homfly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>This routine is simply an alias for <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a>. See the documentation for <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> for further details.</p>
<p>At present, Regina only computes HOMFLY-PT polynomials for classical links. If this is a virtual link diagram, then this routine will throw an exception.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyVarX, Link::homflyVarY)</code>.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a> should be called again; this will be instantaneous if the HOMFLY-PT polynomial has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link diagram is classical (not virtual).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This is a virtual (not classical) link diagram.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a856c907997ffe4a3006b388fab1ae843" title="An optimised backtracking algorithm.">Algorithm::Backtrack</a> will use Kauffman's skein-template algorithm, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY-PT polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="aa88368c61fae199e0a3dfa48b09ef46a" name="aa88368c61fae199e0a3dfa48b09ef46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88368c61fae199e0a3dfa48b09ef46a">&#9670;&#160;</a></span>homflyAZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::homflyAZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>alpha</em> and <em>z</em>. </p>
<p>At present, Regina only computes HOMFLY-PT polynomials for classical links. If this is a virtual link diagram, then this routine will throw an exception.</p>
<p>This variant of the HOMFLY-PT polynomial is described (amongst other places) in G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY-PT polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>alpha</em> and <em>z</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> should be called again; this will be instantaneous if the HOMFLY-PT polynomial has already been calculated.</p>
<p>If the HOMFLY-PT polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p>Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link diagram is classical (not virtual).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This is a virtual (not classical) link diagram.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a856c907997ffe4a3006b388fab1ae843" title="An optimised backtracking algorithm.">Algorithm::Backtrack</a> will use Kauffman's skein-template algorithm, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY-PT polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a3cf01ac5bd43984ba0530b5548e24755" name="a3cf01ac5bd43984ba0530b5548e24755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf01ac5bd43984ba0530b5548e24755">&#9670;&#160;</a></span>homflyAZtoLM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; regina::Link::homflyAZtoLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>homflyAZ</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts between the (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) representations of the HOMFLY-PT polynomial. </p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>See <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homflyAZ</td><td>the HOMFLY-PT polynomial of a link as a polynomial in <em>alpha</em> and <em>z</em>, where (<em>alpha</em>, <em>z</em>) are represented by (<em>x</em>, <em>y</em>) in the class Laurent2&lt;Integer&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY-PT polynomial of the same link as a polynomial in <em>l</em> and <em>m</em>, where (<em>l</em>, <em>m</em>) are represented by (<em>x</em>, <em>y</em>) in the class Laurent2&lt;Integer&gt;. </dd></dl>

</div>
</div>
<a id="a7ee829fa01ddd45f97fa2fed002d950e" name="a7ee829fa01ddd45f97fa2fed002d950e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee829fa01ddd45f97fa2fed002d950e">&#9670;&#160;</a></span>homflyLM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::homflyLM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in <em>l</em> and <em>m</em>. </p>
<p>At present, Regina only computes HOMFLY-PT polynomials for classical links. If this is a virtual link diagram, then this routine will throw an exception.</p>
<p>This variant of the HOMFLY-PT polynomial is described (amongst other places) in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994.</p>
<p>The (<em>alpha</em>, <em>z</em>) and (<em>l</em>, <em>m</em>) variants of the HOMFLY-PT polynomial are related by a simple transformation: <em>alpha</em> = <em>l</em> <em>i</em> and <em>z</em> = -<em>m</em> <em>i</em>, where <em>i</em> represents (as usual) a square root of -1.</p>
<p>This routine returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>l</em> and <em>m</em> (which are represented by <em>x</em> and <em>y</em> respectively in the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a>).</p>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>.</p>
<p>The default implementation uses Kauffman's skein-template algorithm; see L. H. Kauffman, "State models for link polynomials", L'enseignement mathematique 36 (1990), 1-37, or for a more recent summary see G. Gouesbet et al., "Computer evaluation of Homfly
polynomials by using Gauss codes, with a skein-template algorithm", Applied Mathematics and Computation 105 (1999), 271-289.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> should be called again; this will be instantaneous if the HOMFLY-PT polynomial has already been calculated.</p>
<p>If the HOMFLY-PT polynomial has already been computed (either in terms of <em>alpha</em> and <em>z</em> or in terms of <em>l</em> and <em>m</em>), then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p>Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link diagram is classical (not virtual).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This is a virtual (not classical) link diagram.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a856c907997ffe4a3006b388fab1ae843" title="An optimised backtracking algorithm.">Algorithm::Backtrack</a> will use Kauffman's skein-template algorithm, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> will use a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the HOMFLY-PT polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a923494c241213368b6e58ec528fa1abd" name="a923494c241213368b6e58ec528fa1abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923494c241213368b6e58ec528fa1abd">&#9670;&#160;</a></span>improveTreewidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::improveTreewidth </td>
          <td>(</td>
          <td class="paramtype">ssize_t</td>          <td class="paramname"><span class="paramname"><em>maxAttempts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to rewrite this link diagram to become one with a smaller width tree decomposition. </p>
<p>Regina does not compute treewidth precisely (and indeed, this is an NP-hard problem); instead what it tries to minimise is the width of the greedy tree decomposition produced by <code>TreeDecomposition(link)</code>.</p>
<p>Much like <a class="el" href="#a348fb1c73d7db51376811fe090129a27" title="Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a>, this routine searches for a better diagram by performing an exhaustive search through all link diagrams that can be reached from this via Reidemeister moves, within certain user-supplied limits as described below. (If this link diagram is disconnected, then there is an exception: this routine will never use a type II move to merge distinct diagram components together, which would never help with improving treewidth). It does this in a way that will never reflect, rotate or reverse the link diagram. Both classical and virtual link diagrams are supported.</p>
<p>This routine can be very slow and very memory-intensive: the number of link diagrams it visits may be exponential in the number of crossings, and it records every diagram that it visits (so as to avoid revisiting the same diagram again). You can limit the cost of this search in two ways:</p>
<ul>
<li>You can pass a <em>maxAttempts</em> argument, which means this return will give up after visiting <em>maxAttempts</em> distinct link diagrams (up to the kind of combinatorial equivalence described by <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a>). If <em>maxAttempts</em> is negative, the number of attempts will not be limited.</li>
<li>You can pass a <em>height</em> argument to limit the number of extra crossings. Again, if <em>height</em> is negative, the number of additional crossings will not be limited.</li>
<li>The defaults for <em>maxAttempts</em> and <em>height</em> are both non-negative, and have been chosen to keep the default invocation of this routine relatively fast.</li>
<li>If <em>both</em> <em>maxAttempts</em> and <em>height</em> are negative, this routine will not terminate until a smaller-width diagram is found. If no such diagram exists then the only way to terminate this routine is to cancel the operation via a progress tracker (read on for details).</li>
</ul>
<p>If this routine finds a diagram with a smaller-width greedy tree decomposition, then:</p>
<ul>
<li>If <em>maxAttempts</em> was negative (i.e., unlimited), it will stop the search at this point and leave you with this better diagram. You may wish to try calling <a class="el" href="#a923494c241213368b6e58ec528fa1abd" title="Attempts to rewrite this link diagram to become one with a smaller width tree decomposition.">improveTreewidth()</a> again, since it is possible that another search will be able to improve the diagram even further.</li>
<li>If <em>maxAttempts</em> was non-negative (i.e., limited), it will keep going by restarting the search again from this better diagram. In other words, this routine will proceed with a kind of "greedy
  descent". The <em>height</em> argument will now be treated with respect to this <em>new</em> diagram, and the number of attempts (which is limited by <em>maxAttempts</em>) will be reset to zero. This means that overall you may end up with more than <em>height</em> extra crossings, and you may have visited more than <em>maxAttempts</em> distinct diagrams; however, if this happens then you know you are getting a better diagram.</li>
</ul>
<p>If this routine cannot produce a smaller-width tree decomposition within the bounds given via <em>maxAttempts</em> and/or <em>height</em>, then it will leave this link diagram unchanged.</p>
<p>If this is a <em>classical</em> link diagram then only classical Reidemeister moves will be used, as implemented by <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a>, <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> and <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a>; in particular, this routine will never consider link diagrams with positive virtual genus. If this is a <em>virtual</em> link diagram, then both classical and virtual Reidemeister moves will be used, including <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a>, <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a>, <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a>, and <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a>; this means that the exploration through the Reidemeister graph might pass through diagrams with smaller and/or greater virtual genus than the original.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either a better link diagram was found or the search was exhausted), and any change to this link diagram will happen in the calling thread.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has at most 64 link components.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link has 64 or more link components. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxAttempts</td><td>the maximum number of distinct link diagrams to examine before we give up and return <code>false</code>, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this diagram was successfully changed to give a smaller-width greedy tree decomposition. </dd></dl>

</div>
</div>
<a id="aba467ea1ca812832b4ff15d6fbe23654" name="aba467ea1ca812832b4ff15d6fbe23654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba467ea1ca812832b4ff15d6fbe23654">&#9670;&#160;</a></span>insertLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given link into this link. </p>
<p>The crossings and components of <em>source</em> will be copied into this link, and placed after any pre-existing crossings and components. Specifically, if the original number of crossings in this link was <em>N</em>, then crossing number <em>i</em> of <em>source</em> will be copied to a new crosssing <code>N+i</code> of this link; likewise for components.</p>
<p>This routine behaves correctly when <em>source</em> is this link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the link whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29ac53ae9a6ba97098bea021daf80035" name="a29ac53ae9a6ba97098bea021daf80035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ac53ae9a6ba97098bea021daf80035">&#9670;&#160;</a></span>insertLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given link into this link. </p>
<p>The crossings and components of <em>source</em> will be moved directly into this link, and placed after any pre-existing crossings and components. Specifically, if the original number of crossings in this link was <em>N</em>, then crossing number <em>i</em> of <em>source</em> will become crosssing <code>N+i</code> of this link; likewise for components.</p>
<p>As is normal for an rvalue reference, after calling this function <em>source</em> will be unusable. Any strand references or crossing pointers that referred to either this link or <em>source</em> will remain valid (and will all now refer to this link), though if they originally referred to <em>source</em> then they will now return different crossing indices and strand IDs.</p>
<p>Calling <code>link.insertLink(source)</code> (where <em>source</em> is an rvalue reference) is similar to calling <code>source.moveContentsTo(link)</code>, but it is a little faster since it does not need to leave <em>source</em> in a usable state.</p>
<p>Regarding packet change events: this function does <em>not</em> fire a change event on <em>source</em>, since it assumes that <em>source</em> is about to be destroyed (which will fire a destruction event instead).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>source</em> is not this link.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Only the copying version of this function is available (i.e., the version that takes <em>source</em> as a const reference). If you want a fast move operation, call <code>source.moveContentsTo(this)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the link whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa11d6d31315c7b000cb653901a0a711c" name="aa11d6d31315c7b000cb653901a0a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d6d31315c7b000cb653901a0a711c">&#9670;&#160;</a></span>insertTorusLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::insertTorusLink </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>positive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new (<em>p</em>, <em>q</em>) torus link into this link. </p>
<p>The parameters <em>p</em> and <em>q</em> must be non-negative, but they do not need to be coprime.</p>
<p>All of the crossings in the new torus link component(s) will be positive if the argument <em>positive</em> is <code>true</code>, or negative otherwise.</p>
<p>The new crossings and components will be inserted at the end of the respective lists in this link.</p>
<p>If your aim is to create a new torus link (as opposed to inserting one into an existing link), it is simpler to just call <a class="el" href="classregina_1_1ExampleLink.html#a5320898a2ce801f9d5ae1d9684b0c954" title="Returns the (p,q) torus link.">ExampleLink::torus()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the first parameter of the new torus link; this must be non-negative. </td></tr>
    <tr><td class="paramname">q</td><td>the second parameter of the new torus link; this must also be non-negative. </td></tr>
    <tr><td class="paramname">positive</td><td><code>true</code> if the crossings in the new torus link should be positive, or <code>false</code> if they should be negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fc961ba707da75f2b71d3585c994cc9" name="a5fc961ba707da75f2b71d3585c994cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc961ba707da75f2b71d3585c994cc9">&#9670;&#160;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a>, which attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated</a></b></dt><dd>This routine has been renamed to <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a>. See <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link diagram was successfully simplified. </dd></dl>

</div>
</div>
<a id="a821a3c1d060bdc5f3807ee1a64064775" name="a821a3c1d060bdc5f3807ee1a64064775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821a3c1d060bdc5f3807ee1a64064775">&#9670;&#160;</a></span>isAlternating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isAlternating </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this link diagram is alternating. </p>
<p>Note that this routine cannot tell whether the <em>link</em> is alternating (i.e., whether there <em>exists</em> an alternating diagram). Instead, it simply returns whether this specific diagram is alternating or not.</p>
<p>The empty diagram and any zero-crossing unknot components will be considered alternating.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an alternating diagram, or <code>false</code> if this is a non-alternating diagram. </dd></dl>

</div>
</div>
<a id="aef04100b89965f3d9215ccd3b45c068d" name="aef04100b89965f3d9215ccd3b45c068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef04100b89965f3d9215ccd3b45c068d">&#9670;&#160;</a></span>isClassical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isClassical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link diagram is classical (that is, planar). </p>
<p>A link diagram that is <em>not</em> classical cannot be drawn in the plane without the addition of virtual crossings.</p>
<p>Some notes:</p>
<ul>
<li>Calling <a class="el" href="#aef04100b89965f3d9215ccd3b45c068d" title="Determines whether this link diagram is classical (that is, planar).">isClassical()</a> is equivalent to testing whether <a class="el" href="#ac664dc51d245b364d16e03cabf71b716" title="Determines the virtual genus of this link diagram.">virtualGenus()</a> is zero.</li>
<li>This is a property of the link <em>diagram</em>, not the link itself. In particular, it is possible for a classical link to be represented using a non-classical diagram (i.e., a diagram that requires virtual crossings when drawn in the plane).</li>
<li>As mentioned in the class notes, the <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> class does not actually store virtual crossings; instead it treats the link diagram as living within some closed orientable surface. Any discussion of virtual crossings in the notes above is for exposition only.</li>
</ul>
<p>This routine runs in time linear in the size of the link diagram. However, the virtual genus is cached, and so subsequent calls to <a class="el" href="#aef04100b89965f3d9215ccd3b45c068d" title="Determines whether this link diagram is classical (that is, planar).">isClassical()</a> or <a class="el" href="#ac664dc51d245b364d16e03cabf71b716" title="Determines the virtual genus of this link diagram.">virtualGenus()</a> will be instantaneous.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link diagram is classical. (i.e., planar). </dd></dl>

</div>
</div>
<a id="abaef4e2484c8c9c8c995ed709a43acfb" name="abaef4e2484c8c9c8c995ed709a43acfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaef4e2484c8c9c8c995ed709a43acfb">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection. </p>
<p>This tests whether it is possible to travel from any part of the link to any other part of the link by:</p>
<ul>
<li>following the link around its components, and/or;</li>
<li>jumping between upper and lower strands at crossings.</li>
</ul>
<p>In particular, the link diagram may be connected even if the link has multiple components.</p>
<p>Connectivity is a property of the diagram, not an invariant of the link itself, since the locations of the crossings matter. In particular:</p>
<ul>
<li>a disconnected diagram <em>must</em> describe a splittable link;</li>
<li>a splittable link, however, could be represented by either a connected or disconnected link diagram.</li>
</ul>
<p>This is almost, but not quite, equivalent to testing whether the underlying 4-valent graph of the link diagram is connected. Specifically, where <code>link.isConnected()</code> and <code>link.graph().<a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb" title="Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.">isConnected()</a></code> differ is in cases where the link has zero-crossing components (i.e., unknotted circles disjoint from the rest of the diagram). Zero-crossing components are considered here in <code><a class="el" href="#abaef4e2484c8c9c8c995ed709a43acfb" title="Determines whether this link diagram is connected, if we treat each crossing as a 4-way intersection.">Link.isConnected()</a></code> but <em>not</em> in <code><a class="el" href="classregina_1_1ModelLinkGraph.html#a2545252542893d425c305061876822c4" title="Identifies whether this graph is connected.">ModelLinkGraph.isConnected()</a></code>, since such components cannot be represented by a 4-valent graph (and so the <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent graph with a specific embedding in some closed orientable surface.">ModelLinkGraph</a> class ignores them completely).</p>
<p>For the purposes of this routine, an empty link is considered to be connected.</p>
<p>Note: for knots and empty links, this routine is constant time. For multiple-component links, it is linear in the link size.</p>
<p>See also <a class="el" href="#a9c1cff257b0e1ac3dce82146c476e3a8" title="Returns the total number of connected diagram components.">countDiagramComponents()</a> which returns an integer count instead of a boolean, and <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a> which extracts the diagra components as individual <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link diagram is connected. </dd></dl>

</div>
</div>
<a id="ad12a7e69700971494486e299bbc39c57" name="ad12a7e69700971494486e299bbc39c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12a7e69700971494486e299bbc39c57">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this link is empty. </p>
<p>An empty link is one with no components at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this link is empty. </dd></dl>

</div>
</div>
<a id="a194f84f5ad2fb28ab1a0da34aa69d8a8" name="a194f84f5ad2fb28ab1a0da34aa69d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194f84f5ad2fb28ab1a0da34aa69d8a8">&#9670;&#160;</a></span>jenkins() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link using Bob Jenkins' text format, returning a single string. </p>
<p>Jenkins' format is lengthy. However, in contrast to classical Gauss codes or Dowker-Thistlethwaite notation, there are no topological ambiguities in the format, and reconstructing a link from Jenkins' format is simple. Moreover, the format is suitable for links with any number of components, and can be used with both virtual and classical links.</p>
<p>Jenkins' format is described in his HOMFLY-PT polynomial software, which is available online from <a href="http://burtleburtle.net/bob/knot/homfly.html">http://burtleburtle.net/bob/knot/homfly.html</a>. The format consists of a sequence of integers separated by whitespace, constructed as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 0, 1, ..., <em>n</em>-1.</li>
<li>Write the number of components in the link.</li>
<li>Next, for each link component:<ul>
<li>write the number of times you pass a crossing when traversing the component (i.e., the length of the component);</li>
<li>write two integers for each crossing that you pass in such a traversal: the crossing label, and then +1 if you pass over the crossing or -1 if you pass under the crossing.</li>
</ul>
</li>
<li>Finally, for each crossing:<ul>
<li>write the crossing label;</li>
<li>write the sign of the crossing (either +1 or -1).</li>
</ul>
</li>
</ul>
<p>As an example, you could describe the left-hand trefoil using the following sequence:</p>
<pre class="fragment">1
6   0 1   1 -1   2 1   0 -1   1 1   2 -1
0 -1   1 -1   2 -1
</pre><p>Another example is the Hopf link, which you could describe using the following sequence:</p>
<pre class="fragment">2
2   0 1   1 -1
2   0 -1   1 1
0 1   1 1
</pre><p>The string that is returned will contain multiple lines, and will end in a newline. The specific choice of whitespace (i.e., the "formatting" of the sequence) may change in future versions of Regina.</p>
<p>The routine <a class="el" href="#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a> returns this same data in machine-readable format (as a C++ vector), instead of the human-readable format used here (a string). There is also another variant of <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' text format. </dd></dl>

</div>
</div>
<a id="a6509ca2eaf2920bf4dc7e69eb5f5f499" name="a6509ca2eaf2920bf4dc7e69eb5f5f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6509ca2eaf2920bf4dc7e69eb5f5f499">&#9670;&#160;</a></span>jenkins() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::jenkins </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link to the given output stream using Bob Jenkins' text format. </p>
<p>See <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format as it is used in Regina.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a>. In particular, the output will typically span multiple lines, and will finish with a newline.</p>
<p>For a function that <em>returns</em> the link in Jenkins' format (as opposed to writing it to an output stream), you could use <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> (which returns the description as a human-readable string), or <a class="el" href="#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a> (which returns it as a machine-readable sequence of integers).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> or <a class="el" href="#a73f2e96eaaf8284a8f6afc0094ccd793" title="Exports this link using Bob Jenkins&#39; text format, returning a vector of integers.">jenkinsData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f2e96eaaf8284a8f6afc0094ccd793" name="a73f2e96eaaf8284a8f6afc0094ccd793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f2e96eaaf8284a8f6afc0094ccd793">&#9670;&#160;</a></span>jenkinsData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; regina::Link::jenkinsData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this link using Bob Jenkins' text format, returning a vector of integers. </p>
<p>See <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> for a full description of Jenkins' format as it is used in Regina.</p>
<p>This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="#a194f84f5ad2fb28ab1a0da34aa69d8a8" title="Exports this link using Bob Jenkins&#39; text format, returning a single string.">jenkins()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link has so many crossings and/or components that its description in Jenkins' format cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a description of this link using Jenkins' format in machine-readable form. </dd></dl>

</div>
</div>
<a id="abb8b6c7c6a93fbec91c28282238c7465" name="abb8b6c7c6a93fbec91c28282238c7465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b6c7c6a93fbec91c28282238c7465">&#9670;&#160;</a></span>jones() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::jones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the Jones polynomial of this link with all exponents doubled, using a single thread and an explicit progress tracker. </p>
<p>This routine is provided for backward compatibility: its only purpose is to offer a syntax that was supported in old versions of Regina but is not consistent with the new form of <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> that supports multithreading.</p>
<p>See jones(Algorithm, int, ProgressTracker*) for further details on what this routine does and relevant warnings that you should be aware of.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated</a></b></dt><dd>If you need to use this form of <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> (i.e., single-threaded with an explicit progress tracker), you should call <code>jones(alg, 1, tracker)</code> instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jones polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a82d4fa2ccffd5c8744f0eb02a5ac4bdb" name="a82d4fa2ccffd5c8744f0eb02a5ac4bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb">&#9670;&#160;</a></span>jones() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Laurent.html">Laurent</a>&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt; &amp; regina::Link::jones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67">Algorithm::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jones polynomial of this link, but with all exponents doubled. </p>
<p>By "all exponents doubled", we are indicating that the Jones polynomial is in fact a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>. So, for example:</p>
<ul>
<li>The right-hand trefoil has Jones polynomial <code>1/t + 1/t^3 - 1/t^4</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>x^-2 + x^-6 - x^-8</code>.</li>
<li>The Hopf link has Jones polynomial <code>-1/sqrt(x) - 1/sqrt(x^5)</code>, and so this routine returns the <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial <code>-x^-1 - x^-5</code>.</li>
</ul>
<p>If this is the empty link, then this routine will return the zero polynomial.</p>
<p>Regina follows the conventions described in C. C. Adams, "The knot book", W. H. Freeman &amp; Co., 1994. If you wish to convert to the conventions used by Khovanov as described in Dror Bar-Natan, "On Khovanov's categorifiction of the Jones
polynomial", Algebraic &amp; Geometric Topology 2 (2002), 337-370, you can simply take the polynomial returned by this routine and replace the variable <em>x</em> (which represents the square root of <em>t</em>) with the expression -<em>q</em>.</p>
<p>To pretty-print this polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>.</p>
<p>Bear in mind that each time a link changes, all of its polynomials will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> should be called again; this will be instantaneous if the Jones polynomial has already been calculated.</p>
<p>If this polynomial has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger numbers of crossings.</p>
<p>Since Regina 7.0, this routine will not return until the polynomial computation is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the computation to start in the background), simply call this routine in a new detached thread.</p>
<dl class="section warning"><dt>Warning</dt><dd>The naive algorithm can only handle a limited number of crossings (currently at most 63). If you pass <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> and you have too many crossings (which is not advised, since the naive algorithm requires 2^<em>n</em> time), then this routine will ignore your choice of algorithm and use the treewidth-based algorithm regardless.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is <em>so</em> large that the total number of strands cannot fit into a signed <code>int</code>. (On a typical machine where <code>int</code> is 32-bit, this would require over a <em>billion</em> crossings). Note that, if you have such a link, then this function (which is exponential time) would be intractably slow anyway.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the polynomial. If you are not sure, the default (<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a7a1920d61156abc05a60135aefe8bc67" title="The default algorithm.">Algorithm::Default</a>) is a safe choice. If you wish to specify a particular algorithm, there are currently two choices: <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a512d6102506da4ae0c35312fafcf7376" title="A naive algorithm.">Algorithm::Naive</a> is a slow algorithm that computes the Kauffman bracket by resolving all crossings in all possible ways, and <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a> uses a fixed-parameter tractable treewidth-based algorithm. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the computation will run single-threaded. Currently only the naive algorithm supports multithreading; if you use the treewidth-based algorithm then it will run single-threaded regardless of the value of <em>threads</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jones polynomial, or the zero polynomial if the calculation was cancelled via the given progress tracker. </dd></dl>

</div>
</div>
<a id="a4ff04fa3e747640d374fd95f9d54ac3d" name="a4ff04fa3e747640d374fd95f9d54ac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff04fa3e747640d374fd95f9d54ac3d">&#9670;&#160;</a></span>knotSig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::knotSig </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReflection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReversal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowRotation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a>, which constructs the signature for this knot or link diagram. </p>
<p>This alias <a class="el" href="#a4ff04fa3e747640d374fd95f9d54ac3d" title="Alias for sig(), which constructs the signature for this knot or link diagram.">knotSig()</a> has been kept to reflect the fact that, in older versions of Regina, these signatures were only available for single-component knots; moreover the old name "knot signatures" can still be found in the literature. While this routine is not deprecated, it is recommended to use <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a> in new code.</p>
<p>See <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link diagram has 64 or more link components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowReflection</td><td><code>true</code> if reflecting the entire link diagram should preserve the signature, or <code>false</code> if the signature should distinguish between a diagram and its reflection (unless of course there is a symmetry). </td></tr>
    <tr><td class="paramname">allowReversal</td><td><code>true</code> if reversing some or all link components should preserve the signature, or <code>false</code> if the signature should distinguish between different orientations (again, unless of course there are symmetries). </td></tr>
    <tr><td class="paramname">allowRotation</td><td><code>true</code> if rotating the entire link diagram should preserve the signature, or <code>false</code> if the signature should distinguish between a diagram and its rotation (again, unless there is a symmetry). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature for this link diagram. </dd></dl>

</div>
</div>
<a id="a62b4072bfb8aa015ca5d5816f6b405cc" name="a62b4072bfb8aa015ca5d5816f6b405cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b4072bfb8aa015ca5d5816f6b405cc">&#9670;&#160;</a></span>knowsAlexander()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsAlexander </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Alexander polynomial of this knot already known? See <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a> will be very fast (simply returning the precalculated value).</p>
<p>At present, Regina only computes Alexander polynomials for classical knots. If this link is empty, has multiple components, or uses a virtual diagram, then this routine is still safe to call, and will simply return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a4f59083d93e72fff367b267164137b8d" name="a4f59083d93e72fff367b267164137b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f59083d93e72fff367b267164137b8d">&#9670;&#160;</a></span>knowsArrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsArrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the normalised arrow polynomial of this link already known? See <a class="el" href="#ac6cba955bad42df796502635a382bdd1" title="Returns the normalised arrow polynomial of this link.">arrow()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="#ac6cba955bad42df796502635a382bdd1" title="Returns the normalised arrow polynomial of this link.">arrow()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a6a432a4f3024e537920770c0eb60d2e2" name="a6a432a4f3024e537920770c0eb60d2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a432a4f3024e537920770c0eb60d2e2">&#9670;&#160;</a></span>knowsBracket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsBracket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Kauffman bracket polynomial of this link diagram already known? See <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="ae7100ef279d1f9a4ed7a739e76d5c5d4" name="ae7100ef279d1f9a4ed7a739e76d5c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7100ef279d1f9a4ed7a739e76d5c5d4">&#9670;&#160;</a></span>knowsHomfly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsHomfly </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the HOMFLY-PT polynomial of this link already known? See <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a>, <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> and <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> will all be very fast (simply returning the precalculated values).</p>
<p>At present, Regina only computes HOMFLY-PT polynomials for classical links. If this is a virtual (not classical) link diagram, then this routine is still safe to call, and will simply return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a13a2acb5efa330841a89e91d28e5d64a" name="a13a2acb5efa330841a89e91d28e5d64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a2acb5efa330841a89e91d28e5d64a">&#9670;&#160;</a></span>knowsJones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::knowsJones </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the Jones polynomial of this link already known? See <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="a8cdacd0939c10de129dcf4c9a72f209c" name="a8cdacd0939c10de129dcf4c9a72f209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdacd0939c10de129dcf4c9a72f209c">&#9670;&#160;</a></span>linking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::linking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the linking number of this link, or throws an exception if it is not an integer. </p>
<p>The linking number is an invariant of the link, computed as half the sum of the signs of all crossings that involve different link components.</p>
<p>For classical links, the linking number is always an integer, and so <a class="el" href="#a8cdacd0939c10de129dcf4c9a72f209c" title="Returns the linking number of this link, or throws an exception if it is not an integer.">linking()</a> will always return successfully.</p>
<p>For virtual links, the linking number might have a half-integer part; if this happens then <a class="el" href="#a8cdacd0939c10de129dcf4c9a72f209c" title="Returns the linking number of this link, or throws an exception if it is not an integer.">linking()</a> will throw an exception. If you are working with virtual links then you should use <a class="el" href="#ab13e27c0b1cbca7df9c541df3f567ea8" title="Returns twice the linking number of this link, which is always an integer for both classical and virt...">linking2()</a> instead, which does not halve the sum of signs, and which therefore always returns successfully with an integer result.</p>
<p>The algorithm to compute linking number is linear time.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This is a virtual link whose linking number is not an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linking number. </dd></dl>

</div>
</div>
<a id="ab13e27c0b1cbca7df9c541df3f567ea8" name="ab13e27c0b1cbca7df9c541df3f567ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13e27c0b1cbca7df9c541df3f567ea8">&#9670;&#160;</a></span>linking2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::linking2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns twice the linking number of this link, which is always an integer for both classical and virtual links. </p>
<p>The linking number is an invariant of a link, computed as half the sum of the signs of all crossings that involve different link components. For classical links the linking number is always an integer, whereas for virtual links it might have a half-integer part.</p>
<p>This routine returns <em>twice</em> the linking number, which is always guaranteed to be an integer. If you are working with virtual links then you should use <a class="el" href="#ab13e27c0b1cbca7df9c541df3f567ea8" title="Returns twice the linking number of this link, which is always an integer for both classical and virt...">linking2()</a> instead of <a class="el" href="#a8cdacd0939c10de129dcf4c9a72f209c" title="Returns the linking number of this link, or throws an exception if it is not an integer.">linking()</a>, since <a class="el" href="#a8cdacd0939c10de129dcf4c9a72f209c" title="Returns the linking number of this link, or throws an exception if it is not an integer.">linking()</a> will throw an exception if its result has a fractional part.</p>
<p>The algorithm to compute linking number is linear time.</p>
<dl class="section return"><dt>Returns</dt><dd>twice the linking number. </dd></dl>

</div>
</div>
<a id="acb7e7a62ac8738aa49db49c497cd5327" name="acb7e7a62ac8738aa49db49c497cd5327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7e7a62ac8738aa49db49c497cd5327">&#9670;&#160;</a></span>longComplement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::Link::longComplement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>breakOpen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treats this as a long knot, and returns a triangulation of the complement with mixed real/ideal boundary. </p>
<p>Conceptually, one can think of this routine as doing the following:</p>
<ul>
<li>Break this knot open at the given arc, and embed the knot inside a 3-ball with the two free ends on the boundary of the ball (thus turning this into a <em>long knot</em>);</li>
<li>Drill out the long knot from the 3-ball;</li>
<li>Triangulate the resulting space so that:<ul>
<li>the sphere bounding the ball is represented using four boundary triangles with two points pinched together at some vertex <em>v</em>;</li>
<li>this vertex <em>v</em> has annulus link;</li>
<li>if we trunate <em>v</em>, then the resulting annulus follows the part of boundary where the long knot was drilled out of the ball.</li>
</ul>
</li>
</ul>
<p>The vertex <em>v</em> as described above will be invalid, since its link is an annulus. Essentially, the real part of the boundary (the four boundary triangles) describes the sphere bounding the 3-ball, and the ideal part of the boundary (the link of <em>v</em>) describes the annulus bounding the long knot inside this ball.</p>
<p>If you truncate <em>v</em> (e.g., by calling <code>complement.truncate(v)</code> or <code>complement.truncateIdeal()</code>), then the result will be a valid triangulation of the knot complement with real boundary.</p>
<p>As with <a class="el" href="#a7ac532f70e281f305bafaceb8c627b94" title="Returns an ideal triangulation of the complement of this link diagram.">complement()</a>, each tetrahedron will be oriented according to a right-hand rule: the thumb of the right hand points from vertices 0 to 1, and the fingers curl around to point from vertices 2 to 3. If you pass <em>simplify</em> as <code>true</code>, then Regina will attempt to simplify the triangulation to as few tetrahedra as possible: this may relabel the tetrahedra, though their orientations will be preserved.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a classical knot. That is, the link diagram is not virtual, and has exactly one link component.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty, has multiple components, and/or is virtual (as opposed to classical).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">breakOpen</td><td>indicates where to break open this knot diagram to produce a long knot. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects. This may be a null reference (the default), in which case this routine will choose an arbitrary location to break the knot open. </td></tr>
    <tr><td class="paramname">simplify</td><td><code>true</code> if and only if the resulting triangulation should be simplified to use as few tetrahedra as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long knot complement with mixed real/ideal boundary, as described above. </dd></dl>

</div>
</div>
<a id="a36c7e8a7048b0bf1e00f8eb5c942a224" name="a36c7e8a7048b0bf1e00f8eb5c942a224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c7e8a7048b0bf1e00f8eb5c942a224">&#9670;&#160;</a></span>makeAlternating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::makeAlternating </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a subset of crossings to convert this into an alternating link diagram. </p>
<p>Here, "changing" a crossing means switching its upper and lower strands (so this operation may change this into a topologically different link).</p>
<p>This is always possible for classical link diagrams; however, for virtual link diagrams it might or might not be possibe.</p>
<p>Any zero-crossing unknot components will be considered alternating; likewise, the empty link is considered alternating.</p>
<p>Assuming the diagram <em>can</em> be made alternating, for each connected piece of the link diagram (which may incorporate several link components), one must choose between two possible alternating diagrams. Regina will choose the option that preserves the sign of the lowest-index crossing in that connected piece of the diagram.</p>
<p>If this diagram cannot be made alternating, or if it was already alternating to begin with, then it will be left unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this link diagram was successfully made alternating (or was already alternating to begin with), or <code>false</code> if this is a virtual link diagram that cannot be made alternating. </dd></dl>

</div>
</div>
<a id="aa25abd1f1f1a4ed85dc4d3e69a4ccd01" name="aa25abd1f1f1a4ed85dc4d3e69a4ccd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25abd1f1f1a4ed85dc4d3e69a4ccd01">&#9670;&#160;</a></span>makeVirtual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::makeVirtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given classical crossing into a virtual crossing. </p>
<p>This essentially adds a handle to the surface in which the diagram is embedded, so that the old upper and lower strands can use this handle to pass by one another without actually crossing in the link diagram.</p>
<p>Note that the virtual genus of this link might actually go <em>down</em> as a result of this operation, since the operation might generate more empty handles (which Regina implicitly removes, as explained in the class notes). A virtual link could even become classical as a result of this operation.</p>
<p>For the combinatorics of the link diagram, this operation simply removes the given crossing entirely (recall that Regina does not store virtual crossings explicitly). The incoming and outgoing upper strands will merge into one, and the incoming and outgoing lower strands will merge into one.</p>
<p>This routine is safe to call if <em>crossing</em> is <code>null</code> (in which case this routine does nothing).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>the (classical) crossing that should be made virtual. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e483730179d76b3e17635b9e0d9f30" name="a45e483730179d76b3e17635b9e0d9f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e483730179d76b3e17635b9e0d9f30">&#9670;&#160;</a></span>moveContentsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of this link into the given destination link, leaving this link empty but otherwise usable. </p>
<p>The crossings and components of this link will be moved directly into <em>dest</em>, and placed after any pre-existing crossings and components. Specifically, if the original number of crossings in <em>dest</em> was <em>N</em>, then crossing number <em>i</em> of this link will become crosssing <code>N+i</code> of <em>dest</em>; likewise for components.</p>
<p>This link will become empty as a result, but it will otherwise remain a valid and usable <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a> object. Any strand references or crossing pointers that referred to either this link or <em>dest</em> will remain valid (and will all now refer to <em>dest</em>), though if they originally referred to this link then they will now return different crossing indices and strand IDs.</p>
<p>Calling <code>link.moveContentsTo(dest)</code> is similar to calling <code>dest.insertLink(std::move(link))</code>; it is a little slower but it comes with the benefit of leaving this link in a usable state.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the link into which the contents of this link should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf9867163e5b6defa9aa85d9bd8d9963" name="adf9867163e5b6defa9aa85d9bd8d9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9867163e5b6defa9aa85d9bd8d9963">&#9670;&#160;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::Link::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nice tree decomposition of the 4-valent multigraph formed by this link diagram. </p>
<p>This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of this graph.</p>
<p>See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="classregina_1_1TreeDecomposition.html#a2d545347437905541151b6c112bad03f" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p>This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p>The tree decomposition will be cached, so that if this routine is called a second time (and the underlying link has not been changed) then the same tree decomposition will be returned immediately.</p>
<p>If you wish to supply your own tree decomposition (as opposed to relying on the greedy heuristics that Regina implements), then you can supply it by calling <a class="el" href="#a0e380e04a7b375d081aeafab5d05eb51" title="Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree d...">useTreeDecomposition()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of this link diagram. </dd></dl>

</div>
</div>
<a id="ae7ef06ea5acfb81b4dd9f357988f1108" name="ae7ef06ea5acfb81b4dd9f357988f1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ef06ea5acfb81b4dd9f357988f1108">&#9670;&#160;</a></span>oddWrithe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::oddWrithe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the odd writhe, or self-linking number, of this knot. </p>
<p>The <em>odd writhe</em> is an invariant of virtual knots, which sums the signs of all odd crossings. A crossing <em>c</em> is <em>odd</em> if, when traversing the knot, we pass through an odd number of crossings between the over-strand and the under-strand of <em>c</em>.</p>
<p>Some authors call this invariant the <em>self-linking number</em> of the knot.</p>
<p>For a classical knot, every crossing will be even, and so the odd writhe will always be zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has exactly one component (i.e., it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the odd writhe of this knot. </dd></dl>

</div>
</div>
<a id="af70fd8c81eeca7fdee7af7b16b144b94" name="af70fd8c81eeca7fdee7af7b16b144b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70fd8c81eeca7fdee7af7b16b144b94">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> &amp; regina::Link::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="a7e3fb09880c2f7984d19fc944a3b4b50" name="a7e3fb09880c2f7984d19fc944a3b4b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3fb09880c2f7984d19fc944a3b4b50">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> &amp; regina::Link::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of the given link into this link. </p>
<p>This is a fast (constant time) operation.</p>
<p>All crossings that belong to <em>src</em> will be moved into this link, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this link.</p>
<p>The link that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this link which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the link to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this link. </dd></dl>

</div>
</div>
<a id="aa7ca68202fe7b9672c314b5c7f214e9f" name="aa7ca68202fe7b9672c314b5c7f214e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ca68202fe7b9672c314b5c7f214e9f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this link diagram is combinatorially identical to the given link diagram. </p>
<p>Here "identical" means that:</p>
<ul>
<li>the link diagrams have the same number of crossings and the same number of components;</li>
<li>the same numbered crossings are positive and negative in both diagrams;</li>
<li>the same pairs of numbered crossings have their under/over-strands connected, with the same orientations;</li>
<li>for each <em>i</em>, the starting strand for the <em>th</em> component is the same (under/over) strand of the same numbered crossing in both diagrams.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link diagram to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two link diagrams are combinatorially identical. </dd></dl>

</div>
</div>
<a id="ab8d81af83901af217da0bee17b6bf120" name="ab8d81af83901af217da0bee17b6bf120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d81af83901af217da0bee17b6bf120">&#9670;&#160;</a></span>orientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an oriented Gauss code for this knot, presented as a string. </p>
<p>The oriented Gauss code, based on a format used by Andreeva et al., is an extension of the classical Gauss code with additional characters to describe the orientation of the other strand passing by at each crossing. This extra information removes both the topological ambiguities and the complexity in the reconstruction procedure for classical Gauss codes. It also makes the code suitable for both virtual and classical knots.</p>
<p>This "oriented" format is described at <a href="http://www.javaview.de/services/knots/doc/description.html#gc">http://www.javaview.de/services/knots/doc/description.html#gc</a>, and it works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. At every crossing that you pass, write a token of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right;</li>
<li><em>k</em> is replaced with the integer crossing label.</li>
</ul>
</li>
</ul>
<p>As an example, you can represent the left-hand trefoil using the code:</p>
<pre class="fragment">+&gt;1 -&lt;2 +&gt;3 -&lt;1 +&gt;2 -&lt;3
</pre><p>Note that <em>oriented</em> Gauss codes are different from <em>signed</em> Gauss codes. Both formats improve upon classical Gauss codes by resolving the topological ambiguities and making reconstruction easy; however, they do so in different ways.</p>
<p>Currently Regina only supports Gauss codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Gauss codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p>This routine joins the tokens together as a single string. The tokens will be separated by single spaces, and there will be no newlines.</p>
<p>The routine <a class="el" href="#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a> returns this same data in machine-readable format (as a C++ vector of string tokens), instead of the human-readable format used here (a single long string). There is also another variant of <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> that writes directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code as described above. </dd></dl>

</div>
</div>
<a id="a21eaa9351a071dc7ddcf8e4d1101d584" name="a21eaa9351a071dc7ddcf8e4d1101d584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eaa9351a071dc7ddcf8e4d1101d584">&#9670;&#160;</a></span>orientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this knot to the given output stream. </p>
<p>See <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a>. In particular, the output does not contain any newlines.</p>
<p>For a function that <em>returns</em> the oriented Gauss code (as opposed to writing it to an output stream), you could use <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> (which returns the oriented Gauss code as a human-readable string), or <a class="el" href="#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a> (which returns it as a machine-readable sequence of tokens).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> or <a class="el" href="#a5c104bb3fa0b1cf4a73d85be984eac46" title="Returns an oriented Gauss code for this knot, presented as a vector of string tokens.">orientedGaussData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c104bb3fa0b1cf4a73d85be984eac46" name="a5c104bb3fa0b1cf4a73d85be984eac46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c104bb3fa0b1cf4a73d85be984eac46">&#9670;&#160;</a></span>orientedGaussData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; regina::Link::orientedGaussData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an oriented Gauss code for this knot, presented as a vector of string tokens. </p>
<p>See <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> for a full description of oriented Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>For an <em>n</em>-crossing knot, the elements of the returned vector will be the 2<em>n</em> individual tokens of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code> that would normally be joined with whitespace to form a complete oriented Gauss code. For example, for the left-hand trefoil, the vector might contain the six tokens:</p>
<pre class="fragment">{ "+&gt;1", "-&lt;2", "+&gt;3", "-&lt;1", "+&gt;2", "-&lt;3" }
</pre><p>This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="#ab8d81af83901af217da0bee17b6bf120" title="Returns an oriented Gauss code for this knot, presented as a string.">orientedGauss()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this knot in machine-readable form. </dd></dl>

</div>
</div>
<a id="ae8e1c3af83699d65c033fe591b4e8554" name="ae8e1c3af83699d65c033fe591b4e8554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e1c3af83699d65c033fe591b4e8554">&#9670;&#160;</a></span>overForComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::overForComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates an over-crossing within the same link component as the given strand. </p>
<p>The choice of <em>which</em> over-crossing is returned will be arbitrary (i.e., it might not be the <em>first</em> over-crossing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>a strand reference in this link, which may be a null reference (indicating a zero-crossing component). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an over-crossing in the same link component, or a null reference if the given link component contains only under-crossings (which for classical links means it is a zero-crossing unknot placed beneath the rest of the diagram). </dd></dl>

</div>
</div>
<a id="a6b21aaa8020908478576e1f9325d4f91" name="a6b21aaa8020908478576e1f9325d4f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b21aaa8020908478576e1f9325d4f91">&#9670;&#160;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a text representation of the underlying 4-valent multigraph for this link diagram, using the PACE text format. </p>
<p>This format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a>.</p>
<p>In summary, the PACE text representation will consist of several lines of text:</p>
<ul>
<li>The first line will be of the form <code>p tw &lt;num_vertices&gt; &lt;num_edges&gt;</code>. Note that, since the underlying graph comes from a link diagram, we will always have <em>num_edges</em> equal to twice <em>num_vertices</em>.</li>
<li>Following this will be <em>num_edges</em> lines, one for each edge, each of the form <code>&lt;u&gt; &lt;v&gt;</code>, indicating an edge from vertex number <em>u</em> to vertex number <em>v</em>. In this format, vertices are numbered 1,2,...,<em>num_vertices</em>.</li>
</ul>
<p>An example of this text format is as follows:</p>
<pre class="fragment">p tw 4 8
1 2
1 4
1 2
2 3
3 4
1 3
3 4
2 4
</pre><p>If you are writing this text representation to an output stream then you should call <a class="el" href="#a8f682deb7aeb5c9e3b06c8db4aec3b92" title="Outputs the underlying 4-valent multigraph for this link diagram using the PACE text format.">writePACE()</a> instead, which is more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>the PACE text representation of the underlying 4-valent multigraph, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&#160;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p>There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine Triangulation&lt;3&gt;::inAnyPacket() will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p>The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&#160;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::packet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p>See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a0c585fbf369ed220bc601e883497ab7c" name="a0c585fbf369ed220bc601e883497ab7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c585fbf369ed220bc601e883497ab7c">&#9670;&#160;</a></span>parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::parallel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__link.html#gaaa7f28a9c71fb2f3db92141046be967a">Framing</a></td>          <td class="paramname"><span class="paramname"><em>framing</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__link.html#ggaaa7f28a9c71fb2f3db92141046be967aa8d625b7e64184d5e45d1c2d58acf8d5f">Framing::Seifert</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <em>k</em> cables of this link, all parallel to each other using the given framing. </p>
<p>This routine creates a new link by:</p>
<ul>
<li>treating each component of this link as a ribbon, using the given framing;</li>
<li>creating <em>k</em> parallel copies of the original link, following each other side-by-side along these ribbons.</li>
</ul>
<p>This link will not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of parallel copies to create. This must be non-negative. </td></tr>
    <tr><td class="paramname">framing</td><td>the framing under which these copies will be parallel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>k</em> parallel copies of this link. </dd></dl>

</div>
</div>
<a id="aab64e5e12c443073dda93c1a23d1be9e" name="aab64e5e12c443073dda93c1a23d1be9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab64e5e12c443073dda93c1a23d1be9e">&#9670;&#160;</a></span>pd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::pd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a planar diagram code for this link, presented as a string. </p>
<p>Planar diagram codes encode the local information at each crossing, and present this information as a list of 4-tuples. These codes are available for links as well as knots. Moreover (despite their name) they are available for virtual as well as classical links. However, they do come with some minor restrictions:</p>
<ul>
<li>They cannot encode zero-crossing unknot components (i.e., components for which the <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f" title="Returns a strand in the given component of this link.">component()</a> function returns a null strand). Any such components will simply be omitted from the code. You can detect such components by calling <a class="el" href="#aad0b3f667c9968cc0fbd3b8a2ac4b9a4" title="Returns the number of zero-crossing unknot components in this link.">countTrivialComponents()</a>.</li>
<li>If a link has any components that consist entirely of over-crossings (that is, zero-crossing components that are "placed
  on top of" the rest of the link diagram), then a planar diagram code does not carry enough data to reconstruct the <em>orientation</em> of these components. For classical links, the topology will still be preserved (since such components must be topological unknots), but in general the combinatorics of such a link diagram cannot be reconstructed faithfully. For virtual links, the problems are more serious (since such components may traverse handles in the surface in which the link diagram is embedded). In all cases, you can detect such components by calling <a class="el" href="#a9d2297928a0d1eb98c2f53c1edbee344" title="Determines whether this link has any components whose orientations cannot be recovered from a planar ...">pdAmbiguous()</a>.</li>
</ul>
<p>If you need a text code that can work with these types of link diagrams, you can always use Jenkins' format instead.</p>
<p>Regina adheres to a tight specification for the planar diagram codes that it outputs, in order to ensure compatibility with other software. In particular, Regina's codes are compatible with the Knot Atlas, as seen at <a href="http://katlas.org/wiki/Planar_Diagrams">http://katlas.org/wiki/Planar_Diagrams</a>.</p>
<p>In detail: a planar diagram code for an <em>n</em>-crossing link is formed from a sequence of <em>n</em> 4-tuples of integers. Regina constructs this sequence as follows:</p>
<ul>
<li>Throw away any zero-crossing unknot components.</li>
<li>Let <em>n</em> denote the number of crossings.</li>
<li>Number the strands from 1 to 2<em>n</em> in order as we walk along each component, in order from the first component to the last.</li>
<li>For each crossing <em>c</em>, construct a 4-tuple that lists the four strands that meet at that <em>c</em>, in counter-clockwise order, beginning from the incoming lower strand.</li>
<li>Return the resulting list of <em>n</em> 4-tuples.</li>
</ul>
<p>An example, you can represent the right-hand trefoil using the code:</p>
<pre class="fragment">[[1, 5, 2, 4], [3, 1, 4, 6], [5, 3, 6, 2]]
</pre><p>Some points to be aware of:</p>
<ul>
<li>When building the list of 4-tuples, Regina orders the crossings as follows: again we walk along each component, in order from the first component to the last, and process each crossing when we enter it at the lower strand.</li>
<li>When building each individual 4-tuple, some sources order the strands clockwise instead of counter-clockwise. Regina follows the same counter-clockwise convention that is used by the Knot Atlas and SnapPy.</li>
</ul>
<p>This routine formats the list of 4-tuples as a string, in a way that is consistent with the description in the Knot Atlas at <a href="http://katlas.org/wiki/Planar_Diagrams">http://katlas.org/wiki/Planar_Diagrams</a>.</p>
<p>In particular, each 4-tuple will be formatted with square brackets, commas, and the prefix <code>X</code>, and the main list will be formatted with square brackets, commas, and the prefix <code>PD</code>. An example (for the right-handed trefoil) is:</p>
<pre class="fragment">PD[X[1, 5, 2, 4], X[3, 1, 4, 6], X[5, 3, 6, 2]]
</pre><p>The routine <a class="el" href="#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a> returns this same data in machine-readable format (as a C++ vector of 4-tuples of integers), instead of the human-readable format used here (a single string). There is also another variant of <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>the planar diagram code, as described above. </dd></dl>

</div>
</div>
<a id="a4429732bcfb4c8a26a69e06caa217413" name="a4429732bcfb4c8a26a69e06caa217413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4429732bcfb4c8a26a69e06caa217413">&#9670;&#160;</a></span>pd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::pd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a planar diagram code for this link to the given output stream. </p>
<p>See <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, as well as their limitations.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a>. In particular, the output does not contain any newlines.</p>
<p>For a function that <em>returns</em> the planar diagram code (as opposed to writing it to an output stream), you could use <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> (which returns the code as a human-readable string), or <a class="el" href="#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a> (which returns it as a machine-readable sequence of 4-tuples of integers).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> or <a class="el" href="#abaf406224f5959aeab3bbe877f2498b0" title="Returns a planar diagram code for this link, presented as vector of 4-tuples.">pdData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d2297928a0d1eb98c2f53c1edbee344" name="a9d2297928a0d1eb98c2f53c1edbee344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2297928a0d1eb98c2f53c1edbee344">&#9670;&#160;</a></span>pdAmbiguous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::pdAmbiguous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this link has any components whose orientations cannot be recovered from a planar diagram code. </p>
<p>Such components must have at least one crossing, and must consist <em>entirely</em> of over-crossings. See <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a detailed discussion on such components (which must be trivial for classical links, but which could be more interesting for virtual links).</p>
<p>Note that planar diagram codes have another limitation, which is that they cannot represent zero-crossing components at all (any such components are omitted from planar diagram codes entirely). Zero-crossing components are <em>not</em> recognised by this routine, but can be recognised instead by calling <a class="el" href="#aad0b3f667c9968cc0fbd3b8a2ac4b9a4" title="Returns the number of zero-crossing unknot components in this link.">countTrivialComponents()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if some component of this link has at least one crossing and consists entirely of over-crossings. </dd></dl>

</div>
</div>
<a id="abaf406224f5959aeab3bbe877f2498b0" name="abaf406224f5959aeab3bbe877f2498b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf406224f5959aeab3bbe877f2498b0">&#9670;&#160;</a></span>pdData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; int, 4 &gt; &gt; regina::Link::pdData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a planar diagram code for this link, presented as vector of 4-tuples. </p>
<p>See <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> for a full description of planar diagram codes as they are used in Regina, as well as their limitations.</p>
<p>This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="#aab64e5e12c443073dda93c1a23d1be9e" title="Returns a planar diagram code for this link, presented as a string.">pd()</a> returns the same data in human-readable format (as a string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link has so many crossings that the planar diagram code cannot be expressed using native C++ integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the planar diagram code in machine-readable form. </dd></dl>

</div>
</div>
<a id="a7ae2550f08ceb1a86346ef855841b3c0" name="a7ae2550f08ceb1a86346ef855841b3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae2550f08ceb1a86346ef855841b3c0">&#9670;&#160;</a></span>r1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type I Reidemeister move to remove a crossing at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>The location of this move is specified by the argument <em>crossing</em>, which indicates the crossing that will be removed. Specifically, this move involves undoing a trivial twist at the given crossing.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means this routine will do nothing and simply return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because one crossing is being removed, the other crossings in the link may be reindexed. However, no crossings other than the one involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a5c37f31a7ce0214b319288bd16f27a28" name="a5c37f31a7ce0214b319288bd16f27a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c37f31a7ce0214b319288bd16f27a28">&#9670;&#160;</a></span>r1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type I Reidemeister move to remove a crossing. </p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1(Crossing*)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#adfc6330cab75e59e6a004881950bda21" title="Determines whether it is possible to perform a type I Reidemeister move at the given location to remo...">hasR1()</a>. If you wish to both check and perform the move, call <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because one crossing is being removed, the other crossings in the link may be reindexed. However, no crossings other than the one involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. See r1(crossing*) for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a8d2f9c488b1371df1cd94a1c325f201b" name="a8d2f9c488b1371df1cd94a1c325f201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2f9c488b1371df1cd94a1c325f201b">&#9670;&#160;</a></span>r1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type I Reidemeister move to add a new crossing at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves adding a trivial twist to the given arc; the arguments <em>side</em> and <em>sign</em> indicate on which side of the arc and with which orientation the new twist will be made. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If <em>arc</em> is a null reference, then the new twist will be added to a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If <em>arc</em> is null but there is no zero-crossing component then the move cannot be performed, and if <em>arc</em> is null but there are multiple zero-crossing components then the first such component will be used.</p>
<p>This move is almost always able to be performed: the only situation in which it <em>cannot</em> be performed is if <em>arc</em> is a null reference but this link contains no zero-crossing components, as discussed above.</p>
<p>The existing crossings in this link will keep the same indices, and the new crossing will be given the next index that is available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a831ae0e05e8d6791167c3ae7ab149f97" name="a831ae0e05e8d6791167c3ae7ab149f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831ae0e05e8d6791167c3ae7ab149f97">&#9670;&#160;</a></span>r1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type I Reidemeister move to add a new crossing. </p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#adfc6330cab75e59e6a004881950bda21" title="Determines whether it is possible to perform a type I Reidemeister move at the given location to remo...">hasR1()</a>. If you wish to both check and perform the move, call <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced. See <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a7db0094a1e976219e5b0591dc097b4f4" name="a7db0094a1e976219e5b0591dc097b4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db0094a1e976219e5b0591dc097b4f4">&#9670;&#160;</a></span>r2() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type II Reidemeister move to remove two crossings at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>The location of this move is specified by the argument <em>crossing</em>, Specifically, this move involves pulling apart two arcs of the link (one upper, one lower) that both run between the same pair of crossings. The given crossing should be the start point of the upper arc; that is, when following the upper arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. Note that <em>crossing</em> is one of the two crossings that will be removed by this move.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means this routine will do nothing and simply return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="ac55c416469fc53af9b34bedfa7f1cdce" name="ac55c416469fc53af9b34bedfa7f1cdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55c416469fc53af9b34bedfa7f1cdce">&#9670;&#160;</a></span>r2() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type II Reidemeister move to remove two crossings. </p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a161b736f83359e024d846150cdf055ae" title="Determines whether it is possible to perform a type II Reidemeister move at the given location to rem...">hasR2()</a>. If you wish to both check and perform the move, call <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move. See <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a45e19cade08a16bf715144c8ff936588" name="a45e19cade08a16bf715144c8ff936588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e19cade08a16bf715144c8ff936588">&#9670;&#160;</a></span>r2() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type II Reidemeister move to remove two crossings at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since either of the two arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>The location of this move is specified by the argument <em>arc</em>. Specifically, this move involves pulling apart two arcs of the link that surround a bigon; the given arc must be one of these two arcs. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means this routine will do nothing and simply return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="ac272a63d07cd7762af9fe45c12dad620" name="ac272a63d07cd7762af9fe45c12dad620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac272a63d07cd7762af9fe45c12dad620">&#9670;&#160;</a></span>r2() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type II Reidemeister move to remove two crossings. </p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a161b736f83359e024d846150cdf055ae" title="Determines whether it is possible to perform a type II Reidemeister move at the given location to rem...">hasR2()</a>. If you wish to both check and perform the move, call <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A side-effect of this move is that, because two crossings are being removed, the other crossings in the link may be reindexed. However, no crossings other than the two involved in this move will be destroyed.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed. See <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a57ee1e216fdf92f6e6a1a6d1102b93e5" name="a57ee1e216fdf92f6e6a1a6d1102b93e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee1e216fdf92f6e6a1a6d1102b93e5">&#9670;&#160;</a></span>r2() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two different strands over one another. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>By a <em>classical</em> type II move, we mean that the move can be performed without adding a handle to the surface <em>S</em> in which the link diagram is embedded. More precisely: the two "sides of strands" that will be passed over one another either belong to different connected components of the link diagram, or else both bound the same 2-cell in the dual cell decomposition of <em>S</em>. Performing a classical type II move on a classical link diagram will always result in a classical link diagram.</p>
<p>If you are working with virtual links, you may wish to use <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a> instead, which does allow changing the surface <em>S</em> (and which could therefore convert a classical link diagram into a virtual diagram with positive virtual genus).</p>
<p>The location of this move is specified by the arguments <em>upperArc</em>, <em>upperSide</em>, <em>lowerArc</em> and <em>lowerSide</em>. Specifically, this move involves taking the arc <em>upperArc</em> and pushing it over <em>lowerArc</em> so that the two arcs overlap. The arguments <em>upperSide</em> and <em>lowerSide</em> indicate on which side of each arc the overlap takes place. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If <em>upperArc</em> and <em>lowerArc</em> are identical and non-null, then this routine will declare that the move cannot be performed. This is because passing the same strand over itself requires additional information (it is unclear whether the upper arc comes before or after the lower arc). You can achieve the same effect by adding two twists instead (i.e., performing two type I Reidemeister moves).</p>
<p>If either <em>upperArc</em> or <em>lowerArc</em> is a null reference, then the move will be performed upon a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If one of these arguments is a null reference but there is no zero-crossing component then the move cannot be performed, and if there are multiple zero-crossing components then the first such component will be used.</p>
<p>If <em>both</em> arcs are null references, then the move will be performed upon two <em>different</em> zero-crossing unknot components. In this case, if there are fewer than two such components then the move cannot be performed, and otherwise <em>upperArc</em> will be the first such component and <em>lowerArc</em> will be the second. As before, this routine will refuse to pass the same zero-crossing unknot component over itself, but you can achieve the same effect by adding two twists.</p>
<p>The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The checks for this move are expensive (linear time). If you are certain that the move is legal and you wish to circumvent this check, you can always call <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a> instead. If the move you wish to perform is indeed classical and legal, then <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a> will have the same effect but will avoid the expensive planarity check.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies the arc of the link which will be passed over the other, as described above. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies the arc of the link which will be passed beneath the other, as described above. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="aa9c10fe8c35fed9d165063161f40e0c3" name="aa9c10fe8c35fed9d165063161f40e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c10fe8c35fed9d165063161f40e0c3">&#9670;&#160;</a></span>r2() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a classical type II Reidemeister move to add two new crossings by pushing two different strands over one another. </p>
<p>For more detail on classical type II moves and when they can be performed, see <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a>. This deprecated routine will not perform virtual type II moves; for that you should use the new routine <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a> instead.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a161b736f83359e024d846150cdf055ae" title="Determines whether it is possible to perform a type II Reidemeister move at the given location to rem...">hasR2()</a>. If you wish to both check and perform the move, call <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for this move is expensive (linear time).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies which arc of the link would be passed over another in this move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies which arc of the link would be passed beneath another in this move. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="acea62146d69fc238e33607bc8a5b1625" name="acea62146d69fc238e33607bc8a5b1625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea62146d69fc238e33607bc8a5b1625">&#9670;&#160;</a></span>r2Virtual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstStrand</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing the same strand over itself from opposite sides. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>This move only makes sense when working with virtual links; in a classical setting it is never possible (since opposite sides of the same strand cannot bound the same dual 2-cell on the sphere). For a virtual link diagram, if both sides of the given strand already bound the same 2-cell then this move will not change the virtual genus; otherwise it will add a handle to the surface in which the diagram is embedded, and the virtual genus will increase as a result. In particular, if the original link diagram is classical, then this move will always convert it into a virtual diagram with positive virtual genus.</p>
<p>The location of this move is specified by the arguments <em>arc</em>, <em>firstSide</em>, and <em>firstStrand</em>. Specifically, this move involves:</p>
<ul>
<li>taking two portions of the given arc and pushing these away from the arc in opposite directions, with the first portion (when following the orientation of the link) pushing out on <em>firstSide</em>, and with the second portion pushing out on the opposite side;</li>
<li>passing those two portions over each other, where the first portion moves either over or under the second portion according to whether <em>firstStrand</em> is 1 or 0.</li>
</ul>
<p>See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>If <em>arc</em> is a null reference, then the move will be performed upon a zero-crossing unknot component; it will be assumed that this unknot component is oriented clockwise. If <em>arc</em> is a null reference but there is no zero-crossing component then the move cannot be performed, and if there are multiple zero-crossing components then the first such component will be used.</p>
<p>The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link which will be passed over itself, as described above. </td></tr>
    <tr><td class="paramname">firstSide</td><td>0 if the first portion of the arc should push out to the left of the arc (when walking along the arc in the forward direction), or 1 if the first portion should push out to the right of the arc. </td></tr>
    <tr><td class="paramname">firstStrand</td><td>0 if the first portion of the arc should be pushed under the second, or 1 if the first portion should be pushed over the second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="aa1060d281ec2528f588c68574d3898b6" name="aa1060d281ec2528f588c68574d3898b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1060d281ec2528f588c68574d3898b6">&#9670;&#160;</a></span>r2Virtual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two different strands over one another. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>By a <em>virtual</em> type II move, we mean that the move can be performed upon <em>any</em> two "sides of strands", even if this requires adding a handle to the surface in which the link diagram is embedded. As a result, a virtual type II move could potentially change the virtual genus of the link diagram; in particular, it could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<p>The location of this move is specified by passing two "sides of
strands", in the same way as for classical type II moves. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on how the location arguments are interpreted, and in particular how this move works with zero-crossing unknot components when passing null strand references.</p>
<p>Just like <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a>, this routine cannot pass a strand over itself, since this requires additional information (it is unclear whether the upper arc comes before or after the lower arc). To do this in the classical way (using the same side of the same strand), you can add two twists (type I moves) instead. To do this in the virtual way (using opposite sides of the same strand), you can can call the function <a class="el" href="#acea62146d69fc238e33607bc8a5b1625" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing the sam...">r2Virtual(StrandRef, int, int)</a> which is designed precisely for this purpose.</p>
<p>The existing crossings in this link will keep the same indices, and the two new crossings will be given the next two indices that are available.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies the arc of the link which will be passed over the other. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies the arc of the link which will be passed beneath the other. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="ae18378f79ad72d46190b554a17ba1939" name="ae18378f79ad72d46190b554a17ba1939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18378f79ad72d46190b554a17ba1939">&#9670;&#160;</a></span>r3() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type III Reidemeister move at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. The other variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). This variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>The location of this move is specified by the arguments <em>crossing</em> and <em>side</em>. Specifically, this move takes place around a triangle, and one of the arcs of this triangle is <em>uppermost</em> (in that it passes above the other two arcs). The given crossing should be the start point of this uppermost arc; that is, when following the arc forwards, <em>crossing</em> should be the first of the two crossings that we encounter. The additional argument <em>side</em> indicates on which side of the uppermost arc the third crossing is located.</p>
<p>You may pass a null pointer for <em>crossing</em>. However, in this case the move cannot be performed, which means this routine will do nothing and simply return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a095d5618df71eb7b586cdf12cbdbe5ce" name="a095d5618df71eb7b586cdf12cbdbe5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095d5618df71eb7b586cdf12cbdbe5ce">&#9670;&#160;</a></span>r3() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type III Reidemeister move. </p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a16752ca1a1b0efb69c577d62d3a41cd2" title="Determines whether it is possible to perform a type III Reidemeister move at the given location.">hasR3()</a>. If you wish to both check and perform the move, call <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move. See <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a96f1ba6a75e2ed768d2a2fcbc31ae659" name="a96f1ba6a75e2ed768d2a2fcbc31ae659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f1ba6a75e2ed768d2a2fcbc31ae659">&#9670;&#160;</a></span>r3() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, performs a type III Reidemeister move at the given location. </p>
<p>If such a move is not allowed, then this routine does nothing.</p>
<p>This link diagram will be changed directly.</p>
<p>There are two variants of this routine: one that takes an arc, and one that takes a crossing. This variant, which takes an arc, is more flexible (since any of the three arcs involved in this move can be passed). The other variant, which takes a crossing, offers a canonical way of performing the move (since for each move there is exactly one crossing that describes it).</p>
<p>The location of this move is specified by the arguments <em>arc</em> and <em>side</em>. Specifically, this move takes place around a triangle; the given arc must form one of the three edges of this triangle. The argument <em>side</em> indicates on which side of the arc the third crossing is located. See the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> documentation for the convention on how arcs are represented using <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects.</p>
<p>You may pass a null reference for <em>arc</em>. However, in this case the move cannot be performed, which means this routine will do nothing and simply return <code>false</code>.</p>
<p>All crossings in this link will keep the same indices, and no crossings will be created or destroyed. Instead, the three crossings involved in this move will simply be reordered along the various segments of the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move will be performed, as described above. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move was able to be performed. </dd></dl>

</div>
</div>
<a id="a3de29a853ab4cbecdc5e8bffa4d8c631" name="a3de29a853ab4cbecdc5e8bffa4d8c631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de29a853ab4cbecdc5e8bffa4d8c631">&#9670;&#160;</a></span>r3() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::r3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that tests for and optionally performs a type III Reidemeister move. </p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a>.</p>
<p>This routine will always <em>check</em> whether the requested move is allowed. If it is, and if the argument <em>perform</em> is <code>true</code>, this routine will also <em>perform</em> the move.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated</a></b></dt><dd>If you just wish to test whether such a move is possible, call <a class="el" href="#a16752ca1a1b0efb69c577d62d3a41cd2" title="Determines whether it is possible to perform a type III Reidemeister move at the given location.">hasR3()</a>. If you wish to both check and perform the move, call <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a> without the two additional boolean arguments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move would be performed. See <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
    <tr><td class="paramname">ignored</td><td>an argument that is ignored. In earlier versions of Regina this argument controlled whether we check if the move can be performed; however, now this check is done always. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move, assuming the move is allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the requested move could be performed. </dd></dl>

</div>
</div>
<a id="a8b4396c9fcb99dbb3bb4ba7176b859c4" name="a8b4396c9fcb99dbb3bb4ba7176b859c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4396c9fcb99dbb3bb4ba7176b859c4">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reflect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this link into its reflection. </p>
<p>This routine changes the sign of every crossing, but leaves the upper and lower strands the same.</p>
<ul>
<li>For classical links, this operation corresponds to reflecting the link diagram about some axis in the plane.</li>
<li>For virtual links, this operation performs an orientation-reversing homeomorphism of the surface in which the link diagram embeds.</li>
</ul>
<p>In the language of Jeremy Green's virtual knot tables, this operation is a <em>horizontal</em> mirror image. </p>

</div>
</div>
<a id="a6da54fa7f3352392989e34629c314a91" name="a6da54fa7f3352392989e34629c314a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da54fa7f3352392989e34629c314a91">&#9670;&#160;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves the given crossing. </p>
<p>The two incoming strands will switch connections with the two outgoing strands, with the result that the given crossing is removed entirely.</p>
<dl class="section note"><dt>Note</dt><dd>The number of components in the link will change as a result of this operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the crossing to resolve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9326a4e30a7cfb373020c4c6084775fc" name="a9326a4e30a7cfb373020c4c6084775fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9326a4e30a7cfb373020c4c6084775fc">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of every component of this link. </p>
<p>This routine preserves both the sign and the upper/lower positions at every crossing, but switches all incoming strands with outgoing strands and vice versa (so next() becomes prev(), and prev() becomes next()). </p>

</div>
</div>
<a id="a2267e0436a8d5c13d120fe9a24d25dc6" name="a2267e0436a8d5c13d120fe9a24d25dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2267e0436a8d5c13d120fe9a24d25dc6">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the orientation of just the link component that contains the given strand. </p>
<p>Other components of the link will not be modified.</p>
<p>For knots, this routine is identical to calling <a class="el" href="#a9326a4e30a7cfb373020c4c6084775fc" title="Reverses the orientation of every component of this link.">reverse()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>a strand belonging to some component of this link. This need not be the starting strand for the component (i.e., it does not need to be the strand that is returned by <code><a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f" title="Returns a strand in the given component of this link.">component()</a></code>). This may be a null strand reference, in which case this routine will do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ba30ef9cfbb6a6064faade1c4c00bf" name="ae5ba30ef9cfbb6a6064faade1c4c00bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ba30ef9cfbb6a6064faade1c4c00bf">&#9670;&#160;</a></span>rewrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::rewrite </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all link diagrams that can be reached from this via classical Reidemeister moves, without exceeding a given number of additional crossings. </p>
<p>As of Regina 7.4, this routine is now available for any link diagram (classical or virtual) with fewer than 64 link components. If this link has 64 or more components then this routine will throw an exception (as described below).</p>
<p>This routine iterates through all link diagrams that can be reached from this one via classical Reidemeister moves (with an important exception involving disconnected diagrams), without ever exceeding <em>height</em> additional crossings beyond the original number. With the current implementation, these diagrams <b>could become reflected and/or reversed</b>, and moreover each diagram will only be considered once up to reflection and/or reversal; be aware that this behaviour could change and/or become configurable in a future version of Regina.</p>
<p>By <em>classical</em> Reidemeister moves, we mean that we avoid any moves that could require adding a handle to the surface <em>S</em> in which the link diagram is embedded. That is, we allow ourselves to use the classical type I, II and III moves as implemented by <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a>, <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> and <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a>, but not the <em>virtual</em> type II move as implemented by <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a>. If this link diagram is classical then every link diagram that this routine produces will also be classical; indeed, this routine uses exactly the Reidemeister moves as they would be taught in a standard (classical) knot theory text.</p>
<p>If you are working with <em>virtual</em> links, you may wish to use <a class="el" href="#adf25646ce19fa74f829555a00c686e3d" title="Explores all link diagrams that can be reached from this via classical and/or virtual Reidemeister mo...">rewriteVirtual()</a> instead. The routine <a class="el" href="#adf25646ce19fa74f829555a00c686e3d" title="Explores all link diagrams that can be reached from this via classical and/or virtual Reidemeister mo...">rewriteVirtual()</a> uses the same classical moves as above, but also allows the virtual type II move, which could change the genus of the surface containing the link diagram. Indeed, calling <a class="el" href="#adf25646ce19fa74f829555a00c686e3d" title="Explores all link diagrams that can be reached from this via classical and/or virtual Reidemeister mo...">rewriteVirtual()</a> on a classical link diagram could easily produce virtual diagrams with positive virtual genus.</p>
<p>For every link diagram that this routine encounters (including this starting diagram), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take the following initial argument(s). Either (a) the first argument must be a link (the precise type is discussed below), representing the link diagram that has been found; or else (b) the first two arguments must be of types const std::string&amp; followed by a link, representing both the link diagram and its signature (as returned by <a class="el" href="#a690bcf5d0ded7fae75c63af1bf67c326" title="Constructs the signature for this knot or link diagram.">sig()</a>). The second form is offered in order to avoid unnecessarily recomputation within the <em>action</em> function. If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li>The link argument will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more link diagrams will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this link diagram (i.e., the original link upon which <a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf" title="Explores all link diagrams that can be reached from this via classical Reidemeister moves,...">rewrite()</a> was called). This will not affect the search: all link diagrams that this routine visits will be obtained via Reidemeister moves from the original link diagram, before any subsequent changes (if any) were made.</li>
<li><em>action</em> will only be called once for each link diagram (including this starting diagram). In other words, no link diagram will be revisited a second time in a single call to <a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf" title="Explores all link diagrams that can be reached from this via classical Reidemeister moves,...">rewrite()</a>.</li>
</ul>
<p>The exception for disconnected diagrams is this: if this link diagram has more than one connected component, then this routine will never use a type II move to merge those components together (i.e., the diagram will always remain disconnected). Of course, if your link diagram is disconnected, then it will be <em>much</em> more efficient to call <a class="el" href="#aa13ffadefd563c6a4787d984c7c39ca3" title="Returns the connected components of this link diagram as individual standalone links.">diagramComponents()</a> and run <a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf" title="Explores all link diagrams that can be reached from this via classical Reidemeister moves,...">rewrite()</a> on each component independently.</p>
<p>This routine can be very slow and very memory-intensive, since the number of link diagrams it visits may be exponential in the number of crossings, and it records every link diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some link diagram that is passed to it.</p>
<p>Since Regina 7.0, this routine will not return until the exploration of link diagrams is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the enumeration to start in the background), simply call this routine in a new detached thread.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time); as a corollary, the action should avoid expensive operations where possible (otherwise it will become a serialisation bottleneck in the multithreading).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has fewer than 64 link components.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link has 64 or more link components. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the arguments <em>tracker</em> and <em>args</em> are removed, so you simply call it as rewrite(height, threads, action). Moreover, <em>action</em> must take exactly two arguments (const std::string&amp;, <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>&amp;&amp;) representing the signature and the link diagram, as described in option (b) above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this link diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each link diagram that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial link argument(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="adf25646ce19fa74f829555a00c686e3d" name="adf25646ce19fa74f829555a00c686e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf25646ce19fa74f829555a00c686e3d">&#9670;&#160;</a></span>rewriteVirtual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::rewriteVirtual </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all link diagrams that can be reached from this via classical and/or virtual Reidemeister moves, without exceeding a given number of additional crossings. </p>
<p>This routine works in a similar manner to <a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf" title="Explores all link diagrams that can be reached from this via classical Reidemeister moves,...">rewrite()</a>; you should read the <a class="el" href="#ae5ba30ef9cfbb6a6064faade1c4c00bf" title="Explores all link diagrams that can be reached from this via classical Reidemeister moves,...">rewrite()</a> documentation to learn about what it does, how it works, and how the callable <em>action</em> argument is expected to behave.</p>
<p>The main difference is that, in addition to supporting all three classical Reidemeister moves, this routine also uses the virtual type II Reidemeister move, as implemented by <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a>. As a result, this routine could produce link diagrams with a different virtual genus to the original; in particular, even if the original link diagram is classical, this routine could (and typically will) produce diagrams with positive virtual genus as a result.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has fewer than 64 link components.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link has 64 or more link components. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the arguments <em>tracker</em> and <em>args</em> are removed, so you simply call it as rewriteVirtual(height, threads, action). Moreover, <em>action</em> must take exactly two arguments (const std::string&amp;, <a class="el" href="classregina_1_1Link.html" title="Represents a combinatorial diagram of a directed knot or link.">Link</a>&amp;&amp;) representing the signature and the link diagram, as described in option (b) above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this link diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each link diagram that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial link argument(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="a078b8f0dd10461df6f5b535fb3991bce" name="a078b8f0dd10461df6f5b535fb3991bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078b8f0dd10461df6f5b535fb3991bce">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::rotate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this link diagram, effectively flipping the surface that contains it "upside-down". </p>
<p>This routine keeps the sign of each crossing fixed, but switches the upper and lower strands.</p>
<ul>
<li>For classical links, this operation corresponds to a 3-dimensional rotation about some axis in the plane; the result will be a different diagram of the same link.</li>
<li>For virtual links, let <em>S</em> denote the closed orientable surface in which the link diagram embeds, and think of this as a link in the thickened surface <code>S  I</code>. Then this operation performs an orientation-preserving homeomorphism of <code>S  I</code> that switches the boundaries <code>S  {0}</code> and <code>S  {1}</code>.</li>
</ul>
<p>Some authors refer to this operation as a <em>flip</em>. In the language of Jeremy Green's virtual knot tables, this is the composition of both a vertical and a horizontal mirror image. </p>

</div>
</div>
<a id="a6035efd5fde17e1d4dd3b4e4c698859d" name="a6035efd5fde17e1d4dd3b4e4c698859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6035efd5fde17e1d4dd3b4e4c698859d">&#9670;&#160;</a></span>seifertCircles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::seifertCircles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of Seifert circles for this link diagram. </p>
<p>This is the number of circles obtained when we smooth every crossing in a way that respects the orientations of the strands.</p>
<p>In other words: this routine returns the number of link components that would be obtained if we called <a class="el" href="#a6da54fa7f3352392989e34629c314a91" title="Resolves the given crossing.">resolve()</a> on every crossing in the diagram.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of Seifert circles. </dd></dl>

</div>
</div>
<a id="a1c8dae4e7fb5347ac969b3e07f07c96b" name="a1c8dae4e7fb5347ac969b3e07f07c96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8dae4e7fb5347ac969b3e07f07c96b">&#9670;&#160;</a></span>selfFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::selfFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds trivial twists to this link to ensure that each component has zero writhe. </p>
<p>Here the <em>writhe</em> of a component <em>c</em> is the sum of the signs of all crossings at which <em>c</em> crosses itself.</p>
<p>Any component(s) that already have zero writhe will be left unchanged.</p>
<p>This link will be modified directly.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the link diagram was changed, or <code>false</code> if every component already had zero writhe to begin with. </dd></dl>

</div>
</div>
<a id="a690bcf5d0ded7fae75c63af1bf67c326" name="a690bcf5d0ded7fae75c63af1bf67c326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690bcf5d0ded7fae75c63af1bf67c326">&#9670;&#160;</a></span>sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::sig </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReflection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowReversal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowRotation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <em>signature</em> for this knot or link diagram. </p>
<p>A <em>signature</em> is a compact text representation of a link diagram that uniquely determines the diagram up to any combination of:</p>
<ul>
<li>relabelling;</li>
<li>(optionally) reflecting the entire diagram, which changes the sign of every crossing but leaves the upper and lower strands the same;</li>
<li>(optionally) reversing some or all link components;</li>
<li>(optionally) rotating the entire diagram, which preserves the sign of every crossing but switches the upper and lower strands.</li>
</ul>
<p>Signatures are now supported for all link diagrams with fewer than 64 link components. Specifically:</p>
<ul>
<li>Regina 7.3 and earlier only offered signatures for knots. As of Regina 7.4, signatures are now supported for arbitrary link diagrams (but see the next point), and for knots the new signatures are identical to the old.</li>
<li>The implementation uses bitmasks, and a side-effect of this is that it can only support fewer than 64 link components. However, since the running time is exponential in the number of components (if we allow reversal, which is the default) then it would be completely infeasible to use this routine in practice with <em>more</em> components than this. If there are 64 or more link components then this routine will throw an exception.</li>
</ul>
<p>The signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of crossings.</p>
<p>The routine <a class="el" href="#a953fcb3a718b0460c02da8dd210403c8" title="Recovers a classical or virtual link diagram from its knot/link signature.">fromSig()</a> can be used to recover a link diagram from its signature. The resulting diagram might not be identical to the original, but it will be related by zero or more applications of relabelling, and (according to the arguments) reflection of the diagram, rotation of the diagram, and/or reversal of individual link components.</p>
<p>The running time is quadratic in the number of crossings and (if we allow reversal, which is the default) exponential in the number of link components. For this reason, signatures should not be used for links with a large number of components.</p>
<p>This routine runs in quadratic time.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link diagram has 64 or more link components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowReflection</td><td><code>true</code> if reflecting the entire link diagram should preserve the signature, or <code>false</code> if the signature should distinguish between a diagram and its reflection (unless of course there is a symmetry). </td></tr>
    <tr><td class="paramname">allowReversal</td><td><code>true</code> if reversing some or all link components should preserve the signature, or <code>false</code> if the signature should distinguish between different orientations (again, unless of course there are symmetries). </td></tr>
    <tr><td class="paramname">allowRotation</td><td><code>true</code> if rotating the entire link diagram should preserve the signature, or <code>false</code> if the signature should distinguish between a diagram and its rotation (again, unless there is a symmetry). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature for this link diagram. </dd></dl>

</div>
</div>
<a id="a5e194d012a863db3a04924a418636ec7" name="a5e194d012a863db3a04924a418636ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e194d012a863db3a04924a418636ec7">&#9670;&#160;</a></span>signedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::signedGauss </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a signed Gauss code for this knot, presented as a string. </p>
<p>The signed Gauss code, as described by Kauffman, modifies the classical Gauss code to indicate which crossings are positive and which are negative. This extra information removes both the topological ambiguities and the complexity in the reconstruction procedure for classical Gauss codes. It also makes the code suitable for both virtual and classical knots.</p>
<p>Be warned that for signed Gauss codes, the signs <code>+/-</code> play a very different role from classical Gauss codes: in signed Gauss codes they indicate positive versus negative crossings, whereas in classical Gauss codes they indicate upper versus lower strands.</p>
<p>This format is used in Louis H. Kauffman, "Virtual knot theory", European J. Combin. 20 (1999), no. 7, 663-690. It works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Start at some point on the knot and follow it around. At every crossing that you pass, write symbols of the form <code>Ok+</code>, <code>Ok-</code>, <code>Uk+</code> or <code>Uk-</code>, where:<ul>
<li>the symbol <code>O</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>U</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>+</code> indicates that the crossing labelled <em>k</em> is positive, and the symbol <code>-</code> indicates that the crossing labelled <em>k</em> is negative;</li>
<li><em>k</em> is replaced with the integer crossing label.</li>
</ul>
</li>
<li>All of the symbols should be concatenated together, without any separation by whitespace.</li>
</ul>
<p>As an example, you can represent the figure eight knot using the code:</p>
<pre class="fragment">U1+O2+U3-O4-U2+O1+U4-O3-
</pre><p>Note that <em>signed</em> Gauss codes are different from <em>oriented</em> Gauss codes. Both formats improve upon classical Gauss codes by resolving the topological ambiguities and making reconstruction easy; however, they do so in different ways.</p>
<p>Currently Regina only supports Gauss codes for knots, not empty or multiple component links. If this link does not have precisely one component, then this routine will throw an exception. It is possible that in future versions of Regina, Gauss codes will be expanded to cover all possible link diagrams (hence the choice of <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> as the exception type).</p>
<p>The routine <a class="el" href="#a82a8987f90620d980eb23783090081b2" title="Returns a signed Gauss code for this knot, presented as a vector of string tokens.">signedGaussData()</a> returns this same data in machine-readable format (as a C++ vector of shorter string tokens, one for each crossing that you pass), instead of the single long string that is returned here. There is also another variant of <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> that writes directly to an output stream.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a signed Gauss code as described above. </dd></dl>

</div>
</div>
<a id="ac4a204839898248a5caaf5e18119eeb0" name="ac4a204839898248a5caaf5e18119eeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a204839898248a5caaf5e18119eeb0">&#9670;&#160;</a></span>signedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::signedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a signed Gauss code for this knot to the given output stream. </p>
<p>See <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> for a full description of signed Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>The output from this routine is precisely the string that would be returned by <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a>. In particular, the output does not contain any newlines.</p>
<p>For a function that <em>returns</em> the signed Gauss code (as opposed to writing it to an output stream), you could use <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> (which returns the signed Gauss code as a human-readable string), or <a class="el" href="#a82a8987f90620d980eb23783090081b2" title="Returns a signed Gauss code for this knot, presented as a vector of string tokens.">signedGaussData()</a> (which returns it as a machine-readable sequence of tokens).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variants <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> or <a class="el" href="#a82a8987f90620d980eb23783090081b2" title="Returns a signed Gauss code for this knot, presented as a vector of string tokens.">signedGaussData()</a> that take no arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a8987f90620d980eb23783090081b2" name="a82a8987f90620d980eb23783090081b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a8987f90620d980eb23783090081b2">&#9670;&#160;</a></span>signedGaussData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; regina::Link::signedGaussData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a signed Gauss code for this knot, presented as a vector of string tokens. </p>
<p>See <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> for a full description of signed Gauss codes as they are used in Regina, as well as their limitations.</p>
<p>For an <em>n</em>-crossing knot, the elements of the returned vector will be the 2<em>n</em> individual tokens of the form <code>Ok+</code>, <code>Ok-</code>, <code>Uk+</code> or <code>Uk-</code> that would normally be concatenated together to form a complete signed Gauss code. For example, for the figure eight knot, the vector might contain the eight tokens:</p>
<pre class="fragment">{ "U1+", "O2+", "U3-", "O4-", "U2+", "O1+", "U4-", "O3-" }
</pre><p>This routine returns machine-readable data (as a C++ vector); in contrast, <a class="el" href="#a5e194d012a863db3a04924a418636ec7" title="Returns a signed Gauss code for this knot, presented as a string.">signedGauss()</a> returns the same data in human-readable format (as a single long string).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a signed Gauss code for this knot in machine-readable form. </dd></dl>

</div>
</div>
<a id="a0ae2d7740007b145ca98a0c8e4f4d2d9" name="a0ae2d7740007b145ca98a0c8e4f4d2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae2d7740007b145ca98a0c8e4f4d2d9">&#9670;&#160;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics. </p>
<p>Specifically, this routine tries combinations of Reidemeister moves with the aim of reducing the number of crossings.</p>
<p>Currently this routine uses <a class="el" href="#a3adf6c87c3dc80de018d659e686b48ef" title="Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number o...">simplifyToLocalMinimum()</a> in combination with random type III Reidemeister moves.</p>
<p>Although <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> often works well, it can sometimes get stuck. If this link is a knot (i.e., it has precisely one component), then in such cases you can try the more powerful but (much) slower <a class="el" href="#a348fb1c73d7db51376811fe090129a27" title="Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> instead.</p>
<p>This routine will never reflect, rotate or reverse the link diagram.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same link may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For long-term users of Regina: this is the routine that was for a long time called <a class="el" href="#a5fc961ba707da75f2b71d3585c994cc9" title="Deprecated alias for simplify(), which attempts to simplify this link diagram as intelligently as pos...">intelligentSimplify()</a>. It was renamed to <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> in Regina 7.4.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link diagram was successfully simplified. </dd></dl>

</div>
</div>
<a id="a348fb1c73d7db51376811fe090129a27" name="a348fb1c73d7db51376811fe090129a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348fb1c73d7db51376811fe090129a27">&#9670;&#160;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *</td>          <td class="paramname"><span class="paramname"><em>tracker</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister graph. </p>
<p>This routine is more powerful but much slower than <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a>.</p>
<p>As of Regina 7.4, this routine will never reflect, rotate or reverse the link diagram.</p>
<p>Also, as of Regina 7.4, this routine is now available for any link diagram (classical or virtual) with fewer than 64 link components. If this link has 64 or more components then this routine will throw an exception (as described below).</p>
<p>This routine will iterate through all link diagrams that can be reached from this via Reidemeister moves, without ever exceeding <em>height</em> additional crossings beyond the original number. (If this link diagram is disconnected, then there is an exception: this routine will never use a type II move to merge distinct diagram components together, which would never help with simplification).</p>
<p>If at any stage this routine finds a diagram with <em>fewer</em> crossings than the original, then it will call <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> to simplify the diagram further if possible and will then return <code>true</code>. If it cannot find a diagram with fewer crossings then it will leave this link diagram unchanged and return <code>false</code>.</p>
<p>If this is a <em>classical</em> link diagram then only classical Reidemeister moves will be used, as implemented by <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a>, <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a> and <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a>; in particular, this routine will never consider link diagrams with positive virtual genus. If this is a <em>virtual</em> link diagram, then both classical and virtual Reidemeister moves will be used, including <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1()</a>, <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2()</a>, <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3()</a>, and <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual()</a>; this means that the exploration through the Reidemeister graph might pass through diagrams with smaller and/or greater virtual genus than the original.</p>
<p>This routine can be very slow and very memory-intensive: the number of link diagrams it visits may be exponential in the number of crossings, and it records every diagram that it visits (so as to avoid revisiting the same diagram again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional crossings. This means that the routine will not terminate until a simpler diagram is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p>If you want a <em>fast</em> simplification routine, you should call <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> instead. The benefit of <a class="el" href="#a348fb1c73d7db51376811fe090129a27" title="Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is that, for very stubborn link diagrams where <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> finds itself stuck at a local minimum, <a class="el" href="#a348fb1c73d7db51376811fe090129a27" title="Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p>Since Regina 7.0, this routine will not return until either the link diagram is simplified or the exhaustive search is complete, regardless of whether a progress tracker was passed. If you need the old behaviour (where passing a progress tracker caused the exhaustive search to start in the background), simply call this routine in a new detached thread.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>threads</em>. Even in multithreaded mode, this routine will not return until processing has finished (i.e., either the diagram was simplified or the search was exhausted), and any change to this link diagram will happen in the calling thread.</p>
<p>If this routine is unable to simplify the link diagram, then this link diagram will not be changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has at most 64 link components.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link has 64 or more link components. If a progress tracker was passed, it will be marked as finished before the exception is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> crossings to allow beyond the number of crossings originally present in this diagram, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">threads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this diagram was successfully simplified to fewer crossings. </dd></dl>

</div>
</div>
<a id="a3adf6c87c3dc80de018d659e686b48ef" name="a3adf6c87c3dc80de018d659e686b48ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adf6c87c3dc80de018d659e686b48ef">&#9670;&#160;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Link::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>perform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the link monotonically to some local minimum number of crossings. </p>
<p>End users will probably not want to call this routine. You should call <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a> if you want a fast (and usually effective) means of simplifying a link. If this link is a knot (i.e., it has precisely one component), then you can also call <a class="el" href="#a348fb1c73d7db51376811fe090129a27" title="Attempts to simplify this link diagram using a slow but exhaustive search through the Reidemeister gr...">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p>Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine. Such moves do however feature in <a class="el" href="#a0ae2d7740007b145ca98a0c8e4f4d2d9" title="Attempts to simplify this link diagram as intelligently as possible using fast and greedy heuristics.">simplify()</a>.</p>
<p>This routine will never reflect, rotate or reverse the link diagram.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="a32c6f34794cc62574fcfca388f3f66d9" name="a32c6f34794cc62574fcfca388f3f66d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c6f34794cc62574fcfca388f3f66d9">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of crossings in this link. </p>
<p>Note that a link can have more components than crossings (since it may contain additional zero-crossing unknot components).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="a53fbcb99b3014ab278782289b092403c" name="a53fbcb99b3014ab278782289b092403c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fbcb99b3014ab278782289b092403c">&#9670;&#160;</a></span>source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Link::source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__engine.html#ga4042b3d9832af20a99be34899e313442">Language</a></td>          <td class="paramname"><span class="paramname"><em>language</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__engine.html#gga4042b3d9832af20a99be34899e313442a222a267cc5778206b253be35ee3ddab5">Language::Current</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns C++ or Python source code that can be used to reconstruct this link. </p>
<p>This code will call <a class="el" href="#a13f44d669e5b4139ad6bc8955ef9f5ce" title="Creates a new classical or virtual link from hard-coded information about its crossings and component...">Link::fromData()</a>, passing a series of hard-coded C++ initialiser lists or Python lists (depending on the requested language).</p>
<p>The main purpose of this routine is to generate these hard-coded lists, which can be tedious and error-prone to write by hand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">language</td><td>the language in which the source code should be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the source code that was generated. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aadb5338200b51df9d368711c7bf3954d" name="aadb5338200b51df9d368711c7bf3954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5338200b51df9d368711c7bf3954d">&#9670;&#160;</a></span>strand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::strand </td>
          <td>(</td>
          <td class="paramtype">ssize_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the strand in the link with the given integer ID. </p>
<p>Each strand ID is of the form 2<em>c</em>+<em>s</em>, where <em>c</em> is the index of the crossing, and <em>s</em> is 0 or 1 for the lower or upper strand respectively. A null strand reference (as used to indicate 0-crossing unknot components) has an ID of -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>an integer between -1 and 2*size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the strand of this link with the corresponding ID.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1StrandRef.html#a2b631379159b6e14758a932d14d0a090" title="An integer that uniquely identifies this strand within the link.">StrandRef::id()</a> </dd></dl>

</div>
</div>
<a id="aeb48595553c44333292ad1948caed0ae" name="aeb48595553c44333292ad1948caed0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb48595553c44333292ad1948caed0ae">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given link. </p>
<p>All crossings that belong to this link will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this link. Likewise, all cached properties (e.g., tree decompositions) will be swapped.</p>
<p>In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this link.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both links which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the link whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac540c07f819bf0c967867bf04463cafc" name="ac540c07f819bf0c967867bf04463cafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac540c07f819bf0c967867bf04463cafc">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a classical or virtual link from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input stream <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream (or more...">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the link represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Link.html">Link</a> <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ae31d64de793d9791c85f7ce04ae903f8" name="ae31d64de793d9791c85f7ce04ae903f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31d64de793d9791c85f7ce04ae903f8">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tight encoding of this link to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a5857fcc6d1187bc8d72b900fef3161d6" name="a5857fcc6d1187bc8d72b900fef3161d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5857fcc6d1187bc8d72b900fef3161d6">&#9670;&#160;</a></span>topologyLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TopologyLockable::topologyLocked </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not there are any topology locks currently held on this object. </p>
<p>Strictly speaking, this routine could return a false negative: the number of locks is stored as an 8-bit integer and so in reality this tests whether the number of locks is a multiple of 256. False negatives are mathematically harmless, since the worst that will happen is that topological properties will be cleared when they could have been preserved, and so unnecessary extra computation may be required to compute them again.</p>
<p>This routine will never return a false positive.</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if there are no topology locks currently held on this object, or if a false negative occurs (as described above); or <code>true</code> to indicate that there are currently topology locks held on this object. </dd></dl>

</div>
</div>
<a id="aa4d5e4637efe2ed81e2c9588aaa76591" name="aa4d5e4637efe2ed81e2c9588aaa76591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e4637efe2ed81e2c9588aaa76591">&#9670;&#160;</a></span>translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference from some other link into the corresponding strand reference from this link. </p>
<p>Typically this routine would be used when the given strand comes from a link that is combinatorially identical to this, and you wish to obtain the corresponding strand in this link.</p>
<p>Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other link, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this link.</p>
<p>This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link contains at least as many crossings as the link containing <em>other</em> (though, as noted above, in typical scenarios both links would actually be combinatorially identical).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this link. </dd></dl>

</div>
</div>
<a id="a0b897dacf987697c6afd8a77f1e434b5" name="a0b897dacf987697c6afd8a77f1e434b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b897dacf987697c6afd8a77f1e434b5">&#9670;&#160;</a></span>translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Link::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a crossing from some other link into the corresponding crossing in this link. </p>
<p>Typically this routine would be used when the given crossing comes from a link that is combinatorially identical to this, and you wish to obtain the corresponding crossing in this link.</p>
<p>Specifically: if <em>other</em> refers to crossing number <em>k</em> of some other link, then the return value will refer to crossing number <em>k</em> of this link.</p>
<p>This routine behaves correctly even if <em>other</em> is a null pointer.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link contains at least as many crossings as the link containing <em>other</em> (though, as noted above, in typical scenarios both links would actually be combinatorially identical).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the crossing to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding crossing in this link. </dd></dl>

</div>
</div>
<a id="a1707701b8c7697c63b0f15914542c5af" name="a1707701b8c7697c63b0f15914542c5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1707701b8c7697c63b0f15914542c5af">&#9670;&#160;</a></span>underForComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Link::underForComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates an under-crossing within the same link component as the given strand. </p>
<p>The choice of <em>which</em> under-crossing is returned will be arbitrary (i.e., it might not be the <em>first</em> under-crossing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>a strand reference in this link, which may be a null reference (indicating a zero-crossing component). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an under-crossing in the same link component, or a null reference if the given link component contains only over-crossings (which for classical links means it is a zero-crossing unknot placed above the rest of the diagram). </dd></dl>

</div>
</div>
<a id="a0e380e04a7b375d081aeafab5d05eb51" name="a0e380e04a7b375d081aeafab5d05eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e380e04a7b375d081aeafab5d05eb51">&#9670;&#160;</a></span>useTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::useTreeDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a></td>          <td class="paramname"><span class="paramname"><em>td</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instructs Regina to use the given tree decomposition as the starting point whenever it needs a tree decomposition for this link. </p>
<p>For some link routines, including <a class="el" href="#adf9867163e5b6defa9aa85d9bd8d9963" title="Returns a nice tree decomposition of the 4-valent multigraph formed by this link diagram.">niceTreeDecomposition()</a> as well as computations such as <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> that support the option <a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1aa77838eb25818f7a8b193765912e04dc" title="A treewidth-based algorithm.">Algorithm::Treewidth</a>, Regina needs a tree decomposition of the 4-valent multigraph formed by this link diagram.</p>
<p>By default, Regina will compute (and then cache) such a tree decomposition itself, using in-built greedy heuristics. This routine allows you to supply your <em>own</em> tree decomposition (which, for example, might be a smaller-width tree decomposition that you found using third-party software). By supplying your own tree decomposition <em>td</em> through this routine, Regina will throw away any pre-computed tree decomposition that it has cached, and will instead cache <em>td</em> for future use instead.</p>
<p>Regina may modify the given tree decomposition for its purposes. In particular, <em>td</em> does not need to be a <em>nice</em> tree decomposition (indeed, it does not need to have any special properties beyond the definition of a tree decomposition). Regina will automatically create a nice tree decomposition from it if <em>td</em> is not nice already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">td</td><td>a tree decomposition of the 4-valent multigraph formed by this link diagram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ac664dc51d245b364d16e03cabf71b716" name="ac664dc51d245b364d16e03cabf71b716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac664dc51d245b364d16e03cabf71b716">&#9670;&#160;</a></span>virtualGenus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Link::virtualGenus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the virtual genus of this link diagram. </p>
<p>The virtual genus is the smallest genus of closed orientable surface in which the diagram embeds.</p>
<p>Note that this is a property of the link <em>diagram</em>, not the link itself.</p>
<p>For classical link diagrams, the virtual genus will always be zero (since classical link diagrams are by definition planar).</p>
<p>This routine runs in time linear in the size of the link diagram. However, the virtual genus is cached, and so subsequent calls to <a class="el" href="#ac664dc51d245b364d16e03cabf71b716" title="Determines the virtual genus of this link diagram.">virtualGenus()</a> or <a class="el" href="#aef04100b89965f3d9215ccd3b45c068d" title="Determines whether this link diagram is classical (that is, planar).">isClassical()</a> will be instantaneous.</p>
<dl class="section return"><dt>Returns</dt><dd>the virtual genus of this link diagram. </dd></dl>

</div>
</div>
<a id="ac27dd16fa8758d69382f0ea271eff7c1" name="ac27dd16fa8758d69382f0ea271eff7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27dd16fa8758d69382f0ea271eff7c1">&#9670;&#160;</a></span>whiteheadDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Link::whiteheadDouble </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>positive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the untwisted positive or negative Whitehead double of this knot. </p>
<p>This routine works only with knots, not multiple-component links. If this link is empty or has more than one component, then this routine will throw an exception.</p>
<p>This routine creates a new link by (i) creating two parallel copies of the original knot using the Seifert framing, and then (ii) cutting open these two copies and re-connecting them using a clasp. The signs of the two crossings in the clasp are determined by the optional argument <em>positive</em> (the default is to use two positive crossings).</p>
<p>The two parallel copies of the original link will be oriented as follows: when following the orientation of the original knot, the left copy will have the same orientation, and the right copy will have the reverse orientation.</p>
<p>This link will not be modified.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This link has exactly one component (i.e., it is a knot).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This link is empty or has multiple components.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive</td><td><code>true</code> if the clasp should use positive crossings (which builds the <em>positive</em> Whitehead double), or <code>false</code> if the clasp should use negative crossings (which builds the <em>negative</em> Whitehead double). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested untwisted Whitehead double of this knot. </dd></dl>

</div>
</div>
<a id="acca0c0d2925871a768af0002340230af" name="acca0c0d2925871a768af0002340230af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca0c0d2925871a768af0002340230af">&#9670;&#160;</a></span>withR1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type I Reidemeister move at the given location to remove a crossing. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1(Crossing*)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. See <a class="el" href="#a7ae2550f08ceb1a86346ef855841b3c0" title="If possible, performs a type I Reidemeister move to remove a crossing at the given location.">r1(Crossing*)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="af183bb609a8b0b57d2e873d4d954c241" name="af183bb609a8b0b57d2e873d4d954c241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183bb609a8b0b57d2e873d4d954c241">&#9670;&#160;</a></span>withR1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type I Reidemeister move at the given location to add a new crossing. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type I moves and when they can be performed, see <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies the arc of the link in which the new twist will be introduced. See <a class="el" href="#a8d2f9c488b1371df1cd94a1c325f201b" title="If possible, performs a type I Reidemeister move to add a new crossing at the given location.">r1(StrandRef, int, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the twist should be introduced on the left of the arc (when walking along the arc in the forward direction), or 1 if the twist should be introduced on the right of the arc. </td></tr>
    <tr><td class="paramname">sign</td><td>the sign of the new crossing that will be introduced as part of the twist; this must be +1 or -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="ac5011e93c3f785d127db6d5d89e96f83" name="ac5011e93c3f785d127db6d5d89e96f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5011e93c3f785d127db6d5d89e96f83">&#9670;&#160;</a></span>withR2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type II Reidemeister move at the given location to remove two crossings. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move. See <a class="el" href="#a7db0094a1e976219e5b0591dc097b4f4" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(Crossing*)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a9bd7545786a707faa8fa2065e4d40526" name="a9bd7545786a707faa8fa2065e4d40526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd7545786a707faa8fa2065e4d40526">&#9670;&#160;</a></span>withR2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type II Reidemeister move at the given location to remove two crossings. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type II moves and when they can be performed, see <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed. See <a class="el" href="#a45e19cade08a16bf715144c8ff936588" title="If possible, performs a type II Reidemeister move to remove two crossings at the given location.">r2(StrandRef)</a> for details on exactly how this will be interpreted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a386d60fa28fe84aeadaaeb28f508dcaa" name="a386d60fa28fe84aeadaaeb28f508dcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386d60fa28fe84aeadaaeb28f508dcaa">&#9670;&#160;</a></span>withR2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a classical type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on classical type II moves and when they can be performed, see <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a>. Note that a classical type II move on a classical link diagram will always result in a classical link diagram.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The check for classical type II moves is expensive (linear time). This is in contrast to the check for <em>virtual</em> type II moves, which is extremely fast.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies which arc of the link will be passed over another. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies which arc of the link will be passed beneath another. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="ad8c677ecb4b8c2f76e4d495e4f951d1b" name="ad8c677ecb4b8c2f76e4d495e4f951d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c677ecb4b8c2f76e4d495e4f951d1b">&#9670;&#160;</a></span>withR2Virtual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>firstStrand</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a virtual type II Reidemeister move at the given location to add two new crossings by pushing the same strand over itself from opposite sides. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on these kinds of virtual type II moves and when they can be performed, see <a class="el" href="#acea62146d69fc238e33607bc8a5b1625" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing the sam...">r2Virtual(StrandRef, int, int)</a>. Note that a virtual type II move could potentially change the virtual genus of the link diagram; in particular, it could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies which arc of the link will be passed over itself. See r2(StrandRef, int, int) for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">firstSide</td><td>0 if the first portion of the arc should push out to the left of the arc (when walking along the arc in the forward direction), or 1 if the first portion should push out to the right of the arc. </td></tr>
    <tr><td class="paramname">firstStrand</td><td>0 if the first portion of the arc should be pushed under the second, or 1 if the first portion should be pushed over the second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a0bca178eb78184eacf31be5ef98baed0" name="a0bca178eb78184eacf31be5ef98baed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bca178eb78184eacf31be5ef98baed0">&#9670;&#160;</a></span>withR2Virtual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR2Virtual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>upperArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>upperSide</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>lowerArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lowerSide</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a virtual type II Reidemeister move at the given location to add two new crossings by pushing two different strands over one another. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on these kinds of virtual type II moves and when they can be performed, see <a class="el" href="#aa1060d281ec2528f588c68574d3898b6" title="If possible, performs a virtual type II Reidemeister move to add two new crossings by pushing two dif...">r2Virtual(StrandRef, int, StrandRef, int)</a>. Note that a virtual type II move could potentially change the virtual genus of the link diagram; in particular, it could convert a classical link diagram into a virtual diagram with positive virtual genus.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each of the given strand references is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<p>The check for virtual type II moves is extremely fast (as opposed to <em>classical</em> type II moves, where the check takes linear time).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperArc</td><td>identifies which arc of the link will be passed over another. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">upperSide</td><td>0 if the new overlap should take place on the left of <em>upperArc</em> (when walking along <em>upperArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>upperArc</em>. </td></tr>
    <tr><td class="paramname">lowerArc</td><td>identifies which arc of the link will be passed beneath another. See <a class="el" href="#a57ee1e216fdf92f6e6a1a6d1102b93e5" title="If possible, performs a classical type II Reidemeister move to add two new crossings by pushing two d...">r2(StrandRef, int, StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">lowerSide</td><td>0 if the new overlap should take place on the left of <em>lowerArc</em> (when walking along <em>lowerArc</em> in the forward direction), or 1 if the new overlap should take place on the right of <em>lowerArc</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a966de1bbc0821c23a408a038cc5f6d0a" name="a966de1bbc0821c23a408a038cc5f6d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966de1bbc0821c23a408a038cc5f6d0a">&#9670;&#160;</a></span>withR3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *</td>          <td class="paramname"><span class="paramname"><em>crossing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type III Reidemeister move at the given location. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given crossing is either a null pointer, or else some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "uppermost" arc that features in this move. See <a class="el" href="#ae18378f79ad72d46190b554a17ba1939" title="If possible, performs a type III Reidemeister move at the given location.">r3(Crossing*, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the uppermost arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the uppermost arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a431227a92748747e60dde1f7b7ecbc9a" name="a431227a92748747e60dde1f7b7ecbc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431227a92748747e60dde1f7b7ecbc9a">&#9670;&#160;</a></span>withR3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt; regina::Link::withR3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>arc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If possible, returns the diagram obtained by performing a type III Reidemeister move at the given location. </p>
<p>If such a move is not allowed, then this routine returns no value.</p>
<p>This link diagram will not be changed.</p>
<p>For more detail on type III moves and when they can be performed, see <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given strand reference is either a null reference, or else refers to some strand of some crossing in this link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the triangle about which the move will be performed. See <a class="el" href="#a96f1ba6a75e2ed768d2a2fcbc31ae659" title="If possible, performs a type III Reidemeister move at the given location.">r3(StrandRef, int)</a> for details on exactly how this will be interpreted. </td></tr>
    <tr><td class="paramname">side</td><td>0 if the third crossing of the triangle is located to the left of the arc (when walking along the arc in the forward direction), or 1 if the third crossing is located on the right of the arc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new link diagram obtained by performing the requested move, or no value if the requested move cannot be performed. </dd></dl>

</div>
</div>
<a id="a8f682deb7aeb5c9e3b06c8db4aec3b92" name="a8f682deb7aeb5c9e3b06c8db4aec3b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f682deb7aeb5c9e3b06c8db4aec3b92">&#9670;&#160;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the underlying 4-valent multigraph for this link diagram using the PACE text format. </p>
<p>This format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a>, and is documented in detail by the routine <a class="el" href="#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying 4-valent multigraph for this link diagram,...">pace()</a>.</p>
<p>Calling <code>link.writePACE(out)</code> is equivalent to <code>out &lt;&lt; link.pace()</code>. However, this routine is more efficient.</p>
<p>See the <a class="el" href="#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying 4-valent multigraph for this link diagram,...">pace()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a6b21aaa8020908478576e1f9325d4f91" title="Returns a text representation of the underlying 4-valent multigraph for this link diagram,...">pace()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a075bf4f759b540961ee47b1e5364b492" name="a075bf4f759b540961ee47b1e5364b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075bf4f759b540961ee47b1e5364b492">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a228ed6330752dc62de8a611075e05280" name="a228ed6330752dc62de8a611075e05280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228ed6330752dc62de8a611075e05280">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Link::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this link to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed6e5a318a8fdab39ebea49912074d19" name="aed6e5a318a8fdab39ebea49912074d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e5a318a8fdab39ebea49912074d19">&#9670;&#160;</a></span>writhe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writhe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the writhe of this link diagram. </p>
<p>This is <em>not</em> an invariant of the link; instead it depends on the particular link diagram. It is computed as the sum of the signs of all crossings. It is preserved under Reidemeister moves II and III, but not I.</p>
<dl class="section return"><dt>Returns</dt><dd>the writhe. </dd></dl>

</div>
</div>
<a id="aa8fe822e89589e9d9295299dd95d53e8" name="aa8fe822e89589e9d9295299dd95d53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fe822e89589e9d9295299dd95d53e8">&#9670;&#160;</a></span>writheOfComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writheOfComponent </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the writhe of a single component of this link diagram. </p>
<p>This is the writhe of the diagram when all <em>other</em> components are removed. It is computed as the sum of the signs of all crossings at which the given component crosses itself.</p>
<p>In this version of <a class="el" href="#a93a069ee95598f2e1f27ab15a9de07dc" title="Returns the writhe of a single component of this link diagram.">writheOfComponent()</a>, the component is indicated by its index. This function is equivalent to calling <code>writheOfComponent(component(index))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested component. This must be between 0 and <a class="el" href="#ab4fb9a0932d786dfca9eef2f6e45ec60" title="Returns the number of components in this link.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the writhe of the given component. </dd></dl>

</div>
</div>
<a id="a93a069ee95598f2e1f27ab15a9de07dc" name="a93a069ee95598f2e1f27ab15a9de07dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a069ee95598f2e1f27ab15a9de07dc">&#9670;&#160;</a></span>writheOfComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Link::writheOfComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the writhe of a single component of this link diagram. </p>
<p>This is the writhe of the diagram when all <em>other</em> components are removed. It is computed as the sum of the signs of all crossings at which the given component crosses itself.</p>
<p>In this version of <a class="el" href="#a93a069ee95598f2e1f27ab15a9de07dc" title="Returns the writhe of a single component of this link diagram.">writheOfComponent()</a>, the component is indicated by the argument <em>strand</em>, which may be any strand along the component. In particular, <em>strand</em> does not need to be the "starting strand" returned by <a class="el" href="#a3425a2a6994fbc87baf890e9b429ef6f" title="Returns a strand in the given component of this link.">component()</a>.</p>
<p>The given strand may be a null strand, in which case the return value will be 0 (since Regina uses null strands to refer to zero-crossing unknot components). This is always allowed, regardless of whether the link actually contains any zero-crossing unknot components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>any strand along the component of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the writhe of the component containing the given strand, or 0 if the given strand is a null strand. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad1372a5ee63aa57d809b4ac581f58c08" name="ad1372a5ee63aa57d809b4ac581f58c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1372a5ee63aa57d809b4ac581f58c08">&#9670;&#160;</a></span>affineIndexVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::affineIndexVar = &quot;t&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the affine index polynomial, as returned by <a class="el" href="#a7cb66a5de5c06536f6b2161ee8ed8334" title="Returns the affine index polynomial of this knot.">affineIndex()</a>. </p>
<p>This is provided to help with pretty-printing affine index polynomials for human consumption.</p>
<p>To pretty-print the affine index polynomial for human consumption, you can call <code>Laurent::str(Link::affineIndexVar)</code>. </p>

</div>
</div>
<a id="ab12d1934a6010781108fe8b5ece0ac2d" name="ab12d1934a6010781108fe8b5ece0ac2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12d1934a6010781108fe8b5ece0ac2d">&#9670;&#160;</a></span>alexanderVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::alexanderVar = &quot;t&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Alexander polynomial, as returned by <a class="el" href="#a2f9fc5b699e15f90ef6d90e2d987dbf3" title="Returns the Alexander polynomial of this classical knot.">alexander()</a>. </p>
<p>This is provided to help with pretty-printing Alexander polynomials for human consumption.</p>
<p>To pretty-print the Alexander polynomial for human consumption, you can call <code>Laurent::str(Link::alexanderVar)</code>. </p>

</div>
</div>
<a id="aaa36436fbc04ca5eca7330083fb089aa" name="aaa36436fbc04ca5eca7330083fb089aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa36436fbc04ca5eca7330083fb089aa">&#9670;&#160;</a></span>bracketVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::bracketVar = &quot;A&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Kauffman bracket, as returned by <a class="el" href="#a69e43244712152cd695098010c9a2149" title="Returns the Kauffman bracket polynomial of this link diagram.">bracket()</a>. </p>
<p>This is provided to help with pretty-printing Kauffman brackets for human consumption.</p>
<p>To pretty-print the Kauffman bracket for human consumption, you can call <code>Laurent::str(Link::bracketVar)</code>. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&#160;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1Link.html">Link</a> &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p>As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="ad65f761ba1c3d1badabc9638c27192db" name="ad65f761ba1c3d1badabc9638c27192db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f761ba1c3d1badabc9638c27192db">&#9670;&#160;</a></span>homflyAZVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarX = &quot;\u03B1&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY-PT polynomials for human consumption.</p>
<p>Since <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the mathematical symbol <em>alpha</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY-PT polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="a7acb282c9b668b106d63b5180e34f7f2" name="a7acb282c9b668b106d63b5180e34f7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acb282c9b668b106d63b5180e34f7f2">&#9670;&#160;</a></span>homflyAZVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyAZVarY = &quot;z&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY-PT polynomials for human consumption.</p>
<p>Since <a class="el" href="#aa88368c61fae199e0a3dfa48b09ef46a" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homflyAZ()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>alpha</em> and <em>z</em>, this string just contains the single character <em>z</em>.</p>
<p>To pretty-print this HOMFLY-PT polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyAZVarX, Link::homflyAZVarY)</code>. </p>

</div>
</div>
<a id="af9ce5812b285b56f767c8b3863c13b0c" name="af9ce5812b285b56f767c8b3863c13b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce5812b285b56f767c8b3863c13b0c">&#9670;&#160;</a></span>homflyLMVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarX = &quot;\U0001D4C1&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY-PT polynomials for human consumption.</p>
<p>Since <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the mathematical script symbol for <em>l</em> (encoded in UTF-8).</p>
<p>To pretty-print this HOMFLY-PT polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="af73f30e80276f03658f7d733827631d3" name="af73f30e80276f03658f7d733827631d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73f30e80276f03658f7d733827631d3">&#9670;&#160;</a></span>homflyLMVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyLMVarY = &quot;m&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a>. </p>
<p>This is provided to help with pretty-printing HOMFLY-PT polynomials for human consumption.</p>
<p>Since <a class="el" href="#a7ee829fa01ddd45f97fa2fed002d950e" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in l and m.">homflyLM()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in <em>l</em> and <em>m</em>, this string just contains the single character <em>m</em>.</p>
<p>To pretty-print this HOMFLY-PT polynomial for human consumption, you can call <code>Laurent2::str(Link::homflyLMVarX, Link::homflyLMVarY)</code>. </p>

</div>
</div>
<a id="a6b0447b2d9ec84403a4e07f09198c0d3" name="a6b0447b2d9ec84403a4e07f09198c0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0447b2d9ec84403a4e07f09198c0d3">&#9670;&#160;</a></span>homflyVarX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarX = <a class="el" href="#ad65f761ba1c3d1badabc9638c27192db">homflyAZVarX</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the first variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarX. See the documentation for homflyAZVarX for further details. </p>

</div>
</div>
<a id="ae3e77ac33d5598dac3aeca46abc71cde" name="ae3e77ac33d5598dac3aeca46abc71cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e77ac33d5598dac3aeca46abc71cde">&#9670;&#160;</a></span>homflyVarY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::homflyVarY = <a class="el" href="#a7acb282c9b668b106d63b5180e34f7f2">homflyAZVarY</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the second variable used in the variant of the HOMFLY-PT polynomial as returned by <a class="el" href="#a7556a53360868c1cf7b15f101707451d" title="Returns the HOMFLY-PT polynomial of this classical link, as a polynomial in alpha and z.">homfly()</a>. </p>
<p>This is simply an alias for homflyAZVarY. See the documentation for homflyAZVarY for further details. </p>

</div>
</div>
<a id="a365f08df3a98992ccc0c2c22f23958c6" name="a365f08df3a98992ccc0c2c22f23958c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365f08df3a98992ccc0c2c22f23958c6">&#9670;&#160;</a></span>jonesVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* regina::Link::jonesVar = &quot;\u221At&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the variable used in the Jones polynomial, as returned by <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a>. </p>
<p>This is provided to help with pretty-printing Jones polynomials for human consumption.</p>
<p>Since <a class="el" href="#a82d4fa2ccffd5c8744f0eb02a5ac4bdb" title="Returns the Jones polynomial of this link, but with all exponents doubled.">jones()</a> returns a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the square root of <em>t</em>, this string is just a human-readable representation of the square root of <em>t</em> (encoded in UTF-8).</p>
<p>To pretty-print the Jones polynomial for human consumption, you can call <code>Laurent::str(Link::jonesVar)</code>. </p>

</div>
</div>
<a id="a11f83f8f5e9df2281cb7b65b1d46bd4c" name="a11f83f8f5e9df2281cb7b65b1d46bd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f83f8f5e9df2281cb7b65b1d46bd4c">&#9670;&#160;</a></span>topologyLock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t regina::TopologyLockable::topologyLock_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of topology locks currently held on this object. </p>
<p>Any non-zero number of locks implies that "hook routines" that clear computed properties (as described in the class notes) will preserve properties that are purely topological. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 1999&ndash;2025, The Regina development team
</small></address>
</div><!-- doc-content -->
</body>
</html>
