<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::FacetPairing&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1FacetPairing-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::FacetPairing&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__generic.html">Generic triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents the dual graph of a <em>dim</em>-manifold triangulation; that is, the pairwise matching of facets of <em>dim</em>-dimensional simplices.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/generic.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::FacetPairing&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1FacetPairing.png" usemap="#regina::FacetPairing_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::FacetPairing_3C_20dim_20_3E_map" name="regina::FacetPairing_3C_20dim_20_3E_map">
<area href="classregina_1_1detail_1_1FacetPairingBase.html" title="Provides core functionality for facet pairings (that is, dual graphs) of dim-dimensional triangulatio..." alt="regina::detail::FacetPairingBase&lt; dim &gt;" shape="rect" coords="152,112,446,136"/>
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; FacetPairingBase&lt; dim &gt; &gt;" shape="rect" coords="0,56,294,80"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; FacetPairing&lt; dim &gt; &gt;" shape="rect" coords="304,56,598,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; FacetPairingBase&lt; dim &gt;, false &gt;" shape="rect" coords="0,0,294,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89201e1fcbeb6d02b50b2e81c3de1060" id="r_a89201e1fcbeb6d02b50b2e81c3de1060"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">IsoList</a> = std::vector&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt;&gt;</td></tr>
<tr class="memdesc:a89201e1fcbeb6d02b50b2e81c3de1060"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of isomorphisms on facet pairings.  <br /></td></tr>
<tr class="separator:a89201e1fcbeb6d02b50b2e81c3de1060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe14ad86e70d2b0ce59c963eeca8166e" id="r_afe14ad86e70d2b0ce59c963eeca8166e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe14ad86e70d2b0ce59c963eeca8166e">FacetPairing</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;src)=default</td></tr>
<tr class="memdesc:afe14ad86e70d2b0ce59c963eeca8166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given facet pairing.  <br /></td></tr>
<tr class="separator:afe14ad86e70d2b0ce59c963eeca8166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ac73bad413a4e85c4ea8713f79ac42" id="r_ae3ac73bad413a4e85c4ea8713f79ac42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ac73bad413a4e85c4ea8713f79ac42">FacetPairing</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:ae3ac73bad413a4e85c4ea8713f79ac42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given facet pairing into this facet pairing.  <br /></td></tr>
<tr class="separator:ae3ac73bad413a4e85c4ea8713f79ac42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0110635d7a625de5871392f0ae5915" id="r_aef0110635d7a625de5871392f0ae5915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0110635d7a625de5871392f0ae5915">FacetPairing</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri)</td></tr>
<tr class="memdesc:aef0110635d7a625de5871392f0ae5915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the dual graph of the given triangulation.  <br /></td></tr>
<tr class="separator:aef0110635d7a625de5871392f0ae5915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe62d7d80b673ef1a07eb0984dec400" id="r_a9fe62d7d80b673ef1a07eb0984dec400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fe62d7d80b673ef1a07eb0984dec400">FacetPairing</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a9fe62d7d80b673ef1a07eb0984dec400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new facet pairing from the given input stream.  <br /></td></tr>
<tr class="separator:a9fe62d7d80b673ef1a07eb0984dec400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21af92dd4a90ee1b10f099338305e5ec" id="r_a21af92dd4a90ee1b10f099338305e5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21af92dd4a90ee1b10f099338305e5ec">operator=</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;src)=default</td></tr>
<tr class="memdesc:a21af92dd4a90ee1b10f099338305e5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given facet pairing into this facet pairing.  <br /></td></tr>
<tr class="separator:a21af92dd4a90ee1b10f099338305e5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d3e0d7d601296b8bd6bcbf6fd46b72" id="r_a21d3e0d7d601296b8bd6bcbf6fd46b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21d3e0d7d601296b8bd6bcbf6fd46b72">operator=</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a21d3e0d7d601296b8bd6bcbf6fd46b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given facet pairing into this facet pairing.  <br /></td></tr>
<tr class="separator:a21d3e0d7d601296b8bd6bcbf6fd46b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructors and Assignment</div></td></tr>
<tr class="memitem:a88f2b377e3340f2f16e2baac92e5f904" id="r_a88f2b377e3340f2f16e2baac92e5f904"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a88f2b377e3340f2f16e2baac92e5f904">swap</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a88f2b377e3340f2f16e2baac92e5f904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given facet pairing.  <br /></td></tr>
<tr class="separator:a88f2b377e3340f2f16e2baac92e5f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Queries</div></td></tr>
<tr class="memitem:a05fd123494c0f9d15ffed9f226728b83" id="r_a05fd123494c0f9d15ffed9f226728b83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a05fd123494c0f9d15ffed9f226728b83">size</a> () const</td></tr>
<tr class="memdesc:a05fd123494c0f9d15ffed9f226728b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplices whose facets are described by this facet pairing.  <br /></td></tr>
<tr class="separator:a05fd123494c0f9d15ffed9f226728b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a751dcff6edea48d5407a9de3247927" id="r_a4a751dcff6edea48d5407a9de3247927"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a4a751dcff6edea48d5407a9de3247927">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a4a751dcff6edea48d5407a9de3247927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:a4a751dcff6edea48d5407a9de3247927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391b83deb3b8866fbe3f6d37be1b0f6a" id="r_a391b83deb3b8866fbe3f6d37be1b0f6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a391b83deb3b8866fbe3f6d37be1b0f6a">dest</a> (size_t simp, int facet) const</td></tr>
<tr class="memdesc:a391b83deb3b8866fbe3f6d37be1b0f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:a391b83deb3b8866fbe3f6d37be1b0f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012c646f9f7388f3f4379f2f3281ed69" id="r_a012c646f9f7388f3f4379f2f3281ed69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a012c646f9f7388f3f4379f2f3281ed69">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a012c646f9f7388f3f4379f2f3281ed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:a012c646f9f7388f3f4379f2f3281ed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c56d584b417d3fb51507fb92809721" id="r_a86c56d584b417d3fb51507fb92809721"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a86c56d584b417d3fb51507fb92809721">isUnmatched</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a86c56d584b417d3fb51507fb92809721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <br /></td></tr>
<tr class="separator:a86c56d584b417d3fb51507fb92809721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681f179632365f3001a98d962da28f24" id="r_a681f179632365f3001a98d962da28f24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a681f179632365f3001a98d962da28f24">isUnmatched</a> (size_t simp, int facet) const</td></tr>
<tr class="memdesc:a681f179632365f3001a98d962da28f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <br /></td></tr>
<tr class="separator:a681f179632365f3001a98d962da28f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b81d609b3827899604f1e8a829c884" id="r_a55b81d609b3827899604f1e8a829c884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a55b81d609b3827899604f1e8a829c884">isClosed</a> () const</td></tr>
<tr class="memdesc:a55b81d609b3827899604f1e8a829c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is closed.  <br /></td></tr>
<tr class="separator:a55b81d609b3827899604f1e8a829c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac439676d3f11103163552326f4f5c64d" id="r_ac439676d3f11103163552326f4f5c64d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ac439676d3f11103163552326f4f5c64d">operator==</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac439676d3f11103163552326f4f5c64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given facet pairing are identical.  <br /></td></tr>
<tr class="separator:ac439676d3f11103163552326f4f5c64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e898ff16c0b26e346a1a8f83a8b425" id="r_a71e898ff16c0b26e346a1a8f83a8b425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a71e898ff16c0b26e346a1a8f83a8b425">operator!=</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a71e898ff16c0b26e346a1a8f83a8b425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given facet pairing are not identical.  <br /></td></tr>
<tr class="separator:a71e898ff16c0b26e346a1a8f83a8b425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Connected components</div></td></tr>
<tr class="memitem:a8839c834a0f7d09197febd91530a4157" id="r_a8839c834a0f7d09197febd91530a4157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a8839c834a0f7d09197febd91530a4157">isConnected</a> () const</td></tr>
<tr class="memdesc:a8839c834a0f7d09197febd91530a4157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is connected.  <br /></td></tr>
<tr class="separator:a8839c834a0f7d09197febd91530a4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e41a81d6146ccad710691f5de91fb3" id="r_af1e41a81d6146ccad710691f5de91fb3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af1e41a81d6146ccad710691f5de91fb3">divideConnected</a> (size_t minSide) const</td></tr>
<tr class="memdesc:af1e41a81d6146ccad710691f5de91fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cut that divides this facet pairing into two connected pieces, both of size at least <em>minSide</em>.  <br /></td></tr>
<tr class="separator:af1e41a81d6146ccad710691f5de91fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphic Representations</div></td></tr>
<tr class="memitem:ad720be5515121b69f7ce62e5bbda9b5b" id="r_ad720be5515121b69f7ce62e5bbda9b5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b">isCanonical</a> () const</td></tr>
<tr class="memdesc:ad720be5515121b69f7ce62e5bbda9b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical form.  <br /></td></tr>
<tr class="separator:ad720be5515121b69f7ce62e5bbda9b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27ab47dd1f680f939eadab960fac9e" id="r_a7a27ab47dd1f680f939eadab960fac9e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7a27ab47dd1f680f939eadab960fac9e">canonical</a> () const</td></tr>
<tr class="memdesc:a7a27ab47dd1f680f939eadab960fac9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical form of this facet pairing, along with one isomorphism that transforms this pairing into canonial form.  <br /></td></tr>
<tr class="separator:a7a27ab47dd1f680f939eadab960fac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c4f6d9bf9e233bc6c8fa04dd6c8304" id="r_a70c4f6d9bf9e233bc6c8fa04dd6c8304"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">IsoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a70c4f6d9bf9e233bc6c8fa04dd6c8304">canonicalAll</a> () const</td></tr>
<tr class="memdesc:a70c4f6d9bf9e233bc6c8fa04dd6c8304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical form of this facet pairing, along with the list of all isomorphisms that transform this pairing into canonial form.  <br /></td></tr>
<tr class="separator:a70c4f6d9bf9e233bc6c8fa04dd6c8304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4a0cf9cc419b3cb7cf1dc9d3370340" id="r_a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">IsoList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a2b4a0cf9cc419b3cb7cf1dc9d3370340">findAutomorphisms</a> () const</td></tr>
<tr class="memdesc:a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all combinatorial automorphisms of this facet pairing, assuming the pairing is already in canonical form.  <br /></td></tr>
<tr class="separator:a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a663cb963d4d177f69ec39c7f7409d278" id="r_a663cb963d4d177f69ec39c7f7409d278"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a663cb963d4d177f69ec39c7f7409d278">size_</a></td></tr>
<tr class="memdesc:a663cb963d4d177f69ec39c7f7409d278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices under consideration.  <br /></td></tr>
<tr class="separator:a663cb963d4d177f69ec39c7f7409d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05ce55cfad3b49aae171e5baa4a5e0" id="r_aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aee05ce55cfad3b49aae171e5baa4a5e0">pairs_</a></td></tr>
<tr class="memdesc:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The other facet to which each simplex facet is paired.  <br /></td></tr>
<tr class="separator:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa07233fd7ef05238df04eaf81fbd3105" id="r_aa07233fd7ef05238df04eaf81fbd3105"><td class="memItemLeft" align="right" valign="top"><a id="aa07233fd7ef05238df04eaf81fbd3105" name="aa07233fd7ef05238df04eaf81fbd3105"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::FacetPairingBase&lt; dim &gt;</b></td></tr>
<tr class="separator:aa07233fd7ef05238df04eaf81fbd3105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6bb08e7f7dd73515c6a2094d9ad55" id="r_adac6bb08e7f7dd73515c6a2094d9ad55"><td class="memItemLeft" align="right" valign="top"><a id="adac6bb08e7f7dd73515c6a2094d9ad55" name="adac6bb08e7f7dd73515c6a2094d9ad55"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Isomorphism&lt; dim &gt;</b></td></tr>
<tr class="separator:adac6bb08e7f7dd73515c6a2094d9ad55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2dc5a763bde3eaa4f20b885dd934a8" id="r_a9b2dc5a763bde3eaa4f20b885dd934a8"><td class="memItemLeft" align="right" valign="top"><a id="a9b2dc5a763bde3eaa4f20b885dd934a8" name="a9b2dc5a763bde3eaa4f20b885dd934a8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Cut</b></td></tr>
<tr class="separator:a9b2dc5a763bde3eaa4f20b885dd934a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input and Output</h2></td></tr>
<tr class="memitem:a2e3a9b5851e0f984a28cc88fa64717c1" id="r_a2e3a9b5851e0f984a28cc88fa64717c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a2e3a9b5851e0f984a28cc88fa64717c1">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2e3a9b5851e0f984a28cc88fa64717c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable representation of this facet pairing to the given output stream.  <br /></td></tr>
<tr class="separator:a2e3a9b5851e0f984a28cc88fa64717c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d594a8fdd5b94c5edd90743fe35ca7" id="r_aa6d594a8fdd5b94c5edd90743fe35ca7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7">textRep</a> () const</td></tr>
<tr class="memdesc:aa6d594a8fdd5b94c5edd90743fe35ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a text-based representation that can be used to reconstruct this facet pairing.  <br /></td></tr>
<tr class="separator:aa6d594a8fdd5b94c5edd90743fe35ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afb56a1370b063c12c4efe634eb771b" id="r_a6afb56a1370b063c12c4efe634eb771b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b">toTextRep</a> () const</td></tr>
<tr class="memdesc:a6afb56a1370b063c12c4efe634eb771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns a text-based representation that can be used to reconstruct this facet pairing.  <br /></td></tr>
<tr class="separator:a6afb56a1370b063c12c4efe634eb771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f4145c9bae5e952359db1cf24b236" id="r_a478f4145c9bae5e952359db1cf24b236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a478f4145c9bae5e952359db1cf24b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this facet pairing to the given output stream.  <br /></td></tr>
<tr class="separator:a478f4145c9bae5e952359db1cf24b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b3698780487e07b4f692639951694" id="r_a862b3698780487e07b4f692639951694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694">writeDot</a> (std::ostream &amp;out, const char *prefix=nullptr, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:a862b3698780487e07b4f692639951694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graph corresponding to this facet pairing in the Graphviz DOT language.  <br /></td></tr>
<tr class="separator:a862b3698780487e07b4f692639951694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8c5f6f14ae74fb740738509145643" id="r_acfc8c5f6f14ae74fb740738509145643"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643">dot</a> (const char *prefix=nullptr, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:acfc8c5f6f14ae74fb740738509145643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz DOT representation of the graph that describes this facet pairing.  <br /></td></tr>
<tr class="separator:acfc8c5f6f14ae74fb740738509145643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beef317a48670f0a4b015b6a9677c62" id="r_a6beef317a48670f0a4b015b6a9677c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a6beef317a48670f0a4b015b6a9677c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:a6beef317a48670f0a4b015b6a9677c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70893091e986ed83bcf6fe88b2b2856e" id="r_a70893091e986ed83bcf6fe88b2b2856e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a70893091e986ed83bcf6fe88b2b2856e">dest</a> (size_t simp, int facet)</td></tr>
<tr class="memdesc:a70893091e986ed83bcf6fe88b2b2856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:a70893091e986ed83bcf6fe88b2b2856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74fc68b1801eae6f8a62220accb4c72" id="r_ab74fc68b1801eae6f8a62220accb4c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab74fc68b1801eae6f8a62220accb4c72">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:ab74fc68b1801eae6f8a62220accb4c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <br /></td></tr>
<tr class="separator:ab74fc68b1801eae6f8a62220accb4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c57ad6815d5771c941ec03eeb326d" id="r_ad11c57ad6815d5771c941ec03eeb326d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad11c57ad6815d5771c941ec03eeb326d">noDest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:ad11c57ad6815d5771c941ec03eeb326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <br /></td></tr>
<tr class="separator:ad11c57ad6815d5771c941ec03eeb326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0f0c63bc8c18ff5eeeca33578554be" id="r_a6f0f0c63bc8c18ff5eeeca33578554be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6f0f0c63bc8c18ff5eeeca33578554be">noDest</a> (size_t simp, int facet) const</td></tr>
<tr class="memdesc:a6f0f0c63bc8c18ff5eeeca33578554be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <br /></td></tr>
<tr class="separator:a6f0f0c63bc8c18ff5eeeca33578554be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa068e67a01afdce19626903a4b867fc6" id="r_aa068e67a01afdce19626903a4b867fc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa068e67a01afdce19626903a4b867fc6">isCanonicalInternal</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">IsoList</a> *list=nullptr) const</td></tr>
<tr class="memdesc:aa068e67a01afdce19626903a4b867fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions.  <br /></td></tr>
<tr class="separator:aa068e67a01afdce19626903a4b867fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482dbc8bae43545ca54baa9732b327bc" id="r_a482dbc8bae43545ca54baa9732b327bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc">fromTextRep</a> (const std::string &amp;rep)</td></tr>
<tr class="memdesc:a482dbc8bae43545ca54baa9732b327bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a facet pairing from a text-based representation.  <br /></td></tr>
<tr class="separator:a482dbc8bae43545ca54baa9732b327bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a39c8fffac5cd25a7acdec79a2ad465" id="r_a1a39c8fffac5cd25a7acdec79a2ad465"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1a39c8fffac5cd25a7acdec79a2ad465">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a1a39c8fffac5cd25a7acdec79a2ad465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a facet pairing from its given tight encoding.  <br /></td></tr>
<tr class="separator:a1a39c8fffac5cd25a7acdec79a2ad465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508aa380bbd5e52e23166a07d4087256" id="r_a508aa380bbd5e52e23166a07d4087256"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256">writeDotHeader</a> (std::ostream &amp;out, const char *graphName=nullptr)</td></tr>
<tr class="memdesc:a508aa380bbd5e52e23166a07d4087256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <br /></td></tr>
<tr class="separator:a508aa380bbd5e52e23166a07d4087256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8dd170b533d87914f798b0e4664d02" id="r_a1f8dd170b533d87914f798b0e4664d02"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02">dotHeader</a> (const char *graphName=nullptr)</td></tr>
<tr class="memdesc:a1f8dd170b533d87914f798b0e4664d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <br /></td></tr>
<tr class="separator:a1f8dd170b533d87914f798b0e4664d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57242b47e393f1bb9a36221d6c5f5f43" id="r_a57242b47e393f1bb9a36221d6c5f5f43"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a57242b47e393f1bb9a36221d6c5f5f43"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43">findAllPairings</a> (size_t nSimplices, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> boundary, int nBdryFacets, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a57242b47e393f1bb9a36221d6c5f5f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible facet pairings satisfying the given constraints.  <br /></td></tr>
<tr class="separator:a57242b47e393f1bb9a36221d6c5f5f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::FacetPairing&lt; dim &gt;</div><p>Represents the dual graph of a <em>dim</em>-manifold triangulation; that is, the pairwise matching of facets of <em>dim</em>-dimensional simplices. </p>
<p>Given a fixed number of <em>dim</em>-dimensional simplices, each facet of each simplex is either paired with some other simplex facet (which is in turn paired with it) or remains unmatched. A simplex facet cannot be paired with itself.</p>
<p>Such a matching models part of the structure of a <em>dim</em>-manifold triangulation, in which each simplex facet is either glued to some other simplex facet (which is in turn glued to it) or is an unglued boundary facet. Note however that a facet pairing does not contain enough information to fully reconstruct a triangulation, since the permutations used for each individual gluing are not stored.</p>
<p>Facet pairings are <em>labelled</em>, in that the simplices are explicitly numbered 0,1,..., and the facets of each simplex are explicitly numbered 0,...,<em>dim</em> (just like in a triangulation). Facet pairings do also come with code to help identify and work with relabellings, via isomorphisms, automorphisms, and canonical representations. In this context:</p>
<ul>
<li>An <em>isomorphism</em> of a facet pairing means a relabelling of the simplices and a relabelling of the (<em>dim</em> + 1) facets within each simplex; this can be represented by the same class Isomorphism&lt;dim&gt; that is used for isomorphisms of triangulations.</li>
<li>An <em>automorphism</em> of a facet pairing is an isomorphism that, when applied, results in an identical facet pairing (i.e., where exactly the same pairs of labelled simplex facets are matched together).</li>
<li>A facet pairing is in <em>canonical form</em> if it is a lexicographically minimal representative of its isomorphism class. Here we order facet pairings by lexicographical comparison of the sequence <code>dest(0,0)</code>, <code>dest(0,1)</code>, ..., <code>dest(<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a05fd123494c0f9d15ffed9f226728b83" title="Returns the number of simplices whose facets are described by this facet pairing.">size()</a>-1, dim)</code> (which in turn uses the ordering defined by FacetSpec&lt;dim&gt;, where each simplex facet is ordered first by simplex number and then by facet number, and where the boundary is ordered last).</li>
</ul>
<p>For dimension 3, this <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class template is specialised and offers more functionality. In order to use this specialised class, you will need to include the corresponding header <a class="el" href="facetpairing3_8h.html" title="Deals with dual graphs of 3-manifold triangulations.">triangulation/facetpairing3.h</a>.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., FacetPairing2 and FacetPairing3 for dimensions 2 and 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a89201e1fcbeb6d02b50b2e81c3de1060" name="a89201e1fcbeb6d02b50b2e81c3de1060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89201e1fcbeb6d02b50b2e81c3de1060">&#9670;&#160;</a></span>IsoList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::IsoList = std::vector&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of isomorphisms on facet pairings. </p>
<p>In particular, this class uses the IsoList type to return the set of all <em>automorphisms</em> of a facet pairing. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe14ad86e70d2b0ce59c963eeca8166e" name="afe14ad86e70d2b0ce59c963eeca8166e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe14ad86e70d2b0ce59c963eeca8166e">&#9670;&#160;</a></span>FacetPairing() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::FacetPairing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given facet pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the facet pairing to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ac73bad413a4e85c4ea8713f79ac42" name="ae3ac73bad413a4e85c4ea8713f79ac42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ac73bad413a4e85c4ea8713f79ac42">&#9670;&#160;</a></span>FacetPairing() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::FacetPairing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given facet pairing into this facet pairing. </p>
<p>This is a fast (constant time) operation.</p>
<p>The facet pairing that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the facet pairing to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef0110635d7a625de5871392f0ae5915" name="aef0110635d7a625de5871392f0ae5915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0110635d7a625de5871392f0ae5915">&#9670;&#160;</a></span>FacetPairing() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::FacetPairing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the dual graph of the given triangulation. </p>
<p>This is the facet pairing that describes how the facets of simplices in the given triangulation are joined together, as described in the class notes.</p>
<p>Calling <code><a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a>&lt;dim&gt;(tri)</code> is equivalent to calling <code>tri.pairing()</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is not empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose facet pairing should be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fe62d7d80b673ef1a07eb0984dec400" name="a9fe62d7d80b673ef1a07eb0984dec400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe62d7d80b673ef1a07eb0984dec400">&#9670;&#160;</a></span>FacetPairing() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::FacetPairing </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a new facet pairing from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7" title="Returns a text-based representation that can be used to reconstruct this facet pairing.">textRep()</a>.</p>
<p>This routine will skip any initial whitespace in the given input stream. Once it finds its first non-whitespace character, it will read the <em>entire</em> line from the input stream and expect that line to containin the text representation of a facet pairing.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The data found in the input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>, which reads this same text format in string form. The main differences between this constructor and <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> are: (i) <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> does not skip over initial whitespace; and (ii) <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> throws <a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a> exceptions on error (not <a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a27ab47dd1f680f939eadab960fac9e" name="a7a27ab47dd1f680f939eadab960fac9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a27ab47dd1f680f939eadab960fac9e">&#9670;&#160;</a></span>canonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::canonical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the canonical form of this facet pairing, along with one isomorphism that transforms this pairing into canonial form. </p>
<p>Note that, while the canoncial form is uniquely determined, the isomorphism is not (since the facet pairing could have non-trivial automorphisms). If you need <em>all</em> such isomorphisms then you should call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a70c4f6d9bf9e233bc6c8fa04dd6c8304" title="Returns the canonical form of this facet pairing, along with the list of all isomorphisms that transf...">canonicalAll()</a> instead.</p>
<p>See the <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class notes for more information on isomorphisms, automorphisms and canonical form.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>c</em>, <em>iso</em>), where <em>c</em> is the canonical form and <em>iso</em> is one isomorphism that converts this facet pairing into <em>c</em>. </dd></dl>

</div>
</div>
<a id="a70c4f6d9bf9e233bc6c8fa04dd6c8304" name="a70c4f6d9bf9e233bc6c8fa04dd6c8304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c4f6d9bf9e233bc6c8fa04dd6c8304">&#9670;&#160;</a></span>canonicalAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, typename <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">::IsoList</a> &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::canonicalAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the canonical form of this facet pairing, along with the list of all isomorphisms that transform this pairing into canonial form. </p>
<p>Note that the list that is returned will be a left coset of the automorphism group of this facet pairing, and also a right coset of the automorphism group of the canonical form.</p>
<p>If you only need one such isomorphism (not all), then you should call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a7a27ab47dd1f680f939eadab960fac9e" title="Returns the canonical form of this facet pairing, along with one isomorphism that transforms this pai...">canonical()</a> instead.</p>
<p>See the <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class notes for more information on isomorphisms, automorphisms and canonical form.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>c</em>, <em>isos</em>), where <em>c</em> is the canonical form and <em>isos</em> is the list of all isomorphisms that convert this facet pairing into <em>c</em>. </dd></dl>

</div>
</div>
<a id="a6beef317a48670f0a4b015b6a9677c62" name="a6beef317a48670f0a4b015b6a9677c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beef317a48670f0a4b015b6a9677c62">&#9670;&#160;</a></span>dest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a4a751dcff6edea48d5407a9de3247927" name="a4a751dcff6edea48d5407a9de3247927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a751dcff6edea48d5407a9de3247927">&#9670;&#160;</a></span>dest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a70893091e986ed83bcf6fe88b2b2856e" name="a70893091e986ed83bcf6fe88b2b2856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70893091e986ed83bcf6fe88b2b2856e">&#9670;&#160;</a></span>dest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a391b83deb3b8866fbe3f6d37be1b0f6a" name="a391b83deb3b8866fbe3f6d37be1b0f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391b83deb3b8866fbe3f6d37be1b0f6a">&#9670;&#160;</a></span>dest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="af1e41a81d6146ccad710691f5de91fb3" name="af1e41a81d6146ccad710691f5de91fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e41a81d6146ccad710691f5de91fb3">&#9670;&#160;</a></span>divideConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a> &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::divideConnected </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>minSide</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a cut that divides this facet pairing into two connected pieces, both of size at least <em>minSide</em>. </p>
<p>If solutions exist, then the cut that is returned will have minimum weight amongst all solutions (i.e., will have the smallest number of matched simplex facets that cross the two sides of the resulting partition). If there are still multiple solutions, then the cut that is returned will have the two pieces with sizes that are as close as possible to equal. If there are <em>still</em> multiple solutions, then the choice will be arbitrary.</p>
<p>Note that it is possible that no solution exists (e.g. this could happen if the matching is a star graph and <em>minSide</em> is greater than 1).</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently the implementation of this routine is exhaustive, and so the running time is exponential in the size of this facet pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minSide</td><td>the minimum number of simplices in each of the two connected pieces; this must be at least 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the best possible cut as described above, or no value if no such cut exists. </dd></dl>

</div>
</div>
<a id="acfc8c5f6f14ae74fb740738509145643" name="acfc8c5f6f14ae74fb740738509145643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc8c5f6f14ae74fb740738509145643">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>subgraph</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Graphviz DOT representation of the graph that describes this facet pairing. </p>
<p>Every vertex of this graph represents a simplex, and every edge represents a pair of simplex facets that are joined together. Note that for a closed triangulation this graph will be entirely (<em>dim</em> + 1)-valent; for triangulations with boundary facets, some graph vertices will have degree <em>dim</em> or less.</p>
<p>The graph can either be written as a complete DOT graph, or as a clustered subgraph within some larger DOT graph (according to whether the argument <em>subgraph</em> is passed as <code>false</code> or <code>true</code>).</p>
<p>If a complete DOT graph is being written, the output may be used as a standalone DOT file ready for use with Graphviz.</p>
<p>If a subgraph is being written, the output will contain a single <code>subgraph</code> section that should be inserted into some larger DOT file. Note that the output generated by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02" title="Returns header information for a Graphviz DOT file that will describe the graphs for one or more face...">dotHeader()</a> or <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, followed by one or more subgraphs and then a closing curly brace will suffice. The subgraph name will begin with the string <code>pairing_</code>.</p>
<p>The argument <em>prefix</em> will be prepended to the name of each graph vertex, and will also be used in the name of the graph or subgraph. Using unique prefixes becomes important if you are calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> or <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> several times to generate several subgraphs for use in a single DOT file. If the <em>prefix</em> argument is null or empty then a default prefix will be used.</p>
<p>Note that this routine generates undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<p>If you are simply writing this string to an output stream then you should call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> instead, which is more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>a string to prepend to the name of each graph vertex, and to include in the graph or subgraph name; see above for details. </td></tr>
    <tr><td class="paramname">subgraph</td><td><code>false</code> if a complete standalone DOT graph should be output, or <code>true</code> if a clustered subgraph should be output for use in some larger DOT file. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. This feature is currently experimental, and the default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="a1f8dd170b533d87914f798b0e4664d02" name="a1f8dd170b533d87914f798b0e4664d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8dd170b533d87914f798b0e4664d02">&#9670;&#160;</a></span>dotHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dotHeader </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>graphName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>See the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> documentation for further information on such graphs.</p>
<p>The output will be in the Graphviz DOT language, and will include appropriate display settings for graphs, edges and nodes. The opening brace for a <code>graph</code> section of the DOT file is included.</p>
<p>This routine may be used with <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> or <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> to generate a single DOT file containing the graphs for several different facet pairings. A complete DOT file can be produced by calling this routine, then calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> or <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in subgraph mode for each facet pairing, then outputting a final closing curly brace.</p>
<p>Note that if you require a DOT file containing the graph for only a single facet pairing, this routine is unnecessary; you may simply call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> or <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in full graph mode instead.</p>
<p>This routine is suitable for generating undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<p>If you are simply writing this string to an output stream then you should call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> instead, which is more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphName</td><td>the name of the graph to write in the DOT header. If this is null or empty then a default graph name will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the DOT header information, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a57242b47e393f1bb9a36221d6c5f5f43" name="a57242b47e393f1bb9a36221d6c5f5f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57242b47e393f1bb9a36221d6c5f5f43">&#9670;&#160;</a></span>findAllPairings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAllPairings </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a></td>          <td class="paramname"><span class="paramname"><em>boundary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nBdryFacets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible facet pairings satisfying the given constraints. </p>
<p>Only connected facet pairings (pairings in which each simplex can be reached from each other via a series of individual matched facets) will be produced.</p>
<p>Each facet pairing will be produced precisely once up to isomorphism. Facet pairings are considered isomorphic if they are related by a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex. Each facet pairing that is generated will be a lexicographically minimal representative of its isomorphism class, i.e., will be in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">isCanonical()</a>.</p>
<p>For each facet pairing that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a const reference to a FacetPairing&lt;dim&gt;. This will be the facet pairing that was found. If <em>action</em> wishes to keep the facet pairing, it should take a deep copy (not a reference), since the facet pairing may be changed and reused after <em>action</em> returns.</li>
<li>If <em>action</em> takes a <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060" title="A list of isomorphisms on facet pairings.">FacetPairing&lt;dim&gt;::IsoList</a> as its second argument (which may be as a reference, and may have const/volatile qualifiers), then this will be the list of all automorphisms of the facet pairing that was found. This list will be passed by value using move semantics. If <em>action</em> does not take a second argument, or if the second argument is of a different type, then the list of automorphisms will not be passed.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<p>Because this class cannot represent an empty facet pairing, if the argument <em>nSimplices</em> is zero then no facet pairings will be generated at all.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you are allowing a large number of boundary facets, then the automorphisms groups could be enormous. In this case it is highly recommended that your action does <em>not</em> take the list of all automorphisms as its second argument, since this will avoid the enormous memory cost of storing and passing such a list.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo</a></b></dt><dd><p class="startdd"><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation.</p>
</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, its form is more restricted: <em>action</em> must take both a facet pairing and its automorphisms (i.e., the automorphisms argument is not optional); moreover, it cannot take any additional arguments beyond these. As a consequence, the additional <em>args</em> list is omitted also.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices whose facets should be (potentially) matched. </td></tr>
    <tr><td class="paramname">boundary</td><td>determines whether any facets may be left unmatched. This set should contain <code>true</code> if pairings with at least one unmatched facet are to be generated, and should contain <code>false</code> if pairings with no unmatched facets are to be generated. </td></tr>
    <tr><td class="paramname">nBdryFacets</td><td>specifies the precise number of facets that should be left unmatched. If this parameter is negative, it is ignored and no additional restriction is imposed. If parameter <em>boundary</em> does not contain <code>true</code>, this parameter is likewise ignored. If parameter <em>boundary</em> does contain true and this parameter is non-negative, only pairings with precisely this many unmatched facets will be generated. In particular, if this parameter is positive then pairings with no unmatched facets will not be produced irrespective of whether <code>false</code> is contained in parameter <em>boundary</em>. Note that, in order to produce any pairings at all, this parameter must be of the same parity as <code>nSimplices * (dim+1)</code>, and can be at most <code>(dim-1) * nSimplices + 2</code>. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each facet pairing that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial facet pairing argument and the optional automorphism argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b4a0cf9cc419b3cb7cf1dc9d3370340" name="a2b4a0cf9cc419b3cb7cf1dc9d3370340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a0cf9cc419b3cb7cf1dc9d3370340">&#9670;&#160;</a></span>findAutomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">::IsoList</a> <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAutomorphisms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all combinatorial automorphisms of this facet pairing, assuming the pairing is already in canonical form. </p>
<p>See the <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class notes for more information on isomorphisms, automorphisms and canonical form.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd>
<dd>
This facet pairing is in canonical form. This is crucial, since this routine uses optimisations that can cause unpredictable breakages if this facet pairing is not in canonical form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all automorphisms. </dd></dl>

</div>
</div>
<a id="a482dbc8bae43545ca54baa9732b327bc" name="a482dbc8bae43545ca54baa9732b327bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482dbc8bae43545ca54baa9732b327bc">&#9670;&#160;</a></span>fromTextRep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::fromTextRep </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rep</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a facet pairing from a text-based representation. </p>
<p>This text-based representation must be in the format produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7" title="Returns a text-based representation that can be used to reconstruct this facet pairing.">textRep()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string was not a valid text-based representation of a facet pairing on a positive number of simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>a text-based representation of a facet pairing, as produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7" title="Returns a text-based representation that can be used to reconstruct this facet pairing.">textRep()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding facet pairing. </dd></dl>

</div>
</div>
<a id="ad720be5515121b69f7ce62e5bbda9b5b" name="ad720be5515121b69f7ce62e5bbda9b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad720be5515121b69f7ce62e5bbda9b5b">&#9670;&#160;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical form. </p>
<p>See the <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class notes for more information on isomorphisms, automorphisms and canonical form.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="aa068e67a01afdce19626903a4b867fc6" name="aa068e67a01afdce19626903a4b867fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa068e67a01afdce19626903a4b867fc6">&#9670;&#160;</a></span>isCanonicalInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonicalInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a89201e1fcbeb6d02b50b2e81c3de1060">IsoList</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions. </p>
<p>If the argument <em>list</em> is non-null, then:</p>
<ul>
<li>If this facet pairing is in canonical form, the given list will be filled with the set of all combinatorial automorphisms of this facet pairing.</li>
<li>If not, the given list will be returned empty.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given list (if one is provided) is empty. </dd>
<dd>
For each simplex <em>t</em>, the only case in which <code>dest(t,i)</code> is greater than <code>dest(t,i+1)</code> is where facets <code>(t,i)</code> and <code>(t,i+1)</code> are paired together. </dd>
<dd>
For each simplex <em>t</em> &gt; 0, it is true that <code>dest(t,0).simp &lt; t</code>. </dd>
<dd>
The sequence <code>dest(1,0)</code>, <code>dest(2,0)</code>, ..., <code>dest(n-1,0)</code> is strictly increasing, where <em>n</em> is the total number of simplices under investigation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which automorphisms will be placed if this facet pairing is indeed canonical, or <em>null</em> if the automorphisms are not requred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="a55b81d609b3827899604f1e8a829c884" name="a55b81d609b3827899604f1e8a829c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b81d609b3827899604f1e8a829c884">&#9670;&#160;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is closed. </p>
<p>A closed facet pairing has no unmatched facets. </p>

</div>
</div>
<a id="a8839c834a0f7d09197febd91530a4157" name="a8839c834a0f7d09197febd91530a4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8839c834a0f7d09197febd91530a4157">&#9670;&#160;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is connected. </p>
<p>A facet pairing is <em>connected</em> if it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</p>
<p>For this purpose, the empty facet pairing is considered to be connected.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this pairing is connected. </dd></dl>

</div>
</div>
<a id="a86c56d584b417d3fb51507fb92809721" name="a86c56d584b417d3fb51507fb92809721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c56d584b417d3fb51507fb92809721">&#9670;&#160;</a></span>isUnmatched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="a681f179632365f3001a98d962da28f24" name="a681f179632365f3001a98d962da28f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681f179632365f3001a98d962da28f24">&#9670;&#160;</a></span>isUnmatched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="ad11c57ad6815d5771c941ec03eeb326d" name="ad11c57ad6815d5771c941ec03eeb326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c57ad6815d5771c941ec03eeb326d">&#9670;&#160;</a></span>noDest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6f0f0c63bc8c18ff5eeeca33578554be" name="a6f0f0c63bc8c18ff5eeeca33578554be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0f0c63bc8c18ff5eeeca33578554be">&#9670;&#160;</a></span>noDest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a71e898ff16c0b26e346a1a8f83a8b425" name="a71e898ff16c0b26e346a1a8f83a8b425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e898ff16c0b26e346a1a8f83a8b425">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given facet pairing are not identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given facet pairing are not identical. </dd></dl>

</div>
</div>
<a id="a21af92dd4a90ee1b10f099338305e5ec" name="a21af92dd4a90ee1b10f099338305e5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21af92dd4a90ee1b10f099338305e5ec">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp; <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given facet pairing into this facet pairing. </p>
<p>It does not matter if this and the given facet pairing use different numbers of top-dimensional simpilices; if they do then this facet pairing will be resized accordingly.</p>
<p>This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the facet pairing to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this facet pairing. </dd></dl>

</div>
</div>
<a id="a21d3e0d7d601296b8bd6bcbf6fd46b72" name="a21d3e0d7d601296b8bd6bcbf6fd46b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d3e0d7d601296b8bd6bcbf6fd46b72">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp; <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given facet pairing into this facet pairing. </p>
<p>This is a fast (constant time) operation.</p>
<p>It does not matter if this and the given facet pairing use different numbers of top-dimensional simpilices; if they do then this facet pairing will be resized accordingly.</p>
<p>The facet pairing that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the facet pairing to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this facet pairing. </dd></dl>

</div>
</div>
<a id="ac439676d3f11103163552326f4f5c64d" name="ac439676d3f11103163552326f4f5c64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac439676d3f11103163552326f4f5c64d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given facet pairing are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given facet pairing are identical. </dd></dl>

</div>
</div>
<a id="ab74fc68b1801eae6f8a62220accb4c72" name="ab74fc68b1801eae6f8a62220accb4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74fc68b1801eae6f8a62220accb4c72">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a012c646f9f7388f3f4379f2f3281ed69" name="a012c646f9f7388f3f4379f2f3281ed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012c646f9f7388f3f4379f2f3281ed69">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a05fd123494c0f9d15ffed9f226728b83" name="a05fd123494c0f9d15ffed9f226728b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fd123494c0f9d15ffed9f226728b83">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of simplices whose facets are described by this facet pairing. </p>
<dl class="section user"><dt>Python</dt><dd>This is also used to implement the Python special method <b>len</b>().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a88f2b377e3340f2f16e2baac92e5f904" name="a88f2b377e3340f2f16e2baac92e5f904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f2b377e3340f2f16e2baac92e5f904">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given facet pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6d594a8fdd5b94c5edd90743fe35ca7" name="aa6d594a8fdd5b94c5edd90743fe35ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d594a8fdd5b94c5edd90743fe35ca7">&#9670;&#160;</a></span>textRep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::textRep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a text-based representation that can be used to reconstruct this facet pairing. </p>
<p>This reconstruction is done through the routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>.</p>
<p>The text produced is not particularly readable; for a human-readable text representation, see routine <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</p>
<p>The string returned will contain no newlines.</p>
<dl class="section return"><dt>Returns</dt><dd>a text-based representation of this facet pairing. </dd></dl>

</div>
</div>
<a id="a1a39c8fffac5cd25a7acdec79a2ad465" name="a1a39c8fffac5cd25a7acdec79a2ad465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a39c8fffac5cd25a7acdec79a2ad465">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a facet pairing from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a <em>dim</em>-dimensional facet pairing on a positive number of simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="namespaceregina.html#a968e5525b0b7c5e65b14b70ae12f8377" title="Reconstructs an integer or boolean from its given tight encoding.">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a <em>dim</em>-dimensional facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the facet pairing represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a478f4145c9bae5e952359db1cf24b236" name="a478f4145c9bae5e952359db1cf24b236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f4145c9bae5e952359db1cf24b236">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this facet pairing to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Every simplex facet is either (i) paired to another simplex facet, (ii) marked as boundary, or (iii) paired to itself (which is often used as a placeholder to indicate that the real destination has not yet been decided). In particular, before-the-start or past-the-end destinations are not allowed.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>Some simplex facet has a destination that is explicitly disallowed by the precondition above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="group__maths.html#gaed202995c74bfebb0d60b38044dfd2b5" title="Returns the tight encoding of the given arbitrary precision integer.">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a6afb56a1370b063c12c4efe634eb771b" name="a6afb56a1370b063c12c4efe634eb771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afb56a1370b063c12c4efe634eb771b">&#9670;&#160;</a></span>toTextRep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::toTextRep </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns a text-based representation that can be used to reconstruct this facet pairing. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7" title="Returns a text-based representation that can be used to reconstruct this facet pairing.">textRep()</a>. See the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aa6d594a8fdd5b94c5edd90743fe35ca7" title="Returns a text-based representation that can be used to reconstruct this facet pairing.">textRep()</a> documentation for further details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a text-based representation of this facet pairing. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a862b3698780487e07b4f692639951694" name="a862b3698780487e07b4f692639951694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862b3698780487e07b4f692639951694">&#9670;&#160;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>subgraph</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>labels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the graph corresponding to this facet pairing in the Graphviz DOT language. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> for further details on what this output contains.</p>
<p>This routine is equivalent to (but faster than) writing the string returned by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> to the given output stream.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string to prepend to the name of each graph vertex, and to include in the graph or subgraph name; see above for details. </td></tr>
    <tr><td class="paramname">subgraph</td><td><code>false</code> if a complete standalone DOT graph should be output, or <code>true</code> if a clustered subgraph should be output for use in some larger DOT file. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. This feature is currently experimental, and the default is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a508aa380bbd5e52e23166a07d4087256" name="a508aa380bbd5e52e23166a07d4087256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508aa380bbd5e52e23166a07d4087256">&#9670;&#160;</a></span>writeDotHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDotHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>graphName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02" title="Returns header information for a Graphviz DOT file that will describe the graphs for one or more face...">dotHeader()</a> for further details on what this output contains.</p>
<p>This routine is equivalent to (but faster than) writing the string returned by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02" title="Returns header information for a Graphviz DOT file that will describe the graphs for one or more face...">dotHeader()</a> to the given output stream.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02" title="Returns header information for a Graphviz DOT file that will describe the graphs for one or more face...">dotHeader()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">graphName</td><td>the name of the graph to write in the DOT header. If this is null or empty then a default graph name will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e3a9b5851e0f984a28cc88fa64717c1" name="a2e3a9b5851e0f984a28cc88fa64717c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a9b5851e0f984a28cc88fa64717c1">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a human-readable representation of this facet pairing to the given output stream. </p>
<p>The string returned will contain no newlines.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aee05ce55cfad3b49aae171e5baa4a5e0" name="aee05ce55cfad3b49aae171e5baa4a5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee05ce55cfad3b49aae171e5baa4a5e0">&#9670;&#160;</a></span>pairs_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::pairs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The other facet to which each simplex facet is paired. </p>
<p>If a simplex facet is left unmatched, the corresponding element of this array will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>). If the destination for a particular facet has not yet been decided, the facet will be paired to itself. </p>

</div>
</div>
<a id="a663cb963d4d177f69ec39c7f7409d278" name="a663cb963d4d177f69ec39c7f7409d278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663cb963d4d177f69ec39c7f7409d278">&#9670;&#160;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices under consideration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>triangulation/<a class="el" href="cut_8h.html">cut.h</a></li>
<li>triangulation/detail/<a class="el" href="detail_2triangulation_8h.html">triangulation.h</a></li>
<li>triangulation/<a class="el" href="forward_8h.html">forward.h</a></li>
<li>triangulation/generic/<a class="el" href="generic_2facetpairing_8h.html">facetpairing.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
