<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::GroupPresentation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1GroupPresentation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::GroupPresentation Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a finite presentation of a group.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;algebra/grouppresentation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GroupPresentation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GroupPresentation.png" usemap="#regina::GroupPresentation_map" alt=""/>
  <map id="regina::GroupPresentation_map" name="regina::GroupPresentation_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GroupPresentation &gt;" shape="rect" coords="0,0,220,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35ffeca6d3c8d43baafeeba6fc0d303b" id="r_a35ffeca6d3c8d43baafeeba6fc0d303b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ffeca6d3c8d43baafeeba6fc0d303b">GroupPresentation</a> ()</td></tr>
<tr class="memdesc:a35ffeca6d3c8d43baafeeba6fc0d303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new presentation with no generators and no relations.  <br /></td></tr>
<tr class="separator:a35ffeca6d3c8d43baafeeba6fc0d303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a1fa153860fe1078a1b57b4da85c10" id="r_af6a1fa153860fe1078a1b57b4da85c10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a1fa153860fe1078a1b57b4da85c10">GroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;src)=default</td></tr>
<tr class="memdesc:af6a1fa153860fe1078a1b57b4da85c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group presentation.  <br /></td></tr>
<tr class="separator:af6a1fa153860fe1078a1b57b4da85c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b706281a8eaef8529497a62dc59921" id="r_ab0b706281a8eaef8529497a62dc59921"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0b706281a8eaef8529497a62dc59921">GroupPresentation</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:ab0b706281a8eaef8529497a62dc59921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group presentation to this new group presentation.  <br /></td></tr>
<tr class="separator:ab0b706281a8eaef8529497a62dc59921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509d69fa435502f36f53a735292b8c22" id="r_a509d69fa435502f36f53a735292b8c22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a509d69fa435502f36f53a735292b8c22">GroupPresentation</a> (unsigned long nGenerators)</td></tr>
<tr class="memdesc:a509d69fa435502f36f53a735292b8c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the free group on the given number of generators.  <br /></td></tr>
<tr class="separator:a509d69fa435502f36f53a735292b8c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e5de7fb4b495c779c61c8580f2723a" id="r_af0e5de7fb4b495c779c61c8580f2723a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e5de7fb4b495c779c61c8580f2723a">GroupPresentation</a> (unsigned long nGens, const std::vector&lt; std::string &gt; &amp;rels)</td></tr>
<tr class="memdesc:af0e5de7fb4b495c779c61c8580f2723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to directly pass an arbitrary number of relators in string format.  <br /></td></tr>
<tr class="separator:af0e5de7fb4b495c779c61c8580f2723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef72094af17afa4000626ba25d94c09e" id="r_aef72094af17afa4000626ba25d94c09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef72094af17afa4000626ba25d94c09e">operator=</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;src)=default</td></tr>
<tr class="memdesc:aef72094af17afa4000626ba25d94c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given group presentation.  <br /></td></tr>
<tr class="separator:aef72094af17afa4000626ba25d94c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56544303c799ecbb60ebc9a5aa246e89" id="r_a56544303c799ecbb60ebc9a5aa246e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56544303c799ecbb60ebc9a5aa246e89">operator=</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a56544303c799ecbb60ebc9a5aa246e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group presentation to this group presentation.  <br /></td></tr>
<tr class="separator:a56544303c799ecbb60ebc9a5aa246e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a6264fd68190d464285549521f784" id="r_a689a6264fd68190d464285549521f784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a689a6264fd68190d464285549521f784">swap</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a689a6264fd68190d464285549521f784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given group presentation.  <br /></td></tr>
<tr class="separator:a689a6264fd68190d464285549521f784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7827368f5d5c46b125c526720eb7b" id="r_aefc7827368f5d5c46b125c526720eb7b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc7827368f5d5c46b125c526720eb7b">addGenerator</a> (unsigned long numToAdd=1)</td></tr>
<tr class="memdesc:aefc7827368f5d5c46b125c526720eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more generators to the group presentation.  <br /></td></tr>
<tr class="separator:aefc7827368f5d5c46b125c526720eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c0d0774772c294693ba8aab15aaf44" id="r_a79c0d0774772c294693ba8aab15aaf44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79c0d0774772c294693ba8aab15aaf44">addRelation</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> rel)</td></tr>
<tr class="memdesc:a79c0d0774772c294693ba8aab15aaf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given relation to the group presentation.  <br /></td></tr>
<tr class="separator:a79c0d0774772c294693ba8aab15aaf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ea6821977d1a2f6709627316e7649" id="r_a610ea6821977d1a2f6709627316e7649"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a610ea6821977d1a2f6709627316e7649">countGenerators</a> () const</td></tr>
<tr class="memdesc:a610ea6821977d1a2f6709627316e7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generators in this group presentation.  <br /></td></tr>
<tr class="separator:a610ea6821977d1a2f6709627316e7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffa647790e42c8d984168db32197d22" id="r_a2ffa647790e42c8d984168db32197d22"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ffa647790e42c8d984168db32197d22">countRelations</a> () const</td></tr>
<tr class="memdesc:a2ffa647790e42c8d984168db32197d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of relations in this group presentation.  <br /></td></tr>
<tr class="separator:a2ffa647790e42c8d984168db32197d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b394968e63b1a679b318400537c926" id="r_ae5b394968e63b1a679b318400537c926"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b394968e63b1a679b318400537c926">relation</a> (size_t index) const</td></tr>
<tr class="memdesc:ae5b394968e63b1a679b318400537c926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relation at the given index in this group presentation.  <br /></td></tr>
<tr class="separator:ae5b394968e63b1a679b318400537c926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d22e83fc705f83a2299c73e052250" id="r_aa21d22e83fc705f83a2299c73e052250"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa21d22e83fc705f83a2299c73e052250">relations</a> () const</td></tr>
<tr class="memdesc:aa21d22e83fc705f83a2299c73e052250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of all relations in this group presentation.  <br /></td></tr>
<tr class="separator:aa21d22e83fc705f83a2299c73e052250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e579e06a36b35db8e8dce18ded41a5" id="r_a46e579e06a36b35db8e8dce18ded41a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e579e06a36b35db8e8dce18ded41a5">isValid</a> () const</td></tr>
<tr class="memdesc:a46e579e06a36b35db8e8dce18ded41a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether all of the relations for the group are indeed words in the generators.  <br /></td></tr>
<tr class="separator:a46e579e06a36b35db8e8dce18ded41a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7811777ca9d3e19fe5a3fddeca753ad" id="r_aa7811777ca9d3e19fe5a3fddeca753ad"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7811777ca9d3e19fe5a3fddeca753ad">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:aa7811777ca9d3e19fe5a3fddeca753ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation as intelligently as possible without further input.  <br /></td></tr>
<tr class="separator:aa7811777ca9d3e19fe5a3fddeca753ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8289666edbc70c23ae947f7697b514dc" id="r_a8289666edbc70c23ae947f7697b514dc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8289666edbc70c23ae947f7697b514dc">smallCancellation</a> ()</td></tr>
<tr class="memdesc:a8289666edbc70c23ae947f7697b514dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation using small cancellation theory.  <br /></td></tr>
<tr class="separator:a8289666edbc70c23ae947f7697b514dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda91276bc32baadb7ed6c83c18e2db0" id="r_aeda91276bc32baadb7ed6c83c18e2db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeda91276bc32baadb7ed6c83c18e2db0">simplifyAndConjugate</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;word) const</td></tr>
<tr class="memdesc:aeda91276bc32baadb7ed6c83c18e2db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses small cancellation theory to reduce the input word, modulo conjugation, using the current presentation of the group.  <br /></td></tr>
<tr class="separator:aeda91276bc32baadb7ed6c83c18e2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7653e9f59d3f194e4b560d7f84f6e6" id="r_aaa7653e9f59d3f194e4b560d7f84f6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa7653e9f59d3f194e4b560d7f84f6e6">proliferateRelators</a> (unsigned long depth=1)</td></tr>
<tr class="memdesc:aaa7653e9f59d3f194e4b560d7f84f6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators.  <br /></td></tr>
<tr class="separator:aaa7653e9f59d3f194e4b560d7f84f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd5465442f764dcca7c9f83683144ff" id="r_a6dd5465442f764dcca7c9f83683144ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd5465442f764dcca7c9f83683144ff">recogniseGroup</a> (bool moreUtf8=false) const</td></tr>
<tr class="memdesc:a6dd5465442f764dcca7c9f83683144ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to recognise the group corresponding to this presentation.  <br /></td></tr>
<tr class="separator:a6dd5465442f764dcca7c9f83683144ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a688500a505588004520eff2807545" id="r_aa0a688500a505588004520eff2807545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a688500a505588004520eff2807545">writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa0a688500a505588004520eff2807545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this group presentation.  <br /></td></tr>
<tr class="separator:aa0a688500a505588004520eff2807545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ee67ee75ee1d9539d235a5cd8f101" id="r_a5c9ee67ee75ee1d9539d235a5cd8f101"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9ee67ee75ee1d9539d235a5cd8f101">relatorLength</a> () const</td></tr>
<tr class="memdesc:a5c9ee67ee75ee1d9539d235a5cd8f101"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of the word lengths of the relators.  <br /></td></tr>
<tr class="separator:a5c9ee67ee75ee1d9539d235a5cd8f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c90bfce0f3442eebd7bfb3108f9531" id="r_a29c90bfce0f3442eebd7bfb3108f9531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c90bfce0f3442eebd7bfb3108f9531">abelianisation</a> () const</td></tr>
<tr class="memdesc:a29c90bfce0f3442eebd7bfb3108f9531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <br /></td></tr>
<tr class="separator:a29c90bfce0f3442eebd7bfb3108f9531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff54d96e2b5fba0f41edc265e000318" id="r_a1ff54d96e2b5fba0f41edc265e000318"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff54d96e2b5fba0f41edc265e000318">abelianRank</a> () const</td></tr>
<tr class="memdesc:a1ff54d96e2b5fba0f41edc265e000318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of the abelianisation of this group.  <br /></td></tr>
<tr class="separator:a1ff54d96e2b5fba0f41edc265e000318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d35e6b669bf2fd3f301b3df74af506" id="r_a39d35e6b669bf2fd3f301b3df74af506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39d35e6b669bf2fd3f301b3df74af506">markedAbelianisation</a> () const</td></tr>
<tr class="memdesc:a39d35e6b669bf2fd3f301b3df74af506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <br /></td></tr>
<tr class="separator:a39d35e6b669bf2fd3f301b3df74af506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f4798b7eca1cb22d8b5c3414d5f256" id="r_a23f4798b7eca1cb22d8b5c3414d5f256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f4798b7eca1cb22d8b5c3414d5f256">identifyAbelian</a> () const</td></tr>
<tr class="memdesc:a23f4798b7eca1cb22d8b5c3414d5f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine if the group is abelian.  <br /></td></tr>
<tr class="separator:a23f4798b7eca1cb22d8b5c3414d5f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81c7a84245d4d123ca2b5d144c9cb21" id="r_af81c7a84245d4d123ca2b5d144c9cb21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81c7a84245d4d123ca2b5d144c9cb21">nielsenTransposition</a> (unsigned long i, unsigned long j)</td></tr>
<tr class="memdesc:af81c7a84245d4d123ca2b5d144c9cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation.  <br /></td></tr>
<tr class="separator:af81c7a84245d4d123ca2b5d144c9cb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af4e4996b9c37bfe2bece59ccb6483" id="r_ac6af4e4996b9c37bfe2bece59ccb6483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6af4e4996b9c37bfe2bece59ccb6483">nielsenInvert</a> (unsigned long i)</td></tr>
<tr class="memdesc:ac6af4e4996b9c37bfe2bece59ccb6483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation.  <br /></td></tr>
<tr class="separator:ac6af4e4996b9c37bfe2bece59ccb6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87e91e72bd03e053343c769fb6ef307" id="r_ac87e91e72bd03e053343c769fb6ef307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac87e91e72bd03e053343c769fb6ef307">nielsenCombine</a> (unsigned long i, unsigned long j, long k, bool rightMult=true)</td></tr>
<tr class="memdesc:ac87e91e72bd03e053343c769fb6ef307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation.  <br /></td></tr>
<tr class="separator:ac87e91e72bd03e053343c769fb6ef307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6828f4f67b183f926cabf6dd6c71937" id="r_aa6828f4f67b183f926cabf6dd6c71937"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6828f4f67b183f926cabf6dd6c71937">intelligentNielsen</a> ()</td></tr>
<tr class="memdesc:aa6828f4f67b183f926cabf6dd6c71937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for Nielsen moves that will simplify the presentation.  <br /></td></tr>
<tr class="separator:aa6828f4f67b183f926cabf6dd6c71937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea2c90c93f861333f497612e7795ab" id="r_aa4ea2c90c93f861333f497612e7795ab"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4ea2c90c93f861333f497612e7795ab">homologicalAlignment</a> ()</td></tr>
<tr class="memdesc:aa4ea2c90c93f861333f497612e7795ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible).  <br /></td></tr>
<tr class="separator:aa4ea2c90c93f861333f497612e7795ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaffe47a96e9a314e584e521d24e812" id="r_a4eaffe47a96e9a314e584e521d24e812"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eaffe47a96e9a314e584e521d24e812">prettyRewriting</a> ()</td></tr>
<tr class="memdesc:a4eaffe47a96e9a314e584e521d24e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entirely cosmetic rewriting of the presentation, which is fast and superficial.  <br /></td></tr>
<tr class="separator:a4eaffe47a96e9a314e584e521d24e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2384d7ab5726e119276ec6095eebb9d" id="r_ab2384d7ab5726e119276ec6095eebb9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2384d7ab5726e119276ec6095eebb9d">operator==</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:ab2384d7ab5726e119276ec6095eebb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given group presentation are identical.  <br /></td></tr>
<tr class="separator:ab2384d7ab5726e119276ec6095eebb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ea030dc6f400f5a6063b493bdefad1" id="r_ad2ea030dc6f400f5a6063b493bdefad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2ea030dc6f400f5a6063b493bdefad1">operator!=</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:ad2ea030dc6f400f5a6063b493bdefad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given group presentation are not identical.  <br /></td></tr>
<tr class="separator:ad2ea030dc6f400f5a6063b493bdefad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57f9afdee9e1c46fa06e802a2c8e652" id="r_aa57f9afdee9e1c46fa06e802a2c8e652"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57f9afdee9e1c46fa06e802a2c8e652">identifySimplyIsomorphicTo</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:aa57f9afdee9e1c46fa06e802a2c8e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>.  <br /></td></tr>
<tr class="separator:aa57f9afdee9e1c46fa06e802a2c8e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76ec8d931ca133a2c145ffbc0ef7955" id="r_ab76ec8d931ca133a2c145ffbc0ef7955"><td class="memTemplParams" colspan="2">template&lt;int index, typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ab76ec8d931ca133a2c145ffbc0ef7955"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab76ec8d931ca133a2c145ffbc0ef7955">enumerateCovers</a> (Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ab76ec8d931ca133a2c145ffbc0ef7955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all transitive representations of this group into the symmetric group <em>S(k)</em>.  <br /></td></tr>
<tr class="separator:ab76ec8d931ca133a2c145ffbc0ef7955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bd6a8f830430afdede743fd401bc53" id="r_a69bd6a8f830430afdede743fd401bc53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69bd6a8f830430afdede743fd401bc53">incidence</a> () const</td></tr>
<tr class="memdesc:a69bd6a8f830430afdede743fd401bc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix indicating which generators are used by which relations.  <br /></td></tr>
<tr class="separator:a69bd6a8f830430afdede743fd401bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98098092897b959de3d027eedabd4ebf" id="r_a98098092897b959de3d027eedabd4ebf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98098092897b959de3d027eedabd4ebf">tex</a> () const</td></tr>
<tr class="memdesc:a98098092897b959de3d027eedabd4ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a TeX representation of this group presentation.  <br /></td></tr>
<tr class="separator:a98098092897b959de3d027eedabd4ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c373720fc59d7973d53f53e3126a409" id="r_a7c373720fc59d7973d53f53e3126a409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c373720fc59d7973d53f53e3126a409">writeTeX</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a7c373720fc59d7973d53f53e3126a409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this group presentation to the given output stream.  <br /></td></tr>
<tr class="separator:a7c373720fc59d7973d53f53e3126a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c930c1a8cdb5e53c2a01747dca8c1e5" id="r_a8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c930c1a8cdb5e53c2a01747dca8c1e5">compact</a> () const</td></tr>
<tr class="memdesc:a8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compact one-line representation of this group presentation, including details of all generators and relations.  <br /></td></tr>
<tr class="separator:a8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9848a7d3303be02671e18c57d28afec" id="r_af9848a7d3303be02671e18c57d28afec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9848a7d3303be02671e18c57d28afec">writeTextCompact</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af9848a7d3303be02671e18c57d28afec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a compact one-line represesentation of this group to the given output stream.  <br /></td></tr>
<tr class="separator:af9848a7d3303be02671e18c57d28afec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ef64c265916b3fdc7e0c513d2b458" id="r_ac64ef64c265916b3fdc7e0c513d2b458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac64ef64c265916b3fdc7e0c513d2b458">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac64ef64c265916b3fdc7e0c513d2b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:ac64ef64c265916b3fdc7e0c513d2b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fa6a40ae529c19a16fdba8f66d6768" id="r_a37fa6a40ae529c19a16fdba8f66d6768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37fa6a40ae529c19a16fdba8f66d6768">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a37fa6a40ae529c19a16fdba8f66d6768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a37fa6a40ae529c19a16fdba8f66d6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aebb7847f17b0c9cd05b9591e909e3a" id="r_a3aebb7847f17b0c9cd05b9591e909e3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aebb7847f17b0c9cd05b9591e909e3a">gap</a> (const std::string &amp;groupVariable=&quot;g&quot;) const</td></tr>
<tr class="memdesc:a3aebb7847f17b0c9cd05b9591e909e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sequence of GAP commands that create this group.  <br /></td></tr>
<tr class="separator:a3aebb7847f17b0c9cd05b9591e909e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bac586bbdb9e0469363e104436c911" id="r_a69bac586bbdb9e0469363e104436c911"><td class="memItemLeft" align="right" valign="top">FinitelyPresentedGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69bac586bbdb9e0469363e104436c911">sage</a> () const</td></tr>
<tr class="memdesc:a69bac586bbdb9e0469363e104436c911"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SageMath-only routine that returns a copy of this group presentation in a format native to SageMath.  <br /></td></tr>
<tr class="separator:a69bac586bbdb9e0469363e104436c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfa27f568258559426edc60e30fdd38b" id="r_abfa27f568258559426edc60e30fdd38b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa27f568258559426edc60e30fdd38b">nGenerators_</a></td></tr>
<tr class="memdesc:abfa27f568258559426edc60e30fdd38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of generators.  <br /></td></tr>
<tr class="separator:abfa27f568258559426edc60e30fdd38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41879d79e8ecd93350c12b420afb0347" id="r_a41879d79e8ecd93350c12b420afb0347"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41879d79e8ecd93350c12b420afb0347">relations_</a></td></tr>
<tr class="memdesc:a41879d79e8ecd93350c12b420afb0347"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relations between the generators.  <br /></td></tr>
<tr class="separator:a41879d79e8ecd93350c12b420afb0347"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a finite presentation of a group. </p>
<p>A presentation consists of a number of generators and a set of relations between these generators that together define the group.</p>
<p>If there are <em>g</em> generators, they will be numbered 0, 1, ..., <em>g</em>-1.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo</a></b></dt><dd>Let's make intelligent simplify a tad more intelligent, and the GUI call a bit more safe. Perhaps parallelize the GUI call, and give users parameters to ensure it won't crash the computer. Also look at the FPGroup package. We should also have a simple way of creating <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> objects directly from text strings. We would like to have something like <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>( numGens, "abAAB", "bccd" ) etc., with arbitrary numbers of relators. Maybe std::tuple. Or "variadic templates"?</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a35ffeca6d3c8d43baafeeba6fc0d303b" name="a35ffeca6d3c8d43baafeeba6fc0d303b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ffeca6d3c8d43baafeeba6fc0d303b">&#9670;&#160;</a></span>GroupPresentation() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new presentation with no generators and no relations. </p>

</div>
</div>
<a id="af6a1fa153860fe1078a1b57b4da85c10" name="af6a1fa153860fe1078a1b57b4da85c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a1fa153860fe1078a1b57b4da85c10">&#9670;&#160;</a></span>GroupPresentation() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group presentation to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0b706281a8eaef8529497a62dc59921" name="ab0b706281a8eaef8529497a62dc59921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b706281a8eaef8529497a62dc59921">&#9670;&#160;</a></span>GroupPresentation() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group presentation to this new group presentation. </p>
<p>This is a fast (constant time) operation.</p>
<p>The group presentation that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group presentation to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a509d69fa435502f36f53a735292b8c22" name="a509d69fa435502f36f53a735292b8c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509d69fa435502f36f53a735292b8c22">&#9670;&#160;</a></span>GroupPresentation() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>nGenerators</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the free group on the given number of generators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGenerators</td><td>the number of generators. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0e5de7fb4b495c779c61c8580f2723a" name="af0e5de7fb4b495c779c61c8580f2723a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e5de7fb4b495c779c61c8580f2723a">&#9670;&#160;</a></span>GroupPresentation() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>nGens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that allows you to directly pass an arbitrary number of relators in string format. </p>
<p>The first argument <em>nGens</em> is the number of generators one wants the group to have. The second argument <em>rels</em> is a vector of strings, where each string gives a single relator. See the GroupExpression::GroupExpression(const std::string&amp;) constructor notes for information on what format these strings can take.</p>
<p>If you wish to create a group presentation from a hard-coded list of relations, you can use this constructor with an initialiser list, via syntax of the form <code><a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>(nGens, { "rel1", "rel2", ... })</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>One or more of the given strings could not be interpreted as a group expression, and/or contains an out-of-range generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGens</td><td>the number of generators. </td></tr>
    <tr><td class="paramname">rels</td><td>a vector of relations each given in string form, as outlined above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29c90bfce0f3442eebd7bfb3108f9531" name="a29c90bfce0f3442eebd7bfb3108f9531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c90bfce0f3442eebd7bfb3108f9531">&#9670;&#160;</a></span>abelianisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::GroupPresentation::abelianisation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<dl class="section return"><dt>Returns</dt><dd>the abelianisation of this group. </dd></dl>

</div>
</div>
<a id="a1ff54d96e2b5fba0f41edc265e000318" name="a1ff54d96e2b5fba0f41edc265e000318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff54d96e2b5fba0f41edc265e000318">&#9670;&#160;</a></span>abelianRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::abelianRank </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank of the abelianisation of this group. </p>
<p>This is the number of <em>Z</em> summands in the abelianisation (i.e., ignoring any torsion summands).</p>
<p>This is much less informative than computing the full abelianisation, but in some cases it might be significantly faster (since it involves just a matrix rank computation as opposed to a Smith normal form).</p>
<p>The result of this routine should be the same as the output of <code><a class="el" href="#a29c90bfce0f3442eebd7bfb3108f9531" title="Computes the abelianisation of this group.">abelianisation()</a>.rank()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the abelianisation of this group. </dd></dl>

</div>
</div>
<a id="aefc7827368f5d5c46b125c526720eb7b" name="aefc7827368f5d5c46b125c526720eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc7827368f5d5c46b125c526720eb7b">&#9670;&#160;</a></span>addGenerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::addGenerator </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>numToAdd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one or more generators to the group presentation. </p>
<p>If the new presentation has <em>g</em> generators, the new generators will be numbered <em>g</em>-1, <em>g</em>-2 and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numToAdd</td><td>the number of generators to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of generators in the new presentation. </dd></dl>

</div>
</div>
<a id="a79c0d0774772c294693ba8aab15aaf44" name="a79c0d0774772c294693ba8aab15aaf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c0d0774772c294693ba8aab15aaf44">&#9670;&#160;</a></span>addRelation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::addRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a></td>          <td class="paramname"><span class="paramname"><em>rel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given relation to the group presentation. </p>
<p>The relation must be of the form <code>expression = 1</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not check whether or not your relation is a word only in the generators of this group. In other words, it does not stop you from using generators beyond the <a class="el" href="#a610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a> bound.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>the expression that the relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this parameter should be the expression <code>g1^2 g2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c930c1a8cdb5e53c2a01747dca8c1e5" name="a8c930c1a8cdb5e53c2a01747dca8c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c930c1a8cdb5e53c2a01747dca8c1e5">&#9670;&#160;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::compact </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a compact one-line representation of this group presentation, including details of all generators and relations. </p>
<p>The output will be of the form <code>&lt; generators | relators &gt;</code>. The full relations will be included, and the entire output will be written on a single line. There will be no final newline.</p>
<p>Currently <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> and <a class="el" href="#a8c930c1a8cdb5e53c2a01747dca8c1e5" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a> are identical functions, though the output from <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> may change in future versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a compact representation of this group presentation. </dd></dl>

</div>
</div>
<a id="a610ea6821977d1a2f6709627316e7649" name="a610ea6821977d1a2f6709627316e7649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610ea6821977d1a2f6709627316e7649">&#9670;&#160;</a></span>countGenerators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::countGenerators </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generators in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators. </dd></dl>

</div>
</div>
<a id="a2ffa647790e42c8d984168db32197d22" name="a2ffa647790e42c8d984168db32197d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffa647790e42c8d984168db32197d22">&#9670;&#160;</a></span>countRelations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupPresentation::countRelations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of relations in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of relations. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab76ec8d931ca133a2c145ffbc0ef7955" name="ab76ec8d931ca133a2c145ffbc0ef7955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76ec8d931ca133a2c145ffbc0ef7955">&#9670;&#160;</a></span>enumerateCovers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index, typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupPresentation::enumerateCovers </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all transitive representations of this group into the symmetric group <em>S(k)</em>. </p>
<p>Each representation is produced exactly once up to conjugacy.</p>
<p>Each such representation corresponds to an index <em>k</em> subgroup, and the multiset of the abelianisations of all these subgroups is a group invariant that (for small enough <em>k</em>) can be computed in reasonable time.</p>
<p>If this is the fundamental group of a manifold, then each such representation also corresponds to a connected <em>k</em>-sheeted cover.</p>
<p>For each representation that is produced, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a group presentation. This will be the index <em>k</em> subgroup corresponding to the representation. This argument will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
<li>It is completely safe for <em>action</em> to (if you wish) make changes to the original presentation (i.e., the group presentation upon which <a class="el" href="#ab76ec8d931ca133a2c145ffbc0ef7955" title="Enumerates all transitive representations of this group into the symmetric group S(k).">enumerateCovers()</a> is being called). This will not interfere with the enumeration or change the results in any way.</li>
</ul>
<p>This routine produces a constant stream of output (i.e., it calls <em>action</em> as soon as each representation is found).</p>
<dl class="section warning"><dt>Warning</dt><dd>The running time is <code>(k!)^g</code>, where <em>k</em> is the subgroup index described above, and <em>g</em> is the number of generators of this group presentation. In particular, the running time grows <em>extremely</em> quickly with <em>k</em>. Moreover, for larger indices this routine may precompute some tables that will never be released (but which only need to be computed the first time that index is used); for index 10 these tables will consume roughly 30MB, and for index 11 they will consume around 320MB.</dd>
<dd>
This routine does <em>not</em> simplify the group presentation before it runs. You should make sure that you have simplified the presentation, either using Regina or some other tool, before running this routine, since (as noted above) the running time is exponential in the number of generators.</dd>
<dd>
Likewise, this routine does not simplify the subgroup presentations before passing them to <em>action</em>. These presentations can be quite large, and (for example) if all you care about is their abelianisations then you are better off using the <em>abelian</em> group simplification / computation instead (which is much faster).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Arrays on this system can be large enough to store <code>2⋅(n-2)!</code> objects. This is a technical condition on the bit-size of <code>size_t</code> that will be explicitly checked (with an exception thrown if it fails). On a 64-bit system this condition will be true for all supported <em>n</em>, but on a 32-bit system or smaller it will mean that <a class="el" href="#ab76ec8d931ca133a2c145ffbc0ef7955" title="Enumerates all transitive representations of this group into the symmetric group S(k).">enumerateCovers()</a> cannot be used for larger values of <em>n</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>A signed integer of the same bit-size as <code>size_t</code> cannot hold <code>2⋅(n-2)!</code>. See the precondition above for further discussion on this constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>There are two versions of this function available in Python. The first form is <code>enumerateCovers(index, action)</code>, which mirrors the C++ function: it takes <em>action</em> which may be a pure Python function, it returns the number of representations found, but it does <em>not</em> take an addition argument list (<em>args</em>). The second form is <code>enumerateCovers(index)</code>, which returns a Python list containing all of the corresponding subgroups, each given as a <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>. In both forms, the template parameter <em>index</em> becomes the first argument to the Python function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>the number <em>k</em> in the description above; in other words, the index of the resulting subgroups. Currently this must be between 2 and 11 inclusive; this range is limited because some of the cached precomputations can consume a <em>lot</em> of space for larger indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each representation that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial subgroup presentation argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of representations found. </dd></dl>

</div>
</div>
<a id="a3aebb7847f17b0c9cd05b9591e909e3a" name="a3aebb7847f17b0c9cd05b9591e909e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aebb7847f17b0c9cd05b9591e909e3a">&#9670;&#160;</a></span>gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::gap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>groupVariable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;g&quot;</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sequence of GAP commands that create this group. </p>
<p>GAP is a widely-used computational algebra system, and can be downloaded from <a href="http://gap-system.org/">http://gap-system.org/</a> .</p>
<p>Other than the variable for the group itself, the commands returned will not use or modify any other GAP variables with the current GAP scope.</p>
<p>The string that is returned will be presented as a single (possibly very long) GAP function call, and will not contain any newlines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupVariable</td><td>the name of the GAP variable to which this group will be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sequence of commands to create this group in GAP. </dd></dl>

</div>
</div>
<a id="aa4ea2c90c93f861333f497612e7795ab" name="aa4ea2c90c93f861333f497612e7795ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ea2c90c93f861333f497612e7795ab">&#9670;&#160;</a></span>homologicalAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt; regina::GroupPresentation::homologicalAlignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible). </p>
<p>Consider this a <em>homological-alignment</em> of the presentation.</p>
<p>If the abelianisation of this group has rank <em>N</em> and <em>M</em> invariant factors <code>d0 | d2 | ... | d(M-1)</code>, this routine applies Nielsen moves to the presentation to ensure that under the <a class="el" href="#a39d35e6b669bf2fd3f301b3df74af506" title="Computes the abelianisation of this group.">markedAbelianisation()</a> routine, generators 0 through <em>M-1</em> are mapped to generators of the relevant <code>Z_di</code> group. Similarly, generators <em>M</em> through <em>M</em>+<em>N</em>-1 are mapped to ±1 in the appropriate factor. All further generators will be mapped to zero.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section note"><dt>Note</dt><dd>If you all care about is whether the presentation changed, you can simply cast the return value to a <code>bool</code>. This will then mirror the behaviour of <a class="el" href="#aa4ea2c90c93f861333f497612e7795ab" title="Rewrites the presentation so that generators of the group map to generators of the abelianisation,...">homologicalAlignment()</a> from Regina 6.0 and earlier, when the return type was simply <code>bool</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism describing the reduction map from the original presentation to the new presentation, or no value if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="a23f4798b7eca1cb22d8b5c3414d5f256" name="a23f4798b7eca1cb22d8b5c3414d5f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f4798b7eca1cb22d8b5c3414d5f256">&#9670;&#160;</a></span>identifyAbelian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::identifyAbelian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to determine if the group is abelian. </p>
<p>A return value of <code>true</code> indicates that this routine successfully certified that the group is abelian. A return value of <code>false</code> indicates an inconclusive result: either the group is non-abelian, or the group is abelian but this routine could not prove so.</p>
<p>If the group is abelian, then markedAbelianization() is the easiest way to see precisely which abelian group it is, and how the generators sit in that group.</p>
<p>You will have better results from this algorithm if the presentation has been simplified, since this algorithm uses small cancellation theory in an attempt to reduce the commutators of all pairs of generators.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have not adequately simplified this presentation this routine will most likely return <code>false</code>. Consider running intelligentSimplify, possibly in concert with <a class="el" href="#aaa7653e9f59d3f194e4b560d7f84f6e6" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, in order to discover adequately many commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the group is shown to be abelian, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="aa57f9afdee9e1c46fa06e802a2c8e652" name="aa57f9afdee9e1c46fa06e802a2c8e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57f9afdee9e1c46fa06e802a2c8e652">&#9670;&#160;</a></span>identifySimplyIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::identifySimplyIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>. </p>
<p>A <em>simple isomorphism</em> is an isomorphism where each generator <em>g<sub>i</sub></em> of this presentation is sent to some generator <em>g<sub>j</sub></em><sup>±1</sup> of the other presentation. Moreover, at present this routine only looks for maps where both presentations have the same number of generators, and where distinct generators <em>g<sub>i</sub></em> of this presentation correspond to distinct generators <em>g<sub>j</sub></em> of the other presentation (possibly with inversion, as noted above).</p>
<p>If this routine returns <code>true</code>, it means that the two presentations are indeed simply isomorphic.</p>
<p>If this routine returns <code>false</code>, it could mean one of many things:</p>
<ul>
<li>The groups are not isomorphic;</li>
<li>The groups are isomorphic, but not simply isomorphic;</li>
<li>The groups are simply isomorphic but this routine could not prove it, due to difficulties with the word problem.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this routine could certify that the two group presentations are simply isomorphic, or <code>false</code> if it could not. </dd></dl>

</div>
</div>
<a id="a69bd6a8f830430afdede743fd401bc53" name="a69bd6a8f830430afdede743fd401bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bd6a8f830430afdede743fd401bc53">&#9670;&#160;</a></span>incidence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; bool &gt; regina::GroupPresentation::incidence </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix indicating which generators are used by which relations. </p>
<p>The rows of the matrix correspond to the relations 0,1,..., and the columns correspond to the generators 0,1,.... The matrix entry in row <em>r</em>, column <em>g</em> will be <code>true</code> if and only if relation <em>r</em> uses generator <em>g</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The numbers of generators and relations are both non-zero.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the incidence matrix between relators and generators. </dd></dl>

</div>
</div>
<a id="aa6828f4f67b183f926cabf6dd6c71937" name="aa6828f4f67b183f926cabf6dd6c71937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6828f4f67b183f926cabf6dd6c71937">&#9670;&#160;</a></span>intelligentNielsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt; regina::GroupPresentation::intelligentNielsen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for Nielsen moves that will simplify the presentation. </p>
<p>Performs one of the most-effective moves, if it can find any.</p>
<p>If this routine does return a homomorphism (because some move was performed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<p>This routine is guaranteed to be deterministic: within the same version of Regina, simplifying identical group presentations will give identical results. These results could, however, change between different versions of Regina.</p>
<dl class="section note"><dt>Note</dt><dd>If you all care about is whether the presentation changed, you can simply cast the return value to a <code>bool</code>. This will then mirror the behaviour of <a class="el" href="#aa6828f4f67b183f926cabf6dd6c71937" title="Looks for Nielsen moves that will simplify the presentation.">intelligentNielsen()</a> from Regina 6.0 and earlier, when the return type was simply <code>bool</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism describing the map from the original presentation to the new presentation, or no value if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="aa7811777ca9d3e19fe5a3fddeca753ad" name="aa7811777ca9d3e19fe5a3fddeca753ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7811777ca9d3e19fe5a3fddeca753ad">&#9670;&#160;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt; regina::GroupPresentation::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation as intelligently as possible without further input. </p>
<p>The current simplification method uses a combination of small cancellation theory and Nielsen moves.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<p>This routine is guaranteed to be deterministic: within the same version of Regina, simplifying identical group presentations will give identical results. These results could, however, change between different versions of Regina.</p>
<dl class="section note"><dt>Note</dt><dd>If you all care about is whether the presentation changed, you can simply cast the return value to a <code>bool</code>. This will then mirror the behaviour of <a class="el" href="#aa7811777ca9d3e19fe5a3fddeca753ad" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplify()</a> from Regina 6.0 and earlier, when the return type was simply <code>bool</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism describing the reduction map from the original presentation to the new presentation, or no value if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="a46e579e06a36b35db8e8dce18ded41a5" name="a46e579e06a36b35db8e8dce18ded41a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e579e06a36b35db8e8dce18ded41a5">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether all of the relations for the group are indeed words in the generators. </p>
<p>This routine returns <code>false</code> if at least one relator uses an out-of-bound generator, and <code>true</code> otherwise.</p>
<p>This routine is intended only for sanity checking: you should never have an invalid group presentation in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all of the relations are words in the generators. </dd></dl>

</div>
</div>
<a id="a39d35e6b669bf2fd3f301b3df74af506" name="a39d35e6b669bf2fd3f301b3df74af506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d35e6b669bf2fd3f301b3df74af506">&#9670;&#160;</a></span>markedAbelianisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> regina::GroupPresentation::markedAbelianisation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<p>The coordinates in the chain complex correspond to the generators and relators for this group.</p>
<dl class="section return"><dt>Returns</dt><dd>the abelianisation of this group. </dd></dl>

</div>
</div>
<a id="ac87e91e72bd03e053343c769fb6ef307" name="ac87e91e72bd03e053343c769fb6ef307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87e91e72bd03e053343c769fb6ef307">&#9670;&#160;</a></span>nielsenCombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenCombine </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>rightMult</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation. </p>
<p>It it is the third type of Nielsen move one can apply to a presentation.</p>
<p>This means that, if the new generator <code>Gi</code> is the old <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code>, then we can construct the new presentation from the old by replacing occurrences of <code>Gi</code> by <code>(Gi)(gj)^(-k)</code> or <code>(gj)^(-k)(Gi)</code> respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="#a610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to replace. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the generator to combine with <code>gi</code>. </td></tr>
    <tr><td class="paramname">k</td><td>indicates the power to which we raise <code>gj</code> when performing the replacement; this may be positive or negative (or zero, but this will have no effect). </td></tr>
    <tr><td class="paramname">rightMult</td><td><code>true</code> if we should replace <code>gi</code> by <code>(gi)(gj)^k</code>, or <code>false</code> if we should replace <code>gi</code> by <code>(gj)^k(gi)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="ac6af4e4996b9c37bfe2bece59ccb6483" name="ac6af4e4996b9c37bfe2bece59ccb6483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6af4e4996b9c37bfe2bece59ccb6483">&#9670;&#160;</a></span>nielsenInvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenInvert </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation. </p>
<p>This is the second generator type of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> is strictly less than <a class="el" href="#a610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="af81c7a84245d4d123ca2b5d144c9cb21" name="af81c7a84245d4d123ca2b5d144c9cb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81c7a84245d4d123ca2b5d144c9cb21">&#9670;&#160;</a></span>nielsenTransposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenTransposition </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation. </p>
<p>It is one of the standard Nielsen moves, which is the first of three generator types of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="#a610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the first of the two generators to switch. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the second of the two generators to switch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="ad2ea030dc6f400f5a6063b493bdefad1" name="ad2ea030dc6f400f5a6063b493bdefad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ea030dc6f400f5a6063b493bdefad1">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given group presentation are not identical. </p>
<p>This routine does <em>not</em> test for isomorphism (which in general is an undecidable problem). Instead it tests whether this and the given presentation use exactly the same generators and exactly the same relations, presented in exactly the same order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given group presentation are not identical. </dd></dl>

</div>
</div>
<a id="aef72094af17afa4000626ba25d94c09e" name="aef72094af17afa4000626ba25d94c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef72094af17afa4000626ba25d94c09e">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::GroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group presentation to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group presentation. </dd></dl>

</div>
</div>
<a id="a56544303c799ecbb60ebc9a5aa246e89" name="a56544303c799ecbb60ebc9a5aa246e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56544303c799ecbb60ebc9a5aa246e89">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::GroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group presentation to this group presentation. </p>
<p>This is a fast (constant time) operation.</p>
<p>The group presentation that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group presentation to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group presentation. </dd></dl>

</div>
</div>
<a id="ab2384d7ab5726e119276ec6095eebb9d" name="ab2384d7ab5726e119276ec6095eebb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2384d7ab5726e119276ec6095eebb9d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given group presentation are identical. </p>
<p>This routine does <em>not</em> test for isomorphism (which in general is an undecidable problem). Instead it tests whether this and the given presentation use exactly the same generators and exactly the same relations, presented in exactly the same order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given group presentation are identical. </dd></dl>

</div>
</div>
<a id="a4eaffe47a96e9a314e584e521d24e812" name="a4eaffe47a96e9a314e584e521d24e812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaffe47a96e9a314e584e521d24e812">&#9670;&#160;</a></span>prettyRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt; regina::GroupPresentation::prettyRewriting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entirely cosmetic rewriting of the presentation, which is fast and superficial. </p>
<ol type="1">
<li>If there are any length 1 relators, those generators are deleted, and the remaining relators simplified.</li>
<li>It sorts the relators by number of generator indices that appear, followed by relator numbers (lexico) followed by relator length.</li>
<li>It inverts relators if the net sign of the generators is negative.</li>
<li>Given each generator, it looks for the smallest word where that generator appears with non-zero weight. If negative weight, it inverts that generator.</li>
<li>It cyclically permutes relators to start with smallest gen.</li>
</ol>
<p>If this routine does return a homomorphism (because the choice of generators was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<p>This routine is guaranteed to be deterministic: within the same version of Regina, simplifying identical group presentations will give identical results. These results could, however, change between different versions of Regina.</p>
<dl class="section note"><dt>Note</dt><dd>If you all care about is whether the presentation changed, you can simply cast the return value to a <code>bool</code>. This will then mirror the behaviour of <a class="el" href="#a4eaffe47a96e9a314e584e521d24e812" title="An entirely cosmetic rewriting of the presentation, which is fast and superficial.">prettyRewriting()</a> from Regina 6.0 and earlier, when the return type was simply <code>bool</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo</a></b></dt><dd>As a final step, make elementary simplifications to aid in seeing standard relators like commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism describing the map from the original presentation to the new presentation, or no value if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="aaa7653e9f59d3f194e4b560d7f84f6e6" name="aaa7653e9f59d3f194e4b560d7f84f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7653e9f59d3f194e4b560d7f84f6e6">&#9670;&#160;</a></span>proliferateRelators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::proliferateRelators </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators. </p>
<p>Given a presentation <code>&lt;g_i | r_i&gt;</code>, this routine appends consequences of the relators {r_i} to the presentation that are of the form ab, where both a and b are cyclic permutations of relators from the collection {r_i}.</p>
<p>Passing depth=1 means it will only form products of two relators. Depth=2 means products of three, etc. Depth=4 is typically the last depth before the exponential growth of the operation grows out of hand. It also conveniently trivializes all the complicated trivial group presentations that we've come across so far.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this routine with depth n before having called it at depth n-1 first. Depth=0 is invalid, and depth=1 should be your first call to this routine. This routine gobbles up an exponential amount of memory (exponential in your presentation size times n). So do be careful when using it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>controls the depth of the proliferation, as described above; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd5465442f764dcca7c9f83683144ff" name="a6dd5465442f764dcca7c9f83683144ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd5465442f764dcca7c9f83683144ff">&#9670;&#160;</a></span>recogniseGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::recogniseGroup </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>moreUtf8</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to recognise the group corresponding to this presentation. </p>
<p>This routine is much more likely to be successful if you have already called <a class="el" href="#aa7811777ca9d3e19fe5a3fddeca753ad" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplify()</a>.</p>
<p>Currently, the groups this routine recognises include: the trivial group, abelian groups, free groups, extensions over the integers, and free products of any group the algorithm can recognise (inductively).</p>
<p>The string returned from this routine may use some unicode characters, which will be encoding using UTF-8. If <em>moreUtf8</em> is passed as <code>false</code> then unicode will be used sparingly; if <em>moreUtf8</em> is <code>true</code> then unicode will be use more liberally, resulting in strings that look nicer but require more complex fonts to be available on the user's machine.</p>
<p>Examples of the format of the returned string are:</p>
<ul>
<li><code>0</code> for the trivial group;</li>
<li><code>Z_n</code> for cyclic groups with <em>n</em> &gt; 1;</li>
<li><code>Free(n)</code> for free groups with <em>n</em> &gt; 1 generators - see <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">AbelianGroup::str()</a> for how abelian groups are presented;</li>
<li><code>FreeProduct(G1, G2, ... , Gk)</code> for free products, where one replaces <em>G1</em> through <em>Gk</em> by text strings representing the free summands;</li>
<li><p class="startli"><code>Z~G w/ monodromy H</code> for extensions over Z, where <em>G</em> is a description of the kernel of the homomorphism to the integers, and <em>H</em> is a text string representing the monodromy - see <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">HomMarkedAbelianGroup.str()</a> for details on how these are presented.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd><em>Feature (long-term):</em> Make this recognition more effective.</dd></dl>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a simple string representation of the group if it is recognised, or an empty string if the group is not recognised. </dd></dl>

</div>
</div>
<a id="ae5b394968e63b1a679b318400537c926" name="ae5b394968e63b1a679b318400537c926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b394968e63b1a679b318400537c926">&#9670;&#160;</a></span>relation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp; regina::GroupPresentation::relation </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the relation at the given index in this group presentation. </p>
<p>The relation will be of the form <code>expresson = 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired relation; this must be between 0 and <a class="el" href="#a2ffa647790e42c8d984168db32197d22" title="Returns the number of relations in this group presentation.">countRelations()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expression that the requested relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this will be the expression <code>g1^2 g2</code>. </dd></dl>

</div>
</div>
<a id="aa21d22e83fc705f83a2299c73e052250" name="aa21d22e83fc705f83a2299c73e052250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21d22e83fc705f83a2299c73e052250">&#9670;&#160;</a></span>relations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp; regina::GroupPresentation::relations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of all relations in this group presentation. </p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list of copied <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> objects. In particular, modifying this list or the relations within it will not modify the group presentation from which they came.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The list itself is not returned by reference (instead this routine returns a new Python list). However, the relations within this list are still returned by reference.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of relations. </dd></dl>

</div>
</div>
<a id="a5c9ee67ee75ee1d9539d235a5cd8f101" name="a5c9ee67ee75ee1d9539d235a5cd8f101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ee67ee75ee1d9539d235a5cd8f101">&#9670;&#160;</a></span>relatorLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupPresentation::relatorLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sum of the word lengths of the relators. </p>
<p>Word lengths are computing using <a class="el" href="classregina_1_1GroupExpression.html#a4c683c8a7391ae8ad801b2c48e6ae3f6" title="Returns the length of the word, i.e.">GroupExpression::wordLength()</a>. Used as a coarse measure of the complexity of the presentation.</p>
<dl class="section return"><dt>Returns</dt><dd>the sum of word lengths. </dd></dl>

</div>
</div>
<a id="a69bac586bbdb9e0469363e104436c911" name="a69bac586bbdb9e0469363e104436c911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bac586bbdb9e0469363e104436c911">&#9670;&#160;</a></span>sage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FinitelyPresentedGroup regina::GroupPresentation::sage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A SageMath-only routine that returns a copy of this group presentation in a format native to SageMath. </p>
<dl class="section user"><dt>C++</dt><dd>Not present. </dd></dl>
<dl class="section user"><dt>Python</dt><dd>Only present when run within SageMath.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this group as a mathematical object native to SageMath. </dd></dl>

</div>
</div>
<a id="aeda91276bc32baadb7ed6c83c18e2db0" name="aeda91276bc32baadb7ed6c83c18e2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda91276bc32baadb7ed6c83c18e2db0">&#9670;&#160;</a></span>simplifyAndConjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::simplifyAndConjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses small cancellation theory to reduce the input word, modulo conjugation, using the current presentation of the group. </p>
<p>The input word will be modified directly.</p>
<p>By "modulo conjugation", we mean: if <em>w</em> represents the input word, then this routine might (as part of the reduction process) transform <em>w</em> into a different group element of the form <code>g w g^-1</code>.</p>
<p>In Regina 7.2 and earlier, this routine was called simplifyWord(). It was renamed to <a class="el" href="#aeda91276bc32baadb7ed6c83c18e2db0" title="Uses small cancellation theory to reduce the input word, modulo conjugation, using the current presen...">simplifyAndConjugate()</a> in Regina 7.3 to make it clear to the user that conjugation might take place. Note that, even in older versions of Regina, this routine could always potentially conjugate.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is only as good as the relator table for the group. You might want to consider running <a class="el" href="#aa7811777ca9d3e19fe5a3fddeca753ad" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplify()</a>, possibly in concert with <a class="el" href="#aaa7653e9f59d3f194e4b560d7f84f6e6" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, before using this routine for any significant tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word you would like to simplify (modulo conjugation). This must be a word in the generators of this group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the input word was modified. </dd></dl>

</div>
</div>
<a id="a8289666edbc70c23ae947f7697b514dc" name="a8289666edbc70c23ae947f7697b514dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8289666edbc70c23ae947f7697b514dc">&#9670;&#160;</a></span>smallCancellation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt; regina::GroupPresentation::smallCancellation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation using small cancellation theory. </p>
<p>The simplification method is based on the Dehn algorithm for hyperbolic groups, i.e. small cancellation theory. This means we look to see if part of one relator can be used to simplify others. If so, make the substitution and simplify. We continue until no more presentation-shortening substitutions are available. We follow that by killing any available generators using words where generators appear a single time.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<p>This routine is guaranteed to be deterministic: within the same version of Regina, simplifying identical group presentations will give identical results. These results could, however, change between different versions of Regina.</p>
<dl class="section note"><dt>Note</dt><dd>If you all care about is whether the presentation changed, you can simply cast the return value to a <code>bool</code>. This will then mirror the behaviour of <a class="el" href="#a8289666edbc70c23ae947f7697b514dc" title="Attempts to simplify the group presentation using small cancellation theory.">smallCancellation()</a> from Regina 6.0 and earlier, when the return type was simply <code>bool</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd><em>Optimise (long-term):</em> This routine could use some small tweaks - recognition of utility of some score==0 moves, such as commutators, for example.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism describing the reduction map from the original presentation to the new presentation, or no value if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a689a6264fd68190d464285549521f784" name="a689a6264fd68190d464285549521f784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a6264fd68190d464285549521f784">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98098092897b959de3d027eedabd4ebf" name="a98098092897b959de3d027eedabd4ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98098092897b959de3d027eedabd4ebf">&#9670;&#160;</a></span>tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::tex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a TeX representation of this group presentation. </p>
<p>The output will be of the form <code>&lt; generators | relators &gt;</code>. There will be no final newline.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this group presentation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a7c373720fc59d7973d53f53e3126a409" name="a7c373720fc59d7973d53f53e3126a409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c373720fc59d7973d53f53e3126a409">&#9670;&#160;</a></span>writeTeX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this group presentation to the given output stream. </p>
<p>See <a class="el" href="#a98098092897b959de3d027eedabd4ebf" title="Returns a TeX representation of this group presentation.">tex()</a> for details on how this is formed.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a98098092897b959de3d027eedabd4ebf" title="Returns a TeX representation of this group presentation.">tex()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9848a7d3303be02671e18c57d28afec" name="af9848a7d3303be02671e18c57d28afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9848a7d3303be02671e18c57d28afec">&#9670;&#160;</a></span>writeTextCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextCompact </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a compact one-line represesentation of this group to the given output stream. </p>
<p>See <a class="el" href="#a8c930c1a8cdb5e53c2a01747dca8c1e5" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a> for details on how this is formed.</p>
<p>Currently <a class="el" href="#ac64ef64c265916b3fdc7e0c513d2b458" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> and <a class="el" href="#af9848a7d3303be02671e18c57d28afec" title="Writes a compact one-line represesentation of this group to the given output stream.">writeTextCompact()</a> are identical functions, though the output from <a class="el" href="#ac64ef64c265916b3fdc7e0c513d2b458" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> may change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a8c930c1a8cdb5e53c2a01747dca8c1e5" title="Returns a compact one-line representation of this group presentation, including details of all genera...">compact()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37fa6a40ae529c19a16fdba8f66d6768" name="a37fa6a40ae529c19a16fdba8f66d6768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fa6a40ae529c19a16fdba8f66d6768">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64ef64c265916b3fdc7e0c513d2b458" name="ac64ef64c265916b3fdc7e0c513d2b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64ef64c265916b3fdc7e0c513d2b458">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>Currently <a class="el" href="#ac64ef64c265916b3fdc7e0c513d2b458" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> and <a class="el" href="#af9848a7d3303be02671e18c57d28afec" title="Writes a compact one-line represesentation of this group to the given output stream.">writeTextCompact()</a> are identical functions, though the output from <a class="el" href="#ac64ef64c265916b3fdc7e0c513d2b458" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> may change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a688500a505588004520eff2807545" name="aa0a688500a505588004520eff2807545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a688500a505588004520eff2807545">&#9670;&#160;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this group presentation. </p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abfa27f568258559426edc60e30fdd38b" name="abfa27f568258559426edc60e30fdd38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa27f568258559426edc60e30fdd38b">&#9670;&#160;</a></span>nGenerators_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::nGenerators_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of generators. </p>

</div>
</div>
<a id="a41879d79e8ecd93350c12b420afb0347" name="a41879d79e8ecd93350c12b420afb0347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41879d79e8ecd93350c12b420afb0347">&#9670;&#160;</a></span>relations_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&gt; regina::GroupPresentation::relations_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The relations between the generators. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="grouppresentation_8h.html">grouppresentation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
