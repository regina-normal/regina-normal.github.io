<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::GroupExpression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1GroupExpression-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::GroupExpression Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents an expression involving generators from a group presentation or a free group.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;algebra/grouppresentation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GroupExpression:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GroupExpression.png" usemap="#regina::GroupExpression_map" alt=""/>
  <map id="regina::GroupExpression_map" name="regina::GroupExpression_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; GroupExpression, true &gt;" shape="rect" coords="0,56,291,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GroupExpression, supportsUtf8 &gt;" shape="rect" coords="0,0,291,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0406bb34696a5358cc45d9879ffb43e4" id="r_a0406bb34696a5358cc45d9879ffb43e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0406bb34696a5358cc45d9879ffb43e4">GroupExpression</a> ()=default</td></tr>
<tr class="memdesc:a0406bb34696a5358cc45d9879ffb43e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The terms that make up this expression.  <br /></td></tr>
<tr class="separator:a0406bb34696a5358cc45d9879ffb43e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fbb7d519743a0d40eba5742f08ff43" id="r_a52fbb7d519743a0d40eba5742f08ff43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52fbb7d519743a0d40eba5742f08ff43">GroupExpression</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="#a8904a6bde73d6a1ea0427a9262ec7951">term</a>)</td></tr>
<tr class="memdesc:a52fbb7d519743a0d40eba5742f08ff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression containing a single term.  <br /></td></tr>
<tr class="separator:a52fbb7d519743a0d40eba5742f08ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984a3a3dde2a66732501ccc8507c3e91" id="r_a984a3a3dde2a66732501ccc8507c3e91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984a3a3dde2a66732501ccc8507c3e91">GroupExpression</a> (unsigned long <a class="el" href="#aa5851d978d13f5844ccbf2a6bc7de001">generator</a>, long <a class="el" href="#aff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>)</td></tr>
<tr class="memdesc:a984a3a3dde2a66732501ccc8507c3e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression containing a single term.  <br /></td></tr>
<tr class="separator:a984a3a3dde2a66732501ccc8507c3e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa40d8d9b5076e6736e236d27a08aab" id="r_a7fa40d8d9b5076e6736e236d27a08aab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa40d8d9b5076e6736e236d27a08aab">GroupExpression</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;)=default</td></tr>
<tr class="memdesc:a7fa40d8d9b5076e6736e236d27a08aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression that is a clone of the given expression.  <br /></td></tr>
<tr class="separator:a7fa40d8d9b5076e6736e236d27a08aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9541a15914ded9344a109a768106555" id="r_ab9541a15914ded9344a109a768106555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9541a15914ded9344a109a768106555">GroupExpression</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ab9541a15914ded9344a109a768106555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given expression to this new expression.  <br /></td></tr>
<tr class="separator:ab9541a15914ded9344a109a768106555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7806e3811ae130f3ab2e8d25b5af4802" id="r_a7806e3811ae130f3ab2e8d25b5af4802"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7806e3811ae130f3ab2e8d25b5af4802">GroupExpression</a> (const char *input, unsigned long nGens=0)</td></tr>
<tr class="memdesc:a7806e3811ae130f3ab2e8d25b5af4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to interpret the given input string as a word in a group.  <br /></td></tr>
<tr class="separator:a7806e3811ae130f3ab2e8d25b5af4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818c93db3c72aa97dffb01cfd6d33171" id="r_a818c93db3c72aa97dffb01cfd6d33171"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a818c93db3c72aa97dffb01cfd6d33171">GroupExpression</a> (const std::string &amp;input, unsigned long nGens=0)</td></tr>
<tr class="memdesc:a818c93db3c72aa97dffb01cfd6d33171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to interpret the given input string as a word in a group.  <br /></td></tr>
<tr class="separator:a818c93db3c72aa97dffb01cfd6d33171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496610829b9f880dfecb6353e0b80895" id="r_a496610829b9f880dfecb6353e0b80895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496610829b9f880dfecb6353e0b80895">operator=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;)=default</td></tr>
<tr class="memdesc:a496610829b9f880dfecb6353e0b80895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this expression a clone of the given expression.  <br /></td></tr>
<tr class="separator:a496610829b9f880dfecb6353e0b80895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8b6a1fb191f76eac06ffa969dea897" id="r_a3b8b6a1fb191f76eac06ffa969dea897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8b6a1fb191f76eac06ffa969dea897">operator=</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a3b8b6a1fb191f76eac06ffa969dea897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given expression to this expression.  <br /></td></tr>
<tr class="separator:a3b8b6a1fb191f76eac06ffa969dea897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff651ce01ffe895628cfecfaaed10a2" id="r_acff651ce01ffe895628cfecfaaed10a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff651ce01ffe895628cfecfaaed10a2">swap</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:acff651ce01ffe895628cfecfaaed10a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given expression.  <br /></td></tr>
<tr class="separator:acff651ce01ffe895628cfecfaaed10a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2ca294cd89c65857d242215a72a650" id="r_aff2ca294cd89c65857d242215a72a650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2ca294cd89c65857d242215a72a650">operator==</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const</td></tr>
<tr class="memdesc:aff2ca294cd89c65857d242215a72a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <br /></td></tr>
<tr class="separator:aff2ca294cd89c65857d242215a72a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402158ae2680818b04bb815e3ed7eb9" id="r_a0402158ae2680818b04bb815e3ed7eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0402158ae2680818b04bb815e3ed7eb9">operator!=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const</td></tr>
<tr class="memdesc:a0402158ae2680818b04bb815e3ed7eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <br /></td></tr>
<tr class="separator:a0402158ae2680818b04bb815e3ed7eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7107330382d76de56540ef1e5ec986e" id="r_ab7107330382d76de56540ef1e5ec986e"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7107330382d76de56540ef1e5ec986e">terms</a> ()</td></tr>
<tr class="memdesc:ab7107330382d76de56540ef1e5ec986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of terms in this expression.  <br /></td></tr>
<tr class="separator:ab7107330382d76de56540ef1e5ec986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961eb0fc634f28142e23abe582fe977a" id="r_a961eb0fc634f28142e23abe582fe977a"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a961eb0fc634f28142e23abe582fe977a">terms</a> () const</td></tr>
<tr class="memdesc:a961eb0fc634f28142e23abe582fe977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the list of terms in this expression.  <br /></td></tr>
<tr class="separator:a961eb0fc634f28142e23abe582fe977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeebe99241025551efccdbc0640417f" id="r_a2aeebe99241025551efccdbc0640417f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aeebe99241025551efccdbc0640417f">countTerms</a> () const</td></tr>
<tr class="memdesc:a2aeebe99241025551efccdbc0640417f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of terms in this expression.  <br /></td></tr>
<tr class="separator:a2aeebe99241025551efccdbc0640417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c683c8a7391ae8ad801b2c48e6ae3f6" id="r_a4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c683c8a7391ae8ad801b2c48e6ae3f6">wordLength</a> () const</td></tr>
<tr class="memdesc:a4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the word, i.e.  <br /></td></tr>
<tr class="separator:a4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab76ba3c8c7120f4b99787bd78068d39" id="r_aab76ba3c8c7120f4b99787bd78068d39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab76ba3c8c7120f4b99787bd78068d39">isTrivial</a> () const</td></tr>
<tr class="memdesc:aab76ba3c8c7120f4b99787bd78068d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this is the trivial (unit) word.  <br /></td></tr>
<tr class="separator:aab76ba3c8c7120f4b99787bd78068d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e343e87b3c1b157a97292651e1d25" id="r_aad4e343e87b3c1b157a97292651e1d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4e343e87b3c1b157a97292651e1d25">erase</a> ()</td></tr>
<tr class="memdesc:aad4e343e87b3c1b157a97292651e1d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all terms from this this word.  <br /></td></tr>
<tr class="separator:aad4e343e87b3c1b157a97292651e1d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904a6bde73d6a1ea0427a9262ec7951" id="r_a8904a6bde73d6a1ea0427a9262ec7951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8904a6bde73d6a1ea0427a9262ec7951">term</a> (size_t index)</td></tr>
<tr class="memdesc:a8904a6bde73d6a1ea0427a9262ec7951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the term at the given index in this expression.  <br /></td></tr>
<tr class="separator:a8904a6bde73d6a1ea0427a9262ec7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b094648fc06a56a42041221e491849" id="r_a39b094648fc06a56a42041221e491849"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b094648fc06a56a42041221e491849">term</a> (size_t index) const</td></tr>
<tr class="memdesc:a39b094648fc06a56a42041221e491849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the term at the given index in this expression.  <br /></td></tr>
<tr class="separator:a39b094648fc06a56a42041221e491849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5851d978d13f5844ccbf2a6bc7de001" id="r_aa5851d978d13f5844ccbf2a6bc7de001"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5851d978d13f5844ccbf2a6bc7de001">generator</a> (size_t index) const</td></tr>
<tr class="memdesc:aa5851d978d13f5844ccbf2a6bc7de001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generator corresonding to the term at the given index in this expression.  <br /></td></tr>
<tr class="separator:aa5851d978d13f5844ccbf2a6bc7de001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0207f2d1602d0e1a7752b9bb2b0183" id="r_aff0207f2d1602d0e1a7752b9bb2b0183"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0207f2d1602d0e1a7752b9bb2b0183">exponent</a> (size_t index) const</td></tr>
<tr class="memdesc:aff0207f2d1602d0e1a7752b9bb2b0183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exponent corresonding to the term at the given index in this expression.  <br /></td></tr>
<tr class="separator:aff0207f2d1602d0e1a7752b9bb2b0183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a2753d395ab5cb3089cb09ec637d86" id="r_a29a2753d395ab5cb3089cb09ec637d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29a2753d395ab5cb3089cb09ec637d86">addTermFirst</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="#a8904a6bde73d6a1ea0427a9262ec7951">term</a>)</td></tr>
<tr class="memdesc:a29a2753d395ab5cb3089cb09ec637d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <br /></td></tr>
<tr class="separator:a29a2753d395ab5cb3089cb09ec637d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe441455a1744f9b5a02cc0fa20bfcf" id="r_adfe441455a1744f9b5a02cc0fa20bfcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfe441455a1744f9b5a02cc0fa20bfcf">addTermFirst</a> (unsigned long <a class="el" href="#aa5851d978d13f5844ccbf2a6bc7de001">generator</a>, long <a class="el" href="#aff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>)</td></tr>
<tr class="memdesc:adfe441455a1744f9b5a02cc0fa20bfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <br /></td></tr>
<tr class="separator:adfe441455a1744f9b5a02cc0fa20bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372453b28e949d4ddacd682fb655cbda" id="r_a372453b28e949d4ddacd682fb655cbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372453b28e949d4ddacd682fb655cbda">addTermLast</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="#a8904a6bde73d6a1ea0427a9262ec7951">term</a>)</td></tr>
<tr class="memdesc:a372453b28e949d4ddacd682fb655cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <br /></td></tr>
<tr class="separator:a372453b28e949d4ddacd682fb655cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539c39976a30b6836a750ffb57fd4d90" id="r_a539c39976a30b6836a750ffb57fd4d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a539c39976a30b6836a750ffb57fd4d90">addTermLast</a> (unsigned long <a class="el" href="#aa5851d978d13f5844ccbf2a6bc7de001">generator</a>, long <a class="el" href="#aff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>)</td></tr>
<tr class="memdesc:a539c39976a30b6836a750ffb57fd4d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <br /></td></tr>
<tr class="separator:a539c39976a30b6836a750ffb57fd4d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0097a9bb9484c3620e49c2d34910b91c" id="r_a0097a9bb9484c3620e49c2d34910b91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0097a9bb9484c3620e49c2d34910b91c">addTermsFirst</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> word)</td></tr>
<tr class="memdesc:a0097a9bb9484c3620e49c2d34910b91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the left by the given word.  <br /></td></tr>
<tr class="separator:a0097a9bb9484c3620e49c2d34910b91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57767b0dbea5b60e03a8064acd5ec8a9" id="r_a57767b0dbea5b60e03a8064acd5ec8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57767b0dbea5b60e03a8064acd5ec8a9">addTermsLast</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> word)</td></tr>
<tr class="memdesc:a57767b0dbea5b60e03a8064acd5ec8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the right by the given word.  <br /></td></tr>
<tr class="separator:a57767b0dbea5b60e03a8064acd5ec8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688406ed1ec6e9f3dfd4f31a220729c4" id="r_a688406ed1ec6e9f3dfd4f31a220729c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a688406ed1ec6e9f3dfd4f31a220729c4">cycleRight</a> ()</td></tr>
<tr class="memdesc:a688406ed1ec6e9f3dfd4f31a220729c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the leftmost term around to the rightmost.  <br /></td></tr>
<tr class="separator:a688406ed1ec6e9f3dfd4f31a220729c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30471b33e30035e299ebfae316519d0c" id="r_a30471b33e30035e299ebfae316519d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30471b33e30035e299ebfae316519d0c">cycleLeft</a> ()</td></tr>
<tr class="memdesc:a30471b33e30035e299ebfae316519d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the rightmost term around to the leftmost.  <br /></td></tr>
<tr class="separator:a30471b33e30035e299ebfae316519d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec288bc576d3dcc7256e47ef3995cdf5" id="r_aec288bc576d3dcc7256e47ef3995cdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec288bc576d3dcc7256e47ef3995cdf5">inverse</a> () const</td></tr>
<tr class="memdesc:aec288bc576d3dcc7256e47ef3995cdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of this expression.  <br /></td></tr>
<tr class="separator:aec288bc576d3dcc7256e47ef3995cdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e65aaa150201d3df9fd6199d136d63e" id="r_a7e65aaa150201d3df9fd6199d136d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e65aaa150201d3df9fd6199d136d63e">invert</a> ()</td></tr>
<tr class="memdesc:a7e65aaa150201d3df9fd6199d136d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts this expression.  <br /></td></tr>
<tr class="separator:a7e65aaa150201d3df9fd6199d136d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015f07c961ebed05749020568d57e6a3" id="r_a015f07c961ebed05749020568d57e6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015f07c961ebed05749020568d57e6a3">power</a> (long <a class="el" href="#aff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>) const</td></tr>
<tr class="memdesc:a015f07c961ebed05749020568d57e6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this expression raised to the given power.  <br /></td></tr>
<tr class="separator:a015f07c961ebed05749020568d57e6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e1f2423da57b6bd93984762691bf2" id="r_ae77e1f2423da57b6bd93984762691bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae77e1f2423da57b6bd93984762691bf2">simplify</a> (bool cyclic=false)</td></tr>
<tr class="memdesc:ae77e1f2423da57b6bd93984762691bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies this expression.  <br /></td></tr>
<tr class="separator:ae77e1f2423da57b6bd93984762691bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc5f90b79dc0a50956c1737ac350c0b" id="r_a5dc5f90b79dc0a50956c1737ac350c0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dc5f90b79dc0a50956c1737ac350c0b">substitute</a> (unsigned long <a class="el" href="#aa5851d978d13f5844ccbf2a6bc7de001">generator</a>, const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;expansion, bool cyclic=false)</td></tr>
<tr class="memdesc:a5dc5f90b79dc0a50956c1737ac350c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every occurrence of the given generator with the given substitute expression.  <br /></td></tr>
<tr class="separator:a5dc5f90b79dc0a50956c1737ac350c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afd7397c082044b70f359aeddd136a2" id="r_a0afd7397c082044b70f359aeddd136a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afd7397c082044b70f359aeddd136a2">substitute</a> (const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;expansions, bool cyclic=false)</td></tr>
<tr class="memdesc:a0afd7397c082044b70f359aeddd136a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every generator in this expression with the corresponding substitute expression from the given map.  <br /></td></tr>
<tr class="separator:a0afd7397c082044b70f359aeddd136a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d02f0fa24e3d333ce3bcfb4e6acee1a" id="r_a1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::map&lt; unsigned long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d02f0fa24e3d333ce3bcfb4e6acee1a">relabellingsThisToOther</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;other, bool cyclic=false) const</td></tr>
<tr class="memdesc:a1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not one can relabel the generators in this word to obtain the given other word.  <br /></td></tr>
<tr class="separator:a1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b0fedf30a85fc54ede2e37c5deb088" id="r_aa8b0fedf30a85fc54ede2e37c5deb088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b0fedf30a85fc54ede2e37c5deb088">writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa8b0fedf30a85fc54ede2e37c5deb088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this expression.  <br /></td></tr>
<tr class="separator:aa8b0fedf30a85fc54ede2e37c5deb088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c33dbc7bdd6ec672da0b4b3964f2f" id="r_a391c33dbc7bdd6ec672da0b4b3964f2f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391c33dbc7bdd6ec672da0b4b3964f2f">tex</a> () const</td></tr>
<tr class="memdesc:a391c33dbc7bdd6ec672da0b4b3964f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a TeX representation of this expression.  <br /></td></tr>
<tr class="separator:a391c33dbc7bdd6ec672da0b4b3964f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5288d1ece14ec07413a046ac62245b1f" id="r_a5288d1ece14ec07413a046ac62245b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5288d1ece14ec07413a046ac62245b1f">writeTeX</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5288d1ece14ec07413a046ac62245b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this expression to the given output stream.  <br /></td></tr>
<tr class="separator:a5288d1ece14ec07413a046ac62245b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919a17d5d9a09661b9415a8d0251e714" id="r_a919a17d5d9a09661b9415a8d0251e714"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a919a17d5d9a09661b9415a8d0251e714">str</a> (bool alphaGen) const</td></tr>
<tr class="memdesc:a919a17d5d9a09661b9415a8d0251e714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this group expression, with a choice of either numbered generators or alphabetic generators.  <br /></td></tr>
<tr class="separator:a919a17d5d9a09661b9415a8d0251e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41623f4250f9cdb72f209b251656245" id="r_af41623f4250f9cdb72f209b251656245"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41623f4250f9cdb72f209b251656245">utf8</a> (bool alphaGen) const</td></tr>
<tr class="memdesc:af41623f4250f9cdb72f209b251656245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this group expression using unicode characters, with a choice of either numbered generators or alphabetic generators.  <br /></td></tr>
<tr class="separator:af41623f4250f9cdb72f209b251656245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0408f35a669a110a62b85d34487b4be" id="r_ac0408f35a669a110a62b85d34487b4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0408f35a669a110a62b85d34487b4be">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="#af41623f4250f9cdb72f209b251656245">utf8</a>=false, bool alphaGen=false) const</td></tr>
<tr class="memdesc:ac0408f35a669a110a62b85d34487b4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream, using either numbered generators or alphabetic generators.  <br /></td></tr>
<tr class="separator:ac0408f35a669a110a62b85d34487b4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an expression involving generators from a group presentation or a free group. </p>
<p>An expression is represented as word, i.e, a sequence of powers of generators all of which are multiplied in order. Each power of a generator corresponds to an individual <a class="el" href="structregina_1_1GroupExpressionTerm.html" title="Represents a power of a generator in a group presentation.">GroupExpressionTerm</a>.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> contains the three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<p>Note that generators are indexed starting from 0 (so, for example, <code>g3</code> represents the <em>fourth</em> generator in the group presentation, not the third).</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0406bb34696a5358cc45d9879ffb43e4" name="a0406bb34696a5358cc45d9879ffb43e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0406bb34696a5358cc45d9879ffb43e4">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The terms that make up this expression. </p>
<p>Creates a new expression with no terms. </p>

</div>
</div>
<a id="a52fbb7d519743a0d40eba5742f08ff43" name="a52fbb7d519743a0d40eba5742f08ff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fbb7d519743a0d40eba5742f08ff43">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression containing a single term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to use as the new expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a984a3a3dde2a66732501ccc8507c3e91" name="a984a3a3dde2a66732501ccc8507c3e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984a3a3dde2a66732501ccc8507c3e91">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression containing a single term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator to use in the term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised in the term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fa40d8d9b5076e6736e236d27a08aab" name="a7fa40d8d9b5076e6736e236d27a08aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa40d8d9b5076e6736e236d27a08aab">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression that is a clone of the given expression. </p>

</div>
</div>
<a id="ab9541a15914ded9344a109a768106555" name="ab9541a15914ded9344a109a768106555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9541a15914ded9344a109a768106555">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given expression to this new expression. </p>
<p>This is a fast (constant time) operation.</p>
<p>The expression that was passed will no longer be usable. </p>

</div>
</div>
<a id="a7806e3811ae130f3ab2e8d25b5af4802" name="a7806e3811ae130f3ab2e8d25b5af4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7806e3811ae130f3ab2e8d25b5af4802">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>nGens</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to interpret the given input string as a word in a group. </p>
<p>Regina can recognise strings in the following four basic forms:</p>
<ul>
<li><code>a^7b^-2</code></li>
<li><code>aaaaaaaBB</code></li>
<li><code>a^7B^2</code></li>
<li><code>g0^7g1^-2</code></li>
</ul>
<p>The string may contain whitespace, which will simply be ignored. The empty string will be treated as an expression with no terms.</p>
<p>Note that generators are numbered starting from 0. This means, for example, that <code>a</code>, <code>b</code> and <code>c</code> correspond to <code>g0</code>, <code>g1</code> and <code>g2</code> respectively.</p>
<p>If the optional argument <em>nGens</em> is passed and is positive, then this constructor will explicitly check that the given string only uses generators 0,...,(<em>nGens-1</em>).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string could not be interpreted as a group expression, or else <em>nGens</em> was positive and the given string contains an out-of-range generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input string that is to be interpreted. </td></tr>
    <tr><td class="paramname">nGens</td><td>the number of generators in the group presentation. If this is 0 (the default), then this argument will be ignored and this constructor will not check whether generators are within range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a818c93db3c72aa97dffb01cfd6d33171" name="a818c93db3c72aa97dffb01cfd6d33171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818c93db3c72aa97dffb01cfd6d33171">&#9670;&#160;</a></span>GroupExpression() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>nGens</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to interpret the given input string as a word in a group. </p>
<p>Regina can recognise strings in the following four basic forms:</p>
<ul>
<li><code>a^7b^-2</code></li>
<li><code>aaaaaaaBB</code></li>
<li><code>a^7B^2</code></li>
<li><code>g0^7g1^-2</code></li>
</ul>
<p>The string may contain whitespace, which will simply be ignored. The empty string will be treated as an expression with no terms.</p>
<p>Note that generators are numbered starting from 0. This means, for example, that <code>a</code>, <code>b</code> and <code>c</code> correspond to <code>g0</code>, <code>g1</code> and <code>g2</code> respectively.</p>
<p>If the optional argument <em>nGens</em> is passed and is positive, then this constructor will explicitly check that the given string only uses generators 0,...,(<em>nGens-1</em>).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string could not be interpreted as a group expression, or else <em>nGens</em> was positive and the given string contains an out-of-range generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input string that is to be interpreted. </td></tr>
    <tr><td class="paramname">nGens</td><td>the number of generators in the group presentation. If this is 0 (the default), then this argument will be ignored and this constructor will not check whether generators are within range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29a2753d395ab5cb3089cb09ec637d86" name="a29a2753d395ab5cb3089cb09ec637d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a2753d395ab5cb3089cb09ec637d86">&#9670;&#160;</a></span>addTermFirst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfe441455a1744f9b5a02cc0fa20bfcf" name="adfe441455a1744f9b5a02cc0fa20bfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe441455a1744f9b5a02cc0fa20bfcf">&#9670;&#160;</a></span>addTermFirst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372453b28e949d4ddacd682fb655cbda" name="a372453b28e949d4ddacd682fb655cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372453b28e949d4ddacd682fb655cbda">&#9670;&#160;</a></span>addTermLast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a539c39976a30b6836a750ffb57fd4d90" name="a539c39976a30b6836a750ffb57fd4d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539c39976a30b6836a750ffb57fd4d90">&#9670;&#160;</a></span>addTermLast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0097a9bb9484c3620e49c2d34910b91c" name="a0097a9bb9484c3620e49c2d34910b91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0097a9bb9484c3620e49c2d34910b91c">&#9670;&#160;</a></span>addTermsFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a></td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this expression on the left by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57767b0dbea5b60e03a8064acd5ec8a9" name="a57767b0dbea5b60e03a8064acd5ec8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57767b0dbea5b60e03a8064acd5ec8a9">&#9670;&#160;</a></span>addTermsLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a></td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this expression on the right by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aeebe99241025551efccdbc0640417f" name="a2aeebe99241025551efccdbc0640417f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeebe99241025551efccdbc0640417f">&#9670;&#160;</a></span>countTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::countTerms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> contains three terms. See also <a class="el" href="#a4c683c8a7391ae8ad801b2c48e6ae3f6" title="Returns the length of the word, i.e.">wordLength()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms. </dd></dl>

</div>
</div>
<a id="a30471b33e30035e299ebfae316519d0c" name="a30471b33e30035e299ebfae316519d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30471b33e30035e299ebfae316519d0c">&#9670;&#160;</a></span>cycleLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleLeft </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the rightmost term around to the leftmost. </p>
<p>All other terms shift one step to the right.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_in^jn g_i1^j1 g_i1^j1 ... g_in-1^jn-1</code>. </p>

</div>
</div>
<a id="a688406ed1ec6e9f3dfd4f31a220729c4" name="a688406ed1ec6e9f3dfd4f31a220729c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688406ed1ec6e9f3dfd4f31a220729c4">&#9670;&#160;</a></span>cycleRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleRight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the leftmost term around to the rightmost. </p>
<p>All other terms shift one step to the left.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_i2^j2 ... g_in^jn g_i1^j1</code>. </p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="aad4e343e87b3c1b157a97292651e1d25" name="aad4e343e87b3c1b157a97292651e1d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4e343e87b3c1b157a97292651e1d25">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::erase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all terms from this this word. </p>
<p>This effectively turns this word into the identity element. </p>

</div>
</div>
<a id="aff0207f2d1602d0e1a7752b9bb2b0183" name="aff0207f2d1602d0e1a7752b9bb2b0183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0207f2d1602d0e1a7752b9bb2b0183">&#9670;&#160;</a></span>exponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::GroupExpression::exponent </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exponent corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is O(<em>n</em>) where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="#a2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested exponent. </dd></dl>

</div>
</div>
<a id="aa5851d978d13f5844ccbf2a6bc7de001" name="aa5851d978d13f5844ccbf2a6bc7de001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5851d978d13f5844ccbf2a6bc7de001">&#9670;&#160;</a></span>generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupExpression::generator </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the generator corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is O(<em>n</em>) where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="#a2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the requested generator. </dd></dl>

</div>
</div>
<a id="aec288bc576d3dcc7256e47ef3995cdf5" name="aec288bc576d3dcc7256e47ef3995cdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec288bc576d3dcc7256e47ef3995cdf5">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::GroupExpression::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of this expression. </p>
<p>The terms will be reversed and the exponents negated.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this expression. </dd></dl>

</div>
</div>
<a id="a7e65aaa150201d3df9fd6199d136d63e" name="a7e65aaa150201d3df9fd6199d136d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e65aaa150201d3df9fd6199d136d63e">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::invert </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts this expression. </p>
<p>Does not allocate or deallocate anything. </p>

</div>
</div>
<a id="aab76ba3c8c7120f4b99787bd78068d39" name="aab76ba3c8c7120f4b99787bd78068d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab76ba3c8c7120f4b99787bd78068d39">&#9670;&#160;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::isTrivial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this is the trivial (unit) word. </p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will be treated as non-trivial).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial word. </dd></dl>

</div>
</div>
<a id="a0402158ae2680818b04bb815e3ed7eb9" name="a0402158ae2680818b04bb815e3ed7eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0402158ae2680818b04bb815e3ed7eb9">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Checks to see whether or not these two words represent different literal strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are not identical. </dd></dl>

</div>
</div>
<a id="a496610829b9f880dfecb6353e0b80895" name="a496610829b9f880dfecb6353e0b80895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496610829b9f880dfecb6353e0b80895">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp; regina::GroupExpression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this expression a clone of the given expression. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this expression. </dd></dl>

</div>
</div>
<a id="a3b8b6a1fb191f76eac06ffa969dea897" name="a3b8b6a1fb191f76eac06ffa969dea897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8b6a1fb191f76eac06ffa969dea897">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp; regina::GroupExpression::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given expression to this expression. </p>
<p>This is a fast (constant time) operation.</p>
<p>The expression that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this expression. </dd></dl>

</div>
</div>
<a id="aff2ca294cd89c65857d242215a72a650" name="aff2ca294cd89c65857d242215a72a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2ca294cd89c65857d242215a72a650">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Checks to see whether or not these two words represent the same literal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are identical. </dd></dl>

</div>
</div>
<a id="a015f07c961ebed05749020568d57e6a3" name="a015f07c961ebed05749020568d57e6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015f07c961ebed05749020568d57e6a3">&#9670;&#160;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::GroupExpression::power </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this expression raised to the given power. </p>
<p>The given exponent may be positive, zero or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>the power to which this expression should be raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this expression raised to the given power. </dd></dl>

</div>
</div>
<a id="a1d02f0fa24e3d333ce3bcfb4e6acee1a" name="a1d02f0fa24e3d333ce3bcfb4e6acee1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d02f0fa24e3d333ce3bcfb4e6acee1a">&#9670;&#160;</a></span>relabellingsThisToOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::map&lt; unsigned long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt; regina::GroupExpression::relabellingsThisToOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cyclic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not one can relabel the generators in this word to obtain the given other word. </p>
<p>If so, returns a non-empty list of all such relabellings. If not, returns an empty list.</p>
<p>Relabellings are partially-defined permutations on the generator set, also allowing for possible inversions if cyclic is <code>true</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo</a></b></dt><dd>Change this to use less heavyweight types and less deep copying.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>cyclic</em> is <code>true</code>, then both this word and <em>other</em> have been cyclically reduced.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the word to compare against this. </td></tr>
    <tr><td class="paramname">cyclic</td><td>if <code>false</code> we get a list of exact relabellings from this word to <em>other</em>. If <code>true</code>, it can be up to cyclic permutation and inversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of permutations, implemented as maps from generator indices of this word to generator indices of <em>other</em>. </dd></dl>

</div>
</div>
<a id="ae77e1f2423da57b6bd93984762691bf2" name="ae77e1f2423da57b6bd93984762691bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77e1f2423da57b6bd93984762691bf2">&#9670;&#160;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::simplify </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cyclic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies this expression. </p>
<p>Adjacent powers of the same generator will be combined, and terms with an exponent of zero will be removed. Note that it is <em>not</em> assumed that the underlying group is abelian.</p>
<p>You may declare that the expression is cyclic, in which case it is assumed that terms may be moved from the back to the front and vice versa. Thus expression <code>g1 g2 g1 g2 g1</code> simplifies to <code>g1^2 g2 g1 g2</code> if it is cyclic, but does not simplify at all if it is not cyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this expression was changed. </dd></dl>

</div>
</div>
<a id="a919a17d5d9a09661b9415a8d0251e714" name="a919a17d5d9a09661b9415a8d0251e714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919a17d5d9a09661b9415a8d0251e714">&#9670;&#160;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupExpression::str </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alphaGen</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this group expression, with a choice of either numbered generators or alphabetic generators. </p>
<p>If <em>alphaGen</em> is <code>false</code>, the text representation will be of the form <code>g2^4 g13^-5 g4</code>. If <em>alphaGen</em> is <code>true</code>, this routine will assume your word is in an alphabet of no more than 26 letters, and will format the word using lower-case ASCII, i.e., <code>c^4 n^-5 e</code>.</p>
<p>Note that there is also a zero-argument version of <a class="el" href="#a919a17d5d9a09661b9415a8d0251e714" title="Returns a short text representation of this group expression, with a choice of either numbered genera...">str()</a>, inherited through the <a class="el" href="structregina_1_1ShortOutput.html" title="A common base class for objects that provide short text output only.">ShortOutput</a> base class. This zero-argument <a class="el" href="#a919a17d5d9a09661b9415a8d0251e714" title="Returns a short text representation of this group expression, with a choice of either numbered genera...">str()</a> gives the same output as <code>str(false)</code>.</p>
<p>Note that generators are numbered starting from 0. This means, for example, that <code>a</code>, <code>b</code> and <code>c</code> correspond to <code>g0</code>, <code>g1</code> and <code>g2</code> respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>alphaGen</em> is <code>true</code>, the number of generators in the corresponding group must be 26 or fewer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alphaGen</td><td>indicates whether to use numbered or alphabetic generators, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this group expression. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a0afd7397c082044b70f359aeddd136a2" name="a0afd7397c082044b70f359aeddd136a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afd7397c082044b70f359aeddd136a2">&#9670;&#160;</a></span>substitute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expansions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cyclic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces every generator in this expression with the corresponding substitute expression from the given map. </p>
<p>Specifically, each generator <em>i</em> will be replaced with the expression <code>expansions[i]</code>.</p>
<p>The expression will be simplified once all substitutions are complete.</p>
<p>Unlike the single-generator verison of <a class="el" href="#a5dc5f90b79dc0a50956c1737ac350c0b" title="Replaces every occurrence of the given generator with the given substitute expression.">substitute()</a>, it is perfectly fine if this <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> object appears in the <em>expansions</em> list, and/or if the same <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> object appears several times in the given list.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The length of <em>expansions</em> is at least <em>g</em>+1, where <em>g</em> is the largest generator that appears in this expression. In other words, <code>expansions[i]</code> exists for every generator <em>i</em> that appears in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expansions</td><td>the list of substitutes for all generators in this expression. </td></tr>
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic; see <a class="el" href="#ae77e1f2423da57b6bd93984762691bf2" title="Simplifies this expression.">simplify()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dc5f90b79dc0a50956c1737ac350c0b" name="a5dc5f90b79dc0a50956c1737ac350c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc5f90b79dc0a50956c1737ac350c0b">&#9670;&#160;</a></span>substitute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::substitute </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expansion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cyclic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces every occurrence of the given generator with the given substitute expression. </p>
<p>If the given generator was found, the expression will be simplified once the substitution is complete.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given expansion is not the same <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a> object as this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the generator to be replaced. </td></tr>
    <tr><td class="paramname">expansion</td><td>the substitute expression that will replace every occurrence of the given generator. </td></tr>
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic; see <a class="el" href="#ae77e1f2423da57b6bd93984762691bf2" title="Simplifies this expression.">simplify()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if any substitutions were made. </dd></dl>

</div>
</div>
<a id="acff651ce01ffe895628cfecfaaed10a2" name="acff651ce01ffe895628cfecfaaed10a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff651ce01ffe895628cfecfaaed10a2">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the expression whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8904a6bde73d6a1ea0427a9262ec7951" name="a8904a6bde73d6a1ea0427a9262ec7951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904a6bde73d6a1ea0427a9262ec7951">&#9670;&#160;</a></span>term() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is O(<em>n</em>) where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="#a2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a id="a39b094648fc06a56a42041221e491849" name="a39b094648fc06a56a42041221e491849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b094648fc06a56a42041221e491849">&#9670;&#160;</a></span>term() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is O(<em>n</em>) where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="#a2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a id="ab7107330382d76de56540ef1e5ec986e" name="ab7107330382d76de56540ef1e5ec986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7107330382d76de56540ef1e5ec986e">&#9670;&#160;</a></span>terms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of terms in this expression. </p>
<p>These are the actual terms stored internally; any modifications made to this list will show up in the expression itself.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python</dt><dd>The list itself is not returned by reference (instead this routine returns a new Python list). However, the terms within this list are still returned by reference (i.e., you can use the elements of this list to modify each term individually).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a id="a961eb0fc634f28142e23abe582fe977a" name="a961eb0fc634f28142e23abe582fe977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961eb0fc634f28142e23abe582fe977a">&#9670;&#160;</a></span>terms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the list of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python</dt><dd>The list itself is not returned by reference (instead this routine returns a new Python list). However, the terms within this list are still returned by reference.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a id="a391c33dbc7bdd6ec672da0b4b3964f2f" name="a391c33dbc7bdd6ec672da0b4b3964f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c33dbc7bdd6ec672da0b4b3964f2f">&#9670;&#160;</a></span>tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupExpression::tex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a TeX representation of this expression. </p>
<p>The text representation will be of the form <code>g_2^4 g_{13}^{-5} g_4</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this expression. </dd></dl>

</div>
</div>
<a id="af41623f4250f9cdb72f209b251656245" name="af41623f4250f9cdb72f209b251656245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41623f4250f9cdb72f209b251656245">&#9670;&#160;</a></span>utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupExpression::utf8 </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alphaGen</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this group expression using unicode characters, with a choice of either numbered generators or alphabetic generators. </p>
<p>This outputs a similar text representation to str(bool), except that all exponents will be written using superscript characters encoded in UTF-8. See str(bool) for further details.</p>
<p>Note that there is also a zero-argument version of <a class="el" href="#af41623f4250f9cdb72f209b251656245" title="Returns a short text representation of this group expression using unicode characters,...">utf8()</a>, inherited through the <a class="el" href="structregina_1_1ShortOutput.html" title="A common base class for objects that provide short text output only.">ShortOutput</a> base class. This zero-argument <a class="el" href="#af41623f4250f9cdb72f209b251656245" title="Returns a short text representation of this group expression using unicode characters,...">utf8()</a> gives the same output as <code>utf8(false)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>alphaGen</em> is <code>true</code>, the number of generators in the corresponding group must be 26 or fewer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alphaGen</td><td>indicates whether to use numbered or alphabetic generators, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this group expression. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="#a919a17d5d9a09661b9415a8d0251e714" title="Returns a short text representation of this group expression, with a choice of either numbered genera...">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="#a919a17d5d9a09661b9415a8d0251e714" title="Returns a short text representation of this group expression, with a choice of either numbered genera...">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a4c683c8a7391ae8ad801b2c48e6ae3f6" name="a4c683c8a7391ae8ad801b2c48e6ae3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c683c8a7391ae8ad801b2c48e6ae3f6">&#9670;&#160;</a></span>wordLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::wordLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the word, i.e. </p>
<p>the number of letters with exponent +1 or -1 for which this word is expressable as a product.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> is a word of length four. See also <a class="el" href="#a2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>.</p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will count as length two).</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the word. </dd></dl>

</div>
</div>
<a id="a5288d1ece14ec07413a046ac62245b1f" name="a5288d1ece14ec07413a046ac62245b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5288d1ece14ec07413a046ac62245b1f">&#9670;&#160;</a></span>writeTeX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this expression to the given output stream. </p>
<p>The text representation will be of the form <code>g_2^4 g_{13}^{-5} g_4</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a391c33dbc7bdd6ec672da0b4b3964f2f" title="Returns a TeX representation of this expression.">tex()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>, supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0408f35a669a110a62b85d34487b4be" name="ac0408f35a669a110a62b85d34487b4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0408f35a669a110a62b85d34487b4be">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>utf8</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alphaGen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream, using either numbered generators or alphabetic generators. </p>
<p>The text representation will be of the form <code>g2^4 g13^-5 g4</code>. If the <em>alphaGen</em> flag is <code>true</code>, it will assume your word is in an alphabet of no more than 26 letters, and will write the word using lower-case ASCII, i.e., <code>c^4 n^-5 e</code>. If the <em>utf8</em> flag is <code>true</code>, all exponents will be written using superscript characters encoded in UTF-8.</p>
<p>Note that generators are numbered starting from 0. This means, for example, that <code>a</code>, <code>b</code> and <code>c</code> correspond to <code>g0</code>, <code>g1</code> and <code>g2</code> respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>alphaGen</em> is <code>true</code>, the number of generators in the corresponding group must be 26 or fewer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="#a919a17d5d9a09661b9415a8d0251e714" title="Returns a short text representation of this group expression, with a choice of either numbered genera...">str()</a> or <a class="el" href="#af41623f4250f9cdb72f209b251656245" title="Returns a short text representation of this group expression using unicode characters,...">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if exponents should be written using unicode superscript characters, or <code>false</code> if they should be written using a caret (^) symbol. </td></tr>
    <tr><td class="paramname">alphaGen</td><td>indicates whether to use numbered or alphabetic generators, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8b0fedf30a85fc54ede2e37c5deb088" name="aa8b0fedf30a85fc54ede2e37c5deb088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b0fedf30a85fc54ede2e37c5deb088">&#9670;&#160;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this expression. </p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="grouppresentation_8h.html">grouppresentation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
