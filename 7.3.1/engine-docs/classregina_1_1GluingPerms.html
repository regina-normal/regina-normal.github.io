<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::GluingPerms&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1GluingPerms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::GluingPerms&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a specific set of gluing permutations to complement a particular pairwise matching of simplex facets.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;census/gluingperms.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GluingPerms&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GluingPerms.png" usemap="#regina::GluingPerms_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::GluingPerms_3C_20dim_20_3E_map" name="regina::GluingPerms_3C_20dim_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GluingPerms&lt; dim &gt; &gt;" shape="rect" coords="0,0,229,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4df45664c518279d24f5eb67e3f4567" id="r_af4df45664c518279d24f5eb67e3f4567"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> = typename <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim&gt;::Index</td></tr>
<tr class="memdesc:af4df45664c518279d24f5eb67e3f4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native signed integer type large enough to count all permutations on <em>dim</em> elements.  <br /></td></tr>
<tr class="separator:af4df45664c518279d24f5eb67e3f4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc6adb9b73c4e41dd67c87797f0d4b3c" id="r_acc6adb9b73c4e41dd67c87797f0d4b3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc6adb9b73c4e41dd67c87797f0d4b3c">GluingPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;<a class="el" href="#a9e9b92148c565f7343423d8bfa5f0115">pairing</a>)</td></tr>
<tr class="memdesc:acc6adb9b73c4e41dd67c87797f0d4b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new permutation set.  <br /></td></tr>
<tr class="separator:acc6adb9b73c4e41dd67c87797f0d4b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7309925b669563ee391e0c506add305" id="r_ac7309925b669563ee391e0c506add305"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7309925b669563ee391e0c506add305">GluingPerms</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&amp;<a class="el" href="#a9e9b92148c565f7343423d8bfa5f0115">pairing</a>)</td></tr>
<tr class="memdesc:ac7309925b669563ee391e0c506add305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new permutation set.  <br /></td></tr>
<tr class="separator:ac7309925b669563ee391e0c506add305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2262d84caa604aac9c5ebfb29535129f" id="r_a2262d84caa604aac9c5ebfb29535129f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2262d84caa604aac9c5ebfb29535129f">GluingPerms</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;src)</td></tr>
<tr class="memdesc:a2262d84caa604aac9c5ebfb29535129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given gluing permutation set.  <br /></td></tr>
<tr class="separator:a2262d84caa604aac9c5ebfb29535129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f9bf2fbf42a3d1609a98448f110b9b" id="r_a01f9bf2fbf42a3d1609a98448f110b9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01f9bf2fbf42a3d1609a98448f110b9b">GluingPerms</a> (<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a01f9bf2fbf42a3d1609a98448f110b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given gluing permutation set into this new gluing permutation set.  <br /></td></tr>
<tr class="separator:a01f9bf2fbf42a3d1609a98448f110b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb274fddfacdad1fbe870fa0dba57a51" id="r_acb274fddfacdad1fbe870fa0dba57a51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb274fddfacdad1fbe870fa0dba57a51">GluingPerms</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:acb274fddfacdad1fbe870fa0dba57a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new set of gluing permutations from the given input stream.  <br /></td></tr>
<tr class="separator:acb274fddfacdad1fbe870fa0dba57a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d584bf4ffb32f2227db4310fd12997e" id="r_a5d584bf4ffb32f2227db4310fd12997e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d584bf4ffb32f2227db4310fd12997e">~GluingPerms</a> ()</td></tr>
<tr class="memdesc:a5d584bf4ffb32f2227db4310fd12997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any memory used by this structure.  <br /></td></tr>
<tr class="separator:a5d584bf4ffb32f2227db4310fd12997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ecb04ebcbe06b7ee2d27263ade28ab" id="r_ae8ecb04ebcbe06b7ee2d27263ade28ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8ecb04ebcbe06b7ee2d27263ade28ab">operator=</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;src)</td></tr>
<tr class="memdesc:ae8ecb04ebcbe06b7ee2d27263ade28ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given gluing permutation set.  <br /></td></tr>
<tr class="separator:ae8ecb04ebcbe06b7ee2d27263ade28ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c744a1b1131e75f57a00cba28780efb" id="r_a9c744a1b1131e75f57a00cba28780efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c744a1b1131e75f57a00cba28780efb">operator=</a> (<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a9c744a1b1131e75f57a00cba28780efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given gluing permutation set into this new gluing permutation set.  <br /></td></tr>
<tr class="separator:a9c744a1b1131e75f57a00cba28780efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dea98d4db02581becbd3ec38f94e32" id="r_a85dea98d4db02581becbd3ec38f94e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85dea98d4db02581becbd3ec38f94e32">swap</a> (<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a85dea98d4db02581becbd3ec38f94e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given gluing permutation set.  <br /></td></tr>
<tr class="separator:a85dea98d4db02581becbd3ec38f94e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b696c4807e1d0b5b217591e20f1bd1b" id="r_a6b696c4807e1d0b5b217591e20f1bd1b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b696c4807e1d0b5b217591e20f1bd1b">size</a> () const</td></tr>
<tr class="memdesc:a6b696c4807e1d0b5b217591e20f1bd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of simplices under consideration.  <br /></td></tr>
<tr class="separator:a6b696c4807e1d0b5b217591e20f1bd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9b92148c565f7343423d8bfa5f0115" id="r_a9e9b92148c565f7343423d8bfa5f0115"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e9b92148c565f7343423d8bfa5f0115">pairing</a> () const</td></tr>
<tr class="memdesc:a9e9b92148c565f7343423d8bfa5f0115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific pairing of simplex facets that this set of gluing permutations complements.  <br /></td></tr>
<tr class="separator:a9e9b92148c565f7343423d8bfa5f0115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e250c115a0ecec59a6c6df3fb427fd1" id="r_a8e250c115a0ecec59a6c6df3fb427fd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1">perm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a8e250c115a0ecec59a6c6df3fb427fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <br /></td></tr>
<tr class="separator:a8e250c115a0ecec59a6c6df3fb427fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec3fe9850cbadfccb216a95aa0507a9" id="r_aaec3fe9850cbadfccb216a95aa0507a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec3fe9850cbadfccb216a95aa0507a9">perm</a> (size_t simp, int facet) const</td></tr>
<tr class="memdesc:aaec3fe9850cbadfccb216a95aa0507a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <br /></td></tr>
<tr class="separator:aaec3fe9850cbadfccb216a95aa0507a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bd9ea68b105d25fc5bb7dc6ae5bb0b" id="r_a56bd9ea68b105d25fc5bb7dc6ae5bb0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a56bd9ea68b105d25fc5bb7dc6ae5bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:a56bd9ea68b105d25fc5bb7dc6ae5bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af766698e94128b45eb243e1e0756e1f2" id="r_af766698e94128b45eb243e1e0756e1f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af766698e94128b45eb243e1e0756e1f2">permIndex</a> (size_t simp, int facet) const</td></tr>
<tr class="memdesc:af766698e94128b45eb243e1e0756e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:af766698e94128b45eb243e1e0756e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35e279a2696a89c1178b32ef3c6b758" id="r_aa35e279a2696a89c1178b32ef3c6b758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa35e279a2696a89c1178b32ef3c6b758">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:aa35e279a2696a89c1178b32ef3c6b758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers write access to the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:aa35e279a2696a89c1178b32ef3c6b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e20078c0a58396c525090c6744228e" id="r_a35e20078c0a58396c525090c6744228e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35e20078c0a58396c525090c6744228e">permIndex</a> (size_t simp, int facet)</td></tr>
<tr class="memdesc:a35e20078c0a58396c525090c6744228e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers write access to the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:a35e20078c0a58396c525090c6744228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022a579aae98e10a72d903f42485b20" id="r_a7022a579aae98e10a72d903f42485b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7022a579aae98e10a72d903f42485b20">setPermIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, <a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> index)</td></tr>
<tr class="memdesc:a7022a579aae98e10a72d903f42485b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only routine that sets the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:a7022a579aae98e10a72d903f42485b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389528bbb20d91ce0a72ac4a4c6870d2" id="r_a389528bbb20d91ce0a72ac4a4c6870d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a389528bbb20d91ce0a72ac4a4c6870d2">setPermIndex</a> (size_t simp, int facet, <a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> index)</td></tr>
<tr class="memdesc:a389528bbb20d91ce0a72ac4a4c6870d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only routine that sets the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner.  <br /></td></tr>
<tr class="separator:a389528bbb20d91ce0a72ac4a4c6870d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364806abf12bed581e8a75ef35213ea8" id="r_a364806abf12bed581e8a75ef35213ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a364806abf12bed581e8a75ef35213ea8">triangulate</a> () const</td></tr>
<tr class="memdesc:a364806abf12bed581e8a75ef35213ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation modelled by this set of gluing permutations and the associated simplex facet pairing.  <br /></td></tr>
<tr class="separator:a364806abf12bed581e8a75ef35213ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae73a6387eb1b6cd3da1e029db6ec0b" id="r_afae73a6387eb1b6cd3da1e029db6ec0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afae73a6387eb1b6cd3da1e029db6ec0b">dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afae73a6387eb1b6cd3da1e029db6ec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <br /></td></tr>
<tr class="separator:afae73a6387eb1b6cd3da1e029db6ec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ea51c512191b2b792322fffd3e6cb9" id="r_ab7ea51c512191b2b792322fffd3e6cb9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ea51c512191b2b792322fffd3e6cb9">data</a> () const</td></tr>
<tr class="memdesc:ab7ea51c512191b2b792322fffd3e6cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all internal data in a plain text format.  <br /></td></tr>
<tr class="separator:ab7ea51c512191b2b792322fffd3e6cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a75f4d76fe1591d80335f505253db41" id="r_a4a75f4d76fe1591d80335f505253db41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a75f4d76fe1591d80335f505253db41">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a4a75f4d76fe1591d80335f505253db41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <br /></td></tr>
<tr class="separator:a4a75f4d76fe1591d80335f505253db41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4396323aac84aca1d5588719e3e41215" id="r_a4396323aac84aca1d5588719e3e41215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4396323aac84aca1d5588719e3e41215">gluingToIndex</a> (size_t simp, int facet, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a4396323aac84aca1d5588719e3e41215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <br /></td></tr>
<tr class="separator:a4396323aac84aca1d5588719e3e41215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc82564f427e3d083da84c2c4804c87" id="r_a3dc82564f427e3d083da84c2c4804c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc82564f427e3d083da84c2c4804c87">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, <a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> index) const</td></tr>
<tr class="memdesc:a3dc82564f427e3d083da84c2c4804c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1.  <br /></td></tr>
<tr class="separator:a3dc82564f427e3d083da84c2c4804c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a8df74de5eee3d200f8d879e159412" id="r_af9a8df74de5eee3d200f8d879e159412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9a8df74de5eee3d200f8d879e159412">indexToGluing</a> (size_t simp, int facet, <a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> index) const</td></tr>
<tr class="memdesc:af9a8df74de5eee3d200f8d879e159412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1.  <br /></td></tr>
<tr class="separator:af9a8df74de5eee3d200f8d879e159412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6872a252c5df0f277ea5c31e67d81c6" id="r_ae6872a252c5df0f277ea5c31e67d81c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6872a252c5df0f277ea5c31e67d81c6">operator==</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;other) const</td></tr>
<tr class="memdesc:ae6872a252c5df0f277ea5c31e67d81c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given gluing permutation set are identical.  <br /></td></tr>
<tr class="separator:ae6872a252c5df0f277ea5c31e67d81c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c6a6cdaac8da386d82c903735208c8" id="r_ac4c6a6cdaac8da386d82c903735208c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c6a6cdaac8da386d82c903735208c8">operator!=</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;other) const</td></tr>
<tr class="memdesc:ac4c6a6cdaac8da386d82c903735208c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given gluing permutation set are not identical.  <br /></td></tr>
<tr class="separator:ac4c6a6cdaac8da386d82c903735208c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0bf3b7b1d902dc4d9149ebb2197124" id="r_a4c0bf3b7b1d902dc4d9149ebb2197124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c0bf3b7b1d902dc4d9149ebb2197124">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a4c0bf3b7b1d902dc4d9149ebb2197124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a4c0bf3b7b1d902dc4d9149ebb2197124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33beb49558afc2e728ecbfd15e82f93d" id="r_a33beb49558afc2e728ecbfd15e82f93d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33beb49558afc2e728ecbfd15e82f93d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a33beb49558afc2e728ecbfd15e82f93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a33beb49558afc2e728ecbfd15e82f93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adf532540ad36972984c3d7b05e253f26" id="r_adf532540ad36972984c3d7b05e253f26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf532540ad36972984c3d7b05e253f26">fromData</a> (const std::string &amp;<a class="el" href="#ab7ea51c512191b2b792322fffd3e6cb9">data</a>)</td></tr>
<tr class="memdesc:adf532540ad36972984c3d7b05e253f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new set of gluing permutations from the given string.  <br /></td></tr>
<tr class="separator:adf532540ad36972984c3d7b05e253f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::GluingPerms&lt; dim &gt;</div><p>Represents a specific set of gluing permutations to complement a particular pairwise matching of simplex facets. </p>
<p>Given a pairwise matching of facets (as described by class FacetPairing&lt;dim&gt;), each facet that is matched with some other facet will have an associated permutation of (<em>dim</em> + 1) elements.</p>
<p>If a facet is matched with some other facet, the two associated permutations in this set will be inverses. If a facet is left deliberately unmatched, it will have no associated permutation in this set.</p>
<p>Such a set of permutations models part of the structure of a triangulation, in which each simplex facet that is glued to another facet has a corresponding gluing permutation (and the matched facet has the inverse gluing permutation).</p>
<p>The main purpose of this class is to provide a way of quickly describing and manipulating the combinatorial structure of a triangulation without the overhead of a full-blown Triangulation&lt;dim&gt; object. In particular, this class was designed for use in census enumeration, which involves rapid construction and editing of these permutations. To convert this into a full Triangulation&lt;dim&gt; object, you can call <a class="el" href="#a364806abf12bed581e8a75ef35213ea8" title="Returns the triangulation modelled by this set of gluing permutations and the associated simplex face...">triangulate()</a>.</p>
<p>Internally, this class stores each permutation as an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 (that is, an index into the permutation group <em>S_dim</em>). Importantly, you can only <em>set</em> permutations using these indices, via the non-const <a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its part...">permIndex()</a> function - access to the permutations themselves is read-only. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between indicex and permutations, or you can use the read-only member function <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> which returns the permutation directly. Note that this correspondence is non-trivial, and depends on the details of the underlying facet pairing.</p>
<p>This class also supports a special "not yet chosen" permutation, represented using the permutation index -1. Attempting to convert this to a real permutation using <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> or <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> is not allowed, and will result in undefined behaviour.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (gluingperms-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for all dimensions.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation that is being modelled. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af4df45664c518279d24f5eb67e3f4567" name="af4df45664c518279d24f5eb67e3f4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4df45664c518279d24f5eb67e3f4567">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::Index = typename <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim&gt;::Index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A native signed integer type large enough to count all permutations on <em>dim</em> elements. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc6adb9b73c4e41dd67c87797f0d4b3c" name="acc6adb9b73c4e41dd67c87797f0d4b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6adb9b73c4e41dd67c87797f0d4b3c">&#9670;&#160;</a></span>GluingPerms() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::GluingPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new permutation set. </p>
<p>All internal permutations will be marked as not yet chosen, and any attempt to query them before setting them to explicit values will result in undefined behaviour. The corresponding permutation indices will be set to -1.</p>
<p>This constructor induces a deep copy of the given facet pairing.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of simplex facets that this permutation set will complement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7309925b669563ee391e0c506add305" name="ac7309925b669563ee391e0c506add305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7309925b669563ee391e0c506add305">&#9670;&#160;</a></span>GluingPerms() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::GluingPerms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new permutation set. </p>
<p>All internal permutations will be marked as not yet chosen, and any attempt to query them before setting them to explicit values will result in undefined behaviour. The corresponding permutation indices will be set to -1.</p>
<p>This constructor moves the contents of the given facet pairing into this object. After it returns, <em>pairing</em> will no longer be usable.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form.">FacetPairing::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of simplex facets that this permutation set will complement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2262d84caa604aac9c5ebfb29535129f" name="a2262d84caa604aac9c5ebfb29535129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2262d84caa604aac9c5ebfb29535129f">&#9670;&#160;</a></span>GluingPerms() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::GluingPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given gluing permutation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the gluing permutations to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01f9bf2fbf42a3d1609a98448f110b9b" name="a01f9bf2fbf42a3d1609a98448f110b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f9bf2fbf42a3d1609a98448f110b9b">&#9670;&#160;</a></span>GluingPerms() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::GluingPerms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given gluing permutation set into this new gluing permutation set. </p>
<p>This is a fast (constant time) operation.</p>
<p>The permutation set that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the gluing permutations to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb274fddfacdad1fbe870fa0dba57a51" name="acb274fddfacdad1fbe870fa0dba57a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb274fddfacdad1fbe870fa0dba57a51">&#9670;&#160;</a></span>GluingPerms() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::GluingPerms </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a new set of gluing permutations from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="#afae73a6387eb1b6cd3da1e029db6ec0b" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The data found in the input stream is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead call <a class="el" href="#adf532540ad36972984c3d7b05e253f26" title="Reads a new set of gluing permutations from the given string.">fromData()</a>, which takes this same input data in string format.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d584bf4ffb32f2227db4310fd12997e" name="a5d584bf4ffb32f2227db4310fd12997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d584bf4ffb32f2227db4310fd12997e">&#9670;&#160;</a></span>~GluingPerms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates any memory used by this structure. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab7ea51c512191b2b792322fffd3e6cb9" name="ab7ea51c512191b2b792322fffd3e6cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ea51c512191b2b792322fffd3e6cb9">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all internal data in a plain text format. </p>
<p>This gluing permutation sert can be recreated from this text data by calling <a class="el" href="#adf532540ad36972984c3d7b05e253f26" title="Reads a new set of gluing permutations from the given string.">fromData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>This routine returns the same information that <a class="el" href="#afae73a6387eb1b6cd3da1e029db6ec0b" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> writes.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all of this object's internal data in plain text format. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="afae73a6387eb1b6cd3da1e029db6ec0b" name="afae73a6387eb1b6cd3da1e029db6ec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae73a6387eb1b6cd3da1e029db6ec0b">&#9670;&#160;</a></span>dumpData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>This routine outputs the same information that <a class="el" href="#ab7ea51c512191b2b792322fffd3e6cb9" title="Returns all internal data in a plain text format.">data()</a> returns.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. You can instead use <a class="el" href="#ab7ea51c512191b2b792322fffd3e6cb9" title="Returns all internal data in a plain text format.">data()</a>, which returns this same information as a string. However, the matching input stream constructor is not available in Python either, so it is recommended that Python users use <a class="el" href="#adf532540ad36972984c3d7b05e253f26" title="Reads a new set of gluing permutations from the given string.">fromData()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf532540ad36972984c3d7b05e253f26" name="adf532540ad36972984c3d7b05e253f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf532540ad36972984c3d7b05e253f26">&#9670;&#160;</a></span>fromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::fromData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a new set of gluing permutations from the given string. </p>
<p>This routine reads data in the format written by <a class="el" href="#ab7ea51c512191b2b792322fffd3e6cb9" title="Returns all internal data in a plain text format.">data()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The data found in the given string is invalid, incomplete, or incorrectly formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data from which to reconstruct a gluing permutation set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reconstructed gluing permutation set. </dd></dl>

</div>
</div>
<a id="a4a75f4d76fe1591d80335f505253db41" name="a4a75f4d76fe1591d80335f505253db41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a75f4d76fe1591d80335f505253db41">&#9670;&#160;</a></span>gluingToIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gluing</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="a4396323aac84aca1d5588719e3e41215" name="a4396323aac84aca1d5588719e3e41215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4396323aac84aca1d5588719e3e41215">&#9670;&#160;</a></span>gluingToIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a> <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gluing</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="a3dc82564f427e3d083da84c2c4804c87" name="a3dc82564f427e3d083da84c2c4804c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc82564f427e3d083da84c2c4804c87">&#9670;&#160;</a></span>indexToGluing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1. </dd></dl>

</div>
</div>
<a id="af9a8df74de5eee3d200f8d879e159412" name="af9a8df74de5eee3d200f8d879e159412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a8df74de5eee3d200f8d879e159412">&#9670;&#160;</a></span>indexToGluing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1. </dd></dl>

</div>
</div>
<a id="ac4c6a6cdaac8da386d82c903735208c8" name="ac4c6a6cdaac8da386d82c903735208c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c6a6cdaac8da386d82c903735208c8">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given gluing permutation set are not identical. </p>
<p>To be identical, the two sets must use identical facet pairings and all of their corresponding permutations must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the gluing permutation set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given set are not identical. </dd></dl>

</div>
</div>
<a id="ae8ecb04ebcbe06b7ee2d27263ade28ab" name="ae8ecb04ebcbe06b7ee2d27263ade28ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ecb04ebcbe06b7ee2d27263ade28ab">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given gluing permutation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the gluing permutations to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this gluing permutation set. </dd></dl>

</div>
</div>
<a id="a9c744a1b1131e75f57a00cba28780efb" name="a9c744a1b1131e75f57a00cba28780efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c744a1b1131e75f57a00cba28780efb">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given gluing permutation set into this new gluing permutation set. </p>
<p>This is a fast (constant time) operation.</p>
<p>The permutation set that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the gluing permutations to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this gluing permutation set. </dd></dl>

</div>
</div>
<a id="ae6872a252c5df0f277ea5c31e67d81c6" name="ae6872a252c5df0f277ea5c31e67d81c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6872a252c5df0f277ea5c31e67d81c6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given gluing permutation set are identical. </p>
<p>To be identical, the two sets must use identical facet pairings and all of their corresponding permutations must be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the gluing permutation set to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given set are identical. </dd></dl>

</div>
</div>
<a id="a9e9b92148c565f7343423d8bfa5f0115" name="a9e9b92148c565f7343423d8bfa5f0115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9b92148c565f7343423d8bfa5f0115">&#9670;&#160;</a></span>pairing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::pairing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a id="a8e250c115a0ecec59a6c6df3fb427fd1" name="a8e250c115a0ecec59a6c6df3fb427fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e250c115a0ecec59a6c6df3fb427fd1">&#9670;&#160;</a></span>perm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::perm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="#a9e9b92148c565f7343423d8bfa5f0115" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">pairing()</a>). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end). </dd>
<dd>
The requested permutation is not the special "not yet chosen" value (i.e., the internal index that is stored for it is not -1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="aaec3fe9850cbadfccb216a95aa0507a9" name="aaec3fe9850cbadfccb216a95aa0507a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec3fe9850cbadfccb216a95aa0507a9">&#9670;&#160;</a></span>perm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::perm </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="#a9e9b92148c565f7343423d8bfa5f0115" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">pairing()</a>). </dd>
<dd>
The requested permutation is not the special "not yet chosen" value (i.e., the internal index that is stored for it is not -1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="aa35e279a2696a89c1178b32ef3c6b758" name="aa35e279a2696a89c1178b32ef3c6b758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35e279a2696a89c1178b32ef3c6b758">&#9670;&#160;</a></span>permIndex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;<a class="el" href="#af4df45664c518279d24f5eb67e3f4567">::Index</a> &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offers write access to the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations, or you can call <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> for read-only access to the gluing permutation directly.</p>
<p>As described in the class notes, this index can be a real permutation index between 0 and (dim!)-1 inclusive, or it may be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>For Python users, <a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its part...">permIndex()</a> is a read-only function that returns by value. To edit this index, use the Python-only routine <a class="el" href="#a7022a579aae98e10a72d903f42485b20" title="Python-only routine that sets the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet...">setPermIndex()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="a56bd9ea68b105d25fc5bb7dc6ae5bb0b" name="a56bd9ea68b105d25fc5bb7dc6ae5bb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b">&#9670;&#160;</a></span>permIndex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;<a class="el" href="#af4df45664c518279d24f5eb67e3f4567">::Index</a> <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations, or you can call <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> to read the gluing permutation directly.</p>
<p>As described in the class notes, this index could be a real permutation index between 0 and (dim!)-1 inclusive, or it could be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="a35e20078c0a58396c525090c6744228e" name="a35e20078c0a58396c525090c6744228e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e20078c0a58396c525090c6744228e">&#9670;&#160;</a></span>permIndex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;<a class="el" href="#af4df45664c518279d24f5eb67e3f4567">::Index</a> &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offers write access to the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations, or you can call <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> for read-only access to the gluing permutation directly.</p>
<p>As described in the class notes, this index can be a real permutation index between 0 and (dim!)-1 inclusive, or it may be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, <a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its part...">permIndex()</a> is a read-only function that returns by value. To edit this index, use the Python-only routine <a class="el" href="#a7022a579aae98e10a72d903f42485b20" title="Python-only routine that sets the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet...">setPermIndex()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="af766698e94128b45eb243e1e0756e1f2" name="af766698e94128b45eb243e1e0756e1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af766698e94128b45eb243e1e0756e1f2">&#9670;&#160;</a></span>permIndex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;<a class="el" href="#af4df45664c518279d24f5eb67e3f4567">::Index</a> <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations, or you can call <a class="el" href="#a8e250c115a0ecec59a6c6df3fb427fd1" title="Returns the gluing permutation associated with the given simplex facet.">perm()</a> to read the gluing permutation directly.</p>
<p>As described in the class notes, this index could be a real permutation index between 0 and (dim!)-1 inclusive, or it could be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="a7022a579aae98e10a72d903f42485b20" name="a7022a579aae98e10a72d903f42485b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022a579aae98e10a72d903f42485b20">&#9670;&#160;</a></span>setPermIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::setPermIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only routine that sets the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations.</p>
<p>As described in the class notes, this index can be a real permutation index between 0 and (dim!)-1 inclusive, or it may be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its part...">permIndex()</a> is used for both reading and writing: just write <code>permIndex(source) = index</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under consideration. </td></tr>
    <tr><td class="paramname">index</td><td>the new value of the corresponding array index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a389528bbb20d91ce0a72ac4a4c6870d2" name="a389528bbb20d91ce0a72ac4a4c6870d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389528bbb20d91ce0a72ac4a4c6870d2">&#9670;&#160;</a></span>setPermIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::setPermIndex </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af4df45664c518279d24f5eb67e3f4567">Index</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only routine that sets the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this is not the <em>S_n</em> index of the gluing permutation on (<em>dim</em> + 1) elements, but rather the index of a permutation on just <em>dim</em> elements. You can use <a class="el" href="#a3dc82564f427e3d083da84c2c4804c87" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> and <a class="el" href="#a4a75f4d76fe1591d80335f505253db41" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 corresponding to the given gluing permutation from the g...">gluingToIndex()</a> to convert between these indices and gluing permutations.</p>
<p>As described in the class notes, this index can be a real permutation index between 0 and (dim!)-1 inclusive, or it may be the special value -1 indicating that the permutation has not yet been chosen.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="#a56bd9ea68b105d25fc5bb7dc6ae5bb0b" title="Returns the index into array Perm&lt;dim+1&gt;Sn_1 describing how the the given facet is joined to its part...">permIndex()</a> is used for both reading and writing: just write <code>permIndex(simp, facet) = index</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under consideration (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under consideration (between 0 and <em>dim</em> inclusive). </td></tr>
    <tr><td class="paramname">index</td><td>the new value of the corresponding array index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b696c4807e1d0b5b217591e20f1bd1b" name="a6b696c4807e1d0b5b217591e20f1bd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b696c4807e1d0b5b217591e20f1bd1b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a85dea98d4db02581becbd3ec38f94e32" name="a85dea98d4db02581becbd3ec38f94e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dea98d4db02581becbd3ec38f94e32">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given gluing permutation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the set whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a364806abf12bed581e8a75ef35213ea8" name="a364806abf12bed581e8a75ef35213ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364806abf12bed581e8a75ef35213ea8">&#9670;&#160;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the triangulation modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>For every simplex facet in the underlying facet pairing that is glued to a partner, the corresponding gluing permutation in this set is not the special "not yet chosen" value (i.e., does not have internal index -1).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the triangulation modelled by this structure. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a33beb49558afc2e728ecbfd15e82f93d" name="a33beb49558afc2e728ecbfd15e82f93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33beb49558afc2e728ecbfd15e82f93d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0bf3b7b1d902dc4d9149ebb2197124" name="a4c0bf3b7b1d902dc4d9149ebb2197124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0bf3b7b1d902dc4d9149ebb2197124">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingperms_8h.html">gluingperms.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
