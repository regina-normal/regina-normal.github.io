<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::PacketChildren&lt; const_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1PacketChildren-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::PacketChildren&lt; const_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A lightweight object that gives access to all immediate children of a given packet.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;packet/packet.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a504cd2c92ba12dd8d1593524f7a45fa2" id="r_a504cd2c92ba12dd8d1593524f7a45fa2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> = std::conditional_t&lt;const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a>&gt;</td></tr>
<tr class="memdesc:a504cd2c92ba12dd8d1593524f7a45fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>.  <br /></td></tr>
<tr class="separator:a504cd2c92ba12dd8d1593524f7a45fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbd1d4e4654d3d79b3c32a2234e2dedc" id="r_abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbd1d4e4654d3d79b3c32a2234e2dedc">PacketChildren</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the children of the same packet as the given object.  <br /></td></tr>
<tr class="separator:abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9177080f8db5b4abbb8d4c15f0304db" id="r_af9177080f8db5b4abbb8d4c15f0304db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9177080f8db5b4abbb8d4c15f0304db">PacketChildren</a> (std::shared_ptr&lt; <a class="el" href="#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> &gt; parent)</td></tr>
<tr class="memdesc:af9177080f8db5b4abbb8d4c15f0304db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the immediate children of the given packet.  <br /></td></tr>
<tr class="separator:af9177080f8db5b4abbb8d4c15f0304db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4129cb0664d21c30704a083fe8c971d" id="r_ab4129cb0664d21c30704a083fe8c971d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4129cb0664d21c30704a083fe8c971d">operator=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ab4129cb0664d21c30704a083fe8c971d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this object to iterate over the children of the same packet as the given object.  <br /></td></tr>
<tr class="separator:ab4129cb0664d21c30704a083fe8c971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7416da234efb37de5ac06ed0a27719ef" id="r_a7416da234efb37de5ac06ed0a27719ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7416da234efb37de5ac06ed0a27719ef">begin</a> () const</td></tr>
<tr class="memdesc:a7416da234efb37de5ac06ed0a27719ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator pointing to the first immediate child packet.  <br /></td></tr>
<tr class="separator:a7416da234efb37de5ac06ed0a27719ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8028a5779a3216d31c4c573cebd728" id="r_a6d8028a5779a3216d31c4c573cebd728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8028a5779a3216d31c4c573cebd728">end</a> () const</td></tr>
<tr class="memdesc:a6d8028a5779a3216d31c4c573cebd728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator pointing beyond the last immediate child packet.  <br /></td></tr>
<tr class="separator:a6d8028a5779a3216d31c4c573cebd728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08691ed72aa44c713f2c55353aa67185" id="r_a08691ed72aa44c713f2c55353aa67185"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08691ed72aa44c713f2c55353aa67185">__iter__</a> () const</td></tr>
<tr class="memdesc:a08691ed72aa44c713f2c55353aa67185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over all immediate child packets.  <br /></td></tr>
<tr class="separator:a08691ed72aa44c713f2c55353aa67185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c41d132bcf252452a4007bd754bbf" id="r_a423c41d132bcf252452a4007bd754bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a423c41d132bcf252452a4007bd754bbf">operator==</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a423c41d132bcf252452a4007bd754bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over children of the same parent packet.  <br /></td></tr>
<tr class="separator:a423c41d132bcf252452a4007bd754bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2601db337e6fb3a7c4ab832758f19c" id="r_a4e2601db337e6fb3a7c4ab832758f19c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e2601db337e6fb3a7c4ab832758f19c">operator!=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a4e2601db337e6fb3a7c4ab832758f19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over children of different parent packets.  <br /></td></tr>
<tr class="separator:a4e2601db337e6fb3a7c4ab832758f19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;bool const_&gt;<br />
class regina::PacketChildren&lt; const_ &gt;</div><p>A lightweight object that gives access to all immediate children of a given packet. </p>
<p>The purpose of this class is to support iteration through all children of a packet <em>p</em> using range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; parent = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="classregina_1_1Packet.html">Packet</a>&amp; child : parent-&gt;children()) { ... }</div>
<div class="ttc" id="aclassregina_1_1Packet_html"><div class="ttname"><a href="classregina_1_1Packet.html">regina::Packet</a></div><div class="ttdoc">Represents a packet of information that may be individually edited or operated upon.</div><div class="ttdef"><b>Definition</b> packet.h:219</div></div>
</div><!-- fragment --><p>In Python, <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> is an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> child <span class="keywordflow">in</span> parent.children():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>Each object of this class will hold a std::shared_ptr to the packet whose children it gives access to. This guarantees that the packet will not be destroyed during iteration, but it also means that you must ensure that you dispose of these objects once you are finished with them.</p>
<p>These are lightweight objects, small enough to pass by value and swap with std::swap(), with no need for any specialised move operations or swap functions. Copies of a <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> will iterate over the children of the same underlying packet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">const_</td><td>Indicates whether this iterator should offer const or non-const access to the child packets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the C++ interface described here, in Python the classes <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> and <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> together implement the Python iterable/iterator interface. The class <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> has just the single function <code><a class="el" href="#a08691ed72aa44c713f2c55353aa67185" title="Returns a Python iterator over all immediate child packets.">__iter__()</a></code>, which returns a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a>; then <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> implements <code>__next__()</code>, which either returns the next child packet in the iteration or else throws a <code>StopException</code> if there are no more children to return. All iteration in Python is non-const (i.e., Python exclusively uses the classes where <em>const_</em> is <code>false</code>). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a504cd2c92ba12dd8d1593524f7a45fa2" name="a504cd2c92ba12dd8d1593524f7a45fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504cd2c92ba12dd8d1593524f7a45fa2">&#9670;&#160;</a></span>packet_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::packet_type = std::conditional_t&lt;const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abbd1d4e4654d3d79b3c32a2234e2dedc" name="abbd1d4e4654d3d79b3c32a2234e2dedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd1d4e4654d3d79b3c32a2234e2dedc">&#9670;&#160;</a></span>PacketChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the children of the same packet as the given object. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> object is via <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>. </dd></dl>

</div>
</div>
<a id="af9177080f8db5b4abbb8d4c15f0304db" name="af9177080f8db5b4abbb8d4c15f0304db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9177080f8db5b4abbb8d4c15f0304db">&#9670;&#160;</a></span>PacketChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the immediate children of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> object is via <a class="el" href="classregina_1_1Packet.html#a24cdf3858610404e396a8e49b960bd73" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet whose children we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08691ed72aa44c713f2c55353aa67185" name="a08691ed72aa44c713f2c55353aa67185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08691ed72aa44c713f2c55353aa67185">&#9670;&#160;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::__iter__ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over all immediate child packets. </p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> provides the usual <a class="el" href="#a7416da234efb37de5ac06ed0a27719ef" title="Returns a C++ iterator pointing to the first immediate child packet.">begin()</a> and <a class="el" href="#a6d8028a5779a3216d31c4c573cebd728" title="Returns a C++ iterator pointing beyond the last immediate child packet.">end()</a> functions instead. In particular, this allows you to iterate through all immediate child packets in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over all immediate child packets. </dd></dl>

</div>
</div>
<a id="a7416da234efb37de5ac06ed0a27719ef" name="a7416da234efb37de5ac06ed0a27719ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7416da234efb37de5ac06ed0a27719ef">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator pointing to the first immediate child packet. </p>
<p>The iterator range from <a class="el" href="#a7416da234efb37de5ac06ed0a27719ef" title="Returns a C++ iterator pointing to the first immediate child packet.">begin()</a> to <a class="el" href="#a6d8028a5779a3216d31c4c573cebd728" title="Returns a C++ iterator pointing beyond the last immediate child packet.">end()</a> runs through all immediate children in order from first to last.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> implements the Python iterable interface. You can iterate over all immediate child packets in the usual Python way, by treating this <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> object as you would any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="a6d8028a5779a3216d31c4c573cebd728" name="a6d8028a5779a3216d31c4c573cebd728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8028a5779a3216d31c4c573cebd728">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator pointing beyond the last immediate child packet. </p>
<p>The iterator range from <a class="el" href="#a7416da234efb37de5ac06ed0a27719ef" title="Returns a C++ iterator pointing to the first immediate child packet.">begin()</a> to <a class="el" href="#a6d8028a5779a3216d31c4c573cebd728" title="Returns a C++ iterator pointing beyond the last immediate child packet.">end()</a> runs through all immediate children in order from first to last.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> implements the Python iterable interface. You can iterate over all immediate child packets in the usual Python way, by treating this <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> object as you would any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="a4e2601db337e6fb3a7c4ab832758f19c" name="a4e2601db337e6fb3a7c4ab832758f19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2601db337e6fb3a7c4ab832758f19c">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over children of different parent packets. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over children of different packets. </dd></dl>

</div>
</div>
<a id="ab4129cb0664d21c30704a083fe8c971d" name="ab4129cb0664d21c30704a083fe8c971d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4129cb0664d21c30704a083fe8c971d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this object to iterate over the children of the same packet as the given object. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="a423c41d132bcf252452a4007bd754bbf" name="a423c41d132bcf252452a4007bd754bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423c41d132bcf252452a4007bd754bbf">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over children of the same parent packet. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over children of the same packet. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="packet_8h.html">packet.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
