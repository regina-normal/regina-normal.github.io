<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::AbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1AbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::AbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a finitely generated abelian group.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;algebra/abeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::AbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1AbelianGroup.png" usemap="#regina::AbelianGroup_map" alt=""/>
  <map id="regina::AbelianGroup_map" name="regina::AbelianGroup_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; AbelianGroup, true &gt;" shape="rect" coords="0,56,272,80"/>
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; AbelianGroup &gt;" shape="rect" coords="282,56,554,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; AbelianGroup, supportsUtf8 &gt;" shape="rect" coords="0,0,272,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee2f2d945e506379fc2a345e156e1aca" id="r_aee2f2d945e506379fc2a345e156e1aca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee2f2d945e506379fc2a345e156e1aca">AbelianGroup</a> ()=default</td></tr>
<tr class="memdesc:aee2f2d945e506379fc2a345e156e1aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial group.  <br /></td></tr>
<tr class="separator:aee2f2d945e506379fc2a345e156e1aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe48cc46e37632284163c6cd005dfb" id="r_ac6fe48cc46e37632284163c6cd005dfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6fe48cc46e37632284163c6cd005dfb">AbelianGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:ac6fe48cc46e37632284163c6cd005dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <br /></td></tr>
<tr class="separator:ac6fe48cc46e37632284163c6cd005dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5e70bd7e57f8ab65cd40107ee822dd" id="r_a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5e70bd7e57f8ab65cd40107ee822dd">AbelianGroup</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this new group.  <br /></td></tr>
<tr class="separator:a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a992c7ac720d79f30d6d6e088763e9" id="r_a74a992c7ac720d79f30d6d6e088763e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a992c7ac720d79f30d6d6e088763e9">AbelianGroup</a> (size_t <a class="el" href="#aa1068fa5cbb12d301ef4958836646a7f">rank</a>)</td></tr>
<tr class="memdesc:a74a992c7ac720d79f30d6d6e088763e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a free abelian group of the given rank.  <br /></td></tr>
<tr class="separator:a74a992c7ac720d79f30d6d6e088763e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e39b0fbdd69953ded412e8b2910883" id="r_a05e39b0fbdd69953ded412e8b2910883"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05e39b0fbdd69953ded412e8b2910883"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05e39b0fbdd69953ded412e8b2910883">AbelianGroup</a> (size_t <a class="el" href="#aa1068fa5cbb12d301ef4958836646a7f">rank</a>, std::initializer_list&lt; T &gt; invFac)</td></tr>
<tr class="memdesc:a05e39b0fbdd69953ded412e8b2910883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new group with the given rank and invariant factors.  <br /></td></tr>
<tr class="separator:a05e39b0fbdd69953ded412e8b2910883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad0d8f1c13b23a4aebfc8ca5a62a78" id="r_a63ad0d8f1c13b23a4aebfc8ca5a62a78"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classregina_1_1Container.html">Container</a> &gt; </td></tr>
<tr class="memitem:a63ad0d8f1c13b23a4aebfc8ca5a62a78"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63ad0d8f1c13b23a4aebfc8ca5a62a78">AbelianGroup</a> (size_t <a class="el" href="#aa1068fa5cbb12d301ef4958836646a7f">rank</a>, const <a class="el" href="classregina_1_1Container.html">Container</a> &amp;invFac)</td></tr>
<tr class="memdesc:a63ad0d8f1c13b23a4aebfc8ca5a62a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new group with the given rank and invariant factors.  <br /></td></tr>
<tr class="separator:a63ad0d8f1c13b23a4aebfc8ca5a62a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791e00f5098bf6beb7bb48b6dce20050" id="r_a791e00f5098bf6beb7bb48b6dce20050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791e00f5098bf6beb7bb48b6dce20050">AbelianGroup</a> (<a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> presentation)</td></tr>
<tr class="memdesc:a791e00f5098bf6beb7bb48b6dce20050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the abelian group defined by the given presentation matrix.  <br /></td></tr>
<tr class="separator:a791e00f5098bf6beb7bb48b6dce20050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1782f02c61cfc17f669ab34f873ab3c" id="r_aa1782f02c61cfc17f669ab34f873ab3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1782f02c61cfc17f669ab34f873ab3c">AbelianGroup</a> (<a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> M, <a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> N)</td></tr>
<tr class="memdesc:aa1782f02c61cfc17f669ab34f873ab3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex.  <br /></td></tr>
<tr class="separator:aa1782f02c61cfc17f669ab34f873ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7020239c7bcbcdfbbb1da98d5195edb" id="r_ab7020239c7bcbcdfbbb1da98d5195edb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7020239c7bcbcdfbbb1da98d5195edb">AbelianGroup</a> (<a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> M, <a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> N, const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:ab7020239c7bcbcdfbbb1da98d5195edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients.  <br /></td></tr>
<tr class="separator:ab7020239c7bcbcdfbbb1da98d5195edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c67a591d2fc4871f4a5cfbeda335bb8" id="r_a0c67a591d2fc4871f4a5cfbeda335bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c67a591d2fc4871f4a5cfbeda335bb8">addRank</a> (long extraRank=1)</td></tr>
<tr class="memdesc:a0c67a591d2fc4871f4a5cfbeda335bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the rank of the group by the given integer.  <br /></td></tr>
<tr class="separator:a0c67a591d2fc4871f4a5cfbeda335bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0639c896d068034c99eb53f487b93" id="r_a70d0639c896d068034c99eb53f487b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70d0639c896d068034c99eb53f487b93">addTorsion</a> (<a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> degree)</td></tr>
<tr class="memdesc:a70d0639c896d068034c99eb53f487b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <br /></td></tr>
<tr class="separator:a70d0639c896d068034c99eb53f487b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c9b3e44af87012db52b9492e0b59b" id="r_aba8c9b3e44af87012db52b9492e0b59b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8c9b3e44af87012db52b9492e0b59b">addGroup</a> (<a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a> presentation)</td></tr>
<tr class="memdesc:aba8c9b3e44af87012db52b9492e0b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the abelian group defined by the given presentation to this group.  <br /></td></tr>
<tr class="separator:aba8c9b3e44af87012db52b9492e0b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f258af0b04c62e2de0f61df3d710509" id="r_a3f258af0b04c62e2de0f61df3d710509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f258af0b04c62e2de0f61df3d710509">addGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;group)</td></tr>
<tr class="memdesc:a3f258af0b04c62e2de0f61df3d710509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given abelian group to this group.  <br /></td></tr>
<tr class="separator:a3f258af0b04c62e2de0f61df3d710509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1068fa5cbb12d301ef4958836646a7f" id="r_aa1068fa5cbb12d301ef4958836646a7f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1068fa5cbb12d301ef4958836646a7f">rank</a> () const</td></tr>
<tr class="memdesc:aa1068fa5cbb12d301ef4958836646a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the group.  <br /></td></tr>
<tr class="separator:aa1068fa5cbb12d301ef4958836646a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2a8b34a140e7d22927f2c4e1cad6f6" id="r_a7b2a8b34a140e7d22927f2c4e1cad6f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b2a8b34a140e7d22927f2c4e1cad6f6">torsionRank</a> (const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;degree) const</td></tr>
<tr class="memdesc:a7b2a8b34a140e7d22927f2c4e1cad6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <br /></td></tr>
<tr class="separator:a7b2a8b34a140e7d22927f2c4e1cad6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef8fc0bcf6cf5f55a67c4b853527262" id="r_adef8fc0bcf6cf5f55a67c4b853527262"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef8fc0bcf6cf5f55a67c4b853527262">torsionRank</a> (unsigned long degree) const</td></tr>
<tr class="memdesc:adef8fc0bcf6cf5f55a67c4b853527262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <br /></td></tr>
<tr class="separator:adef8fc0bcf6cf5f55a67c4b853527262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7bc0b871554e7302ba01b17470fe0" id="r_a3eb7bc0b871554e7302ba01b17470fe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eb7bc0b871554e7302ba01b17470fe0">countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:a3eb7bc0b871554e7302ba01b17470fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of invariant factors that describe the torsion elements of this group.  <br /></td></tr>
<tr class="separator:a3eb7bc0b871554e7302ba01b17470fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67d3b2e704ec84b1e20555e32f4c3ed" id="r_ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67d3b2e704ec84b1e20555e32f4c3ed">invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given invariant factor describing the torsion elements of this group.  <br /></td></tr>
<tr class="separator:ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65860d714f70889df0fec507a7658f8f" id="r_a65860d714f70889df0fec507a7658f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65860d714f70889df0fec507a7658f8f">isTrivial</a> () const</td></tr>
<tr class="memdesc:a65860d714f70889df0fec507a7658f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <br /></td></tr>
<tr class="separator:a65860d714f70889df0fec507a7658f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919a9f896922a25d7c9b6e32a877471f" id="r_a919a9f896922a25d7c9b6e32a877471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a919a9f896922a25d7c9b6e32a877471f">isZ</a> () const</td></tr>
<tr class="memdesc:a919a9f896922a25d7c9b6e32a877471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <br /></td></tr>
<tr class="separator:a919a9f896922a25d7c9b6e32a877471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284eb7ddcd3a5796b6eb3ccb8db6f1a9" id="r_a284eb7ddcd3a5796b6eb3ccb8db6f1a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a284eb7ddcd3a5796b6eb3ccb8db6f1a9">isFree</a> (size_t r) const</td></tr>
<tr class="memdesc:a284eb7ddcd3a5796b6eb3ccb8db6f1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the free abelian group of the given rank.  <br /></td></tr>
<tr class="separator:a284eb7ddcd3a5796b6eb3ccb8db6f1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e39311ec2f7c786d0c8e9fe7c48219" id="r_ac5e39311ec2f7c786d0c8e9fe7c48219"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e39311ec2f7c786d0c8e9fe7c48219">isZn</a> (size_t n) const</td></tr>
<tr class="memdesc:ac5e39311ec2f7c786d0c8e9fe7c48219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the non-trivial cyclic group on the given number of elements.  <br /></td></tr>
<tr class="separator:ac5e39311ec2f7c786d0c8e9fe7c48219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ed4b87463c30c91f16059b8587522b" id="r_a87ed4b87463c30c91f16059b8587522b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87ed4b87463c30c91f16059b8587522b">operator==</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a87ed4b87463c30c91f16059b8587522b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group have identical presentations (which means they are isomorphic).  <br /></td></tr>
<tr class="separator:a87ed4b87463c30c91f16059b8587522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c5cee9a97206990fcc36ff62906b1" id="r_a654c5cee9a97206990fcc36ff62906b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a654c5cee9a97206990fcc36ff62906b1">operator!=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a654c5cee9a97206990fcc36ff62906b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group have different presentations (which means they are non-isomorphic).  <br /></td></tr>
<tr class="separator:a654c5cee9a97206990fcc36ff62906b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbdfc133bb2e81f4ec95e74049817d4" id="r_a2cbdfc133bb2e81f4ec95e74049817d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cbdfc133bb2e81f4ec95e74049817d4">operator=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:a2cbdfc133bb2e81f4ec95e74049817d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given group.  <br /></td></tr>
<tr class="separator:a2cbdfc133bb2e81f4ec95e74049817d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f96717878ee0e56cd24f20b797019a" id="r_af4f96717878ee0e56cd24f20b797019a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4f96717878ee0e56cd24f20b797019a">operator=</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:af4f96717878ee0e56cd24f20b797019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this group.  <br /></td></tr>
<tr class="separator:af4f96717878ee0e56cd24f20b797019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc7c540ed48c527365fa852a5746dc5" id="r_aafc7c540ed48c527365fa852a5746dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafc7c540ed48c527365fa852a5746dc5">swap</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aafc7c540ed48c527365fa852a5746dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given abelian group.  <br /></td></tr>
<tr class="separator:aafc7c540ed48c527365fa852a5746dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa94585fdce3980370bb8a0a10f33ce" id="r_a0fa94585fdce3980370bb8a0a10f33ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa94585fdce3980370bb8a0a10f33ce">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a0fa94585fdce3980370bb8a0a10f33ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this abelian group to the given output stream.  <br /></td></tr>
<tr class="separator:a0fa94585fdce3980370bb8a0a10f33ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd184409a580597ac709e7875355be74" id="r_afd184409a580597ac709e7875355be74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd184409a580597ac709e7875355be74">writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afd184409a580597ac709e7875355be74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this abelian group.  <br /></td></tr>
<tr class="separator:afd184409a580597ac709e7875355be74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655d3a9de8d18a136f5ca578b6cfa7b9" id="r_a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655d3a9de8d18a136f5ca578b6cfa7b9">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a98808860d27d410bc2124073cb382c29" id="r_a98808860d27d410bc2124073cb382c29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98808860d27d410bc2124073cb382c29">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a98808860d27d410bc2124073cb382c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an abelian group from its given tight encoding.  <br /></td></tr>
<tr class="separator:a98808860d27d410bc2124073cb382c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8fce88f649651e7b17eb6a1ceab58ad0" id="r_a8fce88f649651e7b17eb6a1ceab58ad0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fce88f649651e7b17eb6a1ceab58ad0">rank_</a> { 0 }</td></tr>
<tr class="memdesc:a8fce88f649651e7b17eb6a1ceab58ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of the group (the number of Z components).  <br /></td></tr>
<tr class="separator:a8fce88f649651e7b17eb6a1ceab58ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a3e9caa2736e6126399e890a836d6" id="r_ad69a3e9caa2736e6126399e890a836d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69a3e9caa2736e6126399e890a836d6">revInvFactors_</a></td></tr>
<tr class="memdesc:ad69a3e9caa2736e6126399e890a836d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.  <br /></td></tr>
<tr class="separator:ad69a3e9caa2736e6126399e890a836d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a finitely generated abelian group. </p>
<p>The torsion elements of the group are stored in terms of their invariant factors. For instance, Z_2+Z_3 will appear as Z_6, and Z_2+Z_2+Z_3 will appear as Z_2+Z_6.</p>
<p>In general the factors will appear as Z_<em>d0</em>+...+Z_<em>dn</em>, where the invariant factors <em>di</em> are all greater than 1 and satisfy <em>d0</em>|<em>d1</em>|...|<em>dn</em>. Note that this representation is unique.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo</a></b></dt><dd><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like.</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee2f2d945e506379fc2a345e156e1aca" name="aee2f2d945e506379fc2a345e156e1aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2f2d945e506379fc2a345e156e1aca">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial group. </p>

</div>
</div>
<a id="ac6fe48cc46e37632284163c6cd005dfb" name="ac6fe48cc46e37632284163c6cd005dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fe48cc46e37632284163c6cd005dfb">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>

</div>
</div>
<a id="a0c5e70bd7e57f8ab65cd40107ee822dd" name="a0c5e70bd7e57f8ab65cd40107ee822dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5e70bd7e57f8ab65cd40107ee822dd">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this new group. </p>
<p>This is a fast (constant time) operation.</p>
<p>The group that was passed will no longer be usable. </p>

</div>
</div>
<a id="a74a992c7ac720d79f30d6d6e088763e9" name="a74a992c7ac720d79f30d6d6e088763e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a992c7ac720d79f30d6d6e088763e9">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rank</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a free abelian group of the given rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05e39b0fbdd69953ded412e8b2910883" name="a05e39b0fbdd69953ded412e8b2910883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e39b0fbdd69953ded412e8b2910883">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>invFac</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new group with the given rank and invariant factors. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The invariant factors were not all greater than 1, and/or they did not satisfy the divisibily requirement (where each invariant factor must divide the one after it).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead, use the constructor that takes the invariant factors as a Python list.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>an integer type, which may be a native C++ integer type or one of Regina's own integer types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group (i.e., the number of copies of <em>Z</em>). </td></tr>
    <tr><td class="paramname">invFac</td><td>the list of invariant factors <em>d0</em>, <em>d1</em>, ..., as described in the class notes, where each invariant factor is greater than 1 and divides the invariant factor after it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63ad0d8f1c13b23a4aebfc8ca5a62a78" name="a63ad0d8f1c13b23a4aebfc8ca5a62a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ad0d8f1c13b23a4aebfc8ca5a62a78">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classregina_1_1Container.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>invFac</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new group with the given rank and invariant factors. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The invariant factors were not all greater than 1, and/or they did not satisfy the divisibily requirement (where each invariant factor must divide the one after it).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a></td><td>a container or view that supports reverse iteration via rbegin(), rend(), that has an empty() function, and whose elements may be of a native C++ integer type or one of Regina's own integer types. A suitable example might be std::vector&lt;int&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group (i.e., the number of copies of <em>Z</em>). </td></tr>
    <tr><td class="paramname">invFac</td><td>the list of invariant factors <em>d0</em>, <em>d1</em>, ..., as described in the class notes, where each invariant factor is greater than 1 and divides the invariant factor after it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a791e00f5098bf6beb7bb48b6dce20050" name="a791e00f5098bf6beb7bb48b6dce20050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791e00f5098bf6beb7bb48b6dce20050">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>presentation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the abelian group defined by the given presentation matrix. </p>
<p>Each column of the matrix represents a generator, and each row of the matrix represents a relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1782f02c61cfc17f669ab34f873ab3c" name="aa1782f02c61cfc17f669ab34f873ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1782f02c61cfc17f669ab34f873ab3c">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex. </p>
<p>The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p>The matrices should be thought of as acting on column vectors: this means that the product <code>B×A</code> applies the linear transformation <em>A</em>, then the linear transformation <em>B</em>. This is consistent (for example) with the convention that Regina uses for for multiplying permutations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M×N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7020239c7bcbcdfbbb1da98d5195edb" name="ab7020239c7bcbcdfbbb1da98d5195edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7020239c7bcbcdfbbb1da98d5195edb">&#9670;&#160;</a></span>AbelianGroup() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients. </p>
<p>The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p>The matrices should be thought of as acting on column vectors: this means that the product <code>B×A</code> applies the linear transformation <em>A</em>, then the linear transformation <em>B</em>. This is consistent (for example) with the convention that Regina uses for for multiplying permutations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M×N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">p</td><td>the modulus, which may be any Integer. Zero is interpreted as a request for integer coefficents, which will give the same result as the <a class="el" href="#aa1782f02c61cfc17f669ab34f873ab3c" title="Creates an abelian group as the homology of a chain complex.">AbelianGroup(MatrixInt, MatrixInt)</a> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f258af0b04c62e2de0f61df3d710509" name="a3f258af0b04c62e2de0f61df3d710509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f258af0b04c62e2de0f61df3d710509">&#9670;&#160;</a></span>addGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given abelian group to this group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to add to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba8c9b3e44af87012db52b9492e0b59b" name="aba8c9b3e44af87012db52b9492e0b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c9b3e44af87012db52b9492e0b59b">&#9670;&#160;</a></span>addGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gadcaf44a1a722c8132bd36b53c160bde2">MatrixInt</a></td>          <td class="paramname"><span class="paramname"><em>presentation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the abelian group defined by the given presentation to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the group to be added to this group, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c67a591d2fc4871f4a5cfbeda335bb8" name="a0c67a591d2fc4871f4a5cfbeda335bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c67a591d2fc4871f4a5cfbeda335bb8">&#9670;&#160;</a></span>addRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addRank </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>extraRank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the rank of the group by the given integer. </p>
<p>This integer may be positive, negative or zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The current rank plus the given integer is non-negative. In other words, if we are subtracting rank then we are not trying to subtract more rank than the group actually has.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraRank</td><td>the extra rank to add; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70d0639c896d068034c99eb53f487b93" name="a70d0639c896d068034c99eb53f487b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d0639c896d068034c99eb53f487b93">&#9670;&#160;</a></span>addTorsion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a></td>          <td class="paramname"><span class="paramname"><em>degree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p>As of Regina 7.0, this routine is much faster than it used to be. In particular, if you have many torsion elements to add, it is now efficient just to call <a class="el" href="#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> for each new torsion element, one at a time.</p>
<p>In this routine we add a single copy of Z_<em>d</em>, where <em>d</em> is the given degree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the new torsion element; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eb7bc0b871554e7302ba01b17470fe0" name="a3eb7bc0b871554e7302ba01b17470fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb7bc0b871554e7302ba01b17470fe0">&#9670;&#160;</a></span>countInvariantFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of invariant factors that describe the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab67d3b2e704ec84b1e20555e32f4c3ed" name="ab67d3b2e704ec84b1e20555e32f4c3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67d3b2e704ec84b1e20555e32f4c3ed">&#9670;&#160;</a></span>invariantFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp; regina::AbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given invariant factor describing the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<p>If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="#a3eb7bc0b871554e7302ba01b17470fe0" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="a284eb7ddcd3a5796b6eb3ccb8db6f1a9" name="a284eb7ddcd3a5796b6eb3ccb8db6f1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284eb7ddcd3a5796b6eb3ccb8db6f1a9">&#9670;&#160;</a></span>isFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isFree </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the free abelian group of the given rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the rank of the free abelian group that we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the free abelian group of rank <em>r</em>. </dd></dl>

</div>
</div>
<a id="a65860d714f70889df0fec507a7658f8f" name="a65860d714f70889df0fec507a7658f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65860d714f70889df0fec507a7658f8f">&#9670;&#160;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="a919a9f896922a25d7c9b6e32a877471f" name="a919a9f896922a25d7c9b6e32a877471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919a9f896922a25d7c9b6e32a877471f">&#9670;&#160;</a></span>isZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="ac5e39311ec2f7c786d0c8e9fe7c48219" name="ac5e39311ec2f7c786d0c8e9fe7c48219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e39311ec2f7c786d0c8e9fe7c48219">&#9670;&#160;</a></span>isZn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZn </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the non-trivial cyclic group on the given number of elements. </p>
<p>As a special case, if <em>n</em> = 0 then this routine will test for the infinite cyclic group (i.e., it will behave the same as <a class="el" href="#a919a9f896922a25d7c9b6e32a877471f" title="Determines whether this is the infinite cyclic group (Z).">isZ()</a>). If <em>n</em> = 1, then this routine will test for the trivial group (i.e., it will behave the same as <a class="el" href="#a65860d714f70889df0fec507a7658f8f" title="Determines whether this is the trivial (zero) group.">isTrivial()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements of the cyclic group in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the cyclic group Z_n. </dd></dl>

</div>
</div>
<a id="a654c5cee9a97206990fcc36ff62906b1" name="a654c5cee9a97206990fcc36ff62906b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654c5cee9a97206990fcc36ff62906b1">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group have different presentations (which means they are non-isomorphic). </p>
<p>Since the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class stores <em>only</em> the invariants required to identify the isomorphism type, two groups will compare as equal if and only if they are isomorphic. This is in contrast to the comparisons for <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> (which tests for identical generators and relations), or for <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> (which tests for identical chain complex presentations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have different presentations (i.e., they are non-isomorphic). </dd></dl>

</div>
</div>
<a id="af4f96717878ee0e56cd24f20b797019a" name="af4f96717878ee0e56cd24f20b797019a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f96717878ee0e56cd24f20b797019a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::AbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this group. </p>
<p>This is a fast (constant time) operation.</p>
<p>The group that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="a2cbdfc133bb2e81f4ec95e74049817d4" name="a2cbdfc133bb2e81f4ec95e74049817d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbdfc133bb2e81f4ec95e74049817d4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::AbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given group. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="a87ed4b87463c30c91f16059b8587522b" name="a87ed4b87463c30c91f16059b8587522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ed4b87463c30c91f16059b8587522b">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group have identical presentations (which means they are isomorphic). </p>
<p>Since the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class stores <em>only</em> the invariants required to identify the isomorphism type, two groups will compare as equal if and only if they are isomorphic. This is in contrast to the comparisons for <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> (which tests for identical generators and relations), or for <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> (which tests for identical chain complex presentations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have identical presentations (i.e., they are isomorphic). </dd></dl>

</div>
</div>
<a id="aa1068fa5cbb12d301ef4958836646a7f" name="aa1068fa5cbb12d301ef4958836646a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1068fa5cbb12d301ef4958836646a7f">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the group. </p>
<p>This is the number of included copies of <em>Z</em>.</p>
<p>Equivalently, the rank is the maximum number of linearly independent elements, and it indicates the size of the largest free abelian subgroup. The rank effectively ignores all torsion elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>SnapPy users should be aware that SnapPy defines rank differently. Specifically, SnapPy's <a class="el" href="#aa1068fa5cbb12d301ef4958836646a7f" title="Returns the rank of the group.">AbelianGroup.rank()</a> computation includes torsion factors also.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of included copies of <em>Z</em>. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aafc7c540ed48c527365fa852a5746dc5" name="aafc7c540ed48c527365fa852a5746dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc7c540ed48c527365fa852a5746dc5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given abelian group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98808860d27d410bc2124073cb382c29" name="a98808860d27d410bc2124073cb382c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98808860d27d410bc2124073cb382c29">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::AbelianGroup::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an abelian group from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of an abelian group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for an abelian group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the abelian group represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a0fa94585fdce3980370bb8a0a10f33ce" name="a0fa94585fdce3980370bb8a0a10f33ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa94585fdce3980370bb8a0a10f33ce">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this abelian group to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a7b2a8b34a140e7d22927f2c4e1cad6f6" name="a7b2a8b34a140e7d22927f2c4e1cad6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2a8b34a140e7d22927f2c4e1cad6f6">&#9670;&#160;</a></span>torsionRank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>degree</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="adef8fc0bcf6cf5f55a67c4b853527262" name="adef8fc0bcf6cf5f55a67c4b853527262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef8fc0bcf6cf5f55a67c4b853527262">&#9670;&#160;</a></span>torsionRank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>degree</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a655d3a9de8d18a136f5ca578b6cfa7b9" name="a655d3a9de8d18a136f5ca578b6cfa7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655d3a9de8d18a136f5ca578b6cfa7b9">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>utf8</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> or <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd184409a580597ac709e7875355be74" name="afd184409a580597ac709e7875355be74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd184409a580597ac709e7875355be74">&#9670;&#160;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this abelian group. </p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8fce88f649651e7b17eb6a1ceab58ad0" name="a8fce88f649651e7b17eb6a1ceab58ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fce88f649651e7b17eb6a1ceab58ad0">&#9670;&#160;</a></span>rank_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::rank_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank of the group (the number of Z components). </p>

</div>
</div>
<a id="ad69a3e9caa2736e6126399e890a836d6" name="ad69a3e9caa2736e6126399e890a836d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69a3e9caa2736e6126399e890a836d6">&#9670;&#160;</a></span>revInvFactors_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga6ea6ee3343b36485a2ffcc441e7e17ac">Integer</a>&gt; regina::AbelianGroup::revInvFactors_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes. </p>
<p>These are stored in reverse order, since <a class="el" href="#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> always extends the vector on the <em>d0</em> end. Note that we cannot use std::deque (which does support pushing to the front), since older gcc versions do not have a noexcept std::deque move constructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="abeliangroup_8h.html">abeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
