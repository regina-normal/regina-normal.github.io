<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::FacetSpec&lt; dim &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structregina_1_1FacetSpec-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::FacetSpec&lt; dim &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__triangulation.html">Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A lightweight class used to refer to a particular facet of a particular top-dimensional simplex in a <em>dim</em>-dimensional triangulation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/facetspec.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::FacetSpec&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structregina_1_1FacetSpec.png" usemap="#regina::FacetSpec_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::FacetSpec_3C_20dim_20_3E_map" name="regina::FacetSpec_3C_20dim_20_3E_map">
<area href="structregina_1_1TightEncodable.html" alt="regina::TightEncodable&lt; FacetSpec&lt; dim &gt; &gt;" shape="rect" coords="0,0,269,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbe0fc7bef712f6fd57a28d00c8946a8" id="r_acbe0fc7bef712f6fd57a28d00c8946a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbe0fc7bef712f6fd57a28d00c8946a8">FacetSpec</a> ()=default</td></tr>
<tr class="memdesc:acbe0fc7bef712f6fd57a28d00c8946a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier with no initialisation.  <br /></td></tr>
<tr class="separator:acbe0fc7bef712f6fd57a28d00c8946a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd231c3352acd4b50ed5e8e6e3b027c5" id="r_abd231c3352acd4b50ed5e8e6e3b027c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd231c3352acd4b50ed5e8e6e3b027c5">FacetSpec</a> (ssize_t newSimp, int newFacet)</td></tr>
<tr class="memdesc:abd231c3352acd4b50ed5e8e6e3b027c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier referring to the given facet of the given simplex.  <br /></td></tr>
<tr class="separator:abd231c3352acd4b50ed5e8e6e3b027c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7af8dcff95510cb4056ecf0739ce1d" id="r_a8d7af8dcff95510cb4056ecf0739ce1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7af8dcff95510cb4056ecf0739ce1d">FacetSpec</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;cloneMe)=default</td></tr>
<tr class="memdesc:a8d7af8dcff95510cb4056ecf0739ce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new specifier referring to the same simplex facet as the given specifier.  <br /></td></tr>
<tr class="separator:a8d7af8dcff95510cb4056ecf0739ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f49fbc941f1150c7109c7b2aedfe08" id="r_aa8f49fbc941f1150c7109c7b2aedfe08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f49fbc941f1150c7109c7b2aedfe08">isBoundary</a> (size_t nSimplices) const</td></tr>
<tr class="memdesc:aa8f49fbc941f1150c7109c7b2aedfe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents the overall boundary.  <br /></td></tr>
<tr class="separator:aa8f49fbc941f1150c7109c7b2aedfe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86c41b32df4f5750ffc36d1ddf3968" id="r_aba86c41b32df4f5750ffc36d1ddf3968"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba86c41b32df4f5750ffc36d1ddf3968">isBeforeStart</a> () const</td></tr>
<tr class="memdesc:aba86c41b32df4f5750ffc36d1ddf3968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents a before-the-start value.  <br /></td></tr>
<tr class="separator:aba86c41b32df4f5750ffc36d1ddf3968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b515966451ca7408c09c32a497fbb" id="r_a921b515966451ca7408c09c32a497fbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a921b515966451ca7408c09c32a497fbb">isPastEnd</a> (size_t nSimplices, bool boundaryAlso) const</td></tr>
<tr class="memdesc:a921b515966451ca7408c09c32a497fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this specifier represents a past-the-end value.  <br /></td></tr>
<tr class="separator:a921b515966451ca7408c09c32a497fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee2bae3a73929183a3ff2684500b57" id="r_a4cee2bae3a73929183a3ff2684500b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cee2bae3a73929183a3ff2684500b57">setFirst</a> ()</td></tr>
<tr class="memdesc:a4cee2bae3a73929183a3ff2684500b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the first facet of the first simplex.  <br /></td></tr>
<tr class="separator:a4cee2bae3a73929183a3ff2684500b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef773e92a8bb7deb185cd5a9bdaad44c" id="r_aef773e92a8bb7deb185cd5a9bdaad44c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef773e92a8bb7deb185cd5a9bdaad44c">setBoundary</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:aef773e92a8bb7deb185cd5a9bdaad44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the overall boundary.  <br /></td></tr>
<tr class="separator:aef773e92a8bb7deb185cd5a9bdaad44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488b419491ef1fdc272ae194371b3014" id="r_a488b419491ef1fdc272ae194371b3014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488b419491ef1fdc272ae194371b3014">setBeforeStart</a> ()</td></tr>
<tr class="memdesc:a488b419491ef1fdc272ae194371b3014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to before-the-start.  <br /></td></tr>
<tr class="separator:a488b419491ef1fdc272ae194371b3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add803a508697b9c808b40a3238b677e6" id="r_add803a508697b9c808b40a3238b677e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add803a508697b9c808b40a3238b677e6">setPastEnd</a> (size_t nSimplices)</td></tr>
<tr class="memdesc:add803a508697b9c808b40a3238b677e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to past-the-end.  <br /></td></tr>
<tr class="separator:add803a508697b9c808b40a3238b677e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7aa2cc1dae84954b6f3f4911286fa8" id="r_a0a7aa2cc1dae84954b6f3f4911286fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a7aa2cc1dae84954b6f3f4911286fa8">operator=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other)=default</td></tr>
<tr class="memdesc:a0a7aa2cc1dae84954b6f3f4911286fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this specifier to the value of the given specifier.  <br /></td></tr>
<tr class="separator:a0a7aa2cc1dae84954b6f3f4911286fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572447ee1d803cbeb4a7fea712df837d" id="r_a572447ee1d803cbeb4a7fea712df837d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572447ee1d803cbeb4a7fea712df837d">operator++</a> ()</td></tr>
<tr class="memdesc:a572447ee1d803cbeb4a7fea712df837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this specifier.  <br /></td></tr>
<tr class="separator:a572447ee1d803cbeb4a7fea712df837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1eb127387295a5e50e5f7e0ee979860" id="r_af1eb127387295a5e50e5f7e0ee979860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1eb127387295a5e50e5f7e0ee979860">operator++</a> (int)</td></tr>
<tr class="memdesc:af1eb127387295a5e50e5f7e0ee979860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments this specifier.  <br /></td></tr>
<tr class="separator:af1eb127387295a5e50e5f7e0ee979860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54580334365153f454be61d07c69a817" id="r_a54580334365153f454be61d07c69a817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54580334365153f454be61d07c69a817">operator--</a> ()</td></tr>
<tr class="memdesc:a54580334365153f454be61d07c69a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this specifier.  <br /></td></tr>
<tr class="separator:a54580334365153f454be61d07c69a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefeb4f4f4b195476519ff4e4bb215a6" id="r_aeefeb4f4f4b195476519ff4e4bb215a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeefeb4f4f4b195476519ff4e4bb215a6">operator--</a> (int)</td></tr>
<tr class="memdesc:aeefeb4f4f4b195476519ff4e4bb215a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements this specifier.  <br /></td></tr>
<tr class="separator:aeefeb4f4f4b195476519ff4e4bb215a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748faf43c3c94c3e035cb77d34d5dd9f" id="r_a748faf43c3c94c3e035cb77d34d5dd9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a748faf43c3c94c3e035cb77d34d5dd9f">operator==</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a748faf43c3c94c3e035cb77d34d5dd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given specifier are identical.  <br /></td></tr>
<tr class="separator:a748faf43c3c94c3e035cb77d34d5dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44f091e013edb34324aa69ef149cba1" id="r_aa44f091e013edb34324aa69ef149cba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44f091e013edb34324aa69ef149cba1">operator!=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa44f091e013edb34324aa69ef149cba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given specifier are not identical.  <br /></td></tr>
<tr class="separator:aa44f091e013edb34324aa69ef149cba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b03ac5fffd3a8096fb38a8a0463a8" id="r_a171b03ac5fffd3a8096fb38a8a0463a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171b03ac5fffd3a8096fb38a8a0463a8">operator&lt;</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a171b03ac5fffd3a8096fb38a8a0463a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than the given specifier.  <br /></td></tr>
<tr class="separator:a171b03ac5fffd3a8096fb38a8a0463a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0477f547607c4b7011f33c098953d8e8" id="r_a0477f547607c4b7011f33c098953d8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0477f547607c4b7011f33c098953d8e8">operator&lt;=</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a0477f547607c4b7011f33c098953d8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is less than or equal to the given specifier.  <br /></td></tr>
<tr class="separator:a0477f547607c4b7011f33c098953d8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a65fd73654f462d579357678c80d0a1" id="r_a8a65fd73654f462d579357678c80d0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a65fd73654f462d579357678c80d0a1">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a8a65fd73654f462d579357678c80d0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this specifier to the given output stream.  <br /></td></tr>
<tr class="separator:a8a65fd73654f462d579357678c80d0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea94b16da6b000a1e3623208e0e6d2d" id="r_a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this object.  <br /></td></tr>
<tr class="separator:a8ea94b16da6b000a1e3623208e0e6d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a088ad2d280336661f6aed514edc8904a" id="r_a088ad2d280336661f6aed514edc8904a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a088ad2d280336661f6aed514edc8904a">tightDecode</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a088ad2d280336661f6aed514edc8904a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a specifier from its given tight encoding.  <br /></td></tr>
<tr class="separator:a088ad2d280336661f6aed514edc8904a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89098c7baa3ee0c85febe15d779fbc9c" id="r_a89098c7baa3ee0c85febe15d779fbc9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding</a> (const std::string &amp;enc)</td></tr>
<tr class="memdesc:a89098c7baa3ee0c85febe15d779fbc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an object of type <em>T</em> from its given tight encoding.  <br /></td></tr>
<tr class="separator:a89098c7baa3ee0c85febe15d779fbc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a222da77f26f79f1dbc57fcfc7eef8178" id="r_a222da77f26f79f1dbc57fcfc7eef8178"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a222da77f26f79f1dbc57fcfc7eef8178">simp</a></td></tr>
<tr class="memdesc:a222da77f26f79f1dbc57fcfc7eef8178"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplex referred to.  <br /></td></tr>
<tr class="separator:a222da77f26f79f1dbc57fcfc7eef8178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a68d576c23c475c65a9a4b2aef7ff95" id="r_a5a68d576c23c475c65a9a4b2aef7ff95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a68d576c23c475c65a9a4b2aef7ff95">facet</a></td></tr>
<tr class="memdesc:a5a68d576c23c475c65a9a4b2aef7ff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet of the simplex referred to.  <br /></td></tr>
<tr class="separator:a5a68d576c23c475c65a9a4b2aef7ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
struct regina::FacetSpec&lt; dim &gt;</div><p>A lightweight class used to refer to a particular facet of a particular top-dimensional simplex in a <em>dim</em>-dimensional triangulation. </p>
<p>Only the simplex index and the facet number are stored.</p>
<p>Facilities are provided for iterating through simplex facets. With this in mind, it is also possible to represent the overall boundary, a past-the-end value and a before-the-start value.</p>
<p>When iterating through the simplex facets, the facets will be ordered first by simplex index and then by facet number. The overall boundary appears after all other simplex facets.</p>
<p>If there are <em>n</em> simplices, the simplices will be numbered from 0 to <em>n</em>-1 inclusive. The boundary will be represented as simplex <em>n</em>, facet 0. The past-the-end value will be represented as simplex <em>n</em>, facet 1, and the before-the-start value will be represented as simplex -1, facet <em>dim</em>.</p>
<p>These objects are small enough to pass by value and swap with std::swap(), with no need for any specialised move operations or swap functions.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., FacetSpec2 and FacetSpec3 for dimensions 2 and 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbe0fc7bef712f6fd57a28d00c8946a8" name="acbe0fc7bef712f6fd57a28d00c8946a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe0fc7bef712f6fd57a28d00c8946a8">&#9670;&#160;</a></span>FacetSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::FacetSpec </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier with no initialisation. </p>
<p>This specifier must be initialised before it is used. </p>

</div>
</div>
<a id="abd231c3352acd4b50ed5e8e6e3b027c5" name="abd231c3352acd4b50ed5e8e6e3b027c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd231c3352acd4b50ed5e8e6e3b027c5">&#9670;&#160;</a></span>FacetSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::FacetSpec </td>
          <td>(</td>
          <td class="paramtype">ssize_t</td>          <td class="paramname"><span class="paramname"><em>newSimp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newFacet</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier referring to the given facet of the given simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSimp</td><td>the given simplex; see the class notes for allowable values of this parameter. </td></tr>
    <tr><td class="paramname">newFacet</td><td>the given facet; this should be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7af8dcff95510cb4056ecf0739ce1d" name="a8d7af8dcff95510cb4056ecf0739ce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7af8dcff95510cb4056ecf0739ce1d">&#9670;&#160;</a></span>FacetSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::FacetSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cloneMe</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new specifier referring to the same simplex facet as the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the specifier to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba86c41b32df4f5750ffc36d1ddf3968" name="aba86c41b32df4f5750ffc36d1ddf3968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86c41b32df4f5750ffc36d1ddf3968">&#9670;&#160;</a></span>isBeforeStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isBeforeStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents a before-the-start value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier is before-the-start. </dd></dl>

</div>
</div>
<a id="aa8f49fbc941f1150c7109c7b2aedfe08" name="aa8f49fbc941f1150c7109c7b2aedfe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f49fbc941f1150c7109c7b2aedfe08">&#9670;&#160;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isBoundary </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents the overall boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that the boundary is represented in this specifier as simplex <em>nSimplices</em>, facet 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier represents the overall boundary. </dd></dl>

</div>
</div>
<a id="a921b515966451ca7408c09c32a497fbb" name="a921b515966451ca7408c09c32a497fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921b515966451ca7408c09c32a497fbb">&#9670;&#160;</a></span>isPastEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::isPastEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundaryAlso</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this specifier represents a past-the-end value. </p>
<p>You can optionally declare the overall boundary to be past-the-end as well as the already predefined past-the-end value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that past-the-end is represented in this specifier as simplex <em>nSimplices</em>, facet 1. </td></tr>
    <tr><td class="paramname">boundaryAlso</td><td><code>true</code> if the overall boundary should be considered past-the-end in addition to the predefined past-the-end value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this specifier is past-the-end. </dd></dl>

</div>
</div>
<a id="aa44f091e013edb34324aa69ef149cba1" name="aa44f091e013edb34324aa69ef149cba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44f091e013edb34324aa69ef149cba1">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given specifier are not identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given specifier are not equal. </dd></dl>

</div>
</div>
<a id="a572447ee1d803cbeb4a7fea712df837d" name="a572447ee1d803cbeb4a7fea712df837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572447ee1d803cbeb4a7fea712df837d">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments this specifier. </p>
<p>It will be changed to point to the next simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. The postincrement operator is present in Python as the member function inc().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this specifier. </dd></dl>

</div>
</div>
<a id="af1eb127387295a5e50e5f7e0ee979860" name="af1eb127387295a5e50e5f7e0ee979860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1eb127387295a5e50e5f7e0ee979860">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments this specifier. </p>
<p>It will be changed to point to the next simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is named inc() since python does not support the increment operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this specifier before it was incremented. </dd></dl>

</div>
</div>
<a id="a54580334365153f454be61d07c69a817" name="a54580334365153f454be61d07c69a817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54580334365153f454be61d07c69a817">&#9670;&#160;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements this specifier. </p>
<p>It will be changed to point to the previous simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not before-the-start.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. The postdecrement operator is present in Python as the member function dec().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this specifier. </dd></dl>

</div>
</div>
<a id="aeefeb4f4f4b195476519ff4e4bb215a6" name="aeefeb4f4f4b195476519ff4e4bb215a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefeb4f4f4b195476519ff4e4bb215a6">&#9670;&#160;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements this specifier. </p>
<p>It will be changed to point to the previous simplex facet.</p>
<p>Facets are ordered first by simplex index and then by facet number. The overall boundary appears after all other facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This specifier is not before-the-start.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is named dec() since python does not support the decrement operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this specifier before it was decremented. </dd></dl>

</div>
</div>
<a id="a171b03ac5fffd3a8096fb38a8a0463a8" name="a171b03ac5fffd3a8096fb38a8a0463a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171b03ac5fffd3a8096fb38a8a0463a8">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than the given specifier. </dd></dl>

</div>
</div>
<a id="a0477f547607c4b7011f33c098953d8e8" name="a0477f547607c4b7011f33c098953d8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0477f547607c4b7011f33c098953d8e8">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is less than or equal to the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than or equal to the given specifier. </dd></dl>

</div>
</div>
<a id="a0a7aa2cc1dae84954b6f3f4911286fa8" name="a0a7aa2cc1dae84954b6f3f4911286fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7aa2cc1dae84954b6f3f4911286fa8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a> &amp; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the value of the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the given specifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this specifier. </dd></dl>

</div>
</div>
<a id="a748faf43c3c94c3e035cb77d34d5dd9f" name="a748faf43c3c94c3e035cb77d34d5dd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748faf43c3c94c3e035cb77d34d5dd9f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given specifier are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given specifier are equal. </dd></dl>

</div>
</div>
<a id="a488b419491ef1fdc272ae194371b3014" name="a488b419491ef1fdc272ae194371b3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488b419491ef1fdc272ae194371b3014">&#9670;&#160;</a></span>setBeforeStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setBeforeStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to before-the-start. </p>

</div>
</div>
<a id="aef773e92a8bb7deb185cd5a9bdaad44c" name="aef773e92a8bb7deb185cd5a9bdaad44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef773e92a8bb7deb185cd5a9bdaad44c">&#9670;&#160;</a></span>setBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setBoundary </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the overall boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that the boundary is represented in this specifier as simplex <em>nSimplices</em>, facet 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cee2bae3a73929183a3ff2684500b57" name="a4cee2bae3a73929183a3ff2684500b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cee2bae3a73929183a3ff2684500b57">&#9670;&#160;</a></span>setFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setFirst </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to the first facet of the first simplex. </p>

</div>
</div>
<a id="add803a508697b9c808b40a3238b677e6" name="add803a508697b9c808b40a3238b677e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add803a508697b9c808b40a3238b677e6">&#9670;&#160;</a></span>setPastEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::setPastEnd </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nSimplices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this specifier to past-the-end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices under consideration. Note that past-the-end is represented in this specifier as simplex <em>nSimplices</em>, facet 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a088ad2d280336661f6aed514edc8904a" name="a088ad2d280336661f6aed514edc8904a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088ad2d280336661f6aed514edc8904a">&#9670;&#160;</a></span>tightDecode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::tightDecode </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a specifier from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<p>Before-the-start, past-the-end and boundary specifiers can all be safely reconstructed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>The given input stream does not begin with a tight encoding of a <em>dim</em>-dimensional facet specifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a89098c7baa3ee0c85febe15d779fbc9c">tightDecoding()</a> instead, which takes a string as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with the tight encoding for a <em>dim</em>-dimensional facet specifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specifier represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a89098c7baa3ee0c85febe15d779fbc9c" name="a89098c7baa3ee0c85febe15d779fbc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89098c7baa3ee0c85febe15d779fbc9c">&#9670;&#160;</a></span>tightDecoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &gt;::tightDecoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an object of type <em>T</em> from its given tight encoding. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>The tight encoding should be given as a string. If this string contains leading whitespace or any trailing characters at all (including trailing whitespace), then it will be treated as an invalid encoding (i.e., this routine will throw an exception).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given string is not a tight encoding of an object of type <em>T</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the tight encoding for an object of type <em>T</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="a8a65fd73654f462d579357678c80d0a1" name="a8a65fd73654f462d579357678c80d0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a65fd73654f462d579357678c80d0a1">&#9670;&#160;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this specifier to the given output stream. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p>Before-the-start, past-the-end and boundary specifiers can all be safely encoded.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1TightEncodable.html#a8ea94b16da6b000a1e3623208e0e6d2d">tightEncoding()</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea94b16da6b000a1e3623208e0e6d2d" name="a8ea94b16da6b000a1e3623208e0e6d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea94b16da6b000a1e3623208e0e6d2d">&#9670;&#160;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable</a>&lt; <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &gt;::tightEncoding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this object. </p>
<p>See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This may be thrown for some classes <em>T</em> if the object is in an invalid state. If this is possible, then a more detailed explanation of "invalid" can be found in the class documentation for <em>T</em>, under the member function T::tightEncode(). See <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a478f4145c9bae5e952359db1cf24b236" title="Writes the tight encoding of this facet pairing to the given output stream.">FacetPairing::tightEncode()</a> for an example of this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5a68d576c23c475c65a9a4b2aef7ff95" name="a5a68d576c23c475c65a9a4b2aef7ff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a68d576c23c475c65a9a4b2aef7ff95">&#9670;&#160;</a></span>facet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::facet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The facet of the simplex referred to. </p>
<p>The facet number is between 0 and <em>dim</em> inclusive. </p>

</div>
</div>
<a id="a222da77f26f79f1dbc57fcfc7eef8178" name="a222da77f26f79f1dbc57fcfc7eef8178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222da77f26f79f1dbc57fcfc7eef8178">&#9670;&#160;</a></span>simp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="structregina_1_1FacetSpec.html">regina::FacetSpec</a>&lt; dim &gt;::simp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The simplex referred to. </p>
<p>Simplex numbering begins at 0. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>triangulation/<a class="el" href="cut_8h.html">cut.h</a></li>
<li>triangulation/<a class="el" href="facetspec_8h.html">facetspec.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
