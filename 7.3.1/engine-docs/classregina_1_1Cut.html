<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::Cut Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Cut.html">Cut</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1Cut-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Cut Class Reference<div class="ingroups"><a class="el" href="group__triangulation.html">Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A cut that separates a triangulation or facet pairing into two pieces.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;triangulation/cut.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Cut:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Cut.png" usemap="#regina::Cut_map" alt=""/>
  <map id="regina::Cut_map" name="regina::Cut_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Cut &gt;" shape="rect" coords="0,56,170,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Cut, false &gt;" shape="rect" coords="0,0,170,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3683e87a1e5d3da9913db6061d7ea866" id="r_a3683e87a1e5d3da9913db6061d7ea866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3683e87a1e5d3da9913db6061d7ea866">Cut</a> (size_t <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f">size</a>)</td></tr>
<tr class="memdesc:a3683e87a1e5d3da9913db6061d7ea866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial cut on the given number of top-dimensional simplices.  <br /></td></tr>
<tr class="separator:a3683e87a1e5d3da9913db6061d7ea866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9432c97ad100a11b81eee1a8a74026" id="r_aea9432c97ad100a11b81eee1a8a74026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9432c97ad100a11b81eee1a8a74026">Cut</a> (size_t side0, size_t side1)</td></tr>
<tr class="memdesc:aea9432c97ad100a11b81eee1a8a74026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new cut with the given partition sizes.  <br /></td></tr>
<tr class="separator:aea9432c97ad100a11b81eee1a8a74026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4265fa8f45ec3a4001832cda9fdb596a" id="r_a4265fa8f45ec3a4001832cda9fdb596a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4265fa8f45ec3a4001832cda9fdb596a">Cut</a> (const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;src)</td></tr>
<tr class="memdesc:a4265fa8f45ec3a4001832cda9fdb596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given cut.  <br /></td></tr>
<tr class="separator:a4265fa8f45ec3a4001832cda9fdb596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aefcc1afcf165b5e2ae0a6cb5b84cb" id="r_a13aefcc1afcf165b5e2ae0a6cb5b84cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13aefcc1afcf165b5e2ae0a6cb5b84cb">Cut</a> (<a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a13aefcc1afcf165b5e2ae0a6cb5b84cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given cut into this new cut.  <br /></td></tr>
<tr class="separator:a13aefcc1afcf165b5e2ae0a6cb5b84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838236bff4191b0fc7328d0f35d6b746" id="r_a838236bff4191b0fc7328d0f35d6b746"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:a838236bff4191b0fc7328d0f35d6b746"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a838236bff4191b0fc7328d0f35d6b746">Cut</a> (iterator begin, iterator end)</td></tr>
<tr class="memdesc:a838236bff4191b0fc7328d0f35d6b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new cut using the given partition.  <br /></td></tr>
<tr class="separator:a838236bff4191b0fc7328d0f35d6b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea26e96c346dbee1e0a34c67dc0fe321" id="r_aea26e96c346dbee1e0a34c67dc0fe321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea26e96c346dbee1e0a34c67dc0fe321">~Cut</a> ()</td></tr>
<tr class="memdesc:aea26e96c346dbee1e0a34c67dc0fe321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this cut.  <br /></td></tr>
<tr class="separator:aea26e96c346dbee1e0a34c67dc0fe321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b32d36fe70c2f9b89318d87170a4f" id="r_ad49b32d36fe70c2f9b89318d87170a4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f">size</a> () const</td></tr>
<tr class="memdesc:ad49b32d36fe70c2f9b89318d87170a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairing.  <br /></td></tr>
<tr class="separator:ad49b32d36fe70c2f9b89318d87170a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a9e7428da63e421260b372a366cb87" id="r_a95a9e7428da63e421260b372a366cb87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95a9e7428da63e421260b372a366cb87">size</a> (int whichSide) const</td></tr>
<tr class="memdesc:a95a9e7428da63e421260b372a366cb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of top-dimensional simplices on the given side of the partition described by this cut.  <br /></td></tr>
<tr class="separator:a95a9e7428da63e421260b372a366cb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60f7a9c78146a48cfba544533f4b0a1" id="r_af60f7a9c78146a48cfba544533f4b0a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af60f7a9c78146a48cfba544533f4b0a1">side</a> (size_t simplex) const</td></tr>
<tr class="memdesc:af60f7a9c78146a48cfba544533f4b0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which side of the partition the given simplex lies on.  <br /></td></tr>
<tr class="separator:af60f7a9c78146a48cfba544533f4b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee93a57ffe375b32f7ee23d9ba6bb70" id="r_a1ee93a57ffe375b32f7ee23d9ba6bb70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee93a57ffe375b32f7ee23d9ba6bb70">set</a> (size_t simplex, int newSide)</td></tr>
<tr class="memdesc:a1ee93a57ffe375b32f7ee23d9ba6bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set which side of the partition the given simplex lies on.  <br /></td></tr>
<tr class="separator:a1ee93a57ffe375b32f7ee23d9ba6bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd77a385e869f5f30e417042c70f1b97" id="r_abd77a385e869f5f30e417042c70f1b97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd77a385e869f5f30e417042c70f1b97">isTrivial</a> () const</td></tr>
<tr class="memdesc:abd77a385e869f5f30e417042c70f1b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this cut places all top-dimensional simplices on the same side of the partition.  <br /></td></tr>
<tr class="separator:abd77a385e869f5f30e417042c70f1b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd7571f30316d24ed3c33fa05491c89" id="r_a0bd7571f30316d24ed3c33fa05491c89"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0bd7571f30316d24ed3c33fa05491c89"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bd7571f30316d24ed3c33fa05491c89">weight</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:a0bd7571f30316d24ed3c33fa05491c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight of this cut with respect to the dual graph of the given triangulation.  <br /></td></tr>
<tr class="separator:a0bd7571f30316d24ed3c33fa05491c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e922135ad89582d646d0929ad6d9b" id="r_a6f0e922135ad89582d646d0929ad6d9b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6f0e922135ad89582d646d0929ad6d9b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f0e922135ad89582d646d0929ad6d9b">weight</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;pairing) const</td></tr>
<tr class="memdesc:a6f0e922135ad89582d646d0929ad6d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight of this cut with respect to the given facet pairing.  <br /></td></tr>
<tr class="separator:a6f0e922135ad89582d646d0929ad6d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f491b2632aeee5d2e804cb218c0541" id="r_ad6f491b2632aeee5d2e804cb218c0541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f491b2632aeee5d2e804cb218c0541">operator=</a> (const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;src)</td></tr>
<tr class="memdesc:ad6f491b2632aeee5d2e804cb218c0541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given cut.  <br /></td></tr>
<tr class="separator:ad6f491b2632aeee5d2e804cb218c0541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4fb4e4b42b109c4988e91e515c2f71" id="r_a4d4fb4e4b42b109c4988e91e515c2f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d4fb4e4b42b109c4988e91e515c2f71">operator=</a> (<a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a4d4fb4e4b42b109c4988e91e515c2f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given cut into this cut.  <br /></td></tr>
<tr class="separator:a4d4fb4e4b42b109c4988e91e515c2f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d5e38746a195f63d582072b633a343" id="r_a79d5e38746a195f63d582072b633a343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79d5e38746a195f63d582072b633a343">swap</a> (<a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a79d5e38746a195f63d582072b633a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given cut.  <br /></td></tr>
<tr class="separator:a79d5e38746a195f63d582072b633a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd1999b1e5e52096fb557f2f5f27e6" id="r_a54bd1999b1e5e52096fb557f2f5f27e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bd1999b1e5e52096fb557f2f5f27e6">operator==</a> (const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a54bd1999b1e5e52096fb557f2f5f27e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given cut are identical.  <br /></td></tr>
<tr class="separator:a54bd1999b1e5e52096fb557f2f5f27e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75245d19442d3d9d17be7c9f91984fd9" id="r_a75245d19442d3d9d17be7c9f91984fd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75245d19442d3d9d17be7c9f91984fd9">operator!=</a> (const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a75245d19442d3d9d17be7c9f91984fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given cut are different.  <br /></td></tr>
<tr class="separator:a75245d19442d3d9d17be7c9f91984fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc8c836cc3a7f268a7dc6cb5633b55f" id="r_a1bc8c836cc3a7f268a7dc6cb5633b55f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1bc8c836cc3a7f268a7dc6cb5633b55f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bc8c836cc3a7f268a7dc6cb5633b55f">operator()</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:a1bc8c836cc3a7f268a7dc6cb5633b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the given triangulation using this cut.  <br /></td></tr>
<tr class="separator:a1bc8c836cc3a7f268a7dc6cb5633b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c310ec2f911b5ced072c3d080b01ae" id="r_a80c310ec2f911b5ced072c3d080b01ae"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a80c310ec2f911b5ced072c3d080b01ae"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80c310ec2f911b5ced072c3d080b01ae">operator()</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;pairing) const</td></tr>
<tr class="memdesc:a80c310ec2f911b5ced072c3d080b01ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the given facet pairing using this cut.  <br /></td></tr>
<tr class="separator:a80c310ec2f911b5ced072c3d080b01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8958da08b165462509bb7841a14b799" id="r_ae8958da08b165462509bb7841a14b799"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae8958da08b165462509bb7841a14b799"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8958da08b165462509bb7841a14b799">inclusion</a> () const</td></tr>
<tr class="memdesc:ae8958da08b165462509bb7841a14b799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relationships between simplex numbers before and after this cut is used to partition a triangulation or facet pairing into two pieces.  <br /></td></tr>
<tr class="separator:ae8958da08b165462509bb7841a14b799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae41594d8da932008635a7bfcd150688" id="r_aae41594d8da932008635a7bfcd150688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae41594d8da932008635a7bfcd150688">inc</a> ()</td></tr>
<tr class="memdesc:aae41594d8da932008635a7bfcd150688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into the next cut of the same size.  <br /></td></tr>
<tr class="separator:aae41594d8da932008635a7bfcd150688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c57bae84f8f0cc45b9068aff20d6e9d" id="r_a1c57bae84f8f0cc45b9068aff20d6e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c57bae84f8f0cc45b9068aff20d6e9d">incFixedSizes</a> ()</td></tr>
<tr class="memdesc:a1c57bae84f8f0cc45b9068aff20d6e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into the next cut with the same partition sizes.  <br /></td></tr>
<tr class="separator:a1c57bae84f8f0cc45b9068aff20d6e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcec89f9b13a25a309a17a72ef24814" id="r_acbcec89f9b13a25a309a17a72ef24814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbcec89f9b13a25a309a17a72ef24814">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:acbcec89f9b13a25a309a17a72ef24814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:acbcec89f9b13a25a309a17a72ef24814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cut that separates a triangulation or facet pairing into two pieces. </p>
<p>This is essentially the same concept as a cut in graph theory.</p>
<p>Specifically, a <em>cut</em> in a triangulation or facet pairing partitions the top-dimensional simplices into two <em>sides</em>. This effectively splits the triangulation or facet pairing into two pieces, by removing all gluings between simplices on opposite sides. The two sides of a cut are numbered 0 and 1.</p>
<p>In Regina, a cut has a <em>size</em> and a <em>weight:</em></p>
<ul>
<li>The <em>size</em> refers to the size of the underlying triangulation or facet pairing (i.e., it indicates the total number of top-dimensional simplices).</li>
<li>The <em>weight</em> refers to the number of gluings that are undone by the cut. This is the usual concept of weight from graph theory (i.e., the number of edges in the underlying graph that cross the partition).</li>
</ul>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3683e87a1e5d3da9913db6061d7ea866" name="a3683e87a1e5d3da9913db6061d7ea866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3683e87a1e5d3da9913db6061d7ea866">&#9670;&#160;</a></span>Cut() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::Cut </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial cut on the given number of top-dimensional simplices. </p>
<p>All simplices will be on side 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of top-dimensional simplices in the underlying triangulation or facet pairing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9432c97ad100a11b81eee1a8a74026" name="aea9432c97ad100a11b81eee1a8a74026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9432c97ad100a11b81eee1a8a74026">&#9670;&#160;</a></span>Cut() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::Cut </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>side0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>side1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new cut with the given partition sizes. </p>
<p>The total number of top-dimensional simplices under consideration will be (<em>side0</em> + <em>side1</em>); the first <em>side0</em> simplices will be on side 0, and the remaining <em>side1</em> simplices will be on side 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">side0</td><td>the number of top-dimensional simplices on side 0 of the partition. </td></tr>
    <tr><td class="paramname">side1</td><td>the number of top-dimensional simplices on side 1 of the partition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4265fa8f45ec3a4001832cda9fdb596a" name="a4265fa8f45ec3a4001832cda9fdb596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4265fa8f45ec3a4001832cda9fdb596a">&#9670;&#160;</a></span>Cut() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::Cut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given cut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the cut to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13aefcc1afcf165b5e2ae0a6cb5b84cb" name="a13aefcc1afcf165b5e2ae0a6cb5b84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13aefcc1afcf165b5e2ae0a6cb5b84cb">&#9670;&#160;</a></span>Cut() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::Cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given cut into this new cut. </p>
<p>This is a fast (constant time) operation.</p>
<p>The cut that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the cut to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838236bff4191b0fc7328d0f35d6b746" name="a838236bff4191b0fc7328d0f35d6b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838236bff4191b0fc7328d0f35d6b746">&#9670;&#160;</a></span>Cut() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::Cut </td>
          <td>(</td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new cut using the given partition. </p>
<p>Here a cut on <em>n</em> top-dimensional simplices is described by a sequence of <em>n</em> integers, each equal to 0 or 1, indicating which side of the partition each top-dimensional simplex lies on.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>iterator</em>, when dereferenced, can be cast to an <code>int</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine computes the number of top-dimensional simplices by subtracting <code>end - begin</code>, and so ideally <em>iterator</em> should be a random access iterator type for which this operation is constant time.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>Some element of the given sequence is neither 0 nor 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of iterators, this routine takes a python list of integers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator pointing to the beginning of the 0-1 sequence of sides. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the 0-1 sequence of sides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea26e96c346dbee1e0a34c67dc0fe321" name="aea26e96c346dbee1e0a34c67dc0fe321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea26e96c346dbee1e0a34c67dc0fe321">&#9670;&#160;</a></span>~Cut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Cut::~Cut </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this cut. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="aae41594d8da932008635a7bfcd150688" name="aae41594d8da932008635a7bfcd150688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae41594d8da932008635a7bfcd150688">&#9670;&#160;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Cut::inc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into the next cut of the same size. </p>
<p>The total number of top-dimensional simplices will stay the same, but the number on each side of the partition may change.</p>
<p>To iterate through all cuts of the given size, you should create a new <code>Cut(size)</code> and then make repeated calls to <a class="el" href="#aae41594d8da932008635a7bfcd150688" title="Converts this into the next cut of the same size.">inc()</a>.</p>
<p>If this is already the last partition in such an iteration (i.e., all top-dimensional simplices are already on side 1), then this routine will return <code>false</code> and convert this into the <em>first</em> such partition.</p>
<p>The order of iteration using <a class="el" href="#aae41594d8da932008635a7bfcd150688" title="Converts this into the next cut of the same size.">inc()</a> is lexicographical in the sequence of sides. In particular, if you wish to avoid seeing each cut again with sides 0 and 1 swapped, then you can use the fact that all cuts with <code>side(0) == 0</code> will be seen before any cuts with <code>side(0) == 1</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the partition was successfully incremented, or <code>false</code> if this was already the last partition in such an iteration. </dd></dl>

</div>
</div>
<a id="a1c57bae84f8f0cc45b9068aff20d6e9d" name="a1c57bae84f8f0cc45b9068aff20d6e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c57bae84f8f0cc45b9068aff20d6e9d">&#9670;&#160;</a></span>incFixedSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Cut::incFixedSizes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this into the next cut with the same partition sizes. </p>
<p>Specifically, the number of top-dimensional simplices on each side of the partition will remain the same.</p>
<p>To iterate through all cuts with the given parititon sizes, you should create a new <code>Cut(side0, side1)</code> and then make repeated calls to <a class="el" href="#a1c57bae84f8f0cc45b9068aff20d6e9d" title="Converts this into the next cut with the same partition sizes.">incFixedSizes()</a>.</p>
<p>If this is already the last partition in such an iteration, then this routine will return <code>false</code> and convert this into the <em>first</em> such permutation.</p>
<p>The order of iteration using <a class="el" href="#a1c57bae84f8f0cc45b9068aff20d6e9d" title="Converts this into the next cut with the same partition sizes.">incFixedSizes()</a> is lexicographical in the sequence of sides. In particular, if you wish to avoid seeing each cut again with sides 0 and 1 swapped, then you can use the fact that all cuts with <code>side(0) == 0</code> will be seen before any cuts with <code>side(0) == 1</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the partition was successfully incremented, or <code>false</code> if this was already the last partition in such an iteration. </dd></dl>

</div>
</div>
<a id="ae8958da08b165462509bb7841a14b799" name="ae8958da08b165462509bb7841a14b799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8958da08b165462509bb7841a14b799">&#9670;&#160;</a></span>inclusion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; regina::Cut::inclusion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the relationships between simplex numbers before and after this cut is used to partition a triangulation or facet pairing into two pieces. </p>
<p>Specifically: let <em>from</em> be a trianglation or facet pairing, and let (<em>a</em>, <em>b</em>) be the result of partitioning <em>from</em> using this cut, so <code>(a, b) = cut(from)</code>.</p>
<p>Then this routine returns two isomorphisms <em>p</em> and <em>q</em>, where <em>p</em> describes how <em>a</em> appears as a subcomplex of <em>from</em>, and <em>q</em> describes how <em>b</em> appears as a subcomplex of <em>from</em>. These isomorphisms will be in the direction from <em>a</em> and <em>b</em> to <em>from</em>.</p>
<p>The only interesting parts of these isomorphisms are the mappings between the indices of top-dimensional simplices; all of the facet permutations within each top-dimensional simplex will be identity permutations.</p>
<dl class="section user"><dt>Python</dt><dd>Since Python does not support templates, the dimension <em>dim</em> should be passed as an argument to this function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>indicates which type of isomorphisms to return. Specifically, this integer parameter indicates the dimension of triangulation on which these isomorphisms act.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the two inclusion maps corresponding to this partition. </dd></dl>

</div>
</div>
<a id="abd77a385e869f5f30e417042c70f1b97" name="abd77a385e869f5f30e417042c70f1b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd77a385e869f5f30e417042c70f1b97">&#9670;&#160;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Cut::isTrivial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this cut places all top-dimensional simplices on the same side of the partition. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all simplices are on side 0 or all simplices are on side 1, or <code>false</code> if both sides of the partition are non-empty. </dd></dl>

</div>
</div>
<a id="a75245d19442d3d9d17be7c9f91984fd9" name="a75245d19442d3d9d17be7c9f91984fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75245d19442d3d9d17be7c9f91984fd9">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Cut::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given cut are different. </p>
<p>Two cuts are considered identical if they describe the same partition of simplices into sides 0 and 1.</p>
<p>It does not matter if this and the given cut have different sizes; in this case they will be considered different.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the cut to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given cut are different. </dd></dl>

</div>
</div>
<a id="a80c310ec2f911b5ced072c3d080b01ae" name="a80c310ec2f911b5ced072c3d080b01ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c310ec2f911b5ced072c3d080b01ae">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;, <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &gt; regina::Cut::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions the given facet pairing using this cut. </p>
<p>This routine will return <em>two</em> facet pairings: the first will contain all the top-dimensional simplices on side 0 of this cut, and the second will contain all the top-dimensional simplices on side 1. All matchings between simplex facets within the same side of the partition will be preserved, but any matchings that cross the partition will be lost (and so the corresponding simplex facets will become unmatched).</p>
<p>You can call <a class="el" href="#ae8958da08b165462509bb7841a14b799" title="Returns the relationships between simplex numbers before and after this cut is used to partition a tr...">inclusion()</a> if you need to know how the simplex numbers of the resulting pairings correspond to the simplex numbers of the original pairing.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing has precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices. </dd>
<dd>
Since empty facet pairings are not allowed, this cut must have at least one top-dimensional simplex on each side.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given facet pairing does not have precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This cut has all of its top-dimensional simplices on the same side.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the facet pairing to partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the two resulting facet pairings, one for each side of the partition. </dd></dl>

</div>
</div>
<a id="a1bc8c836cc3a7f268a7dc6cb5633b55f" name="a1bc8c836cc3a7f268a7dc6cb5633b55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc8c836cc3a7f268a7dc6cb5633b55f">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &gt; regina::Cut::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions the given triangulation using this cut. </p>
<p>This routine will return <em>two</em> triangulations: the first will contain all the top-dimensional simplices on side 0 of this cut, and the second will contain all the top-dimensional simplices on side 1. All gluings within the same side of the partition will be preserved, but any gluings that cross the partition will be lost (and so the corresponding simplex facets will become boundary).</p>
<p>You can call <a class="el" href="#ae8958da08b165462509bb7841a14b799" title="Returns the relationships between simplex numbers before and after this cut is used to partition a tr...">inclusion()</a> if you need to know how the simplex numbers of the resulting triangulations correspond to the simplex numbers of the original triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation has precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given triangulation does not have precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the two resulting triangulations, one for each side of the partition. </dd></dl>

</div>
</div>
<a id="ad6f491b2632aeee5d2e804cb218c0541" name="ad6f491b2632aeee5d2e804cb218c0541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f491b2632aeee5d2e804cb218c0541">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp; regina::Cut::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given cut. </p>
<p>It does not matter if this and the given cut have different sizes (i.e., work with different number of top-dimensional simplices); if they do then this cut will be resized as a result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the cut to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this cut. </dd></dl>

</div>
</div>
<a id="a4d4fb4e4b42b109c4988e91e515c2f71" name="a4d4fb4e4b42b109c4988e91e515c2f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4fb4e4b42b109c4988e91e515c2f71">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp; regina::Cut::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given cut into this cut. </p>
<p>This is a fast (constant time) operation.</p>
<p>It does not matter if this and the given cut have different sizes (i.e., work with different number of top-dimensional simplices); if they do then this cut will be resized as a result.</p>
<p>The cut that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the cut to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this cut. </dd></dl>

</div>
</div>
<a id="a54bd1999b1e5e52096fb557f2f5f27e6" name="a54bd1999b1e5e52096fb557f2f5f27e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bd1999b1e5e52096fb557f2f5f27e6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Cut::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given cut are identical. </p>
<p>Two cuts are considered identical if they describe the same partition of simplices into sides 0 and 1.</p>
<p>It does not matter if this and the given cut have different sizes; in this case they will be considered different.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the cut to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given cut are identical. </dd></dl>

</div>
</div>
<a id="a1ee93a57ffe375b32f7ee23d9ba6bb70" name="a1ee93a57ffe375b32f7ee23d9ba6bb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee93a57ffe375b32f7ee23d9ba6bb70">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Cut::set </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simplex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newSide</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set which side of the partition the given simplex lies on. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given side is not 0 or 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex being changed; this must be between 0 and <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">newSide</td><td>the side of the partition that the given simplex should lie on; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60f7a9c78146a48cfba544533f4b0a1" name="af60f7a9c78146a48cfba544533f4b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f7a9c78146a48cfba544533f4b0a1">&#9670;&#160;</a></span>side()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::Cut::side </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>simplex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which side of the partition the given simplex lies on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex being queried; this must be between 0 and <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding side of the partition; this will be either 0 or 1. </dd></dl>

</div>
</div>
<a id="ad49b32d36fe70c2f9b89318d87170a4f" name="ad49b32d36fe70c2f9b89318d87170a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b32d36fe70c2f9b89318d87170a4f">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Cut::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairing. </p>
<p>In other words, this returns the size of the underlying triangulation or facet pairing.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="a95a9e7428da63e421260b372a366cb87" name="a95a9e7428da63e421260b372a366cb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a9e7428da63e421260b372a366cb87">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Cut::size </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>whichSide</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of top-dimensional simplices on the given side of the partition described by this cut. </p>
<p>It will always be true that <code>size(0) + size(1) == <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine runs in linear time, since the sizes of the individual sides are not cached. This is in contrast to the overall total <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a>, which <em>is</em> cached, and which runs in constant time.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given side is not 0 or 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichSide</td><td>the side of the partition to query; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices on the given side. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a79d5e38746a195f63d582072b633a343" name="a79d5e38746a195f63d582072b633a343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d5e38746a195f63d582072b633a343">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Cut::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Cut.html">Cut</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given cut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the cut whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a6f0e922135ad89582d646d0929ad6d9b" name="a6f0e922135ad89582d646d0929ad6d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e922135ad89582d646d0929ad6d9b">&#9670;&#160;</a></span>weight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Cut::weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight of this cut with respect to the given facet pairing. </p>
<p>This is the number of matchings between facets of simplices in the given pairing that cross the partition described by this cut.</p>
<p>In other words, this routine counts the number of facets of top-dimensional simplices on side 0 of the cut that are paired with a facet of some top-dimensional simplex on side 1.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing has precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given facet pairing does not have precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the facet pairing under consideration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the weight of this cut with respect to <em>pairing</em>. </dd></dl>

</div>
</div>
<a id="a0bd7571f30316d24ed3c33fa05491c89" name="a0bd7571f30316d24ed3c33fa05491c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd7571f30316d24ed3c33fa05491c89">&#9670;&#160;</a></span>weight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Cut::weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tri</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight of this cut with respect to the dual graph of the given triangulation. </p>
<p>This is the number of gluings in the given triangulation that cross the partition described by this cut.</p>
<p>In other words, this routine counts the number of facets of top-dimensional simplices on side 0 of the cut that are glued to a facet of some top-dimensional simplex on side 1.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation has precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given triangulation does not have precisely <a class="el" href="#ad49b32d36fe70c2f9b89318d87170a4f" title="Returns the total number of top-dimensional simplices in the underlying triangulation or facet pairin...">size()</a> top-dimensional simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation under consideration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the weight of this cut with respect to <em>tri</em>. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1Cut.html">Cut</a>, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbcec89f9b13a25a309a17a72ef24814" name="acbcec89f9b13a25a309a17a72ef24814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcec89f9b13a25a309a17a72ef24814">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Cut::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/<a class="el" href="cut_8h.html">cut.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
