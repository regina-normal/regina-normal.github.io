<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::SatAnnulus Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structregina_1_1SatAnnulus-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SatAnnulus Struct Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents an annulus formed from a pair of triangles in a Seifert fibred space.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;subcomplex/satannulus.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a81c2692c140b8ed46d060fcc62fffa" id="r_a3a81c2692c140b8ed46d060fcc62fffa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a81c2692c140b8ed46d060fcc62fffa">SatAnnulus</a> ()</td></tr>
<tr class="memdesc:a3a81c2692c140b8ed46d060fcc62fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised structure.  <br /></td></tr>
<tr class="separator:a3a81c2692c140b8ed46d060fcc62fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725f76855ee19292ba616f7c966c3280" id="r_a725f76855ee19292ba616f7c966c3280"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725f76855ee19292ba616f7c966c3280">SatAnnulus</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;)=default</td></tr>
<tr class="memdesc:a725f76855ee19292ba616f7c966c3280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given structure.  <br /></td></tr>
<tr class="separator:a725f76855ee19292ba616f7c966c3280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe163912c7c55275d10e63f1bb6252c5" id="r_afe163912c7c55275d10e63f1bb6252c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe163912c7c55275d10e63f1bb6252c5">SatAnnulus</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r0, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r1)</td></tr>
<tr class="memdesc:afe163912c7c55275d10e63f1bb6252c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure initialised to the given values.  <br /></td></tr>
<tr class="separator:afe163912c7c55275d10e63f1bb6252c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b021984864668862068d6a66a70e6" id="r_a791b021984864668862068d6a66a70e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791b021984864668862068d6a66a70e6">operator=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;)=default</td></tr>
<tr class="memdesc:a791b021984864668862068d6a66a70e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given structure.  <br /></td></tr>
<tr class="separator:a791b021984864668862068d6a66a70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32e5f02d94b293891933065c13a523e" id="r_aa32e5f02d94b293891933065c13a523e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32e5f02d94b293891933065c13a523e">tet</a> (int which) const</td></tr>
<tr class="memdesc:aa32e5f02d94b293891933065c13a523e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that allows you to query the <em>tet</em> field.  <br /></td></tr>
<tr class="separator:aa32e5f02d94b293891933065c13a523e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f3f4af11fc5b31b92bc39725e1e236" id="r_a13f3f4af11fc5b31b92bc39725e1e236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13f3f4af11fc5b31b92bc39725e1e236">roles</a> (int which) const</td></tr>
<tr class="memdesc:a13f3f4af11fc5b31b92bc39725e1e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that allows you to query the <em>roles</em> field.  <br /></td></tr>
<tr class="separator:a13f3f4af11fc5b31b92bc39725e1e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1eacb67e0c0a3e17e1fb8ad737b64" id="r_a6aa1eacb67e0c0a3e17e1fb8ad737b64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aa1eacb67e0c0a3e17e1fb8ad737b64">setTet</a> (int which, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *value)</td></tr>
<tr class="memdesc:a6aa1eacb67e0c0a3e17e1fb8ad737b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that allows you to set the <em>tet</em> field.  <br /></td></tr>
<tr class="separator:a6aa1eacb67e0c0a3e17e1fb8ad737b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e96e5b22c96ed2d1794df8ed95ffec" id="r_a55e96e5b22c96ed2d1794df8ed95ffec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e96e5b22c96ed2d1794df8ed95ffec">setRoles</a> (int which, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; value)</td></tr>
<tr class="memdesc:a55e96e5b22c96ed2d1794df8ed95ffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that allows you to set the <em>roles</em> field.  <br /></td></tr>
<tr class="separator:a55e96e5b22c96ed2d1794df8ed95ffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422274dc01b3829898fc5bd9912c887e" id="r_a422274dc01b3829898fc5bd9912c887e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422274dc01b3829898fc5bd9912c887e">operator==</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:a422274dc01b3829898fc5bd9912c887e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe the same specific presentation of a saturated annulus.  <br /></td></tr>
<tr class="separator:a422274dc01b3829898fc5bd9912c887e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9a3e17d58f8a53930d74b2511f64fd" id="r_a3f9a3e17d58f8a53930d74b2511f64fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f9a3e17d58f8a53930d74b2511f64fd">operator!=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:a3f9a3e17d58f8a53930d74b2511f64fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe different specific presentations of a saturated annulus.  <br /></td></tr>
<tr class="separator:a3f9a3e17d58f8a53930d74b2511f64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79d5cd00f2c2ca5d26497a8bb80c003" id="r_af79d5cd00f2c2ca5d26497a8bb80c003"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af79d5cd00f2c2ca5d26497a8bb80c003">meetsBoundary</a> () const</td></tr>
<tr class="memdesc:af79d5cd00f2c2ca5d26497a8bb80c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many triangles of this annulus lie on the boundary of the triangulation.  <br /></td></tr>
<tr class="separator:af79d5cd00f2c2ca5d26497a8bb80c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314169287c13371d490bfe8f156c2e8" id="r_a3314169287c13371d490bfe8f156c2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3314169287c13371d490bfe8f156c2e8">switchSides</a> ()</td></tr>
<tr class="memdesc:a3314169287c13371d490bfe8f156c2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a representation of the same annulus from the other side.  <br /></td></tr>
<tr class="separator:a3314169287c13371d490bfe8f156c2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1a05d4855418a5e4de2261f93ae9ec" id="r_abe1a05d4855418a5e4de2261f93ae9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe1a05d4855418a5e4de2261f93ae9ec">otherSide</a> () const</td></tr>
<tr class="memdesc:abe1a05d4855418a5e4de2261f93ae9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a representation of the same annulus from the other side.  <br /></td></tr>
<tr class="separator:abe1a05d4855418a5e4de2261f93ae9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb14f03e956c6a208d02226a4a684c2" id="r_a8cb14f03e956c6a208d02226a4a684c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cb14f03e956c6a208d02226a4a684c2">reflectVertical</a> ()</td></tr>
<tr class="memdesc:a8cb14f03e956c6a208d02226a4a684c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the direction of the vertical fibres in this annulus representation.  <br /></td></tr>
<tr class="separator:a8cb14f03e956c6a208d02226a4a684c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cc54b9dfdf84f901beacaab63b9f39" id="r_ac1cc54b9dfdf84f901beacaab63b9f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1cc54b9dfdf84f901beacaab63b9f39">verticalReflection</a> () const</td></tr>
<tr class="memdesc:ac1cc54b9dfdf84f901beacaab63b9f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a representation of this annulus in which the vertical direction of the fibres has been reversed.  <br /></td></tr>
<tr class="separator:ac1cc54b9dfdf84f901beacaab63b9f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d10195c977f38a583700303629ebc8" id="r_a53d10195c977f38a583700303629ebc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53d10195c977f38a583700303629ebc8">reflectHorizontal</a> ()</td></tr>
<tr class="memdesc:a53d10195c977f38a583700303629ebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left-to-right reflection of this annulus representation.  <br /></td></tr>
<tr class="separator:a53d10195c977f38a583700303629ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c5947d121ebf8a25e0849bdf5a7f7e" id="r_aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7c5947d121ebf8a25e0849bdf5a7f7e">horizontalReflection</a> () const</td></tr>
<tr class="memdesc:aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a left-to-right reflected representation of this annulus.  <br /></td></tr>
<tr class="separator:aa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea9c67b200888b3aeb42251ee31c3cc" id="r_aeea9c67b200888b3aeb42251ee31c3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea9c67b200888b3aeb42251ee31c3cc">rotateHalfTurn</a> ()</td></tr>
<tr class="memdesc:aeea9c67b200888b3aeb42251ee31c3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the representation of this annulus by 180 degrees.  <br /></td></tr>
<tr class="separator:aeea9c67b200888b3aeb42251ee31c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2540d455af75c2d5d736267d4b78ff" id="r_a3c2540d455af75c2d5d736267d4b78ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c2540d455af75c2d5d736267d4b78ff">halfTurnRotation</a> () const</td></tr>
<tr class="memdesc:a3c2540d455af75c2d5d736267d4b78ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 180 degree rotated representation of this annulus.  <br /></td></tr>
<tr class="separator:a3c2540d455af75c2d5d736267d4b78ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fddf61384ae226d1811964bbb7a491" id="r_ae5fddf61384ae226d1811964bbb7a491"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5fddf61384ae226d1811964bbb7a491">isAdjacent</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:ae5fddf61384ae226d1811964bbb7a491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections.  <br /></td></tr>
<tr class="separator:ae5fddf61384ae226d1811964bbb7a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166da7e172160fef0a9f818823a2c4d" id="r_ab166da7e172160fef0a9f818823a2c4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab166da7e172160fef0a9f818823a2c4d">isJoined</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other, <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;matching) const</td></tr>
<tr class="memdesc:ab166da7e172160fef0a9f818823a2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent.  <br /></td></tr>
<tr class="separator:ab166da7e172160fef0a9f818823a2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92bb7286c0fb03b929257a7bc4888f1" id="r_ab92bb7286c0fb03b929257a7bc4888f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab92bb7286c0fb03b929257a7bc4888f1">isTwoSidedTorus</a> () const</td></tr>
<tr class="memdesc:ab92bb7286c0fb03b929257a7bc4888f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation.  <br /></td></tr>
<tr class="separator:ab92bb7286c0fb03b929257a7bc4888f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8e50c4838b9acb4fa463e38b9f644" id="r_ac5f8e50c4838b9acb4fa463e38b9f644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f8e50c4838b9acb4fa463e38b9f644">transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;iso, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;newTri)</td></tr>
<tr class="memdesc:ac5f8e50c4838b9acb4fa463e38b9f644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts this annulus representation according to the given isomorphism between triangulations.  <br /></td></tr>
<tr class="separator:ac5f8e50c4838b9acb4fa463e38b9f644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d828c6c26940828bf495373058874" id="r_a9f6d828c6c26940828bf495373058874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6d828c6c26940828bf495373058874">image</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;iso, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;newTri) const</td></tr>
<tr class="memdesc:a9f6d828c6c26940828bf495373058874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the image of this annulus representation under the given isomorphism between triangulations.  <br /></td></tr>
<tr class="separator:a9f6d828c6c26940828bf495373058874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af9b1fdc8b25af9f49b061f7d4617e567" id="r_af9b1fdc8b25af9f49b061f7d4617e567"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b1fdc8b25af9f49b061f7d4617e567">attachLST</a> (<a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r0, <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r1, long alpha, long beta)</td></tr>
<tr class="memdesc:af9b1fdc8b25af9f49b061f7d4617e567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a layered solid torus to the given saturated annulus.  <br /></td></tr>
<tr class="separator:af9b1fdc8b25af9f49b061f7d4617e567"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4aef8622e92a0a20611dd62d5539f78a" id="r_a4aef8622e92a0a20611dd62d5539f78a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aef8622e92a0a20611dd62d5539f78a">tet</a> [2]</td></tr>
<tr class="memdesc:a4aef8622e92a0a20611dd62d5539f78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which tetrahedra provide the first and second triangles.  <br /></td></tr>
<tr class="separator:a4aef8622e92a0a20611dd62d5539f78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561aae549a9dc09de541ea0b76dfcc7a" id="r_a561aae549a9dc09de541ea0b76dfcc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a561aae549a9dc09de541ea0b76dfcc7a">roles</a> [2]</td></tr>
<tr class="memdesc:a561aae549a9dc09de541ea0b76dfcc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how the first and second triangles match up with individual tetrahedron vertices.  <br /></td></tr>
<tr class="separator:a561aae549a9dc09de541ea0b76dfcc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an annulus formed from a pair of triangles in a Seifert fibred space. </p>
<p>This annulus is saturated, i.e., a union of fibres. More than that, the fibres run parallel to the two boundary edges of the annulus.</p>
<p>The annulus is described from one side only. The description includes an array of indices <em>tet</em>[] describing which two tetrahedra provide the triangles of the annulus, as well as an array of permutations <em>roles</em>[] detailing how the annulus matches up with the individual tetrahedron vertices.</p>
<p>The annulus can be drawn as follows, with the upper edge identified with the lower:</p>
<pre>
           *---&gt;---*
           |0  2 / |
   First   |    / 1|  Second
  triangle |   /   | triangle
           |1 /    |
           | / 2  0|
           *---&gt;---*
</pre><p>Suppose that <em>tet</em>[0] and <em>tet</em>[1] are the tetrahedra providing the first and second triangles respectively. Then the markings 0..2 on the first triangle above correspond to vertices <em>roles</em>[0][0..2] of tetrahedron <em>tet</em>[0], and likewise the markings 0..2 on the second triangle above correspond to vertices <em>roles</em>[1][0..2] of tetrahedron <em>tet</em>[1].</p>
<p>Note that the diagram above can also be drawn as follows.</p>
<pre>
           *---&gt;---*
           | \ 2  1|
   First   |0 \    |  Second
  triangle |   \   | triangle
           |    \ 0|
           |1  2 \ |
           *---&gt;---*
</pre><p>Note also that the labelling of the tetrahedra and their vertices establishes an orientation on the vertical fibres, as well as a left-to-right direction across the annulus.</p>
<p>For convenience we refer to edges <em>roles</em>[][0-1] as <em>vertical</em>, edges <em>roles</em>[][0-2] as <em>horizontal</em>, and edge <em>roles</em>[][1-2] as <em>diagonal</em>. This is illustrated in the following diagrams.</p>
<pre>
        V  Horizontal       V   Diagonal
        e  *---&gt;---*        e  *---&gt;---*
        r  |   g / |        r  |H\ 2  1|
        t  |  a / 1|        t  | o\    |
        i  | i /   |        i  |  r\   |
        c  |D /    |        c  |   i\ 0|
        a  | / 2  0|        a  |    z\ |
        l  *---&gt;---*        l  *---&gt;---*
</pre><p>These objects are small enough to pass by value and swap with std::swap(), with no need for any specialised move operations or swap functions.</p>
<dl class="section user"><dt>Python</dt><dd>The member arrays <em>tet</em> and <em>roles</em> are accessed for reading through functions <em><a class="el" href="#a4aef8622e92a0a20611dd62d5539f78a" title="Describes which tetrahedra provide the first and second triangles.">tet()</a></em> and <em><a class="el" href="#a561aae549a9dc09de541ea0b76dfcc7a" title="Describes how the first and second triangles match up with individual tetrahedron vertices.">roles()</a></em> respectively. For instance, the first triangle tetrahedron for the saturated annulus <em>a</em> can be accessed as <code>a.tet(0)</code>. These same member arrays are accessed for writing through functions <em><a class="el" href="#a6aa1eacb67e0c0a3e17e1fb8ad737b64" title="A Python-only routine that allows you to set the tet field.">setTet()</a></em> and <em><a class="el" href="#a55e96e5b22c96ed2d1794df8ed95ffec" title="A Python-only routine that allows you to set the roles field.">setRoles()</a></em>, so for instance the second triangle vertex roles for the saturated annulus <em>a</em> can be modified by calling <code>a.setRoles(1, newRoles)</code>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a81c2692c140b8ed46d060fcc62fffa" name="a3a81c2692c140b8ed46d060fcc62fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a81c2692c140b8ed46d060fcc62fffa">&#9670;&#160;</a></span>SatAnnulus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised structure. </p>
<p>Both tetrahedra will be set to null pointers. </p>

</div>
</div>
<a id="a725f76855ee19292ba616f7c966c3280" name="a725f76855ee19292ba616f7c966c3280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725f76855ee19292ba616f7c966c3280">&#9670;&#160;</a></span>SatAnnulus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given structure. </p>

</div>
</div>
<a id="afe163912c7c55275d10e63f1bb6252c5" name="afe163912c7c55275d10e63f1bb6252c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe163912c7c55275d10e63f1bb6252c5">&#9670;&#160;</a></span>SatAnnulus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;</td>          <td class="paramname"><span class="paramname"><em>r0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;</td>          <td class="paramname"><span class="paramname"><em>r1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure initialised to the given values. </p>
<p>See the class notes for what the various tetrahedra and permutations mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>the tetrahedron to assign to <em>tet</em>[0]. </td></tr>
    <tr><td class="paramname">r0</td><td>the permutation to assign to <em>roles</em>[0]. </td></tr>
    <tr><td class="paramname">t1</td><td>the tetrahedron to assign to <em>tet</em>[1]. </td></tr>
    <tr><td class="paramname">r1</td><td>the permutation to assign to <em>roles</em>[1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9b1fdc8b25af9f49b061f7d4617e567" name="af9b1fdc8b25af9f49b061f7d4617e567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b1fdc8b25af9f49b061f7d4617e567">&#9670;&#160;</a></span>attachLST()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::SatAnnulus::attachLST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;</td>          <td class="paramname"><span class="paramname"><em>r0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;</td>          <td class="paramname"><span class="paramname"><em>r1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a layered solid torus to the given saturated annulus. </p>
<p>Instead of passing a <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> (which only offers const access to the underlying triangluation), you must pass the individual tetrahedra and permutations that describe it.</p>
<p>The layered solid torus will be attached so that the given values <em>alpha</em> and <em>beta</em> describe how the meridinal disc cuts the vertical and horizontal edges of the annulus respectively.</p>
<p>The result will effectively insert an (<em>alpha</em>, <em>beta</em>) exceptional fibre into the Seifert fibred space space, where the vertical edges run parallel to the fibres and the horizontal edges represent the base orbifold. The sign of the fibre is consistent with the fibre inserted by <a class="el" href="classregina_1_1SatLST.html#a4a2609da5d70703ce58dcb3428f9c34a" title="Adjusts the given Seifert fibred space to insert the contents of this saturated block.">SatLST::adjustSFS()</a> (in particular, negating <em>beta</em> will negate the fibre).</p>
<p>In the case of a (2,1) fibre, the layered solid torus will be degenerate (i.e., the two triangles of the annulus will simply be joined together).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given value <em>alpha</em> is not zero. </dd>
<dd>
The given values <em>alpha</em> and <em>beta</em> are coprime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>the tetrahedron corresponding to <a class="el" href="#a4aef8622e92a0a20611dd62d5539f78a" title="Describes which tetrahedra provide the first and second triangles.">SatAnnulus::tet</a>[0]. </td></tr>
    <tr><td class="paramname">r0</td><td>the permutation corresponding to <a class="el" href="#a561aae549a9dc09de541ea0b76dfcc7a" title="Describes how the first and second triangles match up with individual tetrahedron vertices.">SatAnnulus::roles</a>[0]. </td></tr>
    <tr><td class="paramname">t1</td><td>the tetrahedron corresponding to <a class="el" href="#a4aef8622e92a0a20611dd62d5539f78a" title="Describes which tetrahedra provide the first and second triangles.">SatAnnulus::tet</a>[1]. </td></tr>
    <tr><td class="paramname">r1</td><td>the permutation corresponding to <a class="el" href="#a561aae549a9dc09de541ea0b76dfcc7a" title="Describes how the first and second triangles match up with individual tetrahedron vertices.">SatAnnulus::roles</a>[1]. </td></tr>
    <tr><td class="paramname">alpha</td><td>describes how the meridinal disc of the torus should cut the vertical edges. This may be positive or negative. </td></tr>
    <tr><td class="paramname">beta</td><td>describes how the meridinal disc of the torus should cut the horizontal edges. Again this may be positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c2540d455af75c2d5d736267d4b78ff" name="a3c2540d455af75c2d5d736267d4b78ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2540d455af75c2d5d736267d4b78ff">&#9670;&#160;</a></span>halfTurnRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::halfTurnRotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 180 degree rotated representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="#aeea9c67b200888b3aeb42251ee31c3cc" title="Rotates the representation of this annulus by 180 degrees.">rotateHalfTurn()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new 180 degree rotation of this annulus. </dd></dl>

</div>
</div>
<a id="aa7c5947d121ebf8a25e0849bdf5a7f7e" name="aa7c5947d121ebf8a25e0849bdf5a7f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c5947d121ebf8a25e0849bdf5a7f7e">&#9670;&#160;</a></span>horizontalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::horizontalReflection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a left-to-right reflected representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new left-to-right reflection of this annulus. </dd></dl>

</div>
</div>
<a id="a9f6d828c6c26940828bf495373058874" name="a9f6d828c6c26940828bf495373058874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d828c6c26940828bf495373058874">&#9670;&#160;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>originalTri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newTri</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the image of this annulus representation under the given isomorphism between triangulations. </p>
<p>This annulus representation will not be changed. See <a class="el" href="#ac5f8e50c4838b9acb4fa463e38b9f644" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">transform()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the new annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5fddf61384ae226d1811964bbb7a491" name="ae5fddf61384ae226d1811964bbb7a491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fddf61384ae226d1811964bbb7a491">&#9670;&#160;</a></span>isAdjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool, bool &gt; regina::SatAnnulus::isAdjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections. </p>
<p>That is, this routine determines whether this and the given structure represent opposite sides of the same saturated annulus, where the fibres for both structures are consistent (though possibly reversed). See <a class="el" href="#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for details on what "opposite sides" means in this context, and see <a class="el" href="#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and <a class="el" href="#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for descriptions of the various types of reflection.</p>
<p>Information regarding reflections is returned via the second and third elements of the returned tuple (call these <em>refVert</em> and <em>refHoriz</em>). If the two annuli are identically opposite each other as described by <a class="el" href="#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a>, both booleans will be <code>false</code>. If the two annuli are identically opposite after one undergoes a vertical and/or horizontal reflection, then the booleans <em>refVert</em> and/or <em>refHoriz</em> will be <code>true</code> accordingly.</p>
<p>The critical difference between this routine and <a class="el" href="#ab166da7e172160fef0a9f818823a2c4d" title="Determines whether this and the given annulus are joined in some form, even if the fibres on each ann...">isJoined()</a> is that this routine insists that the fibres on each annulus be consistent. This routine is thus suitable for examining joins between different sections of the same Seifert fibred space, for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of booleans (<em>adj</em>, <em>refVert</em>, <em>refHoriz</em>), where: <em>adj</em> is <code>true</code> iff some adjacency was found (either with or without reflections); <em>refVert</em> is <code>true</code> iff a vertical reflection is required; and <em>refHoriz</em> is <code>true</code> iff a horizontal reflection is required. If no adjacency was found at all, then both <em>refVert</em> and <em>refHoriz</em> will be <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab166da7e172160fef0a9f818823a2c4d" name="ab166da7e172160fef0a9f818823a2c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab166da7e172160fef0a9f818823a2c4d">&#9670;&#160;</a></span>isJoined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isJoined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matching</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent. </p>
<p>This routine treats each annulus as though its boundaries are identified to form a torus (though it does not actually test whether this is true). It then examines whether this and the given annulus represent opposite sides of the same torus. More specifically, it tests whether both annuli are formed from the same pair of triangles, and whether the mapping of 0/1/2 markings from one annulus to the other is the same for each triangle. Note that the triangles are allowed to be switched (i.e., the first triangle of one annulus may be the second triangle of the other).</p>
<p>The critical difference between this routine and <a class="el" href="#ae5fddf61384ae226d1811964bbb7a491" title="Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal re...">isAdjacent()</a> is that this routine allows the fibres on each annulus to be inconsistent. This routine is thus suitable for examining joins between different Seifert fibred blocks in a graph manifold, for example.</p>
<p>If the two annuli are joined, the precise relationship between the curves on each annulus will be returned in the matrix <em>matching</em>. Specifically, let <em>x</em> and <em>y</em> be the oriented curves running from markings 0-1 and 0-2 respectively on the first triangle of this annulus. Likewise, let <em>x'</em> and <em>y'</em> run from markings 0-1 and 0-2 respectively on the first triangle of the annulus <em>other</em>. Then the joining between the two annuli can be expressed as follows:</p>
<pre>
    [x ]                [x']
    [  ]  =  matching * [  ].
    [y ]                [y']
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
    <tr><td class="paramname">matching</td><td>returns details on how the curves on each annulus are related. If the this and the given annulus are not joined, then this matrix is not touched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given annulus are found to be joined, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="ab92bb7286c0fb03b929257a7bc4888f1" name="ab92bb7286c0fb03b929257a7bc4888f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92bb7286c0fb03b929257a7bc4888f1">&#9670;&#160;</a></span>isTwoSidedTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isTwoSidedTorus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation. </p>
<p>It will be verified that:</p><ul>
<li>the two triangles of this annulus are joined along all three pairs of edges to form a torus;</li>
<li>the three edges of this torus remain distinct (i.e., different edges of the torus do not become identified within the larger triangulation);</li>
<li>this torus is two-sided within the surrounding triangulation.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this annulus forms an embedded two-sided torus as described above, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="af79d5cd00f2c2ca5d26497a8bb80c003" name="af79d5cd00f2c2ca5d26497a8bb80c003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79d5cd00f2c2ca5d26497a8bb80c003">&#9670;&#160;</a></span>meetsBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SatAnnulus::meetsBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines how many triangles of this annulus lie on the boundary of the triangulation. </p>
<p>Note that this routine can also be used as a boolean function to determine whether any triangles of the annulus lie on the triangulation boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of triangles of this annulus that lie on the boundary of the triangulation; this will be 0, 1 or 2. </dd></dl>

</div>
</div>
<a id="a3f9a3e17d58f8a53930d74b2511f64fd" name="a3f9a3e17d58f8a53930d74b2511f64fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9a3e17d58f8a53930d74b2511f64fd">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe different specific presentations of a saturated annulus. </p>
<p>Specifically, in order to compare as equal, two saturated annuli must use the same two numbered tetrahedra, presented in the same order, and with the same <em>roles</em> permutations.</p>
<p>Because this operation compares tetrahedron <em>numbers</em> and not the underlying Tetrahedron objects, it is meaningful to compare saturated annuli from different triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both structures describe different specific presentations of a saturated annulus. </dd></dl>

</div>
</div>
<a id="a791b021984864668862068d6a66a70e6" name="a791b021984864668862068d6a66a70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b021984864668862068d6a66a70e6">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatAnnulus::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this structure. </dd></dl>

</div>
</div>
<a id="a422274dc01b3829898fc5bd9912c887e" name="a422274dc01b3829898fc5bd9912c887e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422274dc01b3829898fc5bd9912c887e">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe the same specific presentation of a saturated annulus. </p>
<p>Specifically, in order to compare as equal, two saturated annuli must use the same two numbered tetrahedra, presented in the same order, and with the same <em>roles</em> permutations.</p>
<p>Because this operation compares tetrahedron <em>numbers</em> and not the underlying Tetrahedron objects, it is meaningful to compare saturated annuli from different triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both structures describe the same specific presentation of a saturated annulus. </dd></dl>

</div>
</div>
<a id="abe1a05d4855418a5e4de2261f93ae9ec" name="abe1a05d4855418a5e4de2261f93ae9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1a05d4855418a5e4de2261f93ae9ec">&#9670;&#160;</a></span>otherSide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::otherSide </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a representation of the same annulus from the other side. </p>
<p>This structure will not be changed. See <a class="el" href="#a3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus from the other side. </dd></dl>

</div>
</div>
<a id="a53d10195c977f38a583700303629ebc8" name="a53d10195c977f38a583700303629ebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d10195c977f38a583700303629ebc8">&#9670;&#160;</a></span>reflectHorizontal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectHorizontal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left-to-right reflection of this annulus representation. </p>
<p>The vertical direction of the fibres will remain unchanged, but the first and second triangles will be switched (and the 0..2 markings changed to compensate). </p>

</div>
</div>
<a id="a8cb14f03e956c6a208d02226a4a684c2" name="a8cb14f03e956c6a208d02226a4a684c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb14f03e956c6a208d02226a4a684c2">&#9670;&#160;</a></span>reflectVertical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectVertical </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the direction of the vertical fibres in this annulus representation. </p>
<p>The first and second triangles (as described in the class notes) will remain unchanged, but the markings 0 and 1 on each triangle will be switched. </p>

</div>
</div>
<a id="a13f3f4af11fc5b31b92bc39725e1e236" name="a13f3f4af11fc5b31b92bc39725e1e236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f3f4af11fc5b31b92bc39725e1e236">&#9670;&#160;</a></span>roles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::SatAnnulus::roles </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that allows you to query the <em>roles</em> field. </p>
<p>The <em>roles</em> field describes how the two triangles that make up this match up with the individual vertices of their corresponding tetrahedra. See the class notes for details.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. This is only for Python users, who cannot access the <em>tet</em> and <em>roles</em> fields directly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>identifies whether we are querying information for the first or second triangle of this annulus. This argument must be 0 or 1 respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation that describes how the given triangle matches up with the individual vertices of its corresponding tetrahedron. </dd></dl>

</div>
</div>
<a id="aeea9c67b200888b3aeb42251ee31c3cc" name="aeea9c67b200888b3aeb42251ee31c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea9c67b200888b3aeb42251ee31c3cc">&#9670;&#160;</a></span>rotateHalfTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::rotateHalfTurn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the representation of this annulus by 180 degrees. </p>
<p>This has the effect of switching the first and second triangles and also reversing the direction of the vertical fibres.</p>
<p>Calling this routine is equivalent to calling <a class="el" href="#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and then <a class="el" href="#a53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a>. </p>

</div>
</div>
<a id="a55e96e5b22c96ed2d1794df8ed95ffec" name="a55e96e5b22c96ed2d1794df8ed95ffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e96e5b22c96ed2d1794df8ed95ffec">&#9670;&#160;</a></span>setRoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::setRoles </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that allows you to set the <em>roles</em> field. </p>
<p>The <em>roles</em> field describes how the two triangles that make up this match up with the individual vertices of their corresponding tetrahedra. See the class notes for details.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. This is only for Python users, who cannot access the <em>tet</em> and <em>roles</em> fields directly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>identifies whether we are setting information for the first or second triangle of this annulus. This argument must be 0 or 1 respectively. </td></tr>
    <tr><td class="paramname">value</td><td>the permutation that describes how the given triangle matches up with the individual vertices of its corresponding tetrahedron. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aa1eacb67e0c0a3e17e1fb8ad737b64" name="a6aa1eacb67e0c0a3e17e1fb8ad737b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa1eacb67e0c0a3e17e1fb8ad737b64">&#9670;&#160;</a></span>setTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::setTet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that allows you to set the <em>tet</em> field. </p>
<p>The <em>tet</em> field describes which two tetrahedra provide the two triangles that make up this annulus. See the class notes for details.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. This is only for Python users, who cannot access the <em>tet</em> and <em>roles</em> fields directly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>identifies whether we are setting information for the first or second triangle of this annulus. This argument must be 0 or 1 respectively. </td></tr>
    <tr><td class="paramname">value</td><td>the tetrahedron that provides the given triangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3314169287c13371d490bfe8f156c2e8" name="a3314169287c13371d490bfe8f156c2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314169287c13371d490bfe8f156c2e8">&#9670;&#160;</a></span>switchSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::switchSides </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a representation of the same annulus from the other side. </p>
<p>The first and second triangles and their 0..2 markings (as described in the class notes) remain unchanged. However, the two tetrahedra that are used to describe the annulus will be replaced by their counterparts on the other side of the annulus (i.e., the two new tetrahedra that meet the two original tetrahedra along the annulus itself).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation. </dd></dl>

</div>
</div>
<a id="aa32e5f02d94b293891933065c13a523e" name="aa32e5f02d94b293891933065c13a523e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32e5f02d94b293891933065c13a523e">&#9670;&#160;</a></span>tet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; * regina::SatAnnulus::tet </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that allows you to query the <em>tet</em> field. </p>
<p>The <em>tet</em> field describes which two tetrahedra provide the two triangles that make up this annulus. See the class notes for details.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. This is only for Python users, who cannot access the <em>tet</em> and <em>roles</em> fields directly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>identifies whether we are querying information for the first or second triangle of this annulus. This argument must be 0 or 1 respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tetrahedron that provides the given triangle. </dd></dl>

</div>
</div>
<a id="ac5f8e50c4838b9acb4fa463e38b9f644" name="ac5f8e50c4838b9acb4fa463e38b9f644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f8e50c4838b9acb4fa463e38b9f644">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>originalTri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newTri</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts this annulus representation according to the given isomorphism between triangulations. </p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this annulus must refer to tetrahedra in <em>originalTri</em>. This routine will adjust this annulus according to the given isomorphism, so that it refers to the corresponding tetrahedra in <em>newTri</em> (with the <em>roles</em> permutations also updated accordingly).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This annulus refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1cc54b9dfdf84f901beacaab63b9f39" name="ac1cc54b9dfdf84f901beacaab63b9f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cc54b9dfdf84f901beacaab63b9f39">&#9670;&#160;</a></span>verticalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::verticalReflection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a representation of this annulus in which the vertical direction of the fibres has been reversed. </p>
<p>This structure will not be changed. See <a class="el" href="#a8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus in which fibres have been reversed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a561aae549a9dc09de541ea0b76dfcc7a" name="a561aae549a9dc09de541ea0b76dfcc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561aae549a9dc09de541ea0b76dfcc7a">&#9670;&#160;</a></span>roles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::SatAnnulus::roles[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes how the first and second triangles match up with individual tetrahedron vertices. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="a4aef8622e92a0a20611dd62d5539f78a" name="a4aef8622e92a0a20611dd62d5539f78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aef8622e92a0a20611dd62d5539f78a">&#9670;&#160;</a></span>tet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt;3&gt;* regina::SatAnnulus::tet[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes which tetrahedra provide the first and second triangles. </p>
<p>See the class notes for details. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="satannulus_8h.html">satannulus.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
