<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::NormalEncoding Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1NormalEncoding-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::NormalEncoding Class Reference<div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Indicates precisely how a normal surface is encoded by an integer vector.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;surface/normalcoords.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a292faa21e851ab949e3529985f31f740" id="r_a292faa21e851ab949e3529985f31f740"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a292faa21e851ab949e3529985f31f740">NormalEncoding</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:a292faa21e851ab949e3529985f31f740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoding that precisely describes the given normal or almost normal coordinate system.  <br /></td></tr>
<tr class="separator:a292faa21e851ab949e3529985f31f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf323c450820285392b4ecda5f54cc31" id="r_aaf323c450820285392b4ecda5f54cc31"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf323c450820285392b4ecda5f54cc31">NormalEncoding</a> (const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;)=default</td></tr>
<tr class="memdesc:aaf323c450820285392b4ecda5f54cc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given encoding.  <br /></td></tr>
<tr class="separator:aaf323c450820285392b4ecda5f54cc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba30ec134e998b5df3854230c1a0137a" id="r_aba30ec134e998b5df3854230c1a0137a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba30ec134e998b5df3854230c1a0137a">operator=</a> (const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;)=default</td></tr>
<tr class="memdesc:aba30ec134e998b5df3854230c1a0137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given encoding.  <br /></td></tr>
<tr class="separator:aba30ec134e998b5df3854230c1a0137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1462714b5a18e1532f74e743f6076d" id="r_a7f1462714b5a18e1532f74e743f6076d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f1462714b5a18e1532f74e743f6076d">operator==</a> (const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;other) const</td></tr>
<tr class="memdesc:a7f1462714b5a18e1532f74e743f6076d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given encoding are identical.  <br /></td></tr>
<tr class="separator:a7f1462714b5a18e1532f74e743f6076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b64b56d722c63ec83be7f5927c677d5" id="r_a2b64b56d722c63ec83be7f5927c677d5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b64b56d722c63ec83be7f5927c677d5">operator!=</a> (const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;other) const</td></tr>
<tr class="memdesc:a2b64b56d722c63ec83be7f5927c677d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given encoding are different.  <br /></td></tr>
<tr class="separator:a2b64b56d722c63ec83be7f5927c677d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af98096611fcd5a4abd399d43fe71b8" id="r_a1af98096611fcd5a4abd399d43fe71b8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af98096611fcd5a4abd399d43fe71b8">valid</a> () const</td></tr>
<tr class="memdesc:a1af98096611fcd5a4abd399d43fe71b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this describes a vector encoding of normal or almost normal surfaces.  <br /></td></tr>
<tr class="separator:a1af98096611fcd5a4abd399d43fe71b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d81bf2405b305b8ca9e5e4111f492b5" id="r_a2d81bf2405b305b8ca9e5e4111f492b5"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d81bf2405b305b8ca9e5e4111f492b5">block</a> () const</td></tr>
<tr class="memdesc:a2d81bf2405b305b8ca9e5e4111f492b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of coordinates stored for each tetrahedron.  <br /></td></tr>
<tr class="separator:a2d81bf2405b305b8ca9e5e4111f492b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7a40359de91c5d9069ce674d004c3d" id="r_aaf7a40359de91c5d9069ce674d004c3d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf7a40359de91c5d9069ce674d004c3d">storesTriangles</a> () const</td></tr>
<tr class="memdesc:aaf7a40359de91c5d9069ce674d004c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this encoding explicitly stores triangle coordinates.  <br /></td></tr>
<tr class="separator:aaf7a40359de91c5d9069ce674d004c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d61f388fc9326ddc8db182d78ecb8" id="r_a029d61f388fc9326ddc8db182d78ecb8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a029d61f388fc9326ddc8db182d78ecb8">storesOctagons</a> () const</td></tr>
<tr class="memdesc:a029d61f388fc9326ddc8db182d78ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this encoding explicitly stores octagon coordinates.  <br /></td></tr>
<tr class="separator:a029d61f388fc9326ddc8db182d78ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24df8f6ccb22839997e9d4ea79386eb1" id="r_a24df8f6ccb22839997e9d4ea79386eb1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24df8f6ccb22839997e9d4ea79386eb1">storesAngles</a> () const</td></tr>
<tr class="memdesc:a24df8f6ccb22839997e9d4ea79386eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies whether this is the special angle structure encoding.  <br /></td></tr>
<tr class="separator:a24df8f6ccb22839997e9d4ea79386eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b59e09cceac560dac2a4e5220db93" id="r_afe6b59e09cceac560dac2a4e5220db93"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6b59e09cceac560dac2a4e5220db93">couldBeVertexLink</a> () const</td></tr>
<tr class="memdesc:afe6b59e09cceac560dac2a4e5220db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether it is possible for a surface using this encoding to include one or more vertex linking components.  <br /></td></tr>
<tr class="separator:afe6b59e09cceac560dac2a4e5220db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ac9572ffaa1c0bf9ee953cca397886" id="r_af0ac9572ffaa1c0bf9ee953cca397886"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0ac9572ffaa1c0bf9ee953cca397886">couldBeNonCompact</a> () const</td></tr>
<tr class="memdesc:af0ac9572ffaa1c0bf9ee953cca397886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether it is possible for a surface using this encoding to be non-compact.  <br /></td></tr>
<tr class="separator:af0ac9572ffaa1c0bf9ee953cca397886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb508c929826e6e3324e46a227af724d" id="r_abb508c929826e6e3324e46a227af724d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb508c929826e6e3324e46a227af724d">withTriangles</a> () const</td></tr>
<tr class="memdesc:abb508c929826e6e3324e46a227af724d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an extension of this encoding that explicitly stores triangle coordinates.  <br /></td></tr>
<tr class="separator:abb508c929826e6e3324e46a227af724d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52366d9f0ab1bbf7285777208dcf04f3" id="r_a52366d9f0ab1bbf7285777208dcf04f3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52366d9f0ab1bbf7285777208dcf04f3">withoutTriangles</a> () const</td></tr>
<tr class="memdesc:a52366d9f0ab1bbf7285777208dcf04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a restricted version of this encoding that does not store triangle coordinates.  <br /></td></tr>
<tr class="separator:a52366d9f0ab1bbf7285777208dcf04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36bca69ae6b618e9c86ea0f1c1a5e37" id="r_af36bca69ae6b618e9c86ea0f1c1a5e37"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36bca69ae6b618e9c86ea0f1c1a5e37">withOctagons</a> () const</td></tr>
<tr class="memdesc:af36bca69ae6b618e9c86ea0f1c1a5e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an extension of this encoding that explicitly stores octagon coordinates.  <br /></td></tr>
<tr class="separator:af36bca69ae6b618e9c86ea0f1c1a5e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c140060460f7a3af205fe539a6ed6" id="r_ad91c140060460f7a3af205fe539a6ed6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91c140060460f7a3af205fe539a6ed6">withoutOctagons</a> () const</td></tr>
<tr class="memdesc:ad91c140060460f7a3af205fe539a6ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a restricted version of this encoding that does not store octagon coordinates.  <br /></td></tr>
<tr class="separator:ad91c140060460f7a3af205fe539a6ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7034e0cf99a8ec382cd033709c16568" id="r_ad7034e0cf99a8ec382cd033709c16568"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7034e0cf99a8ec382cd033709c16568">operator+</a> (<a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> rhs) const</td></tr>
<tr class="memdesc:ad7034e0cf99a8ec382cd033709c16568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoding that could hold the sum of surfaces that use this and the given encoding.  <br /></td></tr>
<tr class="separator:ad7034e0cf99a8ec382cd033709c16568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5988be5c564972cab9b13909b2ba1c" id="r_a7c5988be5c564972cab9b13909b2ba1c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c5988be5c564972cab9b13909b2ba1c">intValue</a> () const</td></tr>
<tr class="memdesc:a7c5988be5c564972cab9b13909b2ba1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this encoding as an integer.  <br /></td></tr>
<tr class="separator:a7c5988be5c564972cab9b13909b2ba1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a72f0c56d43143281e4ce14a34423cdbe" id="r_a72f0c56d43143281e4ce14a34423cdbe"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f0c56d43143281e4ce14a34423cdbe">empty</a> ()</td></tr>
<tr class="memdesc:a72f0c56d43143281e4ce14a34423cdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoding that is suitable for representing the empty surface, whose normal coordinates are all zero.  <br /></td></tr>
<tr class="separator:a72f0c56d43143281e4ce14a34423cdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f08bf899304fb8e2c6619cbf4cdb9e2" id="r_a3f08bf899304fb8e2c6619cbf4cdb9e2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f08bf899304fb8e2c6619cbf4cdb9e2">fromIntValue</a> (int value)</td></tr>
<tr class="memdesc:a3f08bf899304fb8e2c6619cbf4cdb9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs an encoding from an integer value.  <br /></td></tr>
<tr class="separator:a3f08bf899304fb8e2c6619cbf4cdb9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Indicates precisely how a normal surface is encoded by an integer vector. </p>
<p>Normal surfaces do not always store their internal vectors in the same coordinate system that was used to enumerate the surfaces, and indeed an isolated surface does not know <em>how</em> it was originally created.</p>
<p>Therefore each normal surface keeps a small amount of data, represented by this class, so that it knows how to interpret its internal integer vector. This data also remembers properties of the enumeration process that can be used for optimisations (e.g., the knowledge that, even if the vector stores triangle coordinates, the surface cannot contain any vertex linking components).</p>
<p>For convenience, there is also a special encoding that identifies an angle structure vector; this can be created via <code>NormalEncoding(NS_ANGLE)</code>, and can be recognised via <a class="el" href="#a24df8f6ccb22839997e9d4ea79386eb1" title="Identifies whether this is the special angle structure encoding.">storesAngles()</a>. However, like NS_ANGLE itself, this special angle structure encoding does <em>not</em> represent a normal surface, cannot be combined with other encodings, and must not be used with any of Regina's routines unless the documentation explicitly allows it. Specifically, any code that accepts a <a class="el" href="classregina_1_1NormalEncoding.html" title="Indicates precisely how a normal surface is encoded by an integer vector.">NormalEncoding</a> argument may silently assume that the encoding is <em>not</em> the special angle structure encoding, unless the documentation explicitly says otherwise.</p>
<p>Encodings have the important property that any rational multiple of a normal surface <em>s</em> can always be stored using the same encoding as is used for <em>s</em>. (In particular, taking a rational multiple will not invalidate any of the property flags in the encoding.)</p>
<p>These objects are small enough to pass by value and swap with std::swap(), with no need for any specialised move operations or swap functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a292faa21e851ab949e3529985f31f740" name="a292faa21e851ab949e3529985f31f740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292faa21e851ab949e3529985f31f740">&#9670;&#160;</a></span>NormalEncoding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalEncoding::NormalEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a></td>          <td class="paramname"><span class="paramname"><em>coords</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an encoding that precisely describes the given normal or almost normal coordinate system. </p>
<p>This is the encoding that you would use with a "pen and paper" enumeration of surfaces in the given coordinate system, with no further conversion, optimisation, or post-processing.</p>
<p>Note that, when Regina enumerates surfaces in the given coordinate system, it might choose to post-process the resulting vectors to use a different encoding. For example, when enumerating surfaces in quad or quad-oct coordinates, Regina computes and stores triangle coordinates also, and so for its own <em>internal</em> choice of encoding, <a class="el" href="#aaf7a40359de91c5d9069ce674d004c3d" title="Returns whether this encoding explicitly stores triangle coordinates.">storesTriangles()</a> will return <code>true</code>. In contrast, if you simply create a <code>NormalEncoding(NS_QUAD)</code>, then the resulting encoding will have <a class="el" href="#aaf7a40359de91c5d9069ce674d004c3d" title="Returns whether this encoding explicitly stores triangle coordinates.">storesTriangles()</a> return <code>false</code>.</p>
<p>If <em>coords</em> is not one of the coordinate systems that Regina can use to enumerate or reconstruct surfaces (or NS_ANGLE, as discussed below), then the resulting encoding will be invalid, and <a class="el" href="#a1af98096611fcd5a4abd399d43fe71b8" title="Returns whether this describes a vector encoding of normal or almost normal surfaces.">valid()</a> will return <code>false</code>. (Here "reconstruct" refers to the special case of NS_AN_LEGACY, which is used only when reading surfaces from very old data files).</p>
<p>As a special case, you may pass NS_ANGLE to this constructor; however, the resulting encoding does not represent a normal surface and must not be used anywhere in Regina unless the documentation explicitly allows it. See the class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>one of Regina's normal or almost normal coordinate systems. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf323c450820285392b4ecda5f54cc31" name="aaf323c450820285392b4ecda5f54cc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf323c450820285392b4ecda5f54cc31">&#9670;&#160;</a></span>NormalEncoding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalEncoding::NormalEncoding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given encoding. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2d81bf2405b305b8ca9e5e4111f492b5" name="a2d81bf2405b305b8ca9e5e4111f492b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d81bf2405b305b8ca9e5e4111f492b5">&#9670;&#160;</a></span>block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NormalEncoding::block </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of coordinates stored for each tetrahedron. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of coordinates per tetrahedron. </dd></dl>

</div>
</div>
<a id="af0ac9572ffaa1c0bf9ee953cca397886" name="af0ac9572ffaa1c0bf9ee953cca397886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ac9572ffaa1c0bf9ee953cca397886">&#9670;&#160;</a></span>couldBeNonCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::couldBeNonCompact </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether it is possible for a surface using this encoding to be non-compact. </p>
<p>Here "non-compact" refers to a surface with infinitely many discs, such as a spun-normal surface. See <a class="el" href="classregina_1_1NormalSurface.html#a40abc1a8ab16f13d8108df83290ec013" title="Determines if this normal surface is compact (has finitely many discs).">NormalSurface::isCompact()</a> for details.</p>
<p>This is typically information that is inherited from whoever enumerated or created the normal surface that uses this encoding.</p>
<p>If this returns <code>true</code>, it does not mean that the surface does actually contain infinitely many discs; it simply means that the user will need to test this themselves. If this returns <code>false</code>, however, it is guaranteed that the surface is compact, with no further testing required.</p>
<p>For the special angle structure encoding (described in the class notes), this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it is possible that the surface might be non-compact. </dd></dl>

</div>
</div>
<a id="afe6b59e09cceac560dac2a4e5220db93" name="afe6b59e09cceac560dac2a4e5220db93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6b59e09cceac560dac2a4e5220db93">&#9670;&#160;</a></span>couldBeVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::couldBeVertexLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether it is possible for a surface using this encoding to include one or more vertex linking components. </p>
<p>This is typically information that is inherited from whoever enumerated or created the normal surface that uses this encoding.</p>
<p>If this returns <code>true</code>, it does not mean that the surface does actually contain vertex linking components; it simply means that the user will need to test this themselves. If this returns <code>false</code>, however, it is guaranteed that the surface does <em>not</em> contain any vertex linking components, with no further testing required.</p>
<p>For the special angle structure encoding (described in the class notes), this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it is possible that the surface might contain one or more vertex linking components. </dd></dl>

</div>
</div>
<a id="a72f0c56d43143281e4ce14a34423cdbe" name="a72f0c56d43143281e4ce14a34423cdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f0c56d43143281e4ce14a34423cdbe">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an encoding that is suitable for representing the empty surface, whose normal coordinates are all zero. </p>
<dl class="section return"><dt>Returns</dt><dd>a suitable encoding for the empty surface. </dd></dl>

</div>
</div>
<a id="a3f08bf899304fb8e2c6619cbf4cdb9e2" name="a3f08bf899304fb8e2c6619cbf4cdb9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f08bf899304fb8e2c6619cbf4cdb9e2">&#9670;&#160;</a></span>fromIntValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::fromIntValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs an encoding from an integer value. </p>
<p>This is a partner routine to <a class="el" href="#a7c5988be5c564972cab9b13909b2ba1c" title="Exports this encoding as an integer.">intValue()</a>: for any encoding <em>enc</em>, the encoding <code>fromIntValue(enc.intValue())</code> is always equal to <em>enc</em>.</p>
<p>The main purpose of <a class="el" href="#a7c5988be5c564972cab9b13909b2ba1c" title="Exports this encoding as an integer.">intValue()</a> and <a class="el" href="#a3f08bf899304fb8e2c6619cbf4cdb9e2" title="Reconstructs an encoding from an integer value.">fromIntValue()</a> is to support reading and writing surfaces to/from Regina's XML file format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>an integer that represents an encoding, typically obtained by calling <a class="el" href="#a7c5988be5c564972cab9b13909b2ba1c" title="Exports this encoding as an integer.">intValue()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding encoding. </dd></dl>

</div>
</div>
<a id="a7c5988be5c564972cab9b13909b2ba1c" name="a7c5988be5c564972cab9b13909b2ba1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5988be5c564972cab9b13909b2ba1c">&#9670;&#160;</a></span>intValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NormalEncoding::intValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exports this encoding as an integer. </p>
<p>The exact value of the integer is meant to be opaque, in the sense that it can only be used with <a class="el" href="#a3f08bf899304fb8e2c6619cbf4cdb9e2" title="Reconstructs an encoding from an integer value.">fromIntValue()</a>. End users are not meant to pull it apart and analyse it (this is what the other query routines in this class are for).</p>
<p>The main purpose of <a class="el" href="#a7c5988be5c564972cab9b13909b2ba1c" title="Exports this encoding as an integer.">intValue()</a> and <a class="el" href="#a3f08bf899304fb8e2c6619cbf4cdb9e2" title="Reconstructs an encoding from an integer value.">fromIntValue()</a> is to support reading and writing surfaces to/from Regina's XML file format.</p>
<p>It is guaranteed that 0 will never be the integer value of a (correctly constructed) encoding.</p>
<dl class="section return"><dt>Returns</dt><dd>an integer that represents this encoding. </dd></dl>

</div>
</div>
<a id="a2b64b56d722c63ec83be7f5927c677d5" name="a2b64b56d722c63ec83be7f5927c677d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b64b56d722c63ec83be7f5927c677d5">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given encoding are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the encoding to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both encodings are different. </dd></dl>

</div>
</div>
<a id="ad7034e0cf99a8ec382cd033709c16568" name="ad7034e0cf99a8ec382cd033709c16568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7034e0cf99a8ec382cd033709c16568">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an encoding that could hold the sum of surfaces that use this and the given encoding. </p>
<p>More precisely, the encoding that is returned is the "simplest" possible encoding that is capable of holding the sum of two surfaces that use this and the given encoding respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither this encoding nor <em>rhs</em> is the special angle structure encoding (see the class notes for details).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the encoding to combine with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the "sum" of this and the given encoding, as defined above. </dd></dl>

</div>
</div>
<a id="aba30ec134e998b5df3854230c1a0137a" name="aba30ec134e998b5df3854230c1a0137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba30ec134e998b5df3854230c1a0137a">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp; regina::NormalEncoding::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given encoding. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this encoding. </dd></dl>

</div>
</div>
<a id="a7f1462714b5a18e1532f74e743f6076d" name="a7f1462714b5a18e1532f74e743f6076d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1462714b5a18e1532f74e743f6076d">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given encoding are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the encoding to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both encodings are identical. </dd></dl>

</div>
</div>
<a id="a24df8f6ccb22839997e9d4ea79386eb1" name="a24df8f6ccb22839997e9d4ea79386eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24df8f6ccb22839997e9d4ea79386eb1">&#9670;&#160;</a></span>storesAngles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::storesAngles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies whether this is the special angle structure encoding. </p>
<p>This routine is used to recognise the "special case" encoding <code>NormalEncoding(NS_ANGLE)</code>. Such an encoding does not represent a normal surface, and cannot be used anywhere in Regina unless explicitly allowed in the documentation. See the class notes for further details. </p>

</div>
</div>
<a id="a029d61f388fc9326ddc8db182d78ecb8" name="a029d61f388fc9326ddc8db182d78ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029d61f388fc9326ddc8db182d78ecb8">&#9670;&#160;</a></span>storesOctagons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::storesOctagons </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this encoding explicitly stores octagon coordinates. </p>
<p>For the special angle structure encoding (described in the class notes), this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if octagon coordinates are stored. </dd></dl>

</div>
</div>
<a id="aaf7a40359de91c5d9069ce674d004c3d" name="aaf7a40359de91c5d9069ce674d004c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7a40359de91c5d9069ce674d004c3d">&#9670;&#160;</a></span>storesTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::storesTriangles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this encoding explicitly stores triangle coordinates. </p>
<p>For the special angle structure encoding (described in the class notes), this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if triangle coordinates are stored. </dd></dl>

</div>
</div>
<a id="a1af98096611fcd5a4abd399d43fe71b8" name="a1af98096611fcd5a4abd399d43fe71b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af98096611fcd5a4abd399d43fe71b8">&#9670;&#160;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalEncoding::valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this describes a vector encoding of normal or almost normal surfaces. </p>
<p>The only case where this would be <code>false</code> is if you create an encoding using either (1) a coordinate system that Regina does not use for enumeration or reconstruction; or (2) another invalid encoding.</p>
<p>For the special angle structure encoding (described in the class notes), this routine will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a valid encoding. </dd></dl>

</div>
</div>
<a id="af36bca69ae6b618e9c86ea0f1c1a5e37" name="af36bca69ae6b618e9c86ea0f1c1a5e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36bca69ae6b618e9c86ea0f1c1a5e37">&#9670;&#160;</a></span>withOctagons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::withOctagons </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an extension of this encoding that explicitly stores octagon coordinates. </p>
<p>All other properties of the encoding will be copied across without changes (including "theoretical" properties such as whether the surface could have vertex linking components, or whether it could be spun-normal).</p>
<p>If this encoding already stores octagon coordinates, then the result will be identical to this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not the special angle structure encoding (see the class notes for details).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an extension of this encoding that stores octagon coordinates. </dd></dl>

</div>
</div>
<a id="ad91c140060460f7a3af205fe539a6ed6" name="ad91c140060460f7a3af205fe539a6ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c140060460f7a3af205fe539a6ed6">&#9670;&#160;</a></span>withoutOctagons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::withoutOctagons </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a restricted version of this encoding that does not store octagon coordinates. </p>
<p>All other properties of the encoding will be copied across without changes (including "theoretical" properties such as whether the surface could have vertex linking components, or whether it could be spun-normal).</p>
<p>If this encoding already does not store octagon coordinates, then the result will be identical to this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not the special angle structure encoding (see the class notes for details).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a restriction of this encoding that does not store octagon coordinates. </dd></dl>

</div>
</div>
<a id="a52366d9f0ab1bbf7285777208dcf04f3" name="a52366d9f0ab1bbf7285777208dcf04f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52366d9f0ab1bbf7285777208dcf04f3">&#9670;&#160;</a></span>withoutTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::withoutTriangles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a restricted version of this encoding that does not store triangle coordinates. </p>
<p>Most other properties of the encoding will be copied across without changes (including "theoretical" properties such as whether the surface could be spun-normal). However, since triangle coordinates will be excluded, the "could contain vertex linking components" property will be explicitly set to <code>false</code>.</p>
<p>If this encoding already does not store triangle coordinates, then the result will be identical to this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not the special angle structure encoding (see the class notes for details).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a restriction of this encoding that does not store triangle coordinates. </dd></dl>

</div>
</div>
<a id="abb508c929826e6e3324e46a227af724d" name="abb508c929826e6e3324e46a227af724d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb508c929826e6e3324e46a227af724d">&#9670;&#160;</a></span>withTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> regina::NormalEncoding::withTriangles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an extension of this encoding that explicitly stores triangle coordinates. </p>
<p>All other properties of the encoding will be copied across without changes (including "theoretical" properties such as whether the surface could have vertex linking components, or whether it could be spun-normal).</p>
<p>If this encoding already stores triangle coordinates, then the result will be identical to this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is not the special angle structure encoding (see the class notes for details).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an extension of this encoding that stores triangle coordinates. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surface/<a class="el" href="normalcoords_8h.html">normalcoords.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
