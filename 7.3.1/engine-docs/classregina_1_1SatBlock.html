<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::SatBlock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1SatBlock-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SatBlock Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a saturated block in a Seifert fibred space.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;subcomplex/satblock.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SatBlock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SatBlock.png" usemap="#regina::SatBlock_map" alt=""/>
  <map id="regina::SatBlock_map" name="regina::SatBlock_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; SatBlock &gt;" shape="rect" coords="525,56,725,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SatBlock, false &gt;" shape="rect" coords="525,0,725,24"/>
<area href="classregina_1_1SatCube.html" title="A saturated block that is a six-tetrahedron cube." alt="regina::SatCube" shape="rect" coords="0,168,200,192"/>
<area href="classregina_1_1SatLST.html" title="A saturated block that is a layered solid torus." alt="regina::SatLST" shape="rect" coords="210,168,410,192"/>
<area href="classregina_1_1SatLayering.html" title="A degenerate saturated block that is a single tetrahedron wrapped around so that two opposite edges t..." alt="regina::SatLayering" shape="rect" coords="420,168,620,192"/>
<area href="classregina_1_1SatMobius.html" title="A degenerate zero-tetrahedron saturated block that corresponds to attaching a Mobius band to a single..." alt="regina::SatMobius" shape="rect" coords="630,168,830,192"/>
<area href="classregina_1_1SatReflectorStrip.html" title="A saturated block that is a reflector strip." alt="regina::SatReflectorStrip" shape="rect" coords="840,168,1040,192"/>
<area href="classregina_1_1SatTriPrism.html" title="A saturated block that is a three-tetrahedron triangular prism." alt="regina::SatTriPrism" shape="rect" coords="1050,168,1250,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f6a621c1f4970f8968c4d7aee186274" id="r_a1f6a621c1f4970f8968c4d7aee186274"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f6a621c1f4970f8968c4d7aee186274">TetList</a> = std::set&lt;const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt;3&gt;*&gt;</td></tr>
<tr class="memdesc:a1f6a621c1f4970f8968c4d7aee186274"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a list of tetrahedra that should not be examined when searching for saturated blocks.  <br /></td></tr>
<tr class="separator:a1f6a621c1f4970f8968c4d7aee186274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1626a88050fce82a844bb7258b20c3e3" id="r_a1626a88050fce82a844bb7258b20c3e3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1626a88050fce82a844bb7258b20c3e3">~SatBlock</a> ()</td></tr>
<tr class="memdesc:a1626a88050fce82a844bb7258b20c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all internal arrays.  <br /></td></tr>
<tr class="separator:a1626a88050fce82a844bb7258b20c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61cefe231132fadb7a123d39309cfa" id="r_aaf61cefe231132fadb7a123d39309cfa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf61cefe231132fadb7a123d39309cfa">countAnnuli</a> () const</td></tr>
<tr class="memdesc:aaf61cefe231132fadb7a123d39309cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of annuli on the boundary of this saturated block.  <br /></td></tr>
<tr class="separator:aaf61cefe231132fadb7a123d39309cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eea7e2e3c38b8ea7891e829ed9f89f" id="r_ab5eea7e2e3c38b8ea7891e829ed9f89f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5eea7e2e3c38b8ea7891e829ed9f89f">annulus</a> (size_t which) const</td></tr>
<tr class="memdesc:ab5eea7e2e3c38b8ea7891e829ed9f89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the requested annulus on the boundary of this saturated block.  <br /></td></tr>
<tr class="separator:ab5eea7e2e3c38b8ea7891e829ed9f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1893440bbd41f62a28f1c49f7d3bfae" id="r_ad1893440bbd41f62a28f1c49f7d3bfae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1893440bbd41f62a28f1c49f7d3bfae">twistedBoundary</a> () const</td></tr>
<tr class="memdesc:ad1893440bbd41f62a28f1c49f7d3bfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a long Mobius strip?  <br /></td></tr>
<tr class="separator:ad1893440bbd41f62a28f1c49f7d3bfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb37b29dfce1624e8329a655b95de4" id="r_a17cb37b29dfce1624e8329a655b95de4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17cb37b29dfce1624e8329a655b95de4">hasAdjacentBlock</a> (size_t whichAnnulus) const</td></tr>
<tr class="memdesc:a17cb37b29dfce1624e8329a655b95de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is another saturated block listed as being adjacent to the given boundary annulus of this block.  <br /></td></tr>
<tr class="separator:a17cb37b29dfce1624e8329a655b95de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b8897c8eec3ddfd7c364eca5b8467" id="r_ade9b8897c8eec3ddfd7c364eca5b8467"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9b8897c8eec3ddfd7c364eca5b8467">adjacentBlock</a> (size_t whichAnnulus) const</td></tr>
<tr class="memdesc:ade9b8897c8eec3ddfd7c364eca5b8467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the saturated block listed as being adjacent to the given boundary annulus of this block.  <br /></td></tr>
<tr class="separator:ade9b8897c8eec3ddfd7c364eca5b8467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6670c4a40284c2161aa3ae261b0a67" id="r_a1c6670c4a40284c2161aa3ae261b0a67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6670c4a40284c2161aa3ae261b0a67">adjacentAnnulus</a> (size_t whichAnnulus) const</td></tr>
<tr class="memdesc:a1c6670c4a40284c2161aa3ae261b0a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block.  <br /></td></tr>
<tr class="separator:a1c6670c4a40284c2161aa3ae261b0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc311f7479aeb6b14a83889b586dc9" id="r_a2fbc311f7479aeb6b14a83889b586dc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fbc311f7479aeb6b14a83889b586dc9">adjacentReflected</a> (size_t whichAnnulus) const</td></tr>
<tr class="memdesc:a2fbc311f7479aeb6b14a83889b586dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the adjacency along the given boundary annulus of this block is reflected.  <br /></td></tr>
<tr class="separator:a2fbc311f7479aeb6b14a83889b586dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f979a098cfd67c2e7261b2305ff736" id="r_a32f979a098cfd67c2e7261b2305ff736"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f979a098cfd67c2e7261b2305ff736">adjacentBackwards</a> (size_t whichAnnulus) const</td></tr>
<tr class="memdesc:a32f979a098cfd67c2e7261b2305ff736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the adjacency along the given boundary annulus of this block is backwards.  <br /></td></tr>
<tr class="separator:a32f979a098cfd67c2e7261b2305ff736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f34b5e1c93a1785b1c60cb443b5413c" id="r_a0f34b5e1c93a1785b1c60cb443b5413c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f34b5e1c93a1785b1c60cb443b5413c">adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const =0</td></tr>
<tr class="memdesc:a0f34b5e1c93a1785b1c60cb443b5413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <br /></td></tr>
<tr class="separator:a0f34b5e1c93a1785b1c60cb443b5413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de3ed22be2495ce0c08e46eb4f9632c" id="r_a6de3ed22be2495ce0c08e46eb4f9632c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *, size_t, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de3ed22be2495ce0c08e46eb4f9632c">nextBoundaryAnnulus</a> (size_t thisAnnulus, bool followPrev) const</td></tr>
<tr class="memdesc:a6de3ed22be2495ce0c08e46eb4f9632c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region.  <br /></td></tr>
<tr class="separator:a6de3ed22be2495ce0c08e46eb4f9632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192ac0dfb2fd6c156ab9aa48d2c9570" id="r_a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7192ac0dfb2fd6c156ab9aa48d2c9570">abbr</a> (bool tex=false) const</td></tr>
<tr class="memdesc:a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an abbreviated name or symbol for this block.  <br /></td></tr>
<tr class="separator:a7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81d8335c3999dfea5665b9d2b21134f" id="r_ab81d8335c3999dfea5665b9d2b21134f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81d8335c3999dfea5665b9d2b21134f">writeAbbr</a> (std::ostream &amp;out, bool tex=false) const =0</td></tr>
<tr class="memdesc:ab81d8335c3999dfea5665b9d2b21134f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <br /></td></tr>
<tr class="separator:ab81d8335c3999dfea5665b9d2b21134f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076736b6fe8a23d801e9bd5179aaf205" id="r_a076736b6fe8a23d801e9bd5179aaf205"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a076736b6fe8a23d801e9bd5179aaf205">operator&lt;</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;compare) const</td></tr>
<tr class="memdesc:a076736b6fe8a23d801e9bd5179aaf205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a consistent ordering of saturated blocks.  <br /></td></tr>
<tr class="separator:a076736b6fe8a23d801e9bd5179aaf205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73538e89187119b81ef155e5c6e5a189" id="r_a73538e89187119b81ef155e5c6e5a189"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73538e89187119b81ef155e5c6e5a189">operator==</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;other) const =0</td></tr>
<tr class="memdesc:a73538e89187119b81ef155e5c6e5a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object represent saturated blocks of the same type with the same combinatorial parameters.  <br /></td></tr>
<tr class="separator:a73538e89187119b81ef155e5c6e5a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9132afd504fc59876171a9a1b0054dd" id="r_ad9132afd504fc59876171a9a1b0054dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9132afd504fc59876171a9a1b0054dd">operator!=</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;other) const</td></tr>
<tr class="memdesc:ad9132afd504fc59876171a9a1b0054dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object do not represent saturated blocks of the same type with the same combinatorial parameters.  <br /></td></tr>
<tr class="separator:ad9132afd504fc59876171a9a1b0054dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27450164476537cc702924e8f039947f" id="r_a27450164476537cc702924e8f039947f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27450164476537cc702924e8f039947f">writeTextShort</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:a27450164476537cc702924e8f039947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:a27450164476537cc702924e8f039947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e17134c367b5c4a28146bc8ea074290" id="r_a1e17134c367b5c4a28146bc8ea074290"><td class="memItemLeft" align="right" valign="top"><a id="a1e17134c367b5c4a28146bc8ea074290" name="a1e17134c367b5c4a28146bc8ea074290"></a>
<a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;)=delete</td></tr>
<tr class="separator:a1e17134c367b5c4a28146bc8ea074290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d" id="r_aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab56d3fe04328343ab2d73567bc050b76" id="r_ab56d3fe04328343ab2d73567bc050b76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab56d3fe04328343ab2d73567bc050b76">SatBlock</a> (size_t nAnnuli, bool <a class="el" href="#ad1893440bbd41f62a28f1c49f7d3bfae">twistedBoundary</a>=false)</td></tr>
<tr class="memdesc:ab56d3fe04328343ab2d73567bc050b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a block with the given number of annuli on the boundary.  <br /></td></tr>
<tr class="separator:ab56d3fe04328343ab2d73567bc050b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5e2d7590e6821abcb395a4788a7f66" id="r_a2f5e2d7590e6821abcb395a4788a7f66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f5e2d7590e6821abcb395a4788a7f66">SatBlock</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a2f5e2d7590e6821abcb395a4788a7f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new clone of the given block.  <br /></td></tr>
<tr class="separator:a2f5e2d7590e6821abcb395a4788a7f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de4e0aaeef6c4687f3c058024b2c8e" id="r_a56de4e0aaeef6c4687f3c058024b2c8e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56de4e0aaeef6c4687f3c058024b2c8e">clone</a> () const =0</td></tr>
<tr class="memdesc:a56de4e0aaeef6c4687f3c058024b2c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly created clone of this saturated block structure.  <br /></td></tr>
<tr class="separator:a56de4e0aaeef6c4687f3c058024b2c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b29e72371d2c5754567983775593871" id="r_a9b29e72371d2c5754567983775593871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b29e72371d2c5754567983775593871">identicalBoundary</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;other) const</td></tr>
<tr class="memdesc:a9b29e72371d2c5754567983775593871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given block have identical boundaries.  <br /></td></tr>
<tr class="separator:a9b29e72371d2c5754567983775593871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78db6e0d43417ce0218691cf0f6a70b9" id="r_a78db6e0d43417ce0218691cf0f6a70b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlockModel.html">SatBlockModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78db6e0d43417ce0218691cf0f6a70b9">modelWith</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:a78db6e0d43417ce0218691cf0f6a70b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new model that combines this block structure with the given triangulation.  <br /></td></tr>
<tr class="separator:a78db6e0d43417ce0218691cf0f6a70b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6f08ca90689619a7e1abd94af0184f" id="r_a6e6f08ca90689619a7e1abd94af0184f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6f08ca90689619a7e1abd94af0184f">transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;iso, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;newTri)</td></tr>
<tr class="memdesc:a6e6f08ca90689619a7e1abd94af0184f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the structure of this block according to the given isomorphism between triangulations.  <br /></td></tr>
<tr class="separator:a6e6f08ca90689619a7e1abd94af0184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a78cc50e61e42c702e1a3dcd1819094d8" id="r_a78cc50e61e42c702e1a3dcd1819094d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78cc50e61e42c702e1a3dcd1819094d8">isBad</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t, const <a class="el" href="#a1f6a621c1f4970f8968c4d7aee186274">TetList</a> &amp;list)</td></tr>
<tr class="memdesc:a78cc50e61e42c702e1a3dcd1819094d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <br /></td></tr>
<tr class="separator:a78cc50e61e42c702e1a3dcd1819094d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b092ed79965d38bb36e5c5487b6749a" id="r_a3b092ed79965d38bb36e5c5487b6749a"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:a3b092ed79965d38bb36e5c5487b6749a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b092ed79965d38bb36e5c5487b6749a">isBad</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *t, const List &amp;list)</td></tr>
<tr class="memdesc:a3b092ed79965d38bb36e5c5487b6749a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <br /></td></tr>
<tr class="separator:a3b092ed79965d38bb36e5c5487b6749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a34f87fcfee3ed68311721699cf162" id="r_a71a34f87fcfee3ed68311721699cf162"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71a34f87fcfee3ed68311721699cf162">notUnique</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *test)</td></tr>
<tr class="memdesc:a71a34f87fcfee3ed68311721699cf162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null.  <br /></td></tr>
<tr class="separator:a71a34f87fcfee3ed68311721699cf162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e2e85cc43c1bdb17d580d6eed5dd1" id="r_a5e4e2e85cc43c1bdb17d580d6eed5dd1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e4e2e85cc43c1bdb17d580d6eed5dd1">notUnique</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *test, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other1)</td></tr>
<tr class="memdesc:a5e4e2e85cc43c1bdb17d580d6eed5dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <br /></td></tr>
<tr class="separator:a5e4e2e85cc43c1bdb17d580d6eed5dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1326c9598a7d8b730ce69072bc0ada1" id="r_ac1326c9598a7d8b730ce69072bc0ada1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1326c9598a7d8b730ce69072bc0ada1">notUnique</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *test, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other1, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other2)</td></tr>
<tr class="memdesc:ac1326c9598a7d8b730ce69072bc0ada1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <br /></td></tr>
<tr class="separator:ac1326c9598a7d8b730ce69072bc0ada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b52a3cc42b29adf27f2223db6192d5b" id="r_a9b52a3cc42b29adf27f2223db6192d5b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b52a3cc42b29adf27f2223db6192d5b">notUnique</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *test, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other1, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other2, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other3)</td></tr>
<tr class="memdesc:a9b52a3cc42b29adf27f2223db6192d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <br /></td></tr>
<tr class="separator:a9b52a3cc42b29adf27f2223db6192d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4758079b3f1c45afcfde23faac5f3" id="r_a1cb4758079b3f1c45afcfde23faac5f3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb4758079b3f1c45afcfde23faac5f3">notUnique</a> (const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *test, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other1, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other2, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other3, const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *other4)</td></tr>
<tr class="memdesc:a1cb4758079b3f1c45afcfde23faac5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <br /></td></tr>
<tr class="separator:a1cb4758079b3f1c45afcfde23faac5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0ccc30e4b13f25ab100f4d25cb677b9a" id="r_a0ccc30e4b13f25ab100f4d25cb677b9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ccc30e4b13f25ab100f4d25cb677b9a">nAnnuli_</a></td></tr>
<tr class="memdesc:a0ccc30e4b13f25ab100f4d25cb677b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary annuli.  <br /></td></tr>
<tr class="separator:a0ccc30e4b13f25ab100f4d25cb677b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a97514c4f3ee1dea5a0331e1161417" id="r_a66a97514c4f3ee1dea5a0331e1161417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a97514c4f3ee1dea5a0331e1161417">annulus_</a></td></tr>
<tr class="memdesc:a66a97514c4f3ee1dea5a0331e1161417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of each boundary annulus, as seen from the inside of this saturated block.  <br /></td></tr>
<tr class="separator:a66a97514c4f3ee1dea5a0331e1161417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46bf466819a76108db37eb218c4a458" id="r_ab46bf466819a76108db37eb218c4a458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab46bf466819a76108db37eb218c4a458">twistedBoundary_</a></td></tr>
<tr class="memdesc:ab46bf466819a76108db37eb218c4a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a Mobius band?  <br /></td></tr>
<tr class="separator:ab46bf466819a76108db37eb218c4a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb04cbf5461053c069fe67c54584c04" id="r_a6fb04cbf5461053c069fe67c54584c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb04cbf5461053c069fe67c54584c04">adjBlock_</a></td></tr>
<tr class="memdesc:a6fb04cbf5461053c069fe67c54584c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known.  <br /></td></tr>
<tr class="separator:a6fb04cbf5461053c069fe67c54584c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8715b852a047e1974a92b9826761141a" id="r_a8715b852a047e1974a92b9826761141a"><td class="memItemLeft" align="right" valign="top">size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8715b852a047e1974a92b9826761141a">adjAnnulus_</a></td></tr>
<tr class="memdesc:a8715b852a047e1974a92b9826761141a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block.  <br /></td></tr>
<tr class="separator:a8715b852a047e1974a92b9826761141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9015c09cdd1987f7c3d1af08bf777" id="r_a88f9015c09cdd1987f7c3d1af08bf777"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f9015c09cdd1987f7c3d1af08bf777">adjReflected_</a></td></tr>
<tr class="memdesc:a88f9015c09cdd1987f7c3d1af08bf777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is reflected (see the class notes above).  <br /></td></tr>
<tr class="separator:a88f9015c09cdd1987f7c3d1af08bf777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcda28943ad300bcfd713f8bb4f59a8" id="r_aafcda28943ad300bcfd713f8bb4f59a8"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafcda28943ad300bcfd713f8bb4f59a8">adjBackwards_</a></td></tr>
<tr class="memdesc:aafcda28943ad300bcfd713f8bb4f59a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is backwards (see the class notes above).  <br /></td></tr>
<tr class="separator:aafcda28943ad300bcfd713f8bb4f59a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a33c02384546b2e9318b461a77d6a69e8" id="r_a33c02384546b2e9318b461a77d6a69e8"><td class="memItemLeft" align="right" valign="top"><a id="a33c02384546b2e9318b461a77d6a69e8" name="a33c02384546b2e9318b461a77d6a69e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SatBlockModel</b></td></tr>
<tr class="separator:a33c02384546b2e9318b461a77d6a69e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f29bd20f5eb80ef7ca92bf0bf236bf" id="r_a95f29bd20f5eb80ef7ca92bf0bf236bf"><td class="memItemLeft" align="right" valign="top"><a id="a95f29bd20f5eb80ef7ca92bf0bf236bf" name="a95f29bd20f5eb80ef7ca92bf0bf236bf"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SatRegion</b></td></tr>
<tr class="separator:a95f29bd20f5eb80ef7ca92bf0bf236bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a saturated block in a Seifert fibred space. </p>
<p>A saturated block is a connected set of tetrahedra built from a subset of fibres (no fibres may enter or exit the boundary of the block). In addition, the boundary of this block must be a ring of saturated annuli, as described by the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class. Aside from this ring of saturated annuli, there may be no other boundary triangles within the block.</p>
<p>The boundary annuli are numbered consecutively as illustrated below, where the markings 0 and 1 within the triangles represent the first and second triangle of each annulus (see the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes for details). Note that the following diagram is viewed from <em>inside</em> the block.</p>
<pre>
              -+---+---+---+---+---+---+-
               |0 /|0 /|0 /|0 /|0 /|0 /|
           ... | / | / | / | / | / | / | ...
               |/ 1|/ 1|/ 1|/ 1|/ 1|/ 1|
              -+---+---+---+---+---+---+-
Annulus #  ...  n-2 n-1  0   1   2   3   ...
</pre><p>The ring of boundary annuli may optionally be twisted, so that together the annuli form a long Mobius band. In this case, for the purposes of labelling and marking annuli, the twist occurs between annuli n-1 and 0. Be careful when dealing with blocks with twisted boundaries, since with twists it is possible to identify an edge with itself in reverse (thus producing something that is not a 3-manifold triangulation).</p>
<p>Each saturated block corresponds to a piece of the base orbifold of the larger Seifert fibred space. For the purpose of connecting the base orbifold together, we assume that the boundary of this particular piece runs horizontally in the diagram above (specifically following the horizontal edges of the boundary annuli, as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes). Insisting on such a boundary may lead to (1,<em>k</em>) twists within the block; these are accounted for by the virtual <a class="el" href="#a0f34b5e1c93a1785b1c60cb443b5413c" title="Adjusts the given Seifert fibred space to insert the contents of this saturated block.">adjustSFS()</a> routine.</p>
<p>Saturated blocks are generally joined to one another (or themselves) along their boundary annuli. For this purpose, each saturated block contains a list of which annulus of this block is adjacent to which annulus of which other block. Adjacencies may be <em>reflected</em>, meaning that the adjacent annulus has its fibres reversed (i.e., the adjacent annulus has undergone an up-to-down reflection); they may also be <em>backwards</em>, meaning that the first triangle of one annulus is joined to the second triangle of the other (and vice versa).</p>
<p>This is an abstract base class: its subclasses correspond to different combinatorial constructions (or in some cases, parameterised families of constructions). Each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a>:</p>
<ul>
<li>must override all pure virtual functions (of course);</li>
<li>should override <a class="el" href="#a6e6f08ca90689619a7e1abd94af0184f" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">transform()</a> if the subclass contains additional data that needs to be altered when an isomorphism is applied;</li>
<li>should not override <a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong()</a>, since <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> uses short output only.</li>
</ul>
<p><a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> does not support value semantics: blocks cannot be copied, swapped, or manually constructed. Their memory is managed by the <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> class (or in special cases the <a class="el" href="classregina_1_1SatBlockModel.html" title="Contains an explicit triangulation of a saturated block along with the accompanying saturated block d...">SatBlockModel</a> class), and their locations in memory define them. See <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> for further details. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1f6a621c1f4970f8968c4d7aee186274" name="a1f6a621c1f4970f8968c4d7aee186274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6a621c1f4970f8968c4d7aee186274">&#9670;&#160;</a></span>TetList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f6a621c1f4970f8968c4d7aee186274">regina::SatBlock::TetList</a> = std::set&lt;const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt;3&gt;*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data structure used to store a list of tetrahedra that should not be examined when searching for saturated blocks. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1626a88050fce82a844bb7258b20c3e3" name="a1626a88050fce82a844bb7258b20c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1626a88050fce82a844bb7258b20c3e3">&#9670;&#160;</a></span>~SatBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::~SatBlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all internal arrays. </p>
<p>Note that any adjacent blocks that are referenced by the <em>adjBlock</em> array will <em>not</em> be destroyed. </p>

</div>
</div>
<a id="ab56d3fe04328343ab2d73567bc050b76" name="ab56d3fe04328343ab2d73567bc050b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d3fe04328343ab2d73567bc050b76">&#9670;&#160;</a></span>SatBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::SatBlock </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nAnnuli</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>twistedBoundary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a block with the given number of annuli on the boundary. </p>
<p>All arrays will be constructed but their contents will remain uninitialised, with the exception that the <em>adjBlock</em> array will be filled with null pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAnnuli</td><td>the number of annuli on the boundary of this block; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twistedBoundary</td><td><code>true</code> if the ring of boundary annuli is twisted to form a long Mobius band, or <code>false</code> (the default) if it is not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f5e2d7590e6821abcb395a4788a7f66" name="a2f5e2d7590e6821abcb395a4788a7f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5e2d7590e6821abcb395a4788a7f66">&#9670;&#160;</a></span>SatBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::SatBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cloneMe</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new clone of the given block. </p>
<p>Note that the new <em>adjBlock_</em> array will contain pointers to the same adjacent blocks as the original. That is, adjacent blocks will not be cloned also; instead pointers to adjacent blocks will simply be copied across.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the saturated block to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7192ac0dfb2fd6c156ab9aa48d2c9570" name="a7192ac0dfb2fd6c156ab9aa48d2c9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192ac0dfb2fd6c156ab9aa48d2c9570">&#9670;&#160;</a></span>abbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SatBlock::abbr </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an abbreviated name or symbol for this block. </p>
<p>This name will reflect the particular block type, but may not provide thorough details.</p>
<p>The name will be no more than a handful of characters long, and will not include a newline (or surrounding dollar signs in TeX mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td><code>true</code> if the name should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abbreviated name for this block. </dd></dl>

</div>
</div>
<a id="a1c6670c4a40284c2161aa3ae261b0a67" name="a1c6670c4a40284c2161aa3ae261b0a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6670c4a40284c2161aa3ae261b0a67">&#9670;&#160;</a></span>adjacentAnnulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SatBlock::adjacentAnnulus </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>whichAnnulus</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding annulus number on the other block that is adjacent along this annulus. </dd></dl>

</div>
</div>
<a id="a32f979a098cfd67c2e7261b2305ff736" name="a32f979a098cfd67c2e7261b2305ff736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f979a098cfd67c2e7261b2305ff736">&#9670;&#160;</a></span>adjacentBackwards()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentBackwards </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>whichAnnulus</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the adjacency along the given boundary annulus of this block is backwards. </p>
<p>See the class notes for a discussion of backwards adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is backwards, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="ade9b8897c8eec3ddfd7c364eca5b8467" name="ade9b8897c8eec3ddfd7c364eca5b8467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b8897c8eec3ddfd7c364eca5b8467">&#9670;&#160;</a></span>adjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatBlock::adjacentBlock </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>whichAnnulus</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other block adjacent along this annulus, or <code>null</code> if there is no adjacent block listed. </dd></dl>

</div>
</div>
<a id="a2fbc311f7479aeb6b14a83889b586dc9" name="a2fbc311f7479aeb6b14a83889b586dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc311f7479aeb6b14a83889b586dc9">&#9670;&#160;</a></span>adjacentReflected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentReflected </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>whichAnnulus</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the adjacency along the given boundary annulus of this block is reflected. </p>
<p>See the class notes for a discussion of reflected adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is reflected, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="a0f34b5e1c93a1785b1c60cb443b5413c" name="a0f34b5e1c93a1785b1c60cb443b5413c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f34b5e1c93a1785b1c60cb443b5413c">&#9670;&#160;</a></span>adjustSFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reflect</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1SatCube.html#a40d6ea312577ae90eec93f82d25c3579">regina::SatCube</a>, <a class="el" href="classregina_1_1SatLayering.html#aa5c4e1c1bb81c2c0d7c4168f3544a800">regina::SatLayering</a>, <a class="el" href="classregina_1_1SatLST.html#a4a2609da5d70703ce58dcb3428f9c34a">regina::SatLST</a>, <a class="el" href="classregina_1_1SatMobius.html#ad15302265d9e67af64d0dc99a17eb23d">regina::SatMobius</a>, <a class="el" href="classregina_1_1SatReflectorStrip.html#aca6663489ef98c097f86953967b27080">regina::SatReflectorStrip</a>, and <a class="el" href="classregina_1_1SatTriPrism.html#a5980ab22702f30273ff7d93814e8b626">regina::SatTriPrism</a>.</p>

</div>
</div>
<a id="ab5eea7e2e3c38b8ea7891e829ed9f89f" name="ab5eea7e2e3c38b8ea7891e829ed9f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eea7e2e3c38b8ea7891e829ed9f89f">&#9670;&#160;</a></span>annulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatBlock::annulus </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>which</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the requested annulus on the boundary of this saturated block. </p>
<p>Annuli are numbered from 0 to <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 as described in the class notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which boundary annulus is requested; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested boundary annulus. </dd></dl>

</div>
</div>
<a id="a56de4e0aaeef6c4687f3c058024b2c8e" name="a56de4e0aaeef6c4687f3c058024b2c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de4e0aaeef6c4687f3c058024b2c8e">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatBlock::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1SatCube.html#a4c9a05297dcb7dab0014f54b888c6665">regina::SatCube</a>, <a class="el" href="classregina_1_1SatLayering.html#a32d114838d339ea034a03facda36ba05">regina::SatLayering</a>, <a class="el" href="classregina_1_1SatLST.html#a5ed63303e680ec48e1e342c9cd8a0bd0">regina::SatLST</a>, <a class="el" href="classregina_1_1SatMobius.html#aabff7831bf78f47b456d85d237b61738">regina::SatMobius</a>, <a class="el" href="classregina_1_1SatReflectorStrip.html#a3aea1ca51b8b1f1141c2e1c05a821b54">regina::SatReflectorStrip</a>, and <a class="el" href="classregina_1_1SatTriPrism.html#a87a6fe9a00b3a689f4d871d5a41d2f45">regina::SatTriPrism</a>.</p>

</div>
</div>
<a id="aaf61cefe231132fadb7a123d39309cfa" name="aaf61cefe231132fadb7a123d39309cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf61cefe231132fadb7a123d39309cfa">&#9670;&#160;</a></span>countAnnuli()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SatBlock::countAnnuli </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of annuli on the boundary of this saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a17cb37b29dfce1624e8329a655b95de4" name="a17cb37b29dfce1624e8329a655b95de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb37b29dfce1624e8329a655b95de4">&#9670;&#160;</a></span>hasAdjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::hasAdjacentBlock </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>whichAnnulus</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there is another saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary annulus has an adjacent block listed, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9b29e72371d2c5754567983775593871" name="a9b29e72371d2c5754567983775593871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b29e72371d2c5754567983775593871">&#9670;&#160;</a></span>identicalBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::identicalBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given block have identical boundaries. </p>
<p>This requires not just that both boundaries represent the same subcomplex of the underlying triangulation, but also that the boundaries use identical saturated annuli, and that these annuli appear in the same order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the block to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given block have identical boundaries, as described above. </dd></dl>

</div>
</div>
<a id="a3b092ed79965d38bb36e5c5487b6749a" name="a3b092ed79965d38bb36e5c5487b6749a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b092ed79965d38bb36e5c5487b6749a">&#9670;&#160;</a></span>isBad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const List &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines. It is a generic routine for working with arbitrary list types.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Forward iterators of type <code>List::const_iterator</code> that span the given list can be obtained by calling <code>list.begin()</code> and <code>list.end()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="a78cc50e61e42c702e1a3dcd1819094d8" name="a78cc50e61e42c702e1a3dcd1819094d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cc50e61e42c702e1a3dcd1819094d8">&#9670;&#160;</a></span>isBad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1f6a621c1f4970f8968c4d7aee186274">TetList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="a78db6e0d43417ce0218691cf0f6a70b9" name="a78db6e0d43417ce0218691cf0f6a70b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78db6e0d43417ce0218691cf0f6a70b9">&#9670;&#160;</a></span>modelWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlockModel.html">SatBlockModel</a> regina::SatBlock::modelWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new model that combines this block structure with the given triangulation. </p>
<p>The new model will take ownership of both this block and the given triangulation.</p>
<p>The purpose of this routine is, essentially, to give subclasses access to the private <a class="el" href="classregina_1_1SatBlockModel.html" title="Contains an explicit triangulation of a saturated block along with the accompanying saturated block d...">SatBlockModel</a> constructor (which <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> can access as a friend class, but which subclasses cannot).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>an explicit triangulation of this block structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a model that holds this block and the given triangulation. </dd></dl>

</div>
</div>
<a id="a6de3ed22be2495ce0c08e46eb4f9632c" name="a6de3ed22be2495ce0c08e46eb4f9632c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de3ed22be2495ce0c08e46eb4f9632c">&#9670;&#160;</a></span>nextBoundaryAnnulus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *, size_t, bool, bool &gt; regina::SatBlock::nextBoundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>thisAnnulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>followPrev</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region. </p>
<p>Suppose that all saturated blocks are merged together according to adjacent boundary annuli, forming larger saturated structures. The remaining annuli that do not have adjacent blocks will group together to form several large boundary rings. Note that each boundary ring might involve annuli from several different blocks, and might or might not have a twist (thus forming a large Klein bottle instead of a large torus).</p>
<p>This routine is used to trace around such a boundary ring. It is assumed that annulus <em>thisAnnulus</em> of this block forms part of a boundary ring (i.e., it has no adjacent block). This routine will then return the next/previous annulus around from this in the large boundary ring. Here "next" means in the direction following from the second triangle of this annulus, and "previous" means in the direction following from the first triangle; the boolean argument <em>followPrev</em> controls which we will be used. This next/previous annulus might belong to another block, or it might even be this original annulus again.</p>
<p>The next/previous annulus itself is not returned, but rather a reference as to how it appears within its enclosing saturated block. Specifically, a block and corresponding annulus number will be included as the first two elements of the returned tuple.</p>
<p>It is possible that the next/previous annulus as it appears within the returned block is oriented differently from how it appears within this large boundary ring. For this reason, two booleans are returned also. The third element of the returned tuple will describe whether the annulus is reflected vertically as it appears within the large boundary ring (i.e., the first and second triangles remain the same but the fibre direction is reversed). Similarly, the fourth element of the tuple will describe whether the annulus is reflected horizontally as it appears within the large boundary ring (i.e., first and second triangles are switched but the fibre direction is unchanged).</p>
<p>It is possible that both a horizontal and vertical reflection take place. Note that any kind of reflection will also affect the locations of the 0/1/2 markings as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes.</p>
<p>Finally, note that if the large boundary ring is twisted (i.e., it forms a Klein bottle), then following the entire boundary ring around using this routine will bring you back to the starting annulus but with the vertical reflection flag set.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Annulus <em>thisAnnulus</em> of this block has no block adjacent to it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to trace around an entire boundary ring, you will need to adjust the argument <em>followPrev</em> according to whether or not the current annulus is reflected horizontally (since, under a horizontal reflection, "next" becomes "previous" and vice versa).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisAnnulus</td><td>describes which original boundary annulus of this block to examine; this must be between 0 and <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">followPrev</td><td><code>true</code> if we should find the previous boundary annulus, or <code>false</code> if we should find the next boundary annulus. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple (<em>nextBlock</em>, <em>nextAnnulus</em>, <em>refVert</em>, <em>refHoriz</em>), where: <em>nextBlock</em> is the block containing the next boundary annulus around from <em>thisAnnulus</em>; <em>nextAnnulus</em> is the specific annulus number within <em>nextBlock</em> of the next annulus around (between 0 and <em>nextBlock-&gt;<a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1</em> inclusive, and the corresponding annulus will have no block adjacent to it); <em>refVert</em> is <code>true</code> iff the next annulus around is vertically reflected; and <em>refHoriz</em> is <code>true</code> iff the next annulus around is horizontally reflected (see above for details on reflections). </dd></dl>

</div>
</div>
<a id="a71a34f87fcfee3ed68311721699cf162" name="a71a34f87fcfee3ed68311721699cf162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a34f87fcfee3ed68311721699cf162">&#9670;&#160;</a></span>notUnique() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>test</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null. </p>
<p>This is intended as a helper routine for isBlock() and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<p>The name <a class="el" href="#a71a34f87fcfee3ed68311721699cf162" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> may seem strang for what is essentially a nullity test; in fact this routine is offered as a degenerate case of other variants of <a class="el" href="#a71a34f87fcfee3ed68311721699cf162" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> that take more tetrahedra as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5e4e2e85cc43c1bdb17d580d6eed5dd1" name="a5e4e2e85cc43c1bdb17d580d6eed5dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e2e85cc43c1bdb17d580d6eed5dd1">&#9670;&#160;</a></span>notUnique() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac1326c9598a7d8b730ce69072bc0ada1" name="ac1326c9598a7d8b730ce69072bc0ada1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1326c9598a7d8b730ce69072bc0ada1">&#9670;&#160;</a></span>notUnique() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em> or <em>other2</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9b52a3cc42b29adf27f2223db6192d5b" name="a9b52a3cc42b29adf27f2223db6192d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b52a3cc42b29adf27f2223db6192d5b">&#9670;&#160;</a></span>notUnique() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other3</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em> or <em>other3</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1cb4758079b3f1c45afcfde23faac5f3" name="a1cb4758079b3f1c45afcfde23faac5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4758079b3f1c45afcfde23faac5f3">&#9670;&#160;</a></span>notUnique() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga96c26329d1774a420e0642abf45bf897">Tetrahedron</a>&lt; 3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>other4</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for isBlock() and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other4</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em>, <em>other3</em> or <em>other4</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad9132afd504fc59876171a9a1b0054dd" name="ad9132afd504fc59876171a9a1b0054dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9132afd504fc59876171a9a1b0054dd">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object do not represent saturated blocks of the same type with the same combinatorial parameters. </p>
<p>See the equality test <a class="el" href="#a73538e89187119b81ef155e5c6e5a189" title="Determines whether this and the given object represent saturated blocks of the same type with the sam...">operator==()</a> for examples of what is meant by "the same combinatorial parameters".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the saturated block to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object do not represent blocks of the same type with the same parameters. </dd></dl>

</div>
</div>
<a id="a076736b6fe8a23d801e9bd5179aaf205" name="a076736b6fe8a23d801e9bd5179aaf205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076736b6fe8a23d801e9bd5179aaf205">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a consistent ordering of saturated blocks. </p>
<p>This ordering is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the saturated block with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this block comes before the given block according to the ordering of saturated blocks, or <code>false</code> if either the blocks are identical or this block comes after the given block. </dd></dl>

</div>
</div>
<a id="a73538e89187119b81ef155e5c6e5a189" name="a73538e89187119b81ef155e5c6e5a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73538e89187119b81ef155e5c6e5a189">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::SatBlock::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object represent saturated blocks of the same type with the same combinatorial parameters. </p>
<p>As examples of what is meant by "combinatorial parameters":</p>
<ul>
<li>Any two <a class="el" href="classregina_1_1SatCube.html" title="A saturated block that is a six-tetrahedron cube.">SatCube</a> objects will compare as equal, since there is only one combinatorial type of <a class="el" href="classregina_1_1SatCube.html" title="A saturated block that is a six-tetrahedron cube.">SatCube</a>.</li>
<li>Two <a class="el" href="classregina_1_1SatReflectorStrip.html" title="A saturated block that is a reflector strip.">SatReflectorStrip</a> objects will compare as equal if their rings of bounary annuli have the same length and are either both twisted or both untwisted.</li>
<li>Two <a class="el" href="classregina_1_1SatLST.html" title="A saturated block that is a layered solid torus.">SatLST</a> objects will compare as equal if their internal layered solid tori have the same three integer parameters (identifying how the meridinal disc meets the three boundary edges), <em>and</em> their corresponding boundary edges are attached to the horizontal/vertical/diagonal edges of the boundary annulus in the same way.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the saturated block to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object represent blocks of the same type with the same parameters. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1SatCube.html#ac756544818cd0ccdd60d97798d753c88">regina::SatCube</a>, <a class="el" href="classregina_1_1SatLayering.html#ac2115baaf13b19248f3e0088d83bf415">regina::SatLayering</a>, <a class="el" href="classregina_1_1SatLST.html#aac41b9e51f0414a258ec722790a5b75f">regina::SatLST</a>, <a class="el" href="classregina_1_1SatMobius.html#ad5a4fdb4f91f340db66fdab78036479f">regina::SatMobius</a>, <a class="el" href="classregina_1_1SatReflectorStrip.html#a4f928b2bc696962a770d1bd0169c3348">regina::SatReflectorStrip</a>, and <a class="el" href="classregina_1_1SatTriPrism.html#ad534d406873a08967e27139a9881d014">regina::SatTriPrism</a>.</p>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a6e6f08ca90689619a7e1abd94af0184f" name="a6e6f08ca90689619a7e1abd94af0184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6f08ca90689619a7e1abd94af0184f">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>originalTri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iso</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newTri</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the structure of this block according to the given isomorphism between triangulations. </p>
<p>Any triangulation-specific information will be transformed accordingly (for instance, the routine <a class="el" href="structregina_1_1SatAnnulus.html#ac5f8e50c4838b9acb4fa463e38b9f644" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">SatAnnulus::transform()</a> will be called for each boundary annulus).</p>
<p>Information regarding adjacent blocks will <em>not</em> be changed. Only structural information for this particular block will be updated.</p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this block must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called the block will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This block currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any subclasses of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> that store additional triangulation-specific information will need to override this routine. When doing so, be sure to call <a class="el" href="#a6e6f08ca90689619a7e1abd94af0184f" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">SatBlock::transform()</a> so that the generic changes defined here will still take place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this saturated block. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated block structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1SatLST.html#a93aad415eb031087ba840301791d8a4a">regina::SatLST</a>.</p>

</div>
</div>
<a id="ad1893440bbd41f62a28f1c49f7d3bfae" name="ad1893440bbd41f62a28f1c49f7d3bfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1893440bbd41f62a28f1c49f7d3bfae">&#9670;&#160;</a></span>twistedBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a long Mobius strip? </p>
<p>Recall from the class notes that the twist occurs between boundary annuli <a class="el" href="#aaf61cefe231132fadb7a123d39309cfa" title="Returns the number of annuli on the boundary of this saturated block.">countAnnuli()</a>-1 and 0.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the ring of boundary annuli is twisted, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ab81d8335c3999dfea5665b9d2b21134f" name="ab81d8335c3999dfea5665b9d2b21134f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81d8335c3999dfea5665b9d2b21134f">&#9670;&#160;</a></span>writeAbbr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a7192ac0dfb2fd6c156ab9aa48d2c9570" title="Returns an abbreviated name or symbol for this block.">abbr()</a> that returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1SatCube.html#a3a75bc834917cbc4dea03ab41f055f37">regina::SatCube</a>, <a class="el" href="classregina_1_1SatLayering.html#a265e7b7e42b84115fc9a99bfa6322120">regina::SatLayering</a>, <a class="el" href="classregina_1_1SatLST.html#ae035387f90806c79669d7d9ff838e7a6">regina::SatLST</a>, <a class="el" href="classregina_1_1SatMobius.html#a0be1cbc31ba5b8b4cfff800d5e55274b">regina::SatMobius</a>, <a class="el" href="classregina_1_1SatReflectorStrip.html#aacf1d38319376efdada01acf757fa342">regina::SatReflectorStrip</a>, and <a class="el" href="classregina_1_1SatTriPrism.html#a723ccdc7de49209c5bf7b3a4977c17e3">regina::SatTriPrism</a>.</p>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call detail() from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27450164476537cc702924e8f039947f" name="a27450164476537cc702924e8f039947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27450164476537cc702924e8f039947f">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1SatCube.html#a25aceb80b2d715df1fda912b17e3f9ad">regina::SatCube</a>, <a class="el" href="classregina_1_1SatLayering.html#adbd63b216e4e5eb3c9a609f5e8dc8855">regina::SatLayering</a>, <a class="el" href="classregina_1_1SatLST.html#acfbaac4cbde7e98d0ccbe103f63e7d65">regina::SatLST</a>, <a class="el" href="classregina_1_1SatMobius.html#aea7173dbbfc1e4b2197f8da857e01809">regina::SatMobius</a>, <a class="el" href="classregina_1_1SatReflectorStrip.html#a30ae58723734d89763e3cd684b89e352">regina::SatReflectorStrip</a>, and <a class="el" href="classregina_1_1SatTriPrism.html#ac988f9304e4a52b69df5ffc232ec34a1">regina::SatTriPrism</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8715b852a047e1974a92b9826761141a" name="a8715b852a047e1974a92b9826761141a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8715b852a047e1974a92b9826761141a">&#9670;&#160;</a></span>adjAnnulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t* regina::SatBlock::adjAnnulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block. </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="aafcda28943ad300bcfd713f8bb4f59a8" name="aafcda28943ad300bcfd713f8bb4f59a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcda28943ad300bcfd713f8bb4f59a8">&#9670;&#160;</a></span>adjBackwards_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjBackwards_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is backwards (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="a6fb04cbf5461053c069fe67c54584c04" name="a6fb04cbf5461053c069fe67c54584c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb04cbf5461053c069fe67c54584c04">&#9670;&#160;</a></span>adjBlock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>** regina::SatBlock::adjBlock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known. </p>

</div>
</div>
<a id="a88f9015c09cdd1987f7c3d1af08bf777" name="a88f9015c09cdd1987f7c3d1af08bf777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9015c09cdd1987f7c3d1af08bf777">&#9670;&#160;</a></span>adjReflected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjReflected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is reflected (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="a66a97514c4f3ee1dea5a0331e1161417" name="a66a97514c4f3ee1dea5a0331e1161417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a97514c4f3ee1dea5a0331e1161417">&#9670;&#160;</a></span>annulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>* regina::SatBlock::annulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Details of each boundary annulus, as seen from the inside of this saturated block. </p>

</div>
</div>
<a id="a0ccc30e4b13f25ab100f4d25cb677b9a" name="a0ccc30e4b13f25ab100f4d25cb677b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccc30e4b13f25ab100f4d25cb677b9a">&#9670;&#160;</a></span>nAnnuli_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SatBlock::nAnnuli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary annuli. </p>

</div>
</div>
<a id="ab46bf466819a76108db37eb218c4a458" name="ab46bf466819a76108db37eb218c4a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46bf466819a76108db37eb218c4a458">&#9670;&#160;</a></span>twistedBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a Mobius band? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="satblock_8h.html">satblock.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
