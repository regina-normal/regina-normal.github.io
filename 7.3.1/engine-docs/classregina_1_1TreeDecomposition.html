<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3.1 Calculation Engine: regina::TreeDecomposition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1TreeDecomposition-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::TreeDecomposition Class Reference<div class="ingroups"><a class="el" href="group__treewidth.html">Treewidth</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a tree decomposition of a graph.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;treewidth/treedecomposition.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TreeDecomposition:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TreeDecomposition.png" usemap="#regina::TreeDecomposition_map" alt=""/>
  <map id="regina::TreeDecomposition_map" name="regina::TreeDecomposition_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; TreeDecomposition &gt;" shape="rect" coords="0,0,223,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a graph, which may be directed or undirected.  <a href="structregina_1_1TreeDecomposition_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a8cf5d6807672712644eae5dc99d42f" id="r_a1a8cf5d6807672712644eae5dc99d42f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8cf5d6807672712644eae5dc99d42f">TreeDecomposition</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;src)</td></tr>
<tr class="memdesc:a1a8cf5d6807672712644eae5dc99d42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new copy of the given tree decomposition.  <br /></td></tr>
<tr class="separator:a1a8cf5d6807672712644eae5dc99d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59aee01df1f3ff0c92782dd3d37175f" id="r_aa59aee01df1f3ff0c92782dd3d37175f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa59aee01df1f3ff0c92782dd3d37175f">TreeDecomposition</a> (<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aa59aee01df1f3ff0c92782dd3d37175f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given tree decomposition into this new tree decomposition.  <br /></td></tr>
<tr class="separator:aa59aee01df1f3ff0c92782dd3d37175f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9260954f8e9341c6a25f7610ab8863f8" id="r_a9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9260954f8e9341c6a25f7610ab8863f8">TreeDecomposition</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a9260954f8e9341c6a25f7610ab8863f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the facet pairing graph of the given triangulation.  <br /></td></tr>
<tr class="separator:a9260954f8e9341c6a25f7610ab8863f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b22a38314cfa157c7df66ebcc084ffc" id="r_a6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b22a38314cfa157c7df66ebcc084ffc">TreeDecomposition</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;pairing, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a6b22a38314cfa157c7df66ebcc084ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the given facet pairing graph.  <br /></td></tr>
<tr class="separator:a6b22a38314cfa157c7df66ebcc084ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19321d5f8b29246685ea6b10b9c0298" id="r_ab19321d5f8b29246685ea6b10b9c0298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19321d5f8b29246685ea6b10b9c0298">TreeDecomposition</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ab19321d5f8b29246685ea6b10b9c0298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram.  <br /></td></tr>
<tr class="separator:ab19321d5f8b29246685ea6b10b9c0298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dabae5ca31984eb49279d5dec6fd77" id="r_ad2dabae5ca31984eb49279d5dec6fd77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2dabae5ca31984eb49279d5dec6fd77"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2dabae5ca31984eb49279d5dec6fd77">TreeDecomposition</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;graph, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ad2dabae5ca31984eb49279d5dec6fd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of an arbitrary graph.  <br /></td></tr>
<tr class="separator:ad2dabae5ca31984eb49279d5dec6fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523704313af5935f994ad82f8553016" id="r_a8523704313af5935f994ad82f8553016"><td class="memTemplParams" colspan="2">template&lt;typename Row &gt; </td></tr>
<tr class="memitem:a8523704313af5935f994ad82f8553016"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8523704313af5935f994ad82f8553016">TreeDecomposition</a> (const std::vector&lt; Row &gt; &amp;graph, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:a8523704313af5935f994ad82f8553016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of an arbitrary graph.  <br /></td></tr>
<tr class="separator:a8523704313af5935f994ad82f8553016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbb52e2966ddb006c8f9964e009e2ee" id="r_a7dbb52e2966ddb006c8f9964e009e2ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dbb52e2966ddb006c8f9964e009e2ee">~TreeDecomposition</a> ()</td></tr>
<tr class="memdesc:a7dbb52e2966ddb006c8f9964e009e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tree decomposition and all of its bags.  <br /></td></tr>
<tr class="separator:a7dbb52e2966ddb006c8f9964e009e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed6f2b4447bcb23fc3164559d575e32" id="r_a2ed6f2b4447bcb23fc3164559d575e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed6f2b4447bcb23fc3164559d575e32">operator=</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;src)</td></tr>
<tr class="memdesc:a2ed6f2b4447bcb23fc3164559d575e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given tree decomposition.  <br /></td></tr>
<tr class="separator:a2ed6f2b4447bcb23fc3164559d575e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba34176107a52ab968337b7c2abd8d6" id="r_a8ba34176107a52ab968337b7c2abd8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba34176107a52ab968337b7c2abd8d6">operator=</a> (<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a8ba34176107a52ab968337b7c2abd8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given tree decomposition into this tree decomposition.  <br /></td></tr>
<tr class="separator:a8ba34176107a52ab968337b7c2abd8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecce7f76d97bce4c482670175b2e02db" id="r_aecce7f76d97bce4c482670175b2e02db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecce7f76d97bce4c482670175b2e02db">swap</a> (<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aecce7f76d97bce4c482670175b2e02db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given tree decomposition.  <br /></td></tr>
<tr class="separator:aecce7f76d97bce4c482670175b2e02db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6d2556cafa5c0bdd1210124797330c" id="r_adf6d2556cafa5c0bdd1210124797330c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf6d2556cafa5c0bdd1210124797330c">width</a> () const</td></tr>
<tr class="memdesc:adf6d2556cafa5c0bdd1210124797330c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of this tree decomposition.  <br /></td></tr>
<tr class="separator:adf6d2556cafa5c0bdd1210124797330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2df0bc8d01571ba0dd7f38a817c4fae" id="r_aa2df0bc8d01571ba0dd7f38a817c4fae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae">size</a> () const</td></tr>
<tr class="memdesc:aa2df0bc8d01571ba0dd7f38a817c4fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bags in this tree decomposition.  <br /></td></tr>
<tr class="separator:aa2df0bc8d01571ba0dd7f38a817c4fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac970ad26e45a07e4d1bb8d3a7b9cc1f6" id="r_ac970ad26e45a07e4d1bb8d3a7b9cc1f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac970ad26e45a07e4d1bb8d3a7b9cc1f6">operator==</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;other) const</td></tr>
<tr class="memdesc:ac970ad26e45a07e4d1bb8d3a7b9cc1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given tree decomposition are identical.  <br /></td></tr>
<tr class="separator:ac970ad26e45a07e4d1bb8d3a7b9cc1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0b4723b978c29def89cca8bdf96fb2" id="r_a7b0b4723b978c29def89cca8bdf96fb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0b4723b978c29def89cca8bdf96fb2">operator!=</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;other) const</td></tr>
<tr class="memdesc:a7b0b4723b978c29def89cca8bdf96fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given tree decomposition are different.  <br /></td></tr>
<tr class="separator:a7b0b4723b978c29def89cca8bdf96fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac" id="r_a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">root</a> () const</td></tr>
<tr class="memdesc:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bag at the root of the underlying tree.  <br /></td></tr>
<tr class="separator:a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac582d233602dae3d42921a1a9a59f0e5" id="r_ac582d233602dae3d42921a1a9a59f0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac582d233602dae3d42921a1a9a59f0e5">first</a> () const</td></tr>
<tr class="memdesc:ac582d233602dae3d42921a1a9a59f0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a postfix iteration through all of the bags in the tree decomposition.  <br /></td></tr>
<tr class="separator:ac582d233602dae3d42921a1a9a59f0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c06b040c85b2bbda234ef7601bc6676" id="r_a7c06b040c85b2bbda234ef7601bc6676"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c06b040c85b2bbda234ef7601bc6676">firstPrefix</a> () const</td></tr>
<tr class="memdesc:a7c06b040c85b2bbda234ef7601bc6676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a prefix iteration through all of the bags in the tree decomposition.  <br /></td></tr>
<tr class="separator:a7c06b040c85b2bbda234ef7601bc6676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e518148a1a0146dbc4aed80b0762567" id="r_a8e518148a1a0146dbc4aed80b0762567"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e518148a1a0146dbc4aed80b0762567">bag</a> (size_t index) const</td></tr>
<tr class="memdesc:a8e518148a1a0146dbc4aed80b0762567"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slow (linear-time) routine that returns the bag at the given index.  <br /></td></tr>
<tr class="separator:a8e518148a1a0146dbc4aed80b0762567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf631d4dcefa2e7f025c727ffa313a6" id="r_abaf631d4dcefa2e7f025c727ffa313a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf631d4dcefa2e7f025c727ffa313a6">compress</a> ()</td></tr>
<tr class="memdesc:abaf631d4dcefa2e7f025c727ffa313a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant bags from this tree decomposition.  <br /></td></tr>
<tr class="separator:abaf631d4dcefa2e7f025c727ffa313a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d545347437905541151b6c112bad03f" id="r_a2d545347437905541151b6c112bad03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d545347437905541151b6c112bad03f">makeNice</a> (const int *heightHint=nullptr)</td></tr>
<tr class="memdesc:a2d545347437905541151b6c112bad03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a nice tree decomposition.  <br /></td></tr>
<tr class="separator:a2d545347437905541151b6c112bad03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa9c488e166bd52474a17abc374eef" id="r_a8aaa9c488e166bd52474a17abc374eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aaa9c488e166bd52474a17abc374eef">reroot</a> (<a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *newRoot)</td></tr>
<tr class="memdesc:a8aaa9c488e166bd52474a17abc374eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition.  <br /></td></tr>
<tr class="separator:a8aaa9c488e166bd52474a17abc374eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af484fcab0b6693f5ad95c367007685f3" id="r_af484fcab0b6693f5ad95c367007685f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af484fcab0b6693f5ad95c367007685f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af484fcab0b6693f5ad95c367007685f3">reroot</a> (const T *costSame, const T *costReverse, const T *costRoot=nullptr)</td></tr>
<tr class="memdesc:af484fcab0b6693f5ad95c367007685f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags.  <br /></td></tr>
<tr class="separator:af484fcab0b6693f5ad95c367007685f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2518695c74624d2e1a536ab88577e6" id="r_a2c2518695c74624d2e1a536ab88577e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2518695c74624d2e1a536ab88577e6">writeDot</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2c2518695c74624d2e1a536ab88577e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition in the Graphviz DOT language.  <br /></td></tr>
<tr class="separator:a2c2518695c74624d2e1a536ab88577e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e2c680f3e8dc9ad87a9b74c94b9b37" id="r_af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e2c680f3e8dc9ad87a9b74c94b9b37">dot</a> () const</td></tr>
<tr class="memdesc:af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz DOT representation of this tree decomposition.  <br /></td></tr>
<tr class="separator:af3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2668cd1871a2d62c7dca27c8540fca91" id="r_a2668cd1871a2d62c7dca27c8540fca91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2668cd1871a2d62c7dca27c8540fca91">writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2668cd1871a2d62c7dca27c8540fca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition using the PACE text format.  <br /></td></tr>
<tr class="separator:a2668cd1871a2d62c7dca27c8540fca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabce1a3f084a041e1dd15c9a5cdb61" id="r_a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dabce1a3f084a041e1dd15c9a5cdb61">pace</a> () const</td></tr>
<tr class="memdesc:a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a text representation of this tree decomposition using the PACE text format.  <br /></td></tr>
<tr class="separator:a0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d6d08edc8c5224ba9f0033d49bedce" id="r_af5d6d08edc8c5224ba9f0033d49bedce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d6d08edc8c5224ba9f0033d49bedce">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:af5d6d08edc8c5224ba9f0033d49bedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:af5d6d08edc8c5224ba9f0033d49bedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2391ff92b92cd58806107fd640be74b" id="r_ad2391ff92b92cd58806107fd640be74b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2391ff92b92cd58806107fd640be74b">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad2391ff92b92cd58806107fd640be74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <br /></td></tr>
<tr class="separator:ad2391ff92b92cd58806107fd640be74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad" id="r_a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2" id="r_ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda" id="r_ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9ab30104049dafeacfe4034aecd999b5" id="r_a9ab30104049dafeacfe4034aecd999b5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab30104049dafeacfe4034aecd999b5">fromPACE</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a9ab30104049dafeacfe4034aecd999b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from a string using the PACE text format.  <br /></td></tr>
<tr class="separator:a9ab30104049dafeacfe4034aecd999b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1568ec71c366ebb2f0475035ac736" id="r_a87d1568ec71c366ebb2f0475035ac736"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d1568ec71c366ebb2f0475035ac736">fromPACE</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a87d1568ec71c366ebb2f0475035ac736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from an input stream using the PACE text format.  <br /></td></tr>
<tr class="separator:a87d1568ec71c366ebb2f0475035ac736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a tree decomposition of a graph. </p>
<p>Whilst this class can be used to build tree decompositions of arbitrary graphs, it also offers a simple interface for building a tree decomposition of the facet pairing graph of a given triangulation. This is an important step in the implementation of fixed-parameter tractable algorithms on triangulated manifolds.</p>
<p>Given a graph <em>G</em>, a tree decomposition of <em>G</em> consists of (i) an underlying tree <em>T</em>; and (ii) a <em>bag</em> at every node of this tree. Each bag is a set of zero or more nodes of <em>G</em>, and these bags are subject to the following constraints:</p>
<ul>
<li>Every node of <em>G</em> belongs to some bag;</li>
<li>Every arc of <em>G</em> has both its endpoints in some common bag;</li>
<li>For every node <em>v</em> of <em>G</em>, the set of <em>all</em> bags containing <em>v</em> forms a (connected) subtree of <em>T</em>.</li>
</ul>
<p>In Regina, the underlying tree <em>T</em> is a rooted tree, so that every non-root bag has exactly one parent bag, and every bag has some number of children (possibly many, possibly zero).</p>
<p>Tree decompositions are generally considered "better" if their bags are smaller (i.e., contain fewer nodes of <em>G</em>). To this end, the <em>width</em> of a tree decomposition is one less than its largest bag size, and the <em>treewidth</em> of <em>G</em> is the minimum width over all tree decompositions of <em>G</em>.</p>
<p>A tree decomposition is described by a single <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> object, and the class <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a> is used to represent each individual bag.</p>
<ul>
<li>You can build a tree decomposition using the various <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> constructors, and manipulate it using member functions such as <a class="el" href="#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> and <a class="el" href="#a2d545347437905541151b6c112bad03f" title="Converts this into a nice tree decomposition.">makeNice()</a>.</li>
<li>To iterate through the bags of the tree decomposition, you can use <a class="el" href="#ac582d233602dae3d42921a1a9a59f0e5" title="Used for a postfix iteration through all of the bags in the tree decomposition.">TreeDecomposition::first()</a> and <a class="el" href="classregina_1_1TreeBag.html#a81f02ece350d837ab790f008960772b7" title="Used for a postfix iteration through all of the bags in a tree decomposition.">TreeBag::next()</a> (for a postfix iteration), or you can use <a class="el" href="#a7c06b040c85b2bbda234ef7601bc6676" title="Used for a prefix iteration through all of the bags in the tree decomposition.">TreeDecomposition::firstPrefix()</a> and <a class="el" href="classregina_1_1TreeBag.html#a9300ac43ee1688d8922279730254ef32" title="Used for a prefix iteration through all of the bags in a tree decomposition.">TreeBag::nextPrefix()</a> (for a prefix iteration).</li>
</ul>
<p>The bags themselves are stored as sets of integers: it is assumed that the nodes of <em>G</em> are numbered 0,1,2,..., and so the bags simply store the numbers of the nodes that they contain.</p>
<p>This class also numbers its bags 0,1,...,<a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a>-1 in a leaves-to-root, left-to-right manner:</p>
<ul>
<li>for each non-root bag <em>b</em>, the parent of <em>b</em> will have a higher index than <em>b</em>;</li>
<li>for each bag <em>b</em> with a next sibling, the next sibling of <em>b</em> will have a higher index than <em>b</em>.</li>
</ul>
<p>This bag numbering may be useful if you wish to store auxiliary information alongside each bag in a separate array. You can access this numbering through the function <a class="el" href="classregina_1_1TreeBag.html#aff62a10140f4de7cc3a7efa2cb2d9626" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>. However, note that <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> does <em>not</em> store its bags in an array, and so the "random access" function <a class="el" href="#a8e518148a1a0146dbc4aed80b0762567" title="A slow (linear-time) routine that returns the bag at the given index.">bag()</a> is slow, with worst-case linear time.</p>
<p>There are two broad classes of algorithms for building tree decompositions: (i) <em>exact</em> algorithms, which are slow but guarantee to find a tree decomposition of the smallest possible width; and (ii) <em>greedy</em> algorithms, which are fast and which aim to keep the width small but which do not promise minimality. Currently Regina only offers greedy algorithms, though this may change in a future release. See the TreeDecompositionAlg enumeration for a list of all algorithms that are currently available.</p>
<p>Note that individual bags are allowed to be empty. Moreover, if the underlying graph <em>G</em> is empty then the tree decomposition may contain no bags at all.</p>
<p>This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a8cf5d6807672712644eae5dc99d42f" name="a1a8cf5d6807672712644eae5dc99d42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8cf5d6807672712644eae5dc99d42f">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a new copy of the given tree decomposition. </p>
<p>This will be a deep copy, in the sense that all of the bags of <em>src</em> will be cloned also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tree decomposition to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59aee01df1f3ff0c92782dd3d37175f" name="aa59aee01df1f3ff0c92782dd3d37175f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59aee01df1f3ff0c92782dd3d37175f">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given tree decomposition into this new tree decomposition. </p>
<p>This is a fast (constant time) operation.</p>
<p>The tree decomposition that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tree decomposition to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9260954f8e9341c6a25f7610ab8863f8" name="a9260954f8e9341c6a25f7610ab8863f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9260954f8e9341c6a25f7610ab8863f8">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangulation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the facet pairing graph of the given triangulation. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation whose facet pairing graph we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b22a38314cfa157c7df66ebcc084ffc" name="a6b22a38314cfa157c7df66ebcc084ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b22a38314cfa157c7df66ebcc084ffc">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pairing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the given facet pairing graph. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the facet pairing graph that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19321d5f8b29246685ea6b10b9c0298" name="ab19321d5f8b29246685ea6b10b9c0298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19321d5f8b29246685ea6b10b9c0298">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>link</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram. </p>
<p>The nodes of the graph will be numbered in the same way as the crossings of the given knot / link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the knot or link that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2dabae5ca31984eb49279d5dec6fd77" name="ad2dabae5ca31984eb49279d5dec6fd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dabae5ca31984eb49279d5dec6fd77">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of an arbitrary graph. </p>
<p>The graph may be directed or undirected.</p>
<p>The graph is specified by an adjacency matrix, expressed using Regina's own matrix type.</p>
<p>Each entry <em>graph</em>[i][j] will be treated as a boolean, indicating whether the graph contains an arc from node <em>i</em> to node <em>j</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The adjacency matrix does not have the same number of rows as columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>graph</em> must be of type <code>MatrixBool</code> (which is the Python type corresponding to the C++ class Matrix&lt;bool&gt;).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>the adjacency matrix of the graph. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8523704313af5935f994ad82f8553016" name="a8523704313af5935f994ad82f8553016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8523704313af5935f994ad82f8553016">&#9670;&#160;</a></span>TreeDecomposition() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Row &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Row &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a></td>          <td class="paramname"><span class="paramname"><em>alg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of an arbitrary graph. </p>
<p>The graph may be directed or undirected.</p>
<p>The graph is specified by an adjacency matrix, given as a vector of rows:</p>
<ul>
<li>The number of elements in each row should be equal to the number of rows (i.e., the adjacency matrix should be square).</li>
<li>The individual elements of each row <em>r</em> should be accessible using a range-based <code>for</code> loop over <em>r</em>.</li>
<li>Each entry in row <em>i</em>, column <em>j</em> will be treated as a boolean, indicating whether the graph contains an arc from node <em>i</em> to node <em>j</em>.</li>
</ul>
<p>An example of a suitable type for the adjacency matrix could be std::vector&lt;std::vector&lt;bool&gt;&gt;.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The adjacency matrix does not have the same number of rows as columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The adjacency matrix should be given as a list of lists.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>the adjacency matrix of the graph. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dbb52e2966ddb006c8f9964e009e2ee" name="a7dbb52e2966ddb006c8f9964e009e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbb52e2966ddb006c8f9964e009e2ee">&#9670;&#160;</a></span>~TreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::~TreeDecomposition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tree decomposition and all of its bags. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e518148a1a0146dbc4aed80b0762567" name="a8e518148a1a0146dbc4aed80b0762567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e518148a1a0146dbc4aed80b0762567">&#9670;&#160;</a></span>bag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::bag </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A slow (linear-time) routine that returns the bag at the given index. </p>
<p>Recall that the bags in a tree decomposition are numbered 0,1,...,<a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a>-1. This routine returns the bag with the given number.</p>
<p>This routine is linear-time, and so you should <em>not</em> use it to iterate through all bags. Instead, to iterate through all bags, use <a class="el" href="#ac582d233602dae3d42921a1a9a59f0e5" title="Used for a postfix iteration through all of the bags in the tree decomposition.">TreeDecomposition::first()</a> and <a class="el" href="classregina_1_1TreeBag.html#a81f02ece350d837ab790f008960772b7" title="Used for a postfix iteration through all of the bags in a tree decomposition.">TreeBag::next()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>slow</em>, with a worst-case linear time. This is because the bags are not stored internally in an array, and so this routine must search the tree from the root downwards to find the bag that is being requested.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the number of a bag; this must be between 0 and <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bag with the given number. </dd></dl>

</div>
</div>
<a id="abaf631d4dcefa2e7f025c727ffa313a6" name="abaf631d4dcefa2e7f025c727ffa313a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf631d4dcefa2e7f025c727ffa313a6">&#9670;&#160;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeDecomposition::compress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes redundant bags from this tree decomposition. </p>
<p>Specifically, this routine "compresses" the tree decomposition as follows: whenever two bags are adjacent in the underlying tree and one is a subset of the other, these bags will be merged.</p>
<p>Note that some <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a> objects may be destroyed (thereby invalidating pointers or references to them), and for those bags that are not destroyed, their indices (as returned by <a class="el" href="classregina_1_1TreeBag.html#aff62a10140f4de7cc3a7efa2cb2d9626" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>) may change.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the tree decomposition was changed. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>, false &gt;::detail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="af3e2c680f3e8dc9ad87a9b74c94b9b37" name="af3e2c680f3e8dc9ad87a9b74c94b9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e2c680f3e8dc9ad87a9b74c94b9b37">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::dot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz DOT representation of this tree decomposition. </p>
<p>This string can be saved as a standalone DOT file, which in turn can be run through Graphviz in order to visualise the tree decomposition.</p>
<p>This routine generates a directed graph (with arrows running from parent bags to their children). The nodes of this graph will be labelled in a way that indicates the tetrahedra contained in each bag. The resulting DOT file should be used with the <em>dot</em> program shipped with Graphviz.</p>
<p>This routine simply returns the output of <a class="el" href="#a2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p>If you are writing this text representation to an output stream then you should call <a class="el" href="#a2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> instead, which is more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>the DOT representation of this tree decomposition, as outlined above. </dd></dl>

</div>
</div>
<a id="ac582d233602dae3d42921a1a9a59f0e5" name="ac582d233602dae3d42921a1a9a59f0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac582d233602dae3d42921a1a9a59f0e5">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::first </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for a postfix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>postfix</em> iteration is one in which all of the children of any bag <em>b</em> will be processed before <em>b</em> itself.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full postfix iteration of bags as follows:</p>
<ul>
<li>the first bag in a postfix iteration is <code>d.first()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.next()</code>;</li>
<li>the iteration terminates when <code>b.next()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>This postfix iteration is equivalent to iterating through bags numbered 0,1,2,...; that is, following the order of <a class="el" href="classregina_1_1TreeBag.html#aff62a10140f4de7cc3a7efa2cb2d9626" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a postfix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="a7c06b040c85b2bbda234ef7601bc6676" name="a7c06b040c85b2bbda234ef7601bc6676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c06b040c85b2bbda234ef7601bc6676">&#9670;&#160;</a></span>firstPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::firstPrefix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for a prefix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>prefix</em> iteration is one in which each bag will be processed before any of its children.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full prefix iteration of bags as follows:</p>
<ul>
<li>the first bag in a prefix iteration is <code>d.firstPrefix()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.nextPrefix()</code>;</li>
<li>the iteration terminates when <code>b.nextPrefix()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>Since the first bag in a prefix iteration must be the root bag, this function is identical to calling <a class="el" href="#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac" title="Returns the bag at the root of the underlying tree.">root()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a prefix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="a9ab30104049dafeacfe4034aecd999b5" name="a9ab30104049dafeacfe4034aecd999b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab30104049dafeacfe4034aecd999b5">&#9670;&#160;</a></span>fromPACE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from a string using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>In short, the format contains a number of lines of text:</p>
<ul>
<li>Any line beginning with <code>c</code> is considered a comment, and will be ignored.</li>
<li>The first non-comment line should be of the form <code>s td &lt;num_bags&gt; &lt;max_bag_size&gt; &lt;num_vertices&gt;</code>.</li>
<li>The next <em>num_bags</em> non-comment lines should describe the contents of the bags. Each such line should be of the form <code>b &lt;bag_number&gt; &lt;element&gt; &lt;element&gt; ...</code>. The bags are numbered 1,2,...,<em>num_bags</em>, and may appear in any order. Likewise, the vertices of the graph are numbered 1,2,...,<em>num_vertices</em>, and within each bag they may again appear in any order.</li>
<li>The remaining <em>num_bags</em> - 1 non-comment lines should indicate the connections between the bags in the tree decomposition. Each such line should be of the form <code>&lt;first_bag_index&gt; &lt;second_bag_index&gt;</code>, where <em>first_bag_index</em> is smaller than <em>second_bag_index</em>.</li>
</ul>
<p>Bags may be empty, but there must be at least one bag, and the connections between the bags must form a tree. This routine will choose the root of the tree arbitrarily.</p>
<p>An example of this text format is as follows:</p>
<pre class="fragment">c A tree decomposition with 4 bags and width 2
s td 4 3 5
b 1 1 2 3
b 2 2 3 4
b 3 3 4 5
b 4
1 2
2 3
2 4
</pre><p>There are two variants of this routine. This variant contains a single string containing the entire text representation. The other variant takes an input stream, from which the text representation will be read.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some basic error checking on the input, this checking is not exhaustive; in particular, it does not verify that the connections between bags actually form a tree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid representation of a tree decomposition using the PACE text format. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding tree decomposition.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a87d1568ec71c366ebb2f0475035ac736" name="a87d1568ec71c366ebb2f0475035ac736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d1568ec71c366ebb2f0475035ac736">&#9670;&#160;</a></span>fromPACE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from an input stream using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>See the routine <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a> for a description of this text format.</p>
<p>There are two variants of this routine. The other variant contains a single string containing the entire text representation. This variant takes an input stream, from which the text representation will be read.</p>
<p>This routine assumes that it should exhaust the input stream (i.e., it should contain no additional text after this text representation).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid representation of a tree decomposition using the PACE text format. As documented more thoroughly in the string variant of this routine, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can use the variant of <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE()</a> that takes a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that provides a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding tree decomposition.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="a2d545347437905541151b6c112bad03f" name="a2d545347437905541151b6c112bad03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d545347437905541151b6c112bad03f">&#9670;&#160;</a></span>makeNice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::makeNice </td>
          <td>(</td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>heightHint</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a nice tree decomposition. </p>
<p>A <em>nice</em> tree decomposition is one in which every bag is one of the following types:</p>
<ul>
<li>an <em>introduce</em> bag, which has only one child bag, and which contains all of the nodes in this child bag plus exactly one new node (and nothing else);</li>
<li>a <em>forget</em> bag, which has only one child bag, and which contains all of the nodes in this child bag except for exactly one missing node (and nothing else);</li>
<li>a <em>join</em> bag, which has exactly two child bags, and where each child bag contains exactly the same nodes as the join bag itself.</li>
</ul>
<p>As a special case, each leaf bag (which has no child bags at all) is also considered to be an introduce bag, and will contain exactly one node.</p>
<p>This routine will also ensure that the root bag is a forget bag, containing no nodes at all.</p>
<p>This routine will set <a class="el" href="classregina_1_1TreeBag.html#abe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> and <a class="el" href="classregina_1_1TreeBag.html#a147ddad1ade025206067ea40fc0a3e03" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> for each bag as follows:</p>
<ul>
<li><a class="el" href="classregina_1_1TreeBag.html#abe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> will be one of the constants from the NiceType enumeration, indicating whether the bag is an introduce, forget or join bag.</li>
<li>For an introduce bag <em>b</em>, <a class="el" href="classregina_1_1TreeBag.html#a147ddad1ade025206067ea40fc0a3e03" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "new" node was introduced. Specifically, the new node will be <code>b.element(b.subtype())</code>.</li>
<li>For a forget bag <em>b</em>, <a class="el" href="classregina_1_1TreeBag.html#a147ddad1ade025206067ea40fc0a3e03" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "missing" node was forgotten. Specifically, the missing node will be <code>b.children()-&gt;element(b.subtype())</code>.</li>
<li>For a join bag, <a class="el" href="classregina_1_1TreeBag.html#a147ddad1ade025206067ea40fc0a3e03" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will be undefined.</li>
</ul>
<p>If the underlying graph is empty, then this routine will produce a tree decomposition with no bags at all.</p>
<p>You may optionally pass an argument <em>heightHint</em>, which is an array indicating how close to the root of the tree you would like each node to be. At present, this only affects the final chain of forget bags leading up to the root bag - if <em>heightHint</em> is passed, then this chain will be ordered so that nodes with a larger <em>heightHint</em> will be forgotten closer to the root bag. These should be considered hints only, in that their effect on the final tree decomposition might change in future versions of Regina.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that <a class="el" href="classregina_1_1TreeBag.html#a147ddad1ade025206067ea40fc0a3e03" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> is <em>not</em> the number of the new or missing node, but instead gives the <em>index</em> of the new or missing node within the relevant bag.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine calls <a class="el" href="#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> automatically, and so there is no need to explicitly call <a class="el" href="#abaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> before calling <a class="el" href="#a2d545347437905541151b6c112bad03f" title="Converts this into a nice tree decomposition.">makeNice()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>If a <em>heightHint</em> argument is given, it should be passed as a Python list of integers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heightHint</td><td>an optional array where, for each node <em>i</em>, a higher value of <code>heightHint[i]</code> indicates that the node should be forgotten closer to the root bag. If this is non-null, then the size of this array should be the number of nodes in the underlying graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b0b4723b978c29def89cca8bdf96fb2" name="a7b0b4723b978c29def89cca8bdf96fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0b4723b978c29def89cca8bdf96fb2">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeDecomposition::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given tree decomposition are different. </p>
<p>To be considered identical (i.e., for this comparison to return <code>false</code>), the two tree decompositions must have the same number of bags; moreover, the same numbered bags must contain the same elements (i.e., numbered graph nodes), and must have the same numbered child bags. Bag types and subtypes are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree decomposition to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given tree decomposition are different. </dd></dl>

</div>
</div>
<a id="a2ed6f2b4447bcb23fc3164559d575e32" name="a2ed6f2b4447bcb23fc3164559d575e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed6f2b4447bcb23fc3164559d575e32">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::TreeDecomposition::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given tree decomposition. </p>
<p>This will be a deep copy, in the sense that all of the bags of <em>src</em> will be copied also.</p>
<p>It does not matter if this and the given tree decomposition were originally built from different and/or differently sized objects or graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tree decomposition to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tree decomposition. </dd></dl>

</div>
</div>
<a id="a8ba34176107a52ab968337b7c2abd8d6" name="a8ba34176107a52ab968337b7c2abd8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba34176107a52ab968337b7c2abd8d6">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; regina::TreeDecomposition::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given tree decomposition into this tree decomposition. </p>
<p>This is a fast (constant time) operation.</p>
<p>The tree decomposition that was passed (<em>src</em>) will no longer be usable.</p>
<p>It does not matter if this and the given tree decomposition were originally built from different and/or differently sized objects or graphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tree decomposition to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tree decomposition. </dd></dl>

</div>
</div>
<a id="ac970ad26e45a07e4d1bb8d3a7b9cc1f6" name="ac970ad26e45a07e4d1bb8d3a7b9cc1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac970ad26e45a07e4d1bb8d3a7b9cc1f6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeDecomposition::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given tree decomposition are identical. </p>
<p>To be considered <em>identical</em>, the two tree decompositions must have the same number of bags; moreover, the same numbered bags must contain the same elements (i.e., numbered graph nodes), and must have the same numbered child bags. Bag types and subtypes are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree decomposition to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given tree decomposition are identical. </dd></dl>

</div>
</div>
<a id="a0dabce1a3f084a041e1dd15c9a5cdb61" name="a0dabce1a3f084a041e1dd15c9a5cdb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabce1a3f084a041e1dd15c9a5cdb61">&#9670;&#160;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::pace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a text representation of this tree decomposition using the PACE text format. </p>
<p>This text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>If you write a tree decomposition using <a class="el" href="#a0dabce1a3f084a041e1dd15c9a5cdb61" title="Returns a text representation of this tree decomposition using the PACE text format.">pace()</a> or <a class="el" href="#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> and then read it again using <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE()</a>, you are <em>not</em> guaranteed to obtain an identical tree decomposition. This is because the PACE text format stores the connections between bags as an undirected, unrooted tree.</p>
<p>If you are writing this text representation to an output stream then you should call <a class="el" href="#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> instead, which is more efficient.</p>
<dl class="section return"><dt>Returns</dt><dd>the PACE text representation of this tree decomposition.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="af484fcab0b6693f5ad95c367007685f3" name="af484fcab0b6693f5ad95c367007685f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af484fcab0b6693f5ad95c367007685f3">&#9670;&#160;</a></span>reroot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>costSame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>costReverse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>costRoot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags. </p>
<p>The user needs to supply three arrays, which are used to estimate the cost of hanging the tree from any possible root. This routine then identifies which root minimises this cost, and reroots the underlying tree from that bag.</p>
<p>The three arrays play the following roles. Let <em>b</em> be some bag at index <em>i</em> in the original tree decomposition, and let <em>p</em> be its parent bag.</p>
<ul>
<li><code>costSame[i]</code> indicates the cost of <em>preserving</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>p</em> is still the parent bag of <em>b</em>). If <em>b</em> is the root bag of the original tree decomposition then <code>costSame[i]</code> is ignored.</li>
<li><code>costReverse[i]</code> indicates the cost of <em>reversing</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>b</em> is now the parent bag of <em>p</em>). Again, if <em>b</em> is the root bag of the original tree decomposition then <code>costReverse[i]</code> is ignored.</li>
<li><code>costRoot[i]</code> is an additional cost that is incurred if and only if <em>b</em> becomes the new root bag. The argument <em>costRoot</em> may be <code>null</code>, in which case these additional costs are all assumed to be zero.</li>
</ul>
<p>It follows that, for each potential new root, there are <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a> costs to aggregate: this comes from <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a>-1 costs from the arrays <em>costSame</em> and/or <em>costReverse</em> (one for each connection between bags in the underlying tree), and one cost from <em>costRoot</em>. These costs will be aggregated by taking the <em>maximum</em> over all individual costs. This means that you do not need to estimate running times and/or memory consumption accurately; instead you only need to find some heuristic that aims to be <em>monotonic</em> in time and/or memory.</p>
<p>So: in essence then, this routine minimises the maximum cost. In the case of a tie, it then minimises multiplicity; that is, it minimises the <em>number</em> of times that this maximum cost occurs over the individual <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a> costs that are being aggregated.</p>
<p>Note that the <em>costSame</em> and <em>costReverse</em> arrays are technically defined as a cost per arc, not a cost per bag. If you wish to estimate a cost per bag, the typical way of doing this would be:</p>
<ul>
<li><code>costSame[i]</code> estimates the processing cost at bag <em>i</em> if its relationship with its parent is preserved;</li>
<li><code>costReverse[i]</code> estimates the processing cost at the original <em>parent</em> of bag <em>i</em> if its relationship with bag <em>i</em> is reversed (i.e., it becomes a child of bag <em>i</em>);</li>
<li><code>costRoot[i]</code> estimates the processing cost at bag <em>i</em> if bag <em>i</em> becomes the root.</li>
</ul>
<p>This scheme ensures that, for any possible rerooting, each bag is costed exactly once amongst the three arrays.</p>
<p>After rerooting, all pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for common types.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The <em>costSame</em> and <em>costReverse</em> arrays, as well as <em>costRoot</em> if it is given, should be passed as Python lists of real numbers.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type being used to estimate costs. It must be possible to assign 0 to a variable of type <em>T</em> using both constructors and the assignment operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">costSame</td><td>An array of <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of preserving each child-parent connection; </td></tr>
    <tr><td class="paramname">costReverse</td><td>An array of <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of reversing each child-parent connection; </td></tr>
    <tr><td class="paramname">costRoot</td><td>An array of <a class="el" href="#aa2df0bc8d01571ba0dd7f38a817c4fae" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an additional estimated cost for each bag being the new root. This array may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aaa9c488e166bd52474a17abc374eef" name="a8aaa9c488e166bd52474a17abc374eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaa9c488e166bd52474a17abc374eef">&#9670;&#160;</a></span>reroot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *</td>          <td class="paramname"><span class="paramname"><em>newRoot</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition. </p>
<p>All pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newRoot</td><td>the bag that should become the root of this tree decomposition. This must already be a bag of this tree decomposition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac" name="a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">&#9670;&#160;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bag at the root of the underlying tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the root bag, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="aa2df0bc8d01571ba0dd7f38a817c4fae" name="aa2df0bc8d01571ba0dd7f38a817c4fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2df0bc8d01571ba0dd7f38a817c4fae">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::TreeDecomposition::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bags in this tree decomposition. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bags. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>, false &gt;::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p>Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aecce7f76d97bce4c482670175b2e02db" name="aecce7f76d97bce4c482670175b2e02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecce7f76d97bce4c482670175b2e02db">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given tree decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tree decomposition whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&#160;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>, false &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p>Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="adf6d2556cafa5c0bdd1210124797330c" name="adf6d2556cafa5c0bdd1210124797330c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6d2556cafa5c0bdd1210124797330c">&#9670;&#160;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t regina::TreeDecomposition::width </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width of this tree decomposition. </p>
<p>This is one less than the size of the largest bag.</p>
<dl class="section return"><dt>Returns</dt><dd>the width of this tree decomposition. </dd></dl>

</div>
</div>
<a id="a2c2518695c74624d2e1a536ab88577e6" name="a2c2518695c74624d2e1a536ab88577e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2518695c74624d2e1a536ab88577e6">&#9670;&#160;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition in the Graphviz DOT language. </p>
<p>This produces a standalone DOT file that can be run through Graphviz in order to visualise the tree decomposition.</p>
<p>This routine generates a directed graph (with arrows running from parent bags to their children). The nodes of this graph will be labelled in a way that indicates the tetrahedra contained in each bag. The resulting DOT file should be used with the <em>dot</em> program shipped with Graphviz.</p>
<p>Calling <code>td.writeDot(out)</code> is equivalent to <code>out &lt;&lt; td.dot()</code>. However, this routine is more efficient.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#af3e2c680f3e8dc9ad87a9b74c94b9b37" title="Returns a Graphviz DOT representation of this tree decomposition.">dot()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a2668cd1871a2d62c7dca27c8540fca91" name="a2668cd1871a2d62c7dca27c8540fca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2668cd1871a2d62c7dca27c8540fca91">&#9670;&#160;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition using the PACE text format. </p>
<p>This text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>If you write a tree decomposition using <a class="el" href="#a0dabce1a3f084a041e1dd15c9a5cdb61" title="Returns a text representation of this tree decomposition using the PACE text format.">pace()</a> or <a class="el" href="#a2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> and then read it again using <a class="el" href="#a9ab30104049dafeacfe4034aecd999b5" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE()</a>, you are <em>not</em> guaranteed to obtain an identical tree decomposition. This is because the PACE text format stores the connections between bags as an undirected, unrooted tree.</p>
<p>Calling <code>td.writePACE(out)</code> is equivalent to <code>out &lt;&lt; td.pace()</code>. However, this routine is more efficient.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="#a0dabce1a3f084a041e1dd15c9a5cdb61" title="Returns a text representation of this tree decomposition using the PACE text format.">pace()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ad2391ff92b92cd58806107fd640be74b" name="ad2391ff92b92cd58806107fd640be74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2391ff92b92cd58806107fd640be74b">&#9670;&#160;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use detail() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d6d08edc8c5224ba9f0033d49bedce" name="af5d6d08edc8c5224ba9f0033d49bedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d6d08edc8c5224ba9f0033d49bedce">&#9670;&#160;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>treewidth/<a class="el" href="treedecomposition_8h.html">treedecomposition.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2025, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
