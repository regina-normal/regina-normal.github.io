<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Standard 3-Manifolds</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Standard 3-Manifolds</div>  </div>
</div><!--header-->
<div class="contents">

<p>Standard 3-manifolds whose structures are well-understood.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GraphLoop.html">regina::GraphLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a closed graph manifold formed by joining a single bounded Seifert fibred space to itself along a torus.  <a href="classregina_1_1GraphLoop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GraphPair.html">regina::GraphPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a closed graph manifold formed by joining two bounded Seifert fibred spaces along a common torus.  <a href="classregina_1_1GraphPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GraphTriple.html">regina::GraphTriple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a closed graph manifold formed by joining three bounded Seifert fibred spaces along their torus boundaries.  <a href="classregina_1_1GraphTriple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Handlebody.html">regina::Handlebody</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arbitrary handlebody.  <a href="classregina_1_1Handlebody.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LensSpace.html">regina::LensSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a general lens space.  <a href="classregina_1_1LensSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html">regina::Manifold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a particular 3-manifold.  <a href="classregina_1_1Manifold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SFSFibre.html">regina::SFSFibre</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an exceptional (<em>alpha</em>, <em>beta</em>) fibre in a Seifert fibred space.  <a href="structregina_1_1SFSFibre.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html">regina::SFSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a general Seifert fibred space, which may be orientable or non-orientable.  <a href="classregina_1_1SFSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAltSet.html">regina::SFSAltSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a variety of alternative representations of a single bounded Seifert fibred space.  <a href="classregina_1_1SFSAltSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SimpleSurfaceBundle.html">regina::SimpleSurfaceBundle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a particularly simple closed surface bundle over the circle.  <a href="classregina_1_1SimpleSurfaceBundle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaCensusManifold.html">regina::SnapPeaCensusManifold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3-manifold from the SnapPea cusped census.  <a href="classregina_1_1SnapPeaCensusManifold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TorusBundle.html">regina::TorusBundle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a torus bundle over the circle.  <a href="classregina_1_1TorusBundle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaebdd53195f8261a28d8200257089fbdd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaebdd53195f8261a28d8200257089fbdd">regina::NGraphLoop</a></td></tr>
<tr class="memdesc:gaebdd53195f8261a28d8200257089fbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#gaebdd53195f8261a28d8200257089fbdd">More...</a><br /></td></tr>
<tr class="separator:gaebdd53195f8261a28d8200257089fbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585c0ce4134749e0805a612d7c5b26b6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga585c0ce4134749e0805a612d7c5b26b6">regina::NGraphPair</a></td></tr>
<tr class="memdesc:ga585c0ce4134749e0805a612d7c5b26b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga585c0ce4134749e0805a612d7c5b26b6">More...</a><br /></td></tr>
<tr class="separator:ga585c0ce4134749e0805a612d7c5b26b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fca6e66d7fce09063dae68b9f7db34d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7fca6e66d7fce09063dae68b9f7db34d">regina::NGraphTriple</a></td></tr>
<tr class="memdesc:ga7fca6e66d7fce09063dae68b9f7db34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga7fca6e66d7fce09063dae68b9f7db34d">More...</a><br /></td></tr>
<tr class="separator:ga7fca6e66d7fce09063dae68b9f7db34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5f18aa593cb68c181eb6fce8b9b37e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaae5f18aa593cb68c181eb6fce8b9b37e">regina::NHandlebody</a></td></tr>
<tr class="memdesc:gaae5f18aa593cb68c181eb6fce8b9b37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#gaae5f18aa593cb68c181eb6fce8b9b37e">More...</a><br /></td></tr>
<tr class="separator:gaae5f18aa593cb68c181eb6fce8b9b37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa881e2c36ff2724f45cf776104857e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaaa881e2c36ff2724f45cf776104857e">regina::NLensSpace</a></td></tr>
<tr class="memdesc:gaaaa881e2c36ff2724f45cf776104857e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#gaaaa881e2c36ff2724f45cf776104857e">More...</a><br /></td></tr>
<tr class="separator:gaaaa881e2c36ff2724f45cf776104857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f753e87935bc5112777ebb9ebfef1f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Manifold.html">Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga69f753e87935bc5112777ebb9ebfef1f">regina::NManifold</a></td></tr>
<tr class="memdesc:ga69f753e87935bc5112777ebb9ebfef1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga69f753e87935bc5112777ebb9ebfef1f">More...</a><br /></td></tr>
<tr class="separator:ga69f753e87935bc5112777ebb9ebfef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b98a69c042ce12888797b6bc17ff22f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1b98a69c042ce12888797b6bc17ff22f">regina::NSFSFibre</a></td></tr>
<tr class="memdesc:ga1b98a69c042ce12888797b6bc17ff22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga1b98a69c042ce12888797b6bc17ff22f">More...</a><br /></td></tr>
<tr class="separator:ga1b98a69c042ce12888797b6bc17ff22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0207b91f4bca65c14ff420791ff40c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gab0207b91f4bca65c14ff420791ff40c2">regina::NSFSpace</a></td></tr>
<tr class="memdesc:gab0207b91f4bca65c14ff420791ff40c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#gab0207b91f4bca65c14ff420791ff40c2">More...</a><br /></td></tr>
<tr class="separator:gab0207b91f4bca65c14ff420791ff40c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2c0068ef2348a68b3df68843e47cb7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SFSAltSet.html">SFSAltSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7f2c0068ef2348a68b3df68843e47cb7">regina::NSFSAltSet</a></td></tr>
<tr class="memdesc:ga7f2c0068ef2348a68b3df68843e47cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga7f2c0068ef2348a68b3df68843e47cb7">More...</a><br /></td></tr>
<tr class="separator:ga7f2c0068ef2348a68b3df68843e47cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f68997f1b535c0b080bdb23652abc8a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f68997f1b535c0b080bdb23652abc8a">regina::NSimpleSurfaceBundle</a></td></tr>
<tr class="memdesc:ga1f68997f1b535c0b080bdb23652abc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga1f68997f1b535c0b080bdb23652abc8a">More...</a><br /></td></tr>
<tr class="separator:ga1f68997f1b535c0b080bdb23652abc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1ce21335cbe7256aa7125376cd5793"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5b1ce21335cbe7256aa7125376cd5793">regina::NSnapPeaCensusManifold</a></td></tr>
<tr class="memdesc:ga5b1ce21335cbe7256aa7125376cd5793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga5b1ce21335cbe7256aa7125376cd5793">More...</a><br /></td></tr>
<tr class="separator:ga5b1ce21335cbe7256aa7125376cd5793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce6fe5b1c49d9fc4af6285825fc093b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7ce6fe5b1c49d9fc4af6285825fc093b">regina::NTorusBundle</a></td></tr>
<tr class="memdesc:ga7ce6fe5b1c49d9fc4af6285825fc093b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__manifold.html#ga7ce6fe5b1c49d9fc4af6285825fc093b">More...</a><br /></td></tr>
<tr class="separator:ga7ce6fe5b1c49d9fc4af6285825fc093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8ca6dbe82be7c2f77c480e5ad720f451"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">regina::SFSpace::classType</a> { <br />
&#160;&#160;<a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451aee6551a605ca5c2257265ae389a8ad49">regina::SFSpace::o1</a> = 101
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a5d35a6be3a142c543fec1e3e53d362a6">regina::SFSpace::o2</a> = 102
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a20296b965f715f5c8d705ba59e39c408">regina::SFSpace::n1</a> = 201
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a2ff57c6837334c6b20769ca49b0db5c1">regina::SFSpace::n2</a> = 202
, <br />
&#160;&#160;<a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451aac79eded7f2f568c7f1f8bc461c99c40">regina::SFSpace::n3</a> = 203
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a0407c4c93466e1b07016a53b14674384">regina::SFSpace::n4</a> = 204
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a1654d3e2dace8737bec604781355ecfc">regina::SFSpace::bo1</a> = 301
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a663bb34f4339e3041e80cfb67be260e1">regina::SFSpace::bo2</a> = 302
, <br />
&#160;&#160;<a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a58c4517e4b1116a250580b8d72c1acd0">regina::SFSpace::bn1</a> = 401
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a5f6b58c0ede57bcfdaced07f2e9415e4">regina::SFSpace::bn2</a> = 402
, <a class="el" href="group__manifold.html#gga8ca6dbe82be7c2f77c480e5ad720f451a4e6ff4256bd817e0cf2f0bb0c61a97e9">regina::SFSpace::bn3</a> = 403
<br />
 }</td></tr>
<tr class="memdesc:ga8ca6dbe82be7c2f77c480e5ad720f451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries.  <a href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">More...</a><br /></td></tr>
<tr class="separator:ga8ca6dbe82be7c2f77c480e5ad720f451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga14f7cd99e9f71b5c810b974ff65b8ee6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga14f7cd99e9f71b5c810b974ff65b8ee6">regina::GraphLoop::GraphLoop</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *<a class="el" href="group__manifold.html#ga27d583b84cda44e83ef019ec6d84bac9">sfs</a>, long mat00, long mat01, long mat10, long mat11)</td></tr>
<tr class="memdesc:ga14f7cd99e9f71b5c810b974ff65b8ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph manifold as a self-identified Seifert fibred space.  <a href="group__manifold.html#ga14f7cd99e9f71b5c810b974ff65b8ee6">More...</a><br /></td></tr>
<tr class="separator:ga14f7cd99e9f71b5c810b974ff65b8ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f33adcf59334df44d14fbc6297ba28a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga3f33adcf59334df44d14fbc6297ba28a">regina::GraphLoop::GraphLoop</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *<a class="el" href="group__manifold.html#ga27d583b84cda44e83ef019ec6d84bac9">sfs</a>, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;<a class="el" href="group__manifold.html#ga2607f6946aac50ea7dbbc3a15b36b539">matchingReln</a>)</td></tr>
<tr class="memdesc:ga3f33adcf59334df44d14fbc6297ba28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph manifold as a self-identified Seifert fibred space.  <a href="group__manifold.html#ga3f33adcf59334df44d14fbc6297ba28a">More...</a><br /></td></tr>
<tr class="separator:ga3f33adcf59334df44d14fbc6297ba28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb095f13105585b47c71b3ece40670d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gabb095f13105585b47c71b3ece40670d8">regina::GraphLoop::GraphLoop</a> (const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gabb095f13105585b47c71b3ece40670d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given graph manifold.  <a href="group__manifold.html#gabb095f13105585b47c71b3ece40670d8">More...</a><br /></td></tr>
<tr class="separator:gabb095f13105585b47c71b3ece40670d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga520bc025de7c0ed30a9ad4cf042731c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga520bc025de7c0ed30a9ad4cf042731c7">regina::GraphLoop::~GraphLoop</a> ()</td></tr>
<tr class="memdesc:ga520bc025de7c0ed30a9ad4cf042731c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure along with the bounded Seifert fibred space and the matching matrix.  <a href="group__manifold.html#ga520bc025de7c0ed30a9ad4cf042731c7">More...</a><br /></td></tr>
<tr class="separator:ga520bc025de7c0ed30a9ad4cf042731c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d583b84cda44e83ef019ec6d84bac9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga27d583b84cda44e83ef019ec6d84bac9">regina::GraphLoop::sfs</a> () const</td></tr>
<tr class="memdesc:ga27d583b84cda44e83ef019ec6d84bac9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the bounded Seifert fibred space that is joined to itself.  <a href="group__manifold.html#ga27d583b84cda44e83ef019ec6d84bac9">More...</a><br /></td></tr>
<tr class="separator:ga27d583b84cda44e83ef019ec6d84bac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2607f6946aac50ea7dbbc3a15b36b539"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2607f6946aac50ea7dbbc3a15b36b539">regina::GraphLoop::matchingReln</a> () const</td></tr>
<tr class="memdesc:ga2607f6946aac50ea7dbbc3a15b36b539"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two boundary tori of the Seifert fibred space are joined together.  <a href="group__manifold.html#ga2607f6946aac50ea7dbbc3a15b36b539">More...</a><br /></td></tr>
<tr class="separator:ga2607f6946aac50ea7dbbc3a15b36b539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdd3197e500785d4fa121017fb3a32d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9cdd3197e500785d4fa121017fb3a32d">regina::GraphLoop::operator&lt;</a> (const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga9cdd3197e500785d4fa121017fb3a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="group__manifold.html#ga9cdd3197e500785d4fa121017fb3a32d">More...</a><br /></td></tr>
<tr class="separator:ga9cdd3197e500785d4fa121017fb3a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f074d89faba1e24f513eda9443e90df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5f074d89faba1e24f513eda9443e90df">regina::GraphLoop::operator=</a> (const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga5f074d89faba1e24f513eda9443e90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given graph manifold.  <a href="group__manifold.html#ga5f074d89faba1e24f513eda9443e90df">More...</a><br /></td></tr>
<tr class="separator:ga5f074d89faba1e24f513eda9443e90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac9c50de5e107583c3931089c59c50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gabac9c50de5e107583c3931089c59c50e">regina::GraphLoop::homology</a> () const override</td></tr>
<tr class="memdesc:gabac9c50de5e107583c3931089c59c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gabac9c50de5e107583c3931089c59c50e">More...</a><br /></td></tr>
<tr class="separator:gabac9c50de5e107583c3931089c59c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53165d7073b27117b6d0ad838a33fd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaf53165d7073b27117b6d0ad838a33fd4">regina::GraphLoop::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:gaf53165d7073b27117b6d0ad838a33fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#gaf53165d7073b27117b6d0ad838a33fd4">More...</a><br /></td></tr>
<tr class="separator:gaf53165d7073b27117b6d0ad838a33fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8b6a036b9ce8163a9ede2a79f696f8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gadb8b6a036b9ce8163a9ede2a79f696f8">regina::GraphLoop::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gadb8b6a036b9ce8163a9ede2a79f696f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#gadb8b6a036b9ce8163a9ede2a79f696f8">More...</a><br /></td></tr>
<tr class="separator:gadb8b6a036b9ce8163a9ede2a79f696f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ff49eed11ad6fb791446a3910ec5f3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga75ff49eed11ad6fb791446a3910ec5f3">regina::GraphLoop::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga75ff49eed11ad6fb791446a3910ec5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga75ff49eed11ad6fb791446a3910ec5f3">More...</a><br /></td></tr>
<tr class="separator:ga75ff49eed11ad6fb791446a3910ec5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f1e11df434f0ae22f2cbb46105e59a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga73f1e11df434f0ae22f2cbb46105e59a">regina::GraphPair::GraphPair</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *sfs0, <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *sfs1, long mat00, long mat01, long mat10, long mat11)</td></tr>
<tr class="memdesc:ga73f1e11df434f0ae22f2cbb46105e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph manifold as a pair of joined Seifert fibred spaces.  <a href="group__manifold.html#ga73f1e11df434f0ae22f2cbb46105e59a">More...</a><br /></td></tr>
<tr class="separator:ga73f1e11df434f0ae22f2cbb46105e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc43762e112555b00c923cebb43ba095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gacc43762e112555b00c923cebb43ba095">regina::GraphPair::GraphPair</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *sfs0, <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *sfs1, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;<a class="el" href="group__manifold.html#ga2536896983d3901423486e38ec34c11f">matchingReln</a>)</td></tr>
<tr class="memdesc:gacc43762e112555b00c923cebb43ba095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph manifold as a pair of joined Seifert fibred spaces.  <a href="group__manifold.html#gacc43762e112555b00c923cebb43ba095">More...</a><br /></td></tr>
<tr class="separator:gacc43762e112555b00c923cebb43ba095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8713f55e59871014f5b0ce124627269"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gab8713f55e59871014f5b0ce124627269">regina::GraphPair::GraphPair</a> (const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gab8713f55e59871014f5b0ce124627269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given graph manifold.  <a href="group__manifold.html#gab8713f55e59871014f5b0ce124627269">More...</a><br /></td></tr>
<tr class="separator:gab8713f55e59871014f5b0ce124627269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b821994aa5e8ae77671ac2ac57ba42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga07b821994aa5e8ae77671ac2ac57ba42">regina::GraphPair::~GraphPair</a> ()</td></tr>
<tr class="memdesc:ga07b821994aa5e8ae77671ac2ac57ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure along with the component Seifert fibred spaces and the matching matrix.  <a href="group__manifold.html#ga07b821994aa5e8ae77671ac2ac57ba42">More...</a><br /></td></tr>
<tr class="separator:ga07b821994aa5e8ae77671ac2ac57ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0d787b77c643cd4e16d0528368aa60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gacc0d787b77c643cd4e16d0528368aa60">regina::GraphPair::sfs</a> (unsigned which) const</td></tr>
<tr class="memdesc:gacc0d787b77c643cd4e16d0528368aa60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two bounded Seifert fibred spaces that are joined together.  <a href="group__manifold.html#gacc0d787b77c643cd4e16d0528368aa60">More...</a><br /></td></tr>
<tr class="separator:gacc0d787b77c643cd4e16d0528368aa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2536896983d3901423486e38ec34c11f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2536896983d3901423486e38ec34c11f">regina::GraphPair::matchingReln</a> () const</td></tr>
<tr class="memdesc:ga2536896983d3901423486e38ec34c11f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two Seifert fibred spaces are joined together.  <a href="group__manifold.html#ga2536896983d3901423486e38ec34c11f">More...</a><br /></td></tr>
<tr class="separator:ga2536896983d3901423486e38ec34c11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e32f429e559ea70083658941011709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga57e32f429e559ea70083658941011709">regina::GraphPair::operator&lt;</a> (const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga57e32f429e559ea70083658941011709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="group__manifold.html#ga57e32f429e559ea70083658941011709">More...</a><br /></td></tr>
<tr class="separator:ga57e32f429e559ea70083658941011709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8646039c075fdad840d32f0385f54330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8646039c075fdad840d32f0385f54330">regina::GraphPair::operator=</a> (const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga8646039c075fdad840d32f0385f54330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given graph manifold.  <a href="group__manifold.html#ga8646039c075fdad840d32f0385f54330">More...</a><br /></td></tr>
<tr class="separator:ga8646039c075fdad840d32f0385f54330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41176e9d795f3509e2ae0d7231306c01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga41176e9d795f3509e2ae0d7231306c01">regina::GraphPair::homology</a> () const override</td></tr>
<tr class="memdesc:ga41176e9d795f3509e2ae0d7231306c01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#ga41176e9d795f3509e2ae0d7231306c01">More...</a><br /></td></tr>
<tr class="separator:ga41176e9d795f3509e2ae0d7231306c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4581dbcd22a69f23af278dbf7739f25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4581dbcd22a69f23af278dbf7739f25">regina::GraphPair::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:gaa4581dbcd22a69f23af278dbf7739f25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#gaa4581dbcd22a69f23af278dbf7739f25">More...</a><br /></td></tr>
<tr class="separator:gaa4581dbcd22a69f23af278dbf7739f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa96f0a2a5eb90bebd10defe4eb1ba7a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaa96f0a2a5eb90bebd10defe4eb1ba7a">regina::GraphPair::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaaa96f0a2a5eb90bebd10defe4eb1ba7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#gaaa96f0a2a5eb90bebd10defe4eb1ba7a">More...</a><br /></td></tr>
<tr class="separator:gaaa96f0a2a5eb90bebd10defe4eb1ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2be30e9d1ca7aa1e5e0e1738b94cecd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac2be30e9d1ca7aa1e5e0e1738b94cecd">regina::GraphPair::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gac2be30e9d1ca7aa1e5e0e1738b94cecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#gac2be30e9d1ca7aa1e5e0e1738b94cecd">More...</a><br /></td></tr>
<tr class="separator:gac2be30e9d1ca7aa1e5e0e1738b94cecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd42f80ad0422322e0c7c37b8e14ad8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafd42f80ad0422322e0c7c37b8e14ad8e">regina::GraphTriple::GraphTriple</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *end0, <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *<a class="el" href="group__manifold.html#gaca0efe81003208ff320439ca754175ad">centre</a>, <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *end1, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;matchingReln0, const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;matchingReln1)</td></tr>
<tr class="memdesc:gafd42f80ad0422322e0c7c37b8e14ad8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph manifold from three bounded Seifert fibred spaces, as described in the class notes.  <a href="group__manifold.html#gafd42f80ad0422322e0c7c37b8e14ad8e">More...</a><br /></td></tr>
<tr class="separator:gafd42f80ad0422322e0c7c37b8e14ad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40ca21a6da490c22e7de7bf2d598335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac40ca21a6da490c22e7de7bf2d598335">regina::GraphTriple::GraphTriple</a> (const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gac40ca21a6da490c22e7de7bf2d598335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given graph manifold.  <a href="group__manifold.html#gac40ca21a6da490c22e7de7bf2d598335">More...</a><br /></td></tr>
<tr class="separator:gac40ca21a6da490c22e7de7bf2d598335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a7f89be8d544d53880a843db75d55b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga93a7f89be8d544d53880a843db75d55b">regina::GraphTriple::~GraphTriple</a> ()</td></tr>
<tr class="memdesc:ga93a7f89be8d544d53880a843db75d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure along with the component Seifert fibred spaces and matching matrices.  <a href="group__manifold.html#ga93a7f89be8d544d53880a843db75d55b">More...</a><br /></td></tr>
<tr class="separator:ga93a7f89be8d544d53880a843db75d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4168bf67476715a1ab6afd8243daa7bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga4168bf67476715a1ab6afd8243daa7bb">regina::GraphTriple::end</a> (unsigned which) const</td></tr>
<tr class="memdesc:ga4168bf67476715a1ab6afd8243daa7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two end spaces.  <a href="group__manifold.html#ga4168bf67476715a1ab6afd8243daa7bb">More...</a><br /></td></tr>
<tr class="separator:ga4168bf67476715a1ab6afd8243daa7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0efe81003208ff320439ca754175ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaca0efe81003208ff320439ca754175ad">regina::GraphTriple::centre</a> () const</td></tr>
<tr class="memdesc:gaca0efe81003208ff320439ca754175ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the central space.  <a href="group__manifold.html#gaca0efe81003208ff320439ca754175ad">More...</a><br /></td></tr>
<tr class="separator:gaca0efe81003208ff320439ca754175ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb6f89ae0521582c9e7aaab3376ae80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafeb6f89ae0521582c9e7aaab3376ae80">regina::GraphTriple::matchingReln</a> (unsigned which) const</td></tr>
<tr class="memdesc:gafeb6f89ae0521582c9e7aaab3376ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two requested bounded Seifert fibred spaces are joined together.  <a href="group__manifold.html#gafeb6f89ae0521582c9e7aaab3376ae80">More...</a><br /></td></tr>
<tr class="separator:gafeb6f89ae0521582c9e7aaab3376ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08caf6d804e672207554d2c0117caab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga08caf6d804e672207554d2c0117caab7">regina::GraphTriple::operator&lt;</a> (const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga08caf6d804e672207554d2c0117caab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="group__manifold.html#ga08caf6d804e672207554d2c0117caab7">More...</a><br /></td></tr>
<tr class="separator:ga08caf6d804e672207554d2c0117caab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12f618fcbfd1d3307a6775a1fe3abfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac12f618fcbfd1d3307a6775a1fe3abfd">regina::GraphTriple::operator=</a> (const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gac12f618fcbfd1d3307a6775a1fe3abfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given graph manifold.  <a href="group__manifold.html#gac12f618fcbfd1d3307a6775a1fe3abfd">More...</a><br /></td></tr>
<tr class="separator:gac12f618fcbfd1d3307a6775a1fe3abfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b42474168352e1fc002fce8530a891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaf0b42474168352e1fc002fce8530a891">regina::GraphTriple::homology</a> () const override</td></tr>
<tr class="memdesc:gaf0b42474168352e1fc002fce8530a891"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gaf0b42474168352e1fc002fce8530a891">More...</a><br /></td></tr>
<tr class="separator:gaf0b42474168352e1fc002fce8530a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga304e24a12efdb840e7bd26f7604e81f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga304e24a12efdb840e7bd26f7604e81f1">regina::GraphTriple::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:ga304e24a12efdb840e7bd26f7604e81f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#ga304e24a12efdb840e7bd26f7604e81f1">More...</a><br /></td></tr>
<tr class="separator:ga304e24a12efdb840e7bd26f7604e81f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633be92056ea45baeab5105937064012"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga633be92056ea45baeab5105937064012">regina::GraphTriple::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga633be92056ea45baeab5105937064012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga633be92056ea45baeab5105937064012">More...</a><br /></td></tr>
<tr class="separator:ga633be92056ea45baeab5105937064012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6313dbdeac312a51f9799e3062e42eb2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga6313dbdeac312a51f9799e3062e42eb2">regina::GraphTriple::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga6313dbdeac312a51f9799e3062e42eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga6313dbdeac312a51f9799e3062e42eb2">More...</a><br /></td></tr>
<tr class="separator:ga6313dbdeac312a51f9799e3062e42eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb52ed0ee3ae805ef92a9ae7d33d3eaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gadb52ed0ee3ae805ef92a9ae7d33d3eaf">regina::Handlebody::Handlebody</a> (unsigned long newHandles, bool newOrientable)</td></tr>
<tr class="memdesc:gadb52ed0ee3ae805ef92a9ae7d33d3eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new handlebody with the given parameters.  <a href="group__manifold.html#gadb52ed0ee3ae805ef92a9ae7d33d3eaf">More...</a><br /></td></tr>
<tr class="separator:gadb52ed0ee3ae805ef92a9ae7d33d3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae983510285a935c0cc7a09656f2999"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gabae983510285a935c0cc7a09656f2999">regina::Handlebody::Handlebody</a> (const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gabae983510285a935c0cc7a09656f2999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given handlebody.  <a href="group__manifold.html#gabae983510285a935c0cc7a09656f2999">More...</a><br /></td></tr>
<tr class="separator:gabae983510285a935c0cc7a09656f2999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b27b4c688347c3992ad41d62e15a88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac6b27b4c688347c3992ad41d62e15a88">regina::Handlebody::~Handlebody</a> ()</td></tr>
<tr class="memdesc:gac6b27b4c688347c3992ad41d62e15a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this handlebody.  <a href="group__manifold.html#gac6b27b4c688347c3992ad41d62e15a88">More...</a><br /></td></tr>
<tr class="separator:gac6b27b4c688347c3992ad41d62e15a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e6b0e7e51f9c125db07dfcce1f59fa"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga06e6b0e7e51f9c125db07dfcce1f59fa">regina::Handlebody::handles</a> () const</td></tr>
<tr class="memdesc:ga06e6b0e7e51f9c125db07dfcce1f59fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of handles of this handlebody.  <a href="group__manifold.html#ga06e6b0e7e51f9c125db07dfcce1f59fa">More...</a><br /></td></tr>
<tr class="separator:ga06e6b0e7e51f9c125db07dfcce1f59fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df7c224bb77dcd138168933a9dd5d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2df7c224bb77dcd138168933a9dd5d80">regina::Handlebody::isOrientable</a> () const</td></tr>
<tr class="memdesc:ga2df7c224bb77dcd138168933a9dd5d80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this handlebody is orientable.  <a href="group__manifold.html#ga2df7c224bb77dcd138168933a9dd5d80">More...</a><br /></td></tr>
<tr class="separator:ga2df7c224bb77dcd138168933a9dd5d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ea9b6e63f0ea2ca950363b7cb17965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga99ea9b6e63f0ea2ca950363b7cb17965">regina::Handlebody::operator==</a> (const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga99ea9b6e63f0ea2ca950363b7cb17965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given handlebody represent the same 3-manifold.  <a href="group__manifold.html#ga99ea9b6e63f0ea2ca950363b7cb17965">More...</a><br /></td></tr>
<tr class="separator:ga99ea9b6e63f0ea2ca950363b7cb17965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a00f69681b2014d863b207ce8ffcb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gab7a00f69681b2014d863b207ce8ffcb8">regina::Handlebody::operator!=</a> (const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;compare) const</td></tr>
<tr class="memdesc:gab7a00f69681b2014d863b207ce8ffcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given handlebody represent different 3-manifolds.  <a href="group__manifold.html#gab7a00f69681b2014d863b207ce8ffcb8">More...</a><br /></td></tr>
<tr class="separator:gab7a00f69681b2014d863b207ce8ffcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e380b4b6af7328945d815e1b9b9976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga10e380b4b6af7328945d815e1b9b9976">regina::Handlebody::operator=</a> (const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga10e380b4b6af7328945d815e1b9b9976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given handlebody.  <a href="group__manifold.html#ga10e380b4b6af7328945d815e1b9b9976">More...</a><br /></td></tr>
<tr class="separator:ga10e380b4b6af7328945d815e1b9b9976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62e2794186d5f7a24b46b65c41a2027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac62e2794186d5f7a24b46b65c41a2027">regina::Handlebody::homology</a> () const override</td></tr>
<tr class="memdesc:gac62e2794186d5f7a24b46b65c41a2027"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gac62e2794186d5f7a24b46b65c41a2027">More...</a><br /></td></tr>
<tr class="separator:gac62e2794186d5f7a24b46b65c41a2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc84e4c18db41d1255d1f8ff6d42a0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga3cc84e4c18db41d1255d1f8ff6d42a0d">regina::Handlebody::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:ga3cc84e4c18db41d1255d1f8ff6d42a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#ga3cc84e4c18db41d1255d1f8ff6d42a0d">More...</a><br /></td></tr>
<tr class="separator:ga3cc84e4c18db41d1255d1f8ff6d42a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a4ea39d9e1a1cd1da69548dacb4a12"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga36a4ea39d9e1a1cd1da69548dacb4a12">regina::Handlebody::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga36a4ea39d9e1a1cd1da69548dacb4a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga36a4ea39d9e1a1cd1da69548dacb4a12">More...</a><br /></td></tr>
<tr class="separator:ga36a4ea39d9e1a1cd1da69548dacb4a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7840044ad08449dcc4ba76765f3046c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gad7840044ad08449dcc4ba76765f3046c">regina::Handlebody::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gad7840044ad08449dcc4ba76765f3046c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#gad7840044ad08449dcc4ba76765f3046c">More...</a><br /></td></tr>
<tr class="separator:gad7840044ad08449dcc4ba76765f3046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8629f2603226ac93f0bd2dc2ab4e01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7e8629f2603226ac93f0bd2dc2ab4e01">regina::LensSpace::LensSpace</a> (unsigned long newP, unsigned long newQ)</td></tr>
<tr class="memdesc:ga7e8629f2603226ac93f0bd2dc2ab4e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new lens space with the given parameters.  <a href="group__manifold.html#ga7e8629f2603226ac93f0bd2dc2ab4e01">More...</a><br /></td></tr>
<tr class="separator:ga7e8629f2603226ac93f0bd2dc2ab4e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4ba47c715267c049ba0d89f2aa47a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2b4ba47c715267c049ba0d89f2aa47a0">regina::LensSpace::LensSpace</a> (const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga2b4ba47c715267c049ba0d89f2aa47a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given lens space.  <a href="group__manifold.html#ga2b4ba47c715267c049ba0d89f2aa47a0">More...</a><br /></td></tr>
<tr class="separator:ga2b4ba47c715267c049ba0d89f2aa47a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bedd7c9c070c6b4dffebdfb7d84736f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7bedd7c9c070c6b4dffebdfb7d84736f">regina::LensSpace::~LensSpace</a> ()</td></tr>
<tr class="memdesc:ga7bedd7c9c070c6b4dffebdfb7d84736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this lens space.  <a href="group__manifold.html#ga7bedd7c9c070c6b4dffebdfb7d84736f">More...</a><br /></td></tr>
<tr class="separator:ga7bedd7c9c070c6b4dffebdfb7d84736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf31f26ecb2df3f75201f94c58a451df"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaf31f26ecb2df3f75201f94c58a451df">regina::LensSpace::p</a> () const</td></tr>
<tr class="memdesc:gaaf31f26ecb2df3f75201f94c58a451df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first parameter <em>p</em> of this lens space L(p,q).  <a href="group__manifold.html#gaaf31f26ecb2df3f75201f94c58a451df">More...</a><br /></td></tr>
<tr class="separator:gaaf31f26ecb2df3f75201f94c58a451df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606a94b07140f5f5920fdabea6a8f993"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga606a94b07140f5f5920fdabea6a8f993">regina::LensSpace::q</a> () const</td></tr>
<tr class="memdesc:ga606a94b07140f5f5920fdabea6a8f993"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second parameter <em>q</em> of this lens space L(p,q).  <a href="group__manifold.html#ga606a94b07140f5f5920fdabea6a8f993">More...</a><br /></td></tr>
<tr class="separator:ga606a94b07140f5f5920fdabea6a8f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade50f94cb7b964ece12406e27204b386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gade50f94cb7b964ece12406e27204b386">regina::LensSpace::operator==</a> (const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:gade50f94cb7b964ece12406e27204b386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given lens space are homeomorphic 3-manifolds.  <a href="group__manifold.html#gade50f94cb7b964ece12406e27204b386">More...</a><br /></td></tr>
<tr class="separator:gade50f94cb7b964ece12406e27204b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc1a3d58ad3c68b272b76e87c3cf4827"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafc1a3d58ad3c68b272b76e87c3cf4827">regina::LensSpace::operator!=</a> (const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:gafc1a3d58ad3c68b272b76e87c3cf4827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given lens space are non-homeomorphic 3-manifolds.  <a href="group__manifold.html#gafc1a3d58ad3c68b272b76e87c3cf4827">More...</a><br /></td></tr>
<tr class="separator:gafc1a3d58ad3c68b272b76e87c3cf4827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a59f70cecedbb3cc5b9fac7d79c74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gad5a59f70cecedbb3cc5b9fac7d79c74e">regina::LensSpace::operator=</a> (const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gad5a59f70cecedbb3cc5b9fac7d79c74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given lens space.  <a href="group__manifold.html#gad5a59f70cecedbb3cc5b9fac7d79c74e">More...</a><br /></td></tr>
<tr class="separator:gad5a59f70cecedbb3cc5b9fac7d79c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746a936e5ed9ecfd0a7dd010aea0a8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga746a936e5ed9ecfd0a7dd010aea0a8a7">regina::LensSpace::construct</a> () const override</td></tr>
<tr class="memdesc:ga746a936e5ed9ecfd0a7dd010aea0a8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="group__manifold.html#ga746a936e5ed9ecfd0a7dd010aea0a8a7">More...</a><br /></td></tr>
<tr class="separator:ga746a936e5ed9ecfd0a7dd010aea0a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d753a813cfd8df5ab1fe452c106d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa3d753a813cfd8df5ab1fe452c106d31">regina::LensSpace::homology</a> () const override</td></tr>
<tr class="memdesc:gaa3d753a813cfd8df5ab1fe452c106d31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gaa3d753a813cfd8df5ab1fe452c106d31">More...</a><br /></td></tr>
<tr class="separator:gaa3d753a813cfd8df5ab1fe452c106d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07f4f53d4e3568b421e8e46367027d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae07f4f53d4e3568b421e8e46367027d4">regina::LensSpace::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:gae07f4f53d4e3568b421e8e46367027d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#gae07f4f53d4e3568b421e8e46367027d4">More...</a><br /></td></tr>
<tr class="separator:gae07f4f53d4e3568b421e8e46367027d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1cf361521fe9874da5a5e233e9c317"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaee1cf361521fe9874da5a5e233e9c317">regina::LensSpace::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaee1cf361521fe9874da5a5e233e9c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#gaee1cf361521fe9874da5a5e233e9c317">More...</a><br /></td></tr>
<tr class="separator:gaee1cf361521fe9874da5a5e233e9c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcd7f9332609c117ed9abdb1b18b34a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gabbcd7f9332609c117ed9abdb1b18b34a">regina::LensSpace::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gabbcd7f9332609c117ed9abdb1b18b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#gabbcd7f9332609c117ed9abdb1b18b34a">More...</a><br /></td></tr>
<tr class="separator:gabbcd7f9332609c117ed9abdb1b18b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0165b4ca5ec15a50152cc965ad6ee317"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0165b4ca5ec15a50152cc965ad6ee317">regina::Manifold::~Manifold</a> ()</td></tr>
<tr class="memdesc:ga0165b4ca5ec15a50152cc965ad6ee317"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor that does nothing.  <a href="group__manifold.html#ga0165b4ca5ec15a50152cc965ad6ee317">More...</a><br /></td></tr>
<tr class="separator:ga0165b4ca5ec15a50152cc965ad6ee317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d702e878c4a5e17dc17245b8e3d667"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga93d702e878c4a5e17dc17245b8e3d667">regina::Manifold::name</a> () const</td></tr>
<tr class="memdesc:ga93d702e878c4a5e17dc17245b8e3d667"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold as a human-readable string.  <a href="group__manifold.html#ga93d702e878c4a5e17dc17245b8e3d667">More...</a><br /></td></tr>
<tr class="separator:ga93d702e878c4a5e17dc17245b8e3d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9282f7e1b3d5e1e0ebb4343614fd70"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0e9282f7e1b3d5e1e0ebb4343614fd70">regina::Manifold::TeXName</a> () const</td></tr>
<tr class="memdesc:ga0e9282f7e1b3d5e1e0ebb4343614fd70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold in TeX format.  <a href="group__manifold.html#ga0e9282f7e1b3d5e1e0ebb4343614fd70">More...</a><br /></td></tr>
<tr class="separator:ga0e9282f7e1b3d5e1e0ebb4343614fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c9d3c3cbce470e4ecb69e91384d02c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gad5c9d3c3cbce470e4ecb69e91384d02c">regina::Manifold::structure</a> () const</td></tr>
<tr class="memdesc:gad5c9d3c3cbce470e4ecb69e91384d02c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the structure of this 3-manifold that might not be evident from its common name.  <a href="group__manifold.html#gad5c9d3c3cbce470e4ecb69e91384d02c">More...</a><br /></td></tr>
<tr class="separator:gad5c9d3c3cbce470e4ecb69e91384d02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf5c09da349003645cdb3a56269b5e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">regina::Manifold::construct</a> () const</td></tr>
<tr class="memdesc:gafdf5c09da349003645cdb3a56269b5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">More...</a><br /></td></tr>
<tr class="separator:gafdf5c09da349003645cdb3a56269b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdccc08b4a2712cda3d3bc6e40ae332"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold::homology</a> () const</td></tr>
<tr class="memdesc:gacbdccc08b4a2712cda3d3bc6e40ae332"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">More...</a><br /></td></tr>
<tr class="separator:gacbdccc08b4a2712cda3d3bc6e40ae332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b5892a97591c988772705b6c06eb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56">regina::Manifold::homologyH1</a> () const</td></tr>
<tr class="memdesc:gaf4b5892a97591c988772705b6c06eb56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56">More...</a><br /></td></tr>
<tr class="separator:gaf4b5892a97591c988772705b6c06eb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae723ffbf9ca421caeac7e990765f5a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold::isHyperbolic</a> () const =0</td></tr>
<tr class="memdesc:ga8ae723ffbf9ca421caeac7e990765f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">More...</a><br /></td></tr>
<tr class="separator:ga8ae723ffbf9ca421caeac7e990765f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340ae7f9e981a404667a1383366c114c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga340ae7f9e981a404667a1383366c114c">regina::Manifold::operator&lt;</a> (const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga340ae7f9e981a404667a1383366c114c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold.  <a href="group__manifold.html#ga340ae7f9e981a404667a1383366c114c">More...</a><br /></td></tr>
<tr class="separator:ga340ae7f9e981a404667a1383366c114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0411f3eb6409674e448dfe4a6b682f"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold::writeName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga8a0411f3eb6409674e448dfe4a6b682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">More...</a><br /></td></tr>
<tr class="separator:ga8a0411f3eb6409674e448dfe4a6b682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48689f189a77113323a55eb8029e3c61"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold::writeTeXName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga48689f189a77113323a55eb8029e3c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">More...</a><br /></td></tr>
<tr class="separator:ga48689f189a77113323a55eb8029e3c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6629373d88ce55bc4a3e12d3cd64a481"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga6629373d88ce55bc4a3e12d3cd64a481">regina::Manifold::writeStructure</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga6629373d88ce55bc4a3e12d3cd64a481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream.  <a href="group__manifold.html#ga6629373d88ce55bc4a3e12d3cd64a481">More...</a><br /></td></tr>
<tr class="separator:ga6629373d88ce55bc4a3e12d3cd64a481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239a494eef37497d14d963ab2d0ad9f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga239a494eef37497d14d963ab2d0ad9f9">regina::Manifold::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga239a494eef37497d14d963ab2d0ad9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__manifold.html#ga239a494eef37497d14d963ab2d0ad9f9">More...</a><br /></td></tr>
<tr class="separator:ga239a494eef37497d14d963ab2d0ad9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c18dbf18c57378e979f81220ebd6eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9c18dbf18c57378e979f81220ebd6eb9">regina::Manifold::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga9c18dbf18c57378e979f81220ebd6eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__manifold.html#ga9c18dbf18c57378e979f81220ebd6eb9">More...</a><br /></td></tr>
<tr class="separator:ga9c18dbf18c57378e979f81220ebd6eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1bf46bca6c71c817c6d1d0c87540d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1b1bf46bca6c71c817c6d1d0c87540d7">regina::Manifold::operator=</a> (const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;)=default</td></tr>
<tr class="memdesc:ga1b1bf46bca6c71c817c6d1d0c87540d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default assignment operator.  <a href="group__manifold.html#ga1b1bf46bca6c71c817c6d1d0c87540d7">More...</a><br /></td></tr>
<tr class="separator:ga1b1bf46bca6c71c817c6d1d0c87540d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5479049508d41b3f07b54380f76b33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9e5479049508d41b3f07b54380f76b33">regina::SFSFibre::SFSFibre</a> ()</td></tr>
<tr class="memdesc:ga9e5479049508d41b3f07b54380f76b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised exceptional fibre.  <a href="group__manifold.html#ga9e5479049508d41b3f07b54380f76b33">More...</a><br /></td></tr>
<tr class="separator:ga9e5479049508d41b3f07b54380f76b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d5836d6d325155e74c1008a6977278"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga51d5836d6d325155e74c1008a6977278">regina::SFSFibre::SFSFibre</a> (long newAlpha, long newBeta)</td></tr>
<tr class="memdesc:ga51d5836d6d325155e74c1008a6977278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new exceptional fibre with the given parameters.  <a href="group__manifold.html#ga51d5836d6d325155e74c1008a6977278">More...</a><br /></td></tr>
<tr class="separator:ga51d5836d6d325155e74c1008a6977278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c41cab79157a8eefcaddd7db0980844"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1c41cab79157a8eefcaddd7db0980844">regina::SFSFibre::SFSFibre</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga1c41cab79157a8eefcaddd7db0980844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new exceptional fibre that is a clone of the given fibre.  <a href="group__manifold.html#ga1c41cab79157a8eefcaddd7db0980844">More...</a><br /></td></tr>
<tr class="separator:ga1c41cab79157a8eefcaddd7db0980844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81a55ece00f7240cee18cd05858cb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa81a55ece00f7240cee18cd05858cb2e">regina::SFSFibre::operator=</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gaa81a55ece00f7240cee18cd05858cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this exceptional fibre a clone of the given fibre.  <a href="group__manifold.html#gaa81a55ece00f7240cee18cd05858cb2e">More...</a><br /></td></tr>
<tr class="separator:gaa81a55ece00f7240cee18cd05858cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3c3ff9d49e0e8bbb0191bc2e36f40c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gadc3c3ff9d49e0e8bbb0191bc2e36f40c">regina::SFSFibre::operator==</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;compare) const</td></tr>
<tr class="memdesc:gadc3c3ff9d49e0e8bbb0191bc2e36f40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given exceptional fibre are identical.  <a href="group__manifold.html#gadc3c3ff9d49e0e8bbb0191bc2e36f40c">More...</a><br /></td></tr>
<tr class="separator:gadc3c3ff9d49e0e8bbb0191bc2e36f40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41830f0ddc7c4dd0f7c99892ea8205b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga41830f0ddc7c4dd0f7c99892ea8205b9">regina::SFSFibre::operator!=</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga41830f0ddc7c4dd0f7c99892ea8205b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given exceptional fibre are different.  <a href="group__manifold.html#ga41830f0ddc7c4dd0f7c99892ea8205b9">More...</a><br /></td></tr>
<tr class="separator:ga41830f0ddc7c4dd0f7c99892ea8205b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0106e32932c0d909d3feb53d50d257c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0106e32932c0d909d3feb53d50d257c8">regina::SFSFibre::operator&lt;</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga0106e32932c0d909d3feb53d50d257c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this exceptional fibre is smaller than the given fibre.  <a href="group__manifold.html#ga0106e32932c0d909d3feb53d50d257c8">More...</a><br /></td></tr>
<tr class="separator:ga0106e32932c0d909d3feb53d50d257c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683c84ac8fd61583bfad01fafc841f17"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga683c84ac8fd61583bfad01fafc841f17">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;f)</td></tr>
<tr class="memdesc:ga683c84ac8fd61583bfad01fafc841f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given fibre in human-readable format to the given output stream.  <a href="group__manifold.html#ga683c84ac8fd61583bfad01fafc841f17">More...</a><br /></td></tr>
<tr class="separator:ga683c84ac8fd61583bfad01fafc841f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577f3044abc53a580a0bf8e7c2c072d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga577f3044abc53a580a0bf8e7c2c072d0">regina::SFSpace::SFSpace</a> ()</td></tr>
<tr class="memdesc:ga577f3044abc53a580a0bf8e7c2c072d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres.  <a href="group__manifold.html#ga577f3044abc53a580a0bf8e7c2c072d0">More...</a><br /></td></tr>
<tr class="separator:ga577f3044abc53a580a0bf8e7c2c072d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fad6e2b785d4a98f21cdfba570992f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9fad6e2b785d4a98f21cdfba570992f7">regina::SFSpace::SFSpace</a> (<a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">classType</a> useClass, unsigned long genus, unsigned long <a class="el" href="group__manifold.html#ga5543c0208bf70b3209cfa5baa741c67f">punctures</a>=0, unsigned long puncturesTwisted=0, unsigned long <a class="el" href="group__manifold.html#ga3c825b5e07e3899d32f02f5fbdcb7268">reflectors</a>=0, unsigned long reflectorsTwisted=0)</td></tr>
<tr class="memdesc:ga9fad6e2b785d4a98f21cdfba570992f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres.  <a href="group__manifold.html#ga9fad6e2b785d4a98f21cdfba570992f7">More...</a><br /></td></tr>
<tr class="separator:ga9fad6e2b785d4a98f21cdfba570992f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4193594b1d8fea9930b1539491a9b268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga4193594b1d8fea9930b1539491a9b268">regina::SFSpace::SFSpace</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga4193594b1d8fea9930b1539491a9b268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space that is a clone of the given space.  <a href="group__manifold.html#ga4193594b1d8fea9930b1539491a9b268">More...</a><br /></td></tr>
<tr class="separator:ga4193594b1d8fea9930b1539491a9b268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc6b7476178bdec9fd20d809c6f3fa2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7dc6b7476178bdec9fd20d809c6f3fa2">regina::SFSpace::~SFSpace</a> ()</td></tr>
<tr class="memdesc:ga7dc6b7476178bdec9fd20d809c6f3fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this Seifert fibred space.  <a href="group__manifold.html#ga7dc6b7476178bdec9fd20d809c6f3fa2">More...</a><br /></td></tr>
<tr class="separator:ga7dc6b7476178bdec9fd20d809c6f3fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3478de5619322ae10f4b768dba68840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaf3478de5619322ae10f4b768dba68840">regina::SFSpace::operator=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gaf3478de5619322ae10f4b768dba68840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies this Seifert fibred space to be a clone of the given space.  <a href="group__manifold.html#gaf3478de5619322ae10f4b768dba68840">More...</a><br /></td></tr>
<tr class="separator:gaf3478de5619322ae10f4b768dba68840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7471230bf920402efaefca3a0fe98414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">classType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga7471230bf920402efaefca3a0fe98414">regina::SFSpace::baseClass</a> () const</td></tr>
<tr class="memdesc:ga7471230bf920402efaefca3a0fe98414"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which of the eleven predefined classes this space belongs to.  <a href="group__manifold.html#ga7471230bf920402efaefca3a0fe98414">More...</a><br /></td></tr>
<tr class="separator:ga7471230bf920402efaefca3a0fe98414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa610d605949c98b6360a87227d0da1a2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa610d605949c98b6360a87227d0da1a2">regina::SFSpace::baseGenus</a> () const</td></tr>
<tr class="memdesc:gaa610d605949c98b6360a87227d0da1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the genus of the base orbifold.  <a href="group__manifold.html#gaa610d605949c98b6360a87227d0da1a2">More...</a><br /></td></tr>
<tr class="separator:gaa610d605949c98b6360a87227d0da1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873210dabde6c5a56e2dfa284e6707ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga873210dabde6c5a56e2dfa284e6707ae">regina::SFSpace::baseOrientable</a> () const</td></tr>
<tr class="memdesc:ga873210dabde6c5a56e2dfa284e6707ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not the base surface is orientable.  <a href="group__manifold.html#ga873210dabde6c5a56e2dfa284e6707ae">More...</a><br /></td></tr>
<tr class="separator:ga873210dabde6c5a56e2dfa284e6707ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc882d6795358f5e96eaa0c423fb4b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gabc882d6795358f5e96eaa0c423fb4b1d">regina::SFSpace::fibreReversing</a> () const</td></tr>
<tr class="memdesc:gabc882d6795358f5e96eaa0c423fb4b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this space contains any fibre-reversing paths.  <a href="group__manifold.html#gabc882d6795358f5e96eaa0c423fb4b1d">More...</a><br /></td></tr>
<tr class="separator:gabc882d6795358f5e96eaa0c423fb4b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b9d08bdd55767057aa12d5a21fa0eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5b9d08bdd55767057aa12d5a21fa0eb">regina::SFSpace::fibreNegating</a> () const</td></tr>
<tr class="memdesc:gaa5b9d08bdd55767057aa12d5a21fa0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold.  <a href="group__manifold.html#gaa5b9d08bdd55767057aa12d5a21fa0eb">More...</a><br /></td></tr>
<tr class="separator:gaa5b9d08bdd55767057aa12d5a21fa0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5543c0208bf70b3209cfa5baa741c67f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5543c0208bf70b3209cfa5baa741c67f">regina::SFSpace::punctures</a> () const</td></tr>
<tr class="memdesc:ga5543c0208bf70b3209cfa5baa741c67f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of punctures in the base orbifold.  <a href="group__manifold.html#ga5543c0208bf70b3209cfa5baa741c67f">More...</a><br /></td></tr>
<tr class="separator:ga5543c0208bf70b3209cfa5baa741c67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2995dbf0df3c0d89a1af68bec6cc6003"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2995dbf0df3c0d89a1af68bec6cc6003">regina::SFSpace::punctures</a> (bool twisted) const</td></tr>
<tr class="memdesc:ga2995dbf0df3c0d89a1af68bec6cc6003"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of punctures of the given type in the base orbifold.  <a href="group__manifold.html#ga2995dbf0df3c0d89a1af68bec6cc6003">More...</a><br /></td></tr>
<tr class="separator:ga2995dbf0df3c0d89a1af68bec6cc6003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c825b5e07e3899d32f02f5fbdcb7268"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga3c825b5e07e3899d32f02f5fbdcb7268">regina::SFSpace::reflectors</a> () const</td></tr>
<tr class="memdesc:ga3c825b5e07e3899d32f02f5fbdcb7268"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of reflector boundary components of the base orbifold.  <a href="group__manifold.html#ga3c825b5e07e3899d32f02f5fbdcb7268">More...</a><br /></td></tr>
<tr class="separator:ga3c825b5e07e3899d32f02f5fbdcb7268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac45bd427305037e276106095cec3c62b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac45bd427305037e276106095cec3c62b">regina::SFSpace::reflectors</a> (bool twisted) const</td></tr>
<tr class="memdesc:gac45bd427305037e276106095cec3c62b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of reflector boundary components of the given type in the base orbifold.  <a href="group__manifold.html#gac45bd427305037e276106095cec3c62b">More...</a><br /></td></tr>
<tr class="separator:gac45bd427305037e276106095cec3c62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0fbc352bf9f9f680dc4622760099c5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gacd0fbc352bf9f9f680dc4622760099c5">regina::SFSpace::fibreCount</a> () const</td></tr>
<tr class="memdesc:gacd0fbc352bf9f9f680dc4622760099c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of exceptional fibres in this Seifert fibred space.  <a href="group__manifold.html#gacd0fbc352bf9f9f680dc4622760099c5">More...</a><br /></td></tr>
<tr class="separator:gacd0fbc352bf9f9f680dc4622760099c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b92f5e9498ac3393481893c104bd6a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga4b92f5e9498ac3393481893c104bd6a0">regina::SFSpace::fibre</a> (unsigned long which) const</td></tr>
<tr class="memdesc:ga4b92f5e9498ac3393481893c104bd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested exceptional fibre.  <a href="group__manifold.html#ga4b92f5e9498ac3393481893c104bd6a0">More...</a><br /></td></tr>
<tr class="separator:ga4b92f5e9498ac3393481893c104bd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f1c254d3237073e5ba12978162ad76"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga96f1c254d3237073e5ba12978162ad76">regina::SFSpace::obstruction</a> () const</td></tr>
<tr class="memdesc:ga96f1c254d3237073e5ba12978162ad76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the obstruction constant <em>b</em> for this Seifert fibred space.  <a href="group__manifold.html#ga96f1c254d3237073e5ba12978162ad76">More...</a><br /></td></tr>
<tr class="separator:ga96f1c254d3237073e5ba12978162ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6811f7faaddfc8024244ad326a8b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gadb6811f7faaddfc8024244ad326a8b2f">regina::SFSpace::addHandle</a> (bool <a class="el" href="group__manifold.html#gabc882d6795358f5e96eaa0c423fb4b1d">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:gadb6811f7faaddfc8024244ad326a8b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new handle into the base orbifold.  <a href="group__manifold.html#gadb6811f7faaddfc8024244ad326a8b2f">More...</a><br /></td></tr>
<tr class="separator:gadb6811f7faaddfc8024244ad326a8b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd42f80225f7c7e0c2af0933baeb338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9dd42f80225f7c7e0c2af0933baeb338">regina::SFSpace::addCrosscap</a> (bool <a class="el" href="group__manifold.html#gabc882d6795358f5e96eaa0c423fb4b1d">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:ga9dd42f80225f7c7e0c2af0933baeb338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new crosscap into the base orbifold.  <a href="group__manifold.html#ga9dd42f80225f7c7e0c2af0933baeb338">More...</a><br /></td></tr>
<tr class="separator:ga9dd42f80225f7c7e0c2af0933baeb338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b831e36639d0182ce5fc4f89b9a218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga77b831e36639d0182ce5fc4f89b9a218">regina::SFSpace::addPuncture</a> (bool twisted=false, unsigned long nPunctures=1)</td></tr>
<tr class="memdesc:ga77b831e36639d0182ce5fc4f89b9a218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one or more new punctures into the base orbifold.  <a href="group__manifold.html#ga77b831e36639d0182ce5fc4f89b9a218">More...</a><br /></td></tr>
<tr class="separator:ga77b831e36639d0182ce5fc4f89b9a218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffaef6a5a9f7187c315817b222e6cf28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaffaef6a5a9f7187c315817b222e6cf28">regina::SFSpace::addReflector</a> (bool twisted=false, unsigned long nReflectors=1)</td></tr>
<tr class="memdesc:gaffaef6a5a9f7187c315817b222e6cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more new reflector boundary components to the base orbifold.  <a href="group__manifold.html#gaffaef6a5a9f7187c315817b222e6cf28">More...</a><br /></td></tr>
<tr class="separator:gaffaef6a5a9f7187c315817b222e6cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cabfe8efaeb3c370e74abf2f50a09be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9cabfe8efaeb3c370e74abf2f50a09be">regina::SFSpace::insertFibre</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;<a class="el" href="group__manifold.html#ga4b92f5e9498ac3393481893c104bd6a0">fibre</a>)</td></tr>
<tr class="memdesc:ga9cabfe8efaeb3c370e74abf2f50a09be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="group__manifold.html#ga9cabfe8efaeb3c370e74abf2f50a09be">More...</a><br /></td></tr>
<tr class="separator:ga9cabfe8efaeb3c370e74abf2f50a09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35622fc87c75f221bff99ce9ad5db238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga35622fc87c75f221bff99ce9ad5db238">regina::SFSpace::insertFibre</a> (long alpha, long beta)</td></tr>
<tr class="memdesc:ga35622fc87c75f221bff99ce9ad5db238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="group__manifold.html#ga35622fc87c75f221bff99ce9ad5db238">More...</a><br /></td></tr>
<tr class="separator:ga35622fc87c75f221bff99ce9ad5db238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070e0759c61a8b7d8816ca10bbee42a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga070e0759c61a8b7d8816ca10bbee42a8">regina::SFSpace::reflect</a> ()</td></tr>
<tr class="memdesc:ga070e0759c61a8b7d8816ca10bbee42a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this space with its mirror image.  <a href="group__manifold.html#ga070e0759c61a8b7d8816ca10bbee42a8">More...</a><br /></td></tr>
<tr class="separator:ga070e0759c61a8b7d8816ca10bbee42a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699dd395b4b242cd4d6157b705f65123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga699dd395b4b242cd4d6157b705f65123">regina::SFSpace::complementAllFibres</a> ()</td></tr>
<tr class="memdesc:ga699dd395b4b242cd4d6157b705f65123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>).  <a href="group__manifold.html#ga699dd395b4b242cd4d6157b705f65123">More...</a><br /></td></tr>
<tr class="separator:ga699dd395b4b242cd4d6157b705f65123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28f4b1aeac0b2105233f4293509c492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gab28f4b1aeac0b2105233f4293509c492">regina::SFSpace::reduce</a> (bool mayReflect=true)</td></tr>
<tr class="memdesc:gab28f4b1aeac0b2105233f4293509c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration.  <a href="group__manifold.html#gab28f4b1aeac0b2105233f4293509c492">More...</a><br /></td></tr>
<tr class="separator:gab28f4b1aeac0b2105233f4293509c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92afcccfae0702575898998bc6cd918b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga92afcccfae0702575898998bc6cd918b">regina::SFSpace::isLensSpace</a> () const</td></tr>
<tr class="memdesc:ga92afcccfae0702575898998bc6cd918b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this Seifert fibred space is a Lens space.  <a href="group__manifold.html#ga92afcccfae0702575898998bc6cd918b">More...</a><br /></td></tr>
<tr class="separator:ga92afcccfae0702575898998bc6cd918b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55dbc5a9fa80611d6cff6724ead915be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga55dbc5a9fa80611d6cff6724ead915be">regina::SFSpace::operator==</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga55dbc5a9fa80611d6cff6724ead915be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure contain precisely the same representations of precisely the same Seifert fibred spaces.  <a href="group__manifold.html#ga55dbc5a9fa80611d6cff6724ead915be">More...</a><br /></td></tr>
<tr class="separator:ga55dbc5a9fa80611d6cff6724ead915be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e3a984ec3bceb32a8ada29ff58460b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga12e3a984ec3bceb32a8ada29ff58460b">regina::SFSpace::operator!=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga12e3a984ec3bceb32a8ada29ff58460b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure do not contain precisely the same representations of precisely the same Seifert fibred spaces.  <a href="group__manifold.html#ga12e3a984ec3bceb32a8ada29ff58460b">More...</a><br /></td></tr>
<tr class="separator:ga12e3a984ec3bceb32a8ada29ff58460b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28e31e2a1e6c0cafb39c26213c6055"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gade28e31e2a1e6c0cafb39c26213c6055">regina::SFSpace::operator&lt;</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:gade28e31e2a1e6c0cafb39c26213c6055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="group__manifold.html#gade28e31e2a1e6c0cafb39c26213c6055">More...</a><br /></td></tr>
<tr class="separator:gade28e31e2a1e6c0cafb39c26213c6055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c754bbd2ccef34de4a81d4a40ba736c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2c754bbd2ccef34de4a81d4a40ba736c">regina::SFSpace::construct</a> () const override</td></tr>
<tr class="memdesc:ga2c754bbd2ccef34de4a81d4a40ba736c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="group__manifold.html#ga2c754bbd2ccef34de4a81d4a40ba736c">More...</a><br /></td></tr>
<tr class="separator:ga2c754bbd2ccef34de4a81d4a40ba736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294c7e7950ca931fc1f47ec332e8ba14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga294c7e7950ca931fc1f47ec332e8ba14">regina::SFSpace::homology</a> () const override</td></tr>
<tr class="memdesc:ga294c7e7950ca931fc1f47ec332e8ba14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#ga294c7e7950ca931fc1f47ec332e8ba14">More...</a><br /></td></tr>
<tr class="separator:ga294c7e7950ca931fc1f47ec332e8ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef1686791fb43a8e4d0b5221c53fd31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8ef1686791fb43a8e4d0b5221c53fd31">regina::SFSpace::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:ga8ef1686791fb43a8e4d0b5221c53fd31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#ga8ef1686791fb43a8e4d0b5221c53fd31">More...</a><br /></td></tr>
<tr class="separator:ga8ef1686791fb43a8e4d0b5221c53fd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370fcf932fcdb4beacf04e4e0bdfc123"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga370fcf932fcdb4beacf04e4e0bdfc123">regina::SFSpace::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga370fcf932fcdb4beacf04e4e0bdfc123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga370fcf932fcdb4beacf04e4e0bdfc123">More...</a><br /></td></tr>
<tr class="separator:ga370fcf932fcdb4beacf04e4e0bdfc123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74307d1ef9a53354aacb00e32fde0555"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga74307d1ef9a53354aacb00e32fde0555">regina::SFSpace::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga74307d1ef9a53354aacb00e32fde0555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga74307d1ef9a53354aacb00e32fde0555">More...</a><br /></td></tr>
<tr class="separator:ga74307d1ef9a53354aacb00e32fde0555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4246776c806d4bf771067bf1d956500"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4246776c806d4bf771067bf1d956500">regina::SFSpace::writeStructure</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaa4246776c806d4bf771067bf1d956500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream.  <a href="group__manifold.html#gaa4246776c806d4bf771067bf1d956500">More...</a><br /></td></tr>
<tr class="separator:gaa4246776c806d4bf771067bf1d956500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d1d768c185e9762aa44962c0050aad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga74d1d768c185e9762aa44962c0050aad">regina::SFSAltSet::SFSAltSet</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *sfs)</td></tr>
<tr class="memdesc:ga74d1d768c185e9762aa44962c0050aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of alternatives for the given Seifert fibred space.  <a href="group__manifold.html#ga74d1d768c185e9762aa44962c0050aad">More...</a><br /></td></tr>
<tr class="separator:ga74d1d768c185e9762aa44962c0050aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8173fe85801cd759182b610a7c7ad545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8173fe85801cd759182b610a7c7ad545">regina::SFSAltSet::deleteAll</a> ()</td></tr>
<tr class="memdesc:ga8173fe85801cd759182b610a7c7ad545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all of the alternative representations in this set.  <a href="group__manifold.html#ga8173fe85801cd759182b610a7c7ad545">More...</a><br /></td></tr>
<tr class="separator:ga8173fe85801cd759182b610a7c7ad545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e40a61b6f6b403cd1fa594ddb407ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8e40a61b6f6b403cd1fa594ddb407ca1">regina::SFSAltSet::deleteAll</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *exception)</td></tr>
<tr class="memdesc:ga8e40a61b6f6b403cd1fa594ddb407ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all of the alternative representations in this set, except for the given exception.  <a href="group__manifold.html#ga8e40a61b6f6b403cd1fa594ddb407ca1">More...</a><br /></td></tr>
<tr class="separator:ga8e40a61b6f6b403cd1fa594ddb407ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb3e8cef4af73bdaccb4541218562d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga3fb3e8cef4af73bdaccb4541218562d1">regina::SFSAltSet::deleteAll</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *exception1, <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *exception2)</td></tr>
<tr class="memdesc:ga3fb3e8cef4af73bdaccb4541218562d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all of the alternative representations in this set, except for the two given exceptions.  <a href="group__manifold.html#ga3fb3e8cef4af73bdaccb4541218562d1">More...</a><br /></td></tr>
<tr class="separator:ga3fb3e8cef4af73bdaccb4541218562d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29657c6df170a281b70b597c9d10901f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga29657c6df170a281b70b597c9d10901f">regina::SFSAltSet::size</a> () const</td></tr>
<tr class="memdesc:ga29657c6df170a281b70b597c9d10901f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of alternative spaces in this set.  <a href="group__manifold.html#ga29657c6df170a281b70b597c9d10901f">More...</a><br /></td></tr>
<tr class="separator:ga29657c6df170a281b70b597c9d10901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a583800775800d36f4bce133109fd07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga6a583800775800d36f4bce133109fd07">regina::SFSAltSet::operator[]</a> (unsigned which) const</td></tr>
<tr class="memdesc:ga6a583800775800d36f4bce133109fd07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested alternative space.  <a href="group__manifold.html#ga6a583800775800d36f4bce133109fd07">More...</a><br /></td></tr>
<tr class="separator:ga6a583800775800d36f4bce133109fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169540a1535da6422acd8b73e5bbc4f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga169540a1535da6422acd8b73e5bbc4f1">regina::SFSAltSet::conversion</a> (unsigned which) const</td></tr>
<tr class="memdesc:ga169540a1535da6422acd8b73e5bbc4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the conversion matrix for the requested alternative space.  <a href="group__manifold.html#ga169540a1535da6422acd8b73e5bbc4f1">More...</a><br /></td></tr>
<tr class="separator:ga169540a1535da6422acd8b73e5bbc4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab02c3ca656eba9eff9b8df5144b6aa31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gab02c3ca656eba9eff9b8df5144b6aa31">regina::SFSAltSet::reflected</a> (unsigned which) const</td></tr>
<tr class="memdesc:gab02c3ca656eba9eff9b8df5144b6aa31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not a reflection was used when creating the requested alternative space.  <a href="group__manifold.html#gab02c3ca656eba9eff9b8df5144b6aa31">More...</a><br /></td></tr>
<tr class="separator:gab02c3ca656eba9eff9b8df5144b6aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503a40baf83846996f088308ba7afd56"><td class="memItemLeft" align="right" valign="top"><a id="ga503a40baf83846996f088308ba7afd56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SFSAltSet::SFSAltSet</b> (const <a class="el" href="classregina_1_1SFSAltSet.html">SFSAltSet</a> &amp;)=delete</td></tr>
<tr class="separator:ga503a40baf83846996f088308ba7afd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd5155214c18b793851ef70c0dfdce7"><td class="memItemLeft" align="right" valign="top"><a id="ga1fd5155214c18b793851ef70c0dfdce7"></a>
<a class="el" href="classregina_1_1SFSAltSet.html">SFSAltSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SFSAltSet::operator=</b> (const <a class="el" href="classregina_1_1SFSAltSet.html">SFSAltSet</a> &amp;)=delete</td></tr>
<tr class="separator:ga1fd5155214c18b793851ef70c0dfdce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938bde5b5a7ee989ea34c308ff694ef0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga938bde5b5a7ee989ea34c308ff694ef0">regina::SimpleSurfaceBundle::SimpleSurfaceBundle</a> (int newType)</td></tr>
<tr class="memdesc:ga938bde5b5a7ee989ea34c308ff694ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface bundle of the given type.  <a href="group__manifold.html#ga938bde5b5a7ee989ea34c308ff694ef0">More...</a><br /></td></tr>
<tr class="separator:ga938bde5b5a7ee989ea34c308ff694ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897973553716a18080964dc2753b27ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga897973553716a18080964dc2753b27ae">regina::SimpleSurfaceBundle::SimpleSurfaceBundle</a> (const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga897973553716a18080964dc2753b27ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given surface bundle.  <a href="group__manifold.html#ga897973553716a18080964dc2753b27ae">More...</a><br /></td></tr>
<tr class="separator:ga897973553716a18080964dc2753b27ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919f1bb75e707dffcc4448eee8aba0d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga919f1bb75e707dffcc4448eee8aba0d1">regina::SimpleSurfaceBundle::type</a> () const</td></tr>
<tr class="memdesc:ga919f1bb75e707dffcc4448eee8aba0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific type of surface bundle being represented.  <a href="group__manifold.html#ga919f1bb75e707dffcc4448eee8aba0d1">More...</a><br /></td></tr>
<tr class="separator:ga919f1bb75e707dffcc4448eee8aba0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5486c515b1ed76d9295bd9aca904a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9b5486c515b1ed76d9295bd9aca904a0">regina::SimpleSurfaceBundle::operator==</a> (const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga9b5486c515b1ed76d9295bd9aca904a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface bundle represent the same 3-manifold.  <a href="group__manifold.html#ga9b5486c515b1ed76d9295bd9aca904a0">More...</a><br /></td></tr>
<tr class="separator:ga9b5486c515b1ed76d9295bd9aca904a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7592ba0cc76eeeda17f5e2f65f0065e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac7592ba0cc76eeeda17f5e2f65f0065e">regina::SimpleSurfaceBundle::operator!=</a> (const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;compare) const</td></tr>
<tr class="memdesc:gac7592ba0cc76eeeda17f5e2f65f0065e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface bundle represent different 3-manifolds.  <a href="group__manifold.html#gac7592ba0cc76eeeda17f5e2f65f0065e">More...</a><br /></td></tr>
<tr class="separator:gac7592ba0cc76eeeda17f5e2f65f0065e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f13da5a80fcf204935b2692c1df8209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0f13da5a80fcf204935b2692c1df8209">regina::SimpleSurfaceBundle::operator=</a> (const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga0f13da5a80fcf204935b2692c1df8209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given surface bundle.  <a href="group__manifold.html#ga0f13da5a80fcf204935b2692c1df8209">More...</a><br /></td></tr>
<tr class="separator:ga0f13da5a80fcf204935b2692c1df8209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a2fa2c2b7182aaa63bbe101ba8f06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gac5a2fa2c2b7182aaa63bbe101ba8f06b">regina::SimpleSurfaceBundle::construct</a> () const override</td></tr>
<tr class="memdesc:gac5a2fa2c2b7182aaa63bbe101ba8f06b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="group__manifold.html#gac5a2fa2c2b7182aaa63bbe101ba8f06b">More...</a><br /></td></tr>
<tr class="separator:gac5a2fa2c2b7182aaa63bbe101ba8f06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e4a959f13960bdf85f9a6d4b42ddb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga19e4a959f13960bdf85f9a6d4b42ddb7">regina::SimpleSurfaceBundle::homology</a> () const override</td></tr>
<tr class="memdesc:ga19e4a959f13960bdf85f9a6d4b42ddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#ga19e4a959f13960bdf85f9a6d4b42ddb7">More...</a><br /></td></tr>
<tr class="separator:ga19e4a959f13960bdf85f9a6d4b42ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17b2bca957301c96a841c12b8a2f9d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gad17b2bca957301c96a841c12b8a2f9d4">regina::SimpleSurfaceBundle::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:gad17b2bca957301c96a841c12b8a2f9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#gad17b2bca957301c96a841c12b8a2f9d4">More...</a><br /></td></tr>
<tr class="separator:gad17b2bca957301c96a841c12b8a2f9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9906fdefac544ff508b78b99274a2036"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9906fdefac544ff508b78b99274a2036">regina::SimpleSurfaceBundle::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga9906fdefac544ff508b78b99274a2036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga9906fdefac544ff508b78b99274a2036">More...</a><br /></td></tr>
<tr class="separator:ga9906fdefac544ff508b78b99274a2036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4fd10178c878c632793e24537f9957"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9e4fd10178c878c632793e24537f9957">regina::SimpleSurfaceBundle::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga9e4fd10178c878c632793e24537f9957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga9e4fd10178c878c632793e24537f9957">More...</a><br /></td></tr>
<tr class="separator:ga9e4fd10178c878c632793e24537f9957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b44d420c71fa2a65510eed408720a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae6b44d420c71fa2a65510eed408720a9">regina::SnapPeaCensusManifold::SnapPeaCensusManifold</a> (char newSection, unsigned long newIndex)</td></tr>
<tr class="memdesc:gae6b44d420c71fa2a65510eed408720a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new SnapPea census manifold with the given parameters.  <a href="group__manifold.html#gae6b44d420c71fa2a65510eed408720a9">More...</a><br /></td></tr>
<tr class="separator:gae6b44d420c71fa2a65510eed408720a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf9b13564f6da0567ecd7853dde87e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8bf9b13564f6da0567ecd7853dde87e8">regina::SnapPeaCensusManifold::SnapPeaCensusManifold</a> (const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga8bf9b13564f6da0567ecd7853dde87e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given SnapPea census manifold.  <a href="group__manifold.html#ga8bf9b13564f6da0567ecd7853dde87e8">More...</a><br /></td></tr>
<tr class="separator:ga8bf9b13564f6da0567ecd7853dde87e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429d071d3555d590014da022430cdbd4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga429d071d3555d590014da022430cdbd4">regina::SnapPeaCensusManifold::~SnapPeaCensusManifold</a> ()</td></tr>
<tr class="memdesc:ga429d071d3555d590014da022430cdbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure.  <a href="group__manifold.html#ga429d071d3555d590014da022430cdbd4">More...</a><br /></td></tr>
<tr class="separator:ga429d071d3555d590014da022430cdbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207ba183a13ed70b5e07ee6602e4f1b3"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga207ba183a13ed70b5e07ee6602e4f1b3">regina::SnapPeaCensusManifold::section</a> () const</td></tr>
<tr class="memdesc:ga207ba183a13ed70b5e07ee6602e4f1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the section of the SnapPea census to which this manifold belongs.  <a href="group__manifold.html#ga207ba183a13ed70b5e07ee6602e4f1b3">More...</a><br /></td></tr>
<tr class="separator:ga207ba183a13ed70b5e07ee6602e4f1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0072dce133fd4614312c5e7ddac874f3"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0072dce133fd4614312c5e7ddac874f3">regina::SnapPeaCensusManifold::index</a> () const</td></tr>
<tr class="memdesc:ga0072dce133fd4614312c5e7ddac874f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this manifold within its particular section of the SnapPea census.  <a href="group__manifold.html#ga0072dce133fd4614312c5e7ddac874f3">More...</a><br /></td></tr>
<tr class="separator:ga0072dce133fd4614312c5e7ddac874f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3692b8b34fae273766c40801a67009e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga3692b8b34fae273766c40801a67009e0">regina::SnapPeaCensusManifold::operator==</a> (const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga3692b8b34fae273766c40801a67009e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure represent the same 3-manifold from the SnapPea census.  <a href="group__manifold.html#ga3692b8b34fae273766c40801a67009e0">More...</a><br /></td></tr>
<tr class="separator:ga3692b8b34fae273766c40801a67009e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941ba295f49ba52c60bfa032e95878d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga941ba295f49ba52c60bfa032e95878d8">regina::SnapPeaCensusManifold::operator!=</a> (const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga941ba295f49ba52c60bfa032e95878d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure represent different 3-manifolds from the SnapPea census.  <a href="group__manifold.html#ga941ba295f49ba52c60bfa032e95878d8">More...</a><br /></td></tr>
<tr class="separator:ga941ba295f49ba52c60bfa032e95878d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582d1b7b3013b7a206155ddeb4811b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga582d1b7b3013b7a206155ddeb4811b92">regina::SnapPeaCensusManifold::operator=</a> (const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga582d1b7b3013b7a206155ddeb4811b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given SnapPea census manifold.  <a href="group__manifold.html#ga582d1b7b3013b7a206155ddeb4811b92">More...</a><br /></td></tr>
<tr class="separator:ga582d1b7b3013b7a206155ddeb4811b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b3fb9895db7ad9d59536a455984c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae0b3fb9895db7ad9d59536a455984c90">regina::SnapPeaCensusManifold::construct</a> () const override</td></tr>
<tr class="memdesc:gae0b3fb9895db7ad9d59536a455984c90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="group__manifold.html#gae0b3fb9895db7ad9d59536a455984c90">More...</a><br /></td></tr>
<tr class="separator:gae0b3fb9895db7ad9d59536a455984c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4705e87ed6b76a4fc6df9a38c600edd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga4705e87ed6b76a4fc6df9a38c600edd9">regina::SnapPeaCensusManifold::homology</a> () const override</td></tr>
<tr class="memdesc:ga4705e87ed6b76a4fc6df9a38c600edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#ga4705e87ed6b76a4fc6df9a38c600edd9">More...</a><br /></td></tr>
<tr class="separator:ga4705e87ed6b76a4fc6df9a38c600edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2355b687057f26d33082416b11cfd969"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2355b687057f26d33082416b11cfd969">regina::SnapPeaCensusManifold::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:ga2355b687057f26d33082416b11cfd969"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#ga2355b687057f26d33082416b11cfd969">More...</a><br /></td></tr>
<tr class="separator:ga2355b687057f26d33082416b11cfd969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81374205db85899342d817b61e7ba97c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga81374205db85899342d817b61e7ba97c">regina::SnapPeaCensusManifold::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga81374205db85899342d817b61e7ba97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#ga81374205db85899342d817b61e7ba97c">More...</a><br /></td></tr>
<tr class="separator:ga81374205db85899342d817b61e7ba97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7678c760733081ce68726950819bad"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8e7678c760733081ce68726950819bad">regina::SnapPeaCensusManifold::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga8e7678c760733081ce68726950819bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#ga8e7678c760733081ce68726950819bad">More...</a><br /></td></tr>
<tr class="separator:ga8e7678c760733081ce68726950819bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f72895eef2fe3db29cc75069d1fe92e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga6f72895eef2fe3db29cc75069d1fe92e">regina::SnapPeaCensusManifold::writeStructure</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga6f72895eef2fe3db29cc75069d1fe92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream.  <a href="group__manifold.html#ga6f72895eef2fe3db29cc75069d1fe92e">More...</a><br /></td></tr>
<tr class="separator:ga6f72895eef2fe3db29cc75069d1fe92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4422bf183660e7207a9363315c186b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gadf4422bf183660e7207a9363315c186b">regina::TorusBundle::TorusBundle</a> ()</td></tr>
<tr class="memdesc:gadf4422bf183660e7207a9363315c186b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial torus bundle over the circle.  <a href="group__manifold.html#gadf4422bf183660e7207a9363315c186b">More...</a><br /></td></tr>
<tr class="separator:gadf4422bf183660e7207a9363315c186b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fddffefd3e013319469f044b4e5a15c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9fddffefd3e013319469f044b4e5a15c">regina::TorusBundle::TorusBundle</a> (const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;newMonodromy)</td></tr>
<tr class="memdesc:ga9fddffefd3e013319469f044b4e5a15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new torus bundle over the circle using the given monodromy.  <a href="group__manifold.html#ga9fddffefd3e013319469f044b4e5a15c">More...</a><br /></td></tr>
<tr class="separator:ga9fddffefd3e013319469f044b4e5a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002e9a568313e13691cbb3e762fa0af2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga002e9a568313e13691cbb3e762fa0af2">regina::TorusBundle::TorusBundle</a> (long mon00, long mon01, long mon10, long mon11)</td></tr>
<tr class="memdesc:ga002e9a568313e13691cbb3e762fa0af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new torus bundle over the circle using the given monodromy.  <a href="group__manifold.html#ga002e9a568313e13691cbb3e762fa0af2">More...</a><br /></td></tr>
<tr class="separator:ga002e9a568313e13691cbb3e762fa0af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2ce9258d5e6dacdc15f1f773f3f362"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1a2ce9258d5e6dacdc15f1f773f3f362">regina::TorusBundle::TorusBundle</a> (const <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga1a2ce9258d5e6dacdc15f1f773f3f362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given torus bundle.  <a href="group__manifold.html#ga1a2ce9258d5e6dacdc15f1f773f3f362">More...</a><br /></td></tr>
<tr class="separator:ga1a2ce9258d5e6dacdc15f1f773f3f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8868c54bd08f80546e4778ba2957845"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae8868c54bd08f80546e4778ba2957845">regina::TorusBundle::monodromy</a> () const</td></tr>
<tr class="memdesc:gae8868c54bd08f80546e4778ba2957845"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the monodromy describing how the upper and lower torus boundaries are identified.  <a href="group__manifold.html#gae8868c54bd08f80546e4778ba2957845">More...</a><br /></td></tr>
<tr class="separator:gae8868c54bd08f80546e4778ba2957845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc437edaf8510f6144b7a7b961f078f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5dc437edaf8510f6144b7a7b961f078f">regina::TorusBundle::operator=</a> (const <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga5dc437edaf8510f6144b7a7b961f078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given torus bundle.  <a href="group__manifold.html#ga5dc437edaf8510f6144b7a7b961f078f">More...</a><br /></td></tr>
<tr class="separator:ga5dc437edaf8510f6144b7a7b961f078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2309d08110eee08f47782ac06573a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaf2309d08110eee08f47782ac06573a3c">regina::TorusBundle::homology</a> () const override</td></tr>
<tr class="memdesc:gaf2309d08110eee08f47782ac06573a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="group__manifold.html#gaf2309d08110eee08f47782ac06573a3c">More...</a><br /></td></tr>
<tr class="separator:gaf2309d08110eee08f47782ac06573a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ebe1d0ba62818e4d90a4cd55cd633c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2ebe1d0ba62818e4d90a4cd55cd633c">regina::TorusBundle::isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:gae2ebe1d0ba62818e4d90a4cd55cd633c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="group__manifold.html#gae2ebe1d0ba62818e4d90a4cd55cd633c">More...</a><br /></td></tr>
<tr class="separator:gae2ebe1d0ba62818e4d90a4cd55cd633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac184a5f21ecf986a59f3b963b343b02"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaac184a5f21ecf986a59f3b963b343b02">regina::TorusBundle::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaac184a5f21ecf986a59f3b963b343b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="group__manifold.html#gaac184a5f21ecf986a59f3b963b343b02">More...</a><br /></td></tr>
<tr class="separator:gaac184a5f21ecf986a59f3b963b343b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9758acb6b91326b9aaa10162f90e7a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae9758acb6b91326b9aaa10162f90e7a8">regina::TorusBundle::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gae9758acb6b91326b9aaa10162f90e7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="group__manifold.html#gae9758acb6b91326b9aaa10162f90e7a8">More...</a><br /></td></tr>
<tr class="separator:gae9758acb6b91326b9aaa10162f90e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae8a5c0cf36831268fb877ed7806f6d12"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae8a5c0cf36831268fb877ed7806f6d12">regina::SFSFibre::alpha</a></td></tr>
<tr class="memdesc:gae8a5c0cf36831268fb877ed7806f6d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first parameter of this (<em>alpha</em>, <em>beta</em>) fibre.  <a href="group__manifold.html#gae8a5c0cf36831268fb877ed7806f6d12">More...</a><br /></td></tr>
<tr class="separator:gae8a5c0cf36831268fb877ed7806f6d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f305e9c7282333f0f008162d56d447"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gad8f305e9c7282333f0f008162d56d447">regina::SFSFibre::beta</a></td></tr>
<tr class="memdesc:gad8f305e9c7282333f0f008162d56d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">The second parameter of this (<em>alpha</em>, <em>beta</em>) fibre.  <a href="group__manifold.html#gad8f305e9c7282333f0f008162d56d447">More...</a><br /></td></tr>
<tr class="separator:gad8f305e9c7282333f0f008162d56d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a880f8b91d709a4d280489ccc85f255"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9a880f8b91d709a4d280489ccc85f255">regina::SimpleSurfaceBundle::S2xS1</a></td></tr>
<tr class="memdesc:ga9a880f8b91d709a4d280489ccc85f255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the orientable 2-sphere bundle over the circle.  <a href="group__manifold.html#ga9a880f8b91d709a4d280489ccc85f255">More...</a><br /></td></tr>
<tr class="separator:ga9a880f8b91d709a4d280489ccc85f255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e1f2620c31263fc67d133b6266c68c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga77e1f2620c31263fc67d133b6266c68c">regina::SimpleSurfaceBundle::S2xS1_TWISTED</a></td></tr>
<tr class="memdesc:ga77e1f2620c31263fc67d133b6266c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the non-orientable twisted 2-sphere bundle over the circle.  <a href="group__manifold.html#ga77e1f2620c31263fc67d133b6266c68c">More...</a><br /></td></tr>
<tr class="separator:ga77e1f2620c31263fc67d133b6266c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcb8b384b20e437b262c2d864a32a4a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaebcb8b384b20e437b262c2d864a32a4a">regina::SimpleSurfaceBundle::RP2xS1</a></td></tr>
<tr class="memdesc:gaebcb8b384b20e437b262c2d864a32a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the projective plane bundle over the circle.  <a href="group__manifold.html#gaebcb8b384b20e437b262c2d864a32a4a">More...</a><br /></td></tr>
<tr class="separator:gaebcb8b384b20e437b262c2d864a32a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37bcfb6c1cec7dc4bb8199fb03d782f1"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga37bcfb6c1cec7dc4bb8199fb03d782f1">regina::SnapPeaCensusManifold::SEC_5</a></td></tr>
<tr class="memdesc:ga37bcfb6c1cec7dc4bb8199fb03d782f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of manifolds formed from five or fewer tetrahedra (both orientable and non-orientable).  <a href="group__manifold.html#ga37bcfb6c1cec7dc4bb8199fb03d782f1">More...</a><br /></td></tr>
<tr class="separator:ga37bcfb6c1cec7dc4bb8199fb03d782f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ea1a993d4098c8c2b813012c41b59d"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga79ea1a993d4098c8c2b813012c41b59d">regina::SnapPeaCensusManifold::SEC_6_OR</a></td></tr>
<tr class="memdesc:ga79ea1a993d4098c8c2b813012c41b59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of orientable manifolds formed from six tetrahedra.  <a href="group__manifold.html#ga79ea1a993d4098c8c2b813012c41b59d">More...</a><br /></td></tr>
<tr class="separator:ga79ea1a993d4098c8c2b813012c41b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a18ef0b5db749a6cf7c111135960644"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga8a18ef0b5db749a6cf7c111135960644">regina::SnapPeaCensusManifold::SEC_6_NOR</a></td></tr>
<tr class="memdesc:ga8a18ef0b5db749a6cf7c111135960644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of non-orientable manifolds formed from six tetrahedra.  <a href="group__manifold.html#ga8a18ef0b5db749a6cf7c111135960644">More...</a><br /></td></tr>
<tr class="separator:ga8a18ef0b5db749a6cf7c111135960644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ee140169d03c2ded606ab80e886d60"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga15ee140169d03c2ded606ab80e886d60">regina::SnapPeaCensusManifold::SEC_7_OR</a></td></tr>
<tr class="memdesc:ga15ee140169d03c2ded606ab80e886d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of orientable manifolds formed from seven tetrahedra.  <a href="group__manifold.html#ga15ee140169d03c2ded606ab80e886d60">More...</a><br /></td></tr>
<tr class="separator:ga15ee140169d03c2ded606ab80e886d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa971f8ef4bab8396c10873afced27edd"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa971f8ef4bab8396c10873afced27edd">regina::SnapPeaCensusManifold::SEC_7_NOR</a></td></tr>
<tr class="memdesc:gaa971f8ef4bab8396c10873afced27edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of non-orientable manifolds formed from seven tetrahedra.  <a href="group__manifold.html#gaa971f8ef4bab8396c10873afced27edd">More...</a><br /></td></tr>
<tr class="separator:gaa971f8ef4bab8396c10873afced27edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Standard 3-manifolds whose structures are well-understood. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaebdd53195f8261a28d8200257089fbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebdd53195f8261a28d8200257089fbdd">&#9670;&nbsp;</a></span>NGraphLoop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> <a class="el" href="group__manifold.html#gaebdd53195f8261a28d8200257089fbdd">regina::NGraphLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>The class NGraphLoop has now been renamed to <a class="el" href="classregina_1_1GraphLoop.html" title="Represents a closed graph manifold formed by joining a single bounded Seifert fibred space to itself ...">GraphLoop</a>. </dd></dl>

</div>
</div>
<a id="ga585c0ce4134749e0805a612d7c5b26b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585c0ce4134749e0805a612d7c5b26b6">&#9670;&nbsp;</a></span>NGraphPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> <a class="el" href="group__manifold.html#ga585c0ce4134749e0805a612d7c5b26b6">regina::NGraphPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>The class NGraphPair has now been renamed to <a class="el" href="classregina_1_1GraphPair.html" title="Represents a closed graph manifold formed by joining two bounded Seifert fibred spaces along a common...">GraphPair</a>. </dd></dl>

</div>
</div>
<a id="ga7fca6e66d7fce09063dae68b9f7db34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fca6e66d7fce09063dae68b9f7db34d">&#9670;&nbsp;</a></span>NGraphTriple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> <a class="el" href="group__manifold.html#ga7fca6e66d7fce09063dae68b9f7db34d">regina::NGraphTriple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>The class NGraphTriple has now been renamed to <a class="el" href="classregina_1_1GraphTriple.html" title="Represents a closed graph manifold formed by joining three bounded Seifert fibred spaces along their ...">GraphTriple</a>. </dd></dl>

</div>
</div>
<a id="gaae5f18aa593cb68c181eb6fce8b9b37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae5f18aa593cb68c181eb6fce8b9b37e">&#9670;&nbsp;</a></span>NHandlebody</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> <a class="el" href="group__manifold.html#gaae5f18aa593cb68c181eb6fce8b9b37e">regina::NHandlebody</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>The class NHandlebody has now been renamed to <a class="el" href="classregina_1_1Handlebody.html" title="Represents an arbitrary handlebody.">Handlebody</a>. </dd></dl>

</div>
</div>
<a id="gaaaa881e2c36ff2724f45cf776104857e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaa881e2c36ff2724f45cf776104857e">&#9670;&nbsp;</a></span>NLensSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> <a class="el" href="group__manifold.html#gaaaa881e2c36ff2724f45cf776104857e">regina::NLensSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>The class NLensSpace has now been renamed to <a class="el" href="classregina_1_1LensSpace.html" title="Represents a general lens space.">LensSpace</a>. </dd></dl>

</div>
</div>
<a id="ga69f753e87935bc5112777ebb9ebfef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f753e87935bc5112777ebb9ebfef1f">&#9670;&nbsp;</a></span>NManifold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Manifold.html">Manifold</a> <a class="el" href="group__manifold.html#ga69f753e87935bc5112777ebb9ebfef1f">regina::NManifold</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>The class NManifold has now been renamed to <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. </dd></dl>

</div>
</div>
<a id="ga7f2c0068ef2348a68b3df68843e47cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2c0068ef2348a68b3df68843e47cb7">&#9670;&nbsp;</a></span>NSFSAltSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SFSAltSet.html">SFSAltSet</a> <a class="el" href="group__manifold.html#ga7f2c0068ef2348a68b3df68843e47cb7">regina::NSFSAltSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>The class NSFSAltSet has now been renamed to <a class="el" href="classregina_1_1SFSAltSet.html" title="Provides a variety of alternative representations of a single bounded Seifert fibred space.">SFSAltSet</a>. </dd></dl>

</div>
</div>
<a id="ga1b98a69c042ce12888797b6bc17ff22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b98a69c042ce12888797b6bc17ff22f">&#9670;&nbsp;</a></span>NSFSFibre</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> <a class="el" href="group__manifold.html#ga1b98a69c042ce12888797b6bc17ff22f">regina::NSFSFibre</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>The class NSFSFibre has now been renamed to <a class="el" href="structregina_1_1SFSFibre.html" title="Represents an exceptional (alpha, beta) fibre in a Seifert fibred space.">SFSFibre</a>. </dd></dl>

</div>
</div>
<a id="gab0207b91f4bca65c14ff420791ff40c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0207b91f4bca65c14ff420791ff40c2">&#9670;&nbsp;</a></span>NSFSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> <a class="el" href="group__manifold.html#gab0207b91f4bca65c14ff420791ff40c2">regina::NSFSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>The class NSFSpace has now been renamed to <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a>. </dd></dl>

</div>
</div>
<a id="ga1f68997f1b535c0b080bdb23652abc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f68997f1b535c0b080bdb23652abc8a">&#9670;&nbsp;</a></span>NSimpleSurfaceBundle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> <a class="el" href="group__manifold.html#ga1f68997f1b535c0b080bdb23652abc8a">regina::NSimpleSurfaceBundle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>The class NSimpleSurfaceBundle has now been renamed to <a class="el" href="classregina_1_1SimpleSurfaceBundle.html" title="Represents a particularly simple closed surface bundle over the circle.">SimpleSurfaceBundle</a>. </dd></dl>

</div>
</div>
<a id="ga5b1ce21335cbe7256aa7125376cd5793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1ce21335cbe7256aa7125376cd5793">&#9670;&nbsp;</a></span>NSnapPeaCensusManifold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> <a class="el" href="group__manifold.html#ga5b1ce21335cbe7256aa7125376cd5793">regina::NSnapPeaCensusManifold</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>The class NSnapPeaCensusManifold has now been renamed to <a class="el" href="classregina_1_1SnapPeaCensusManifold.html" title="Represents a 3-manifold from the SnapPea cusped census.">SnapPeaCensusManifold</a>. </dd></dl>

</div>
</div>
<a id="ga7ce6fe5b1c49d9fc4af6285825fc093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ce6fe5b1c49d9fc4af6285825fc093b">&#9670;&nbsp;</a></span>NTorusBundle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> <a class="el" href="group__manifold.html#ga7ce6fe5b1c49d9fc4af6285825fc093b">regina::NTorusBundle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>The class NTorusBundle has now been renamed to <a class="el" href="classregina_1_1TorusBundle.html" title="Represents a torus bundle over the circle.">TorusBundle</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga8ca6dbe82be7c2f77c480e5ad720f451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca6dbe82be7c2f77c480e5ad720f451">&#9670;&nbsp;</a></span>classType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">regina::SFSpace::classType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451aee6551a605ca5c2257265ae389a8ad49"></a>o1&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a5d35a6be3a142c543fec1e3e53d362a6"></a>o2&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a20296b965f715f5c8d705ba59e39c408"></a>n1&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a2ff57c6837334c6b20769ca49b0db5c1"></a>n2&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451aac79eded7f2f568c7f1f8bc461c99c40"></a>n3&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least two, and that precisely one of its generators gives a fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a0407c4c93466e1b07016a53b14674384"></a>n4&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least three, and that precisely two of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a1654d3e2dace8737bec604781355ecfc"></a>bo1&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a663bb34f4339e3041e80cfb67be260e1"></a>bo2&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains at least one fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a58c4517e4b1116a250580b8d72c1acd0"></a>bn1&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a5f6b58c0ede57bcfdaced07f2e9415e4"></a>bn2&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that its fibre-reversing paths correspond precisely to its orientation-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8ca6dbe82be7c2f77c480e5ad720f451a4e6ff4256bd817e0cf2f0bb0c61a97e9"></a>bn3&#160;</td><td class="fielddoc"><p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, that it contains at least one fibre-reversing path, and that its fibre-reversing paths do not correspond precisely to its orientation-reversing paths. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9dd42f80225f7c7e0c2af0933baeb338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd42f80225f7c7e0c2af0933baeb338">&#9670;&nbsp;</a></span>addCrosscap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addCrosscap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new crosscap into the base orbifold. </p>
<p>This makes the base orbifold non-orientable, and increases its non-orientable genus by one. It is equivalent to removing a disc from the base orbifold and replacing it with a Mobius band.</p>
<p>Note that this operation may alter which of the classes described by classType this space belongs to.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if the generator of the new crosscap should give a fibre-reversing curve in the overall 3-manifold, or <code>false</code> (the default) if it should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb6811f7faaddfc8024244ad326a8b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb6811f7faaddfc8024244ad326a8b2f">&#9670;&nbsp;</a></span>addHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addHandle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new handle into the base orbifold. </p>
<p>This increases the orientable genus of the base orbifold by one, or the non-orientable genus by two. It is equivalent to removing a disc from the base orbifold and replacing it with a punctured torus.</p>
<p>Note that this operation may alter which of the classes described by classType this space belongs to.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if one or both generators of the new handle should give fibre-reversing curves in the overall 3-manifold, or <code>false</code> (the default) if both generators should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77b831e36639d0182ce5fc4f89b9a218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b831e36639d0182ce5fc4f89b9a218">&#9670;&nbsp;</a></span>addPuncture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addPuncture </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nPunctures</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts one or more new punctures into the base orbifold. </p>
<p>The punctures may be twisted or untwisted.</p>
<p>Each puncture insertion is equivalent to removing a disc from the base orbifold. In the untwisted case this results in a new torus boundary for the 3-manifold, and in the twisted case it results in a new Klein bottle boundary.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new punctures should be twisted (i.e., their boundaries should be fibre-reversing), or <code>false</code> if the new punctures should be untwisted. </td></tr>
    <tr><td class="paramname">nPunctures</td><td>the number of new punctures to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaffaef6a5a9f7187c315817b222e6cf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffaef6a5a9f7187c315817b222e6cf28">&#9670;&nbsp;</a></span>addReflector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addReflector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nReflectors</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one or more new reflector boundary components to the base orbifold. </p>
<p>The new reflector boundaries may be twisted or untwisted.</p>
<p>Each addition of a reflector boundary component is equivalent to removing a disc from the base orbifold and replacing it with an annulus with one reflector boundary.</p>
<p>In the untwisted case, it has the effect of removing a trivially fibred solid torus from the overall 3-manifold and replacing it with an appropriately fibred twisted I-bundle over the torus.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new reflector boundaries should be twisted (i.e., the boundaries should be fibre-reversing), or <code>false</code> if the new reflector boundaries should be untwisted. </td></tr>
    <tr><td class="paramname">nReflectors</td><td>the number of new reflector boundaries to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7471230bf920402efaefca3a0fe98414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7471230bf920402efaefca3a0fe98414">&#9670;&nbsp;</a></span>baseClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">SFSpace::classType</a> regina::SFSpace::baseClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which of the eleven predefined classes this space belongs to. </p>
<p>The specific class indicates whether the base orbifold has punctures and/or reflector boundaries, whether the base orbifold is orientable, and gives information on fibre-reversing paths.</p>
<p>The class can be (indirectly) modified by calling <a class="el" href="group__manifold.html#gadb6811f7faaddfc8024244ad326a8b2f" title="Inserts a new handle into the base orbifold.">addHandle()</a>, <a class="el" href="group__manifold.html#ga9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>, <a class="el" href="group__manifold.html#ga77b831e36639d0182ce5fc4f89b9a218" title="Inserts one or more new punctures into the base orbifold.">addPuncture()</a> or <a class="el" href="group__manifold.html#gaffaef6a5a9f7187c315817b222e6cf28" title="Adds one or more new reflector boundary components to the base orbifold.">addReflector()</a>.</p>
<p>For more information on the eleven predefined classes, see the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes or the classType enumeration notes.</p>
<dl class="section return"><dt>Returns</dt><dd>the particular class to which this space belongs. </dd></dl>

</div>
</div>
<a id="gaa610d605949c98b6360a87227d0da1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa610d605949c98b6360a87227d0da1a2">&#9670;&nbsp;</a></span>baseGenus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::baseGenus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the genus of the base orbifold. </p>
<p>All punctures and reflector boundaries in the base orbifold are ignored (i.e., they are treated as though they had been replaced with ordinary filled discs).</p>
<p>The genus is the number of tori or projective planes that the base surface is formed from. In particular, if the base surface is non-orientable then this is the non-orientable genus.</p>
<dl class="section return"><dt>Returns</dt><dd>the genus of the base orbifold. </dd></dl>

</div>
</div>
<a id="ga873210dabde6c5a56e2dfa284e6707ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873210dabde6c5a56e2dfa284e6707ae">&#9670;&nbsp;</a></span>baseOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::baseOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not the base surface is orientable. </p>
<p>Reflector boundary components of the base orbifold are not considered here.</p>
<p>The orientability of the base surface can be (indirectly) modified by calling <a class="el" href="group__manifold.html#ga9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the base surface is orientable. </dd></dl>

</div>
</div>
<a id="gaca0efe81003208ff320439ca754175ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0efe81003208ff320439ca754175ad">&#9670;&nbsp;</a></span>centre()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::GraphTriple::centre </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the central space. </p>
<p>This is the Seifert fibred space with two boundary components, to which the two end spaces are joined. See the class notes for further discussion.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested Seifert fibred space. </dd></dl>

</div>
</div>
<a id="ga699dd395b4b242cd4d6157b705f65123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699dd395b4b242cd4d6157b705f65123">&#9670;&nbsp;</a></span>complementAllFibres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::complementAllFibres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>). </p>
<p>The obstruction constant <em>b</em> is not touched. </p>

</div>
</div>
<a id="gafdf5c09da349003645cdb3a56269b5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdf5c09da349003645cdb3a56269b5e5">&#9670;&nbsp;</a></span>construct() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * regina::Manifold::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented in <a class="el" href="group__manifold.html#gae0b3fb9895db7ad9d59536a455984c90">regina::SnapPeaCensusManifold</a>, <a class="el" href="group__manifold.html#gac5a2fa2c2b7182aaa63bbe101ba8f06b">regina::SimpleSurfaceBundle</a>, <a class="el" href="group__manifold.html#ga2c754bbd2ccef34de4a81d4a40ba736c">regina::SFSpace</a>, and <a class="el" href="group__manifold.html#ga746a936e5ed9ecfd0a7dd010aea0a8a7">regina::LensSpace</a>.</p>

</div>
</div>
<a id="ga746a936e5ed9ecfd0a7dd010aea0a8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga746a936e5ed9ecfd0a7dd010aea0a8a7">&#9670;&nbsp;</a></span>construct() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::LensSpace::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga2c754bbd2ccef34de4a81d4a40ba736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c754bbd2ccef34de4a81d4a40ba736c">&#9670;&nbsp;</a></span>construct() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::SFSpace::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">regina::Manifold</a>.</p>

</div>
</div>
<a id="gac5a2fa2c2b7182aaa63bbe101ba8f06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a2fa2c2b7182aaa63bbe101ba8f06b">&#9670;&nbsp;</a></span>construct() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::SimpleSurfaceBundle::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">regina::Manifold</a>.</p>

</div>
</div>
<a id="gae0b3fb9895db7ad9d59536a455984c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b3fb9895db7ad9d59536a455984c90">&#9670;&nbsp;</a></span>construct() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::SnapPeaCensusManifold::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gafdf5c09da349003645cdb3a56269b5e5">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga169540a1535da6422acd8b73e5bbc4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169540a1535da6422acd8b73e5bbc4f1">&#9670;&nbsp;</a></span>conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::SFSAltSet::conversion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the conversion matrix for the requested alternative space. </p>
<p>This matrix describes the fibre and base curves of the alternative space on the first boundary torus in terms of the fibre and base curves of the original space (which was passed to the <a class="el" href="classregina_1_1SFSAltSet.html" title="Provides a variety of alternative representations of a single bounded Seifert fibred space.">SFSAltSet</a> constructor). See the class notes above for details.</p>
<p>Note that this conversion matrix applies <em>only</em> to the first boundary torus! If there is more than one boundary, the remaining boundary conversions are simpler and depend only on whether a reflection has been used or not. See <a class="el" href="group__manifold.html#gab02c3ca656eba9eff9b8df5144b6aa31" title="Returns whether or not a reflection was used when creating the requested alternative space.">reflected()</a> or the class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the alternatives we should return the conversion matrix for; this must be between 0 and <a class="el" href="group__manifold.html#ga29657c6df170a281b70b597c9d10901f" title="Returns the number of alternative spaces in this set.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conversion matrix for the requested alternative space. </dd></dl>

</div>
</div>
<a id="ga8173fe85801cd759182b610a7c7ad545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8173fe85801cd759182b610a7c7ad545">&#9670;&nbsp;</a></span>deleteAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSAltSet::deleteAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys all of the alternative representations in this set. </p>
<p>This routine is for situations where none of the alternatives here are appropriate for keeping and using elsewhere. </p>

</div>
</div>
<a id="ga8e40a61b6f6b403cd1fa594ddb407ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e40a61b6f6b403cd1fa594ddb407ca1">&#9670;&nbsp;</a></span>deleteAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSAltSet::deleteAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>exception</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys all of the alternative representations in this set, except for the given exception. </p>
<p>If the given exception is null or is not one of the alternatives in this set, every alternative will be destroyed.</p>
<p>This routine is for situations where one of the alternatives has been kept for later use, and the rest are to be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exception</td><td>the one alternative that should not be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3fb3e8cef4af73bdaccb4541218562d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb3e8cef4af73bdaccb4541218562d1">&#9670;&nbsp;</a></span>deleteAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSAltSet::deleteAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>exception1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>exception2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys all of the alternative representations in this set, except for the two given exceptions. </p>
<p>If either exception is null or is not one of the alternatives in this set, it will be ignored (and this routine will behave like the one-exception or no-exceptions variant). Likewise, if both exceptions are the same then this routine will behave like the one-exception variant.</p>
<p>This routine is for situations where one of the alternatives has been kept for later use, but due to other operations that may have taken place (such as space swapping) it is only known that the alternative we kept is one of two possibilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exception1</td><td>the first alternative that should not be destroyed. </td></tr>
    <tr><td class="paramname">exception2</td><td>the second alternative that should not be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4168bf67476715a1ab6afd8243daa7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4168bf67476715a1ab6afd8243daa7bb">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::GraphTriple::end </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two end spaces. </p>
<p>These are the Seifert fibred spaces with just one boundary component, to be joined to the central space. See the class notes for further discussion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>0 if the first end space is to be returned, or 1 if the second end space is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested Seifert fibred space. </dd></dl>

</div>
</div>
<a id="ga4b92f5e9498ac3393481893c104bd6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b92f5e9498ac3393481893c104bd6a0">&#9670;&nbsp;</a></span>fibre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> regina::SFSpace::fibre </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested exceptional fibre. </p>
<p>Fibres are stored in sorted order by <em>alpha</em> (the index) and then by <em>beta</em>. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine takes linear time (specifically, linear in the argument <em>which</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>determines which fibre to return; this must be between 0 and getFibreCount()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested fibre. </dd></dl>

</div>
</div>
<a id="gacd0fbc352bf9f9f680dc4622760099c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd0fbc352bf9f9f680dc4622760099c5">&#9670;&nbsp;</a></span>fibreCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::fibreCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of exceptional fibres in this Seifert fibred space. </p>
<p>Note that the obstruction parameter <em>b</em> is not included in this count. That is, any (1,k) fibres are ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of exceptional fibres. </dd></dl>

</div>
</div>
<a id="gaa5b9d08bdd55767057aa12d5a21fa0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b9d08bdd55767057aa12d5a21fa0eb">&#9670;&nbsp;</a></span>fibreNegating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreNegating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold. </p>
<p>That is, this routine determines whether a (<em>p</em>, <em>q</em>) exceptional fibre can become a (<em>p</em>, -<em>q</em>) exceptional fibre simply by sliding it around.</p>
<p>This is possible if either</p><ul>
<li>the base orbifold has an orientation-reversing loop that does not reverse fibres in the 3-manifold, or</li>
<li>the base orbifold has an orientation-preserving loop that does reverse fibres in the 3-manifold.</li>
</ul>
<p>Note that reflector boundary components, whilst making the overall 3-manifold non-orientable, have no bearing on the outcome of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only an exceptional fibre can be reflected as described above. </dd></dl>

</div>
</div>
<a id="gabc882d6795358f5e96eaa0c423fb4b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc882d6795358f5e96eaa0c423fb4b1d">&#9670;&nbsp;</a></span>fibreReversing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreReversing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this space contains any fibre-reversing paths. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a fibre-reversing path exists. </dd></dl>

</div>
</div>
<a id="gabb095f13105585b47c71b3ece40670d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb095f13105585b47c71b3ece40670d8">&#9670;&nbsp;</a></span>GraphLoop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphLoop::GraphLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f33adcf59334df44d14fbc6297ba28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f33adcf59334df44d14fbc6297ba28a">&#9670;&nbsp;</a></span>GraphLoop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphLoop::GraphLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>matchingReln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new graph manifold as a self-identified Seifert fibred space. </p>
<p>The bounded Seifert fibred space and the entire 2-by-2 matching matrix are each passed separately.</p>
<p>Note that the new object will take ownership of the given Seifert fibred space, and when this object is destroyed the Seifert fibred space will be destroyed also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has precisely two torus boundaries, corresponding to two punctures in the base orbifold. </dd>
<dd>
The given matching matrix has determinant +1 or -1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this constructor clones its <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> argument instead of claiming ownership of it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the bounded Seifert fibred space. </td></tr>
    <tr><td class="paramname">matchingReln</td><td>the 2-by-2 matching matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14f7cd99e9f71b5c810b974ff65b8ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f7cd99e9f71b5c810b974ff65b8ee6">&#9670;&nbsp;</a></span>GraphLoop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphLoop::GraphLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new graph manifold as a self-identified Seifert fibred space. </p>
<p>The bounded Seifert fibred space and the four elements of the 2-by-2 matching matrix are all passed separately. The elements of the matching matrix combine to give the full matrix <em>M</em> as follows:</p>
<pre>
          [ mat00  mat01 ]
    M  =  [              ]
          [ mat10  mat11 ]
</pre><p>Note that the new object will take ownership of the given Seifert fibred space, and when this object is destroyed the Seifert fibred space will be destroyed also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has precisely two torus boundaries, corresponding to two untwisted punctures in the base orbifold. </dd>
<dd>
The given matching matrix has determinant +1 or -1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this constructor clones its <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> argument instead of claiming ownership of it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the bounded Seifert fibred space. </td></tr>
    <tr><td class="paramname">mat00</td><td>the (0,0) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat01</td><td>the (0,1) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat10</td><td>the (1,0) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat11</td><td>the (1,1) element of the matching matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8713f55e59871014f5b0ce124627269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8713f55e59871014f5b0ce124627269">&#9670;&nbsp;</a></span>GraphPair() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphPair::GraphPair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc43762e112555b00c923cebb43ba095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc43762e112555b00c923cebb43ba095">&#9670;&nbsp;</a></span>GraphPair() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphPair::GraphPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>matchingReln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new graph manifold as a pair of joined Seifert fibred spaces. </p>
<p>The two bounded Seifert fibred spaces and the entire 2-by-2 matching matrix are each passed separately.</p>
<p>Note that the new object will take ownership of the two given Seifert fibred spaces, and when this object is destroyed the Seifert fibred spaces will be destroyed also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each Seifert fibred space has a single torus boundary, corresponding to a single untwisted puncture in the base orbifold. </dd>
<dd>
The given matching matrix has determinant +1 or -1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this constructor clones its <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> arguments instead of claiming ownership of them.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs0</td><td>the first Seifert fibred space. </td></tr>
    <tr><td class="paramname">sfs1</td><td>the second Seifert fibred space. </td></tr>
    <tr><td class="paramname">matchingReln</td><td>the 2-by-2 matching matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73f1e11df434f0ae22f2cbb46105e59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73f1e11df434f0ae22f2cbb46105e59a">&#9670;&nbsp;</a></span>GraphPair() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphPair::GraphPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mat11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new graph manifold as a pair of joined Seifert fibred spaces. </p>
<p>The two bounded Seifert fibred spaces and the four elements of the 2-by-2 matching matrix are all passed separately. The elements of the matching matrix combine to give the full matrix <em>M</em> as follows:</p>
<pre>
          [ mat00  mat01 ]
    M  =  [              ]
          [ mat10  mat11 ]
</pre><p>Note that the new object will take ownership of the two given Seifert fibred spaces, and when this object is destroyed the Seifert fibred spaces will be destroyed also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each Seifert fibred space has a single torus boundary, corresponding to a single untwisted puncture in the base orbifold. </dd>
<dd>
The given matching matrix has determinant +1 or -1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this constructor clones its <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> arguments instead of claiming ownership of them.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs0</td><td>the first Seifert fibred space. </td></tr>
    <tr><td class="paramname">sfs1</td><td>the second Seifert fibred space. </td></tr>
    <tr><td class="paramname">mat00</td><td>the (0,0) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat01</td><td>the (0,1) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat10</td><td>the (1,0) element of the matching matrix. </td></tr>
    <tr><td class="paramname">mat11</td><td>the (1,1) element of the matching matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac40ca21a6da490c22e7de7bf2d598335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac40ca21a6da490c22e7de7bf2d598335">&#9670;&nbsp;</a></span>GraphTriple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphTriple::GraphTriple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd42f80ad0422322e0c7c37b8e14ad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd42f80ad0422322e0c7c37b8e14ad8e">&#9670;&nbsp;</a></span>GraphTriple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphTriple::GraphTriple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>matchingReln0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>matchingReln1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new graph manifold from three bounded Seifert fibred spaces, as described in the class notes. </p>
<p>The three Seifert fibred spaces and both 2-by-2 matching matrices are passed separately.</p>
<p>Note that the new object will take ownership of the three given Seifert fibred spaces, and when this object is destroyed the Seifert fibred spaces will be destroyed also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Spaces <em>end0</em> and <em>end1</em> each have a single torus boundary, corresponding to a single untwisted puncture in the base orbifold. </dd>
<dd>
Space <em>centre</em> has two disjoint torus boundaries, corresponding to two untwisted punctures in the base orbifold. </dd>
<dd>
Each of the given matrices has determinant +1 or -1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this constructor clones its <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> arguments instead of claiming ownership of them.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end0</td><td>the first end space, as described in the class notes. </td></tr>
    <tr><td class="paramname">centre</td><td>the central space, as described in the class notes. </td></tr>
    <tr><td class="paramname">end1</td><td>the second end space, as described in the class notes. </td></tr>
    <tr><td class="paramname">matchingReln0</td><td>the 2-by-2 matching matrix that specifies how spaces <em>end0</em> and <em>centre</em> are joined. </td></tr>
    <tr><td class="paramname">matchingReln1</td><td>the 2-by-2 matching matrix that specifies how spaces <em>end1</em> and <em>centre</em> are joined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabae983510285a935c0cc7a09656f2999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae983510285a935c0cc7a09656f2999">&#9670;&nbsp;</a></span>Handlebody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Handlebody::Handlebody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given handlebody. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the handlebody to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb52ed0ee3ae805ef92a9ae7d33d3eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb52ed0ee3ae805ef92a9ae7d33d3eaf">&#9670;&nbsp;</a></span>Handlebody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Handlebody::Handlebody </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newOrientable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new handlebody with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newHandles</td><td>the number of handles of the handlebody. </td></tr>
    <tr><td class="paramname">newOrientable</td><td><code>true</code> if the handlebody is to be orientable or <code>false</code> if the handlebody is to be non-orientable. This must be <code>true</code> if the handlebody has no handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06e6b0e7e51f9c125db07dfcce1f59fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e6b0e7e51f9c125db07dfcce1f59fa">&#9670;&nbsp;</a></span>handles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::Handlebody::handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of handles of this handlebody. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of handles. </dd></dl>

</div>
</div>
<a id="gacbdccc08b4a2712cda3d3bc6e40ae332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbdccc08b4a2712cda3d3bc6e40ae332">&#9670;&nbsp;</a></span>homology() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::Manifold::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented in <a class="el" href="group__manifold.html#gaf2309d08110eee08f47782ac06573a3c">regina::TorusBundle</a>, <a class="el" href="group__manifold.html#ga4705e87ed6b76a4fc6df9a38c600edd9">regina::SnapPeaCensusManifold</a>, <a class="el" href="group__manifold.html#ga19e4a959f13960bdf85f9a6d4b42ddb7">regina::SimpleSurfaceBundle</a>, <a class="el" href="group__manifold.html#ga294c7e7950ca931fc1f47ec332e8ba14">regina::SFSpace</a>, <a class="el" href="group__manifold.html#gaa3d753a813cfd8df5ab1fe452c106d31">regina::LensSpace</a>, <a class="el" href="group__manifold.html#gac62e2794186d5f7a24b46b65c41a2027">regina::Handlebody</a>, <a class="el" href="group__manifold.html#gaf0b42474168352e1fc002fce8530a891">regina::GraphTriple</a>, <a class="el" href="group__manifold.html#ga41176e9d795f3509e2ae0d7231306c01">regina::GraphPair</a>, and <a class="el" href="group__manifold.html#gabac9c50de5e107583c3931089c59c50e">regina::GraphLoop</a>.</p>

</div>
</div>
<a id="gabac9c50de5e107583c3931089c59c50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac9c50de5e107583c3931089c59c50e">&#9670;&nbsp;</a></span>homology() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::GraphLoop::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga41176e9d795f3509e2ae0d7231306c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41176e9d795f3509e2ae0d7231306c01">&#9670;&nbsp;</a></span>homology() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::GraphPair::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaf0b42474168352e1fc002fce8530a891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0b42474168352e1fc002fce8530a891">&#9670;&nbsp;</a></span>homology() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::GraphTriple::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="gac62e2794186d5f7a24b46b65c41a2027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac62e2794186d5f7a24b46b65c41a2027">&#9670;&nbsp;</a></span>homology() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::Handlebody::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaa3d753a813cfd8df5ab1fe452c106d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d753a813cfd8df5ab1fe452c106d31">&#9670;&nbsp;</a></span>homology() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LensSpace::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga294c7e7950ca931fc1f47ec332e8ba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga294c7e7950ca931fc1f47ec332e8ba14">&#9670;&nbsp;</a></span>homology() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SFSpace::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga19e4a959f13960bdf85f9a6d4b42ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e4a959f13960bdf85f9a6d4b42ddb7">&#9670;&nbsp;</a></span>homology() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SimpleSurfaceBundle::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga4705e87ed6b76a4fc6df9a38c600edd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4705e87ed6b76a4fc6df9a38c600edd9">&#9670;&nbsp;</a></span>homology() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SnapPeaCensusManifold::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaf2309d08110eee08f47782ac06573a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2309d08110eee08f47782ac06573a3c">&#9670;&nbsp;</a></span>homology() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::TorusBundle::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gaf4b5892a97591c988772705b6c06eb56" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaf4b5892a97591c988772705b6c06eb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b5892a97591c988772705b6c06eb56">&#9670;&nbsp;</a></span>homologyH1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::Manifold::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__manifold.html#gacbdccc08b4a2712cda3d3bc6e40ae332" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> (a name that is less specific, but a little easier to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

</div>
</div>
<a id="ga0072dce133fd4614312c5e7ddac874f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0072dce133fd4614312c5e7ddac874f3">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SnapPeaCensusManifold::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this manifold within its particular section of the SnapPea census. </p>
<p>Note that indices for each section begin counting at zero.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of this manifold within its section. </dd></dl>

</div>
</div>
<a id="ga9cabfe8efaeb3c370e74abf2f50a09be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cabfe8efaeb3c370e74abf2f50a09be">&#9670;&nbsp;</a></span>insertFibre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>fibre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p>This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p>Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 &lt;= <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibre</td><td>the fibre to insert. The first parameter of this fibre (i.e., its index) must be strictly positive, and the two parameters of this fibre must be coprime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35622fc87c75f221bff99ce9ad5db238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35622fc87c75f221bff99ce9ad5db238">&#9670;&nbsp;</a></span>insertFibre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p>This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p>Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 &lt;= <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the first parameter (i.e., the index) of the fibre to insert; this must be strictly positive. </td></tr>
    <tr><td class="paramname">beta</td><td>the second parameter of the fibre to insert; this must have no common factors with the first parameter <em>alpha</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ae723ffbf9ca421caeac7e990765f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae723ffbf9ca421caeac7e990765f5a">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::Manifold::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implemented in <a class="el" href="group__manifold.html#gae2ebe1d0ba62818e4d90a4cd55cd633c">regina::TorusBundle</a>, <a class="el" href="group__manifold.html#ga2355b687057f26d33082416b11cfd969">regina::SnapPeaCensusManifold</a>, <a class="el" href="group__manifold.html#gad17b2bca957301c96a841c12b8a2f9d4">regina::SimpleSurfaceBundle</a>, <a class="el" href="group__manifold.html#ga8ef1686791fb43a8e4d0b5221c53fd31">regina::SFSpace</a>, <a class="el" href="group__manifold.html#gae07f4f53d4e3568b421e8e46367027d4">regina::LensSpace</a>, <a class="el" href="group__manifold.html#ga3cc84e4c18db41d1255d1f8ff6d42a0d">regina::Handlebody</a>, <a class="el" href="group__manifold.html#ga304e24a12efdb840e7bd26f7604e81f1">regina::GraphTriple</a>, <a class="el" href="group__manifold.html#gaa4581dbcd22a69f23af278dbf7739f25">regina::GraphPair</a>, and <a class="el" href="group__manifold.html#gaf53165d7073b27117b6d0ad838a33fd4">regina::GraphLoop</a>.</p>

</div>
</div>
<a id="gaf53165d7073b27117b6d0ad838a33fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53165d7073b27117b6d0ad838a33fd4">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphLoop::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaa4581dbcd22a69f23af278dbf7739f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4581dbcd22a69f23af278dbf7739f25">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphPair::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga304e24a12efdb840e7bd26f7604e81f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga304e24a12efdb840e7bd26f7604e81f1">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphTriple::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga3cc84e4c18db41d1255d1f8ff6d42a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc84e4c18db41d1255d1f8ff6d42a0d">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Handlebody::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="gae07f4f53d4e3568b421e8e46367027d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07f4f53d4e3568b421e8e46367027d4">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LensSpace::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga8ef1686791fb43a8e4d0b5221c53fd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef1686791fb43a8e4d0b5221c53fd31">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="gad17b2bca957301c96a841c12b8a2f9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad17b2bca957301c96a841c12b8a2f9d4">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SimpleSurfaceBundle::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga2355b687057f26d33082416b11cfd969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2355b687057f26d33082416b11cfd969">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaCensusManifold::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="gae2ebe1d0ba62818e4d90a4cd55cd633c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ebe1d0ba62818e4d90a4cd55cd633c">&#9670;&nbsp;</a></span>isHyperbolic() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TorusBundle::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga92afcccfae0702575898998bc6cd918b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92afcccfae0702575898998bc6cd918b">&#9670;&nbsp;</a></span>isLensSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a>* regina::SFSpace::isLensSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this Seifert fibred space is a Lens space. </p>
<p>If this is a Lens space, the <a class="el" href="classregina_1_1LensSpace.html" title="Represents a general lens space.">LensSpace</a> returned will be newly created and it will be up to the caller of this routine to destroy it.</p>
<dl class="section return"><dt>Returns</dt><dd>a structure containing the details of this Lens space, or <code>null</code> if this is not a Lens space. </dd></dl>

</div>
</div>
<a id="ga2df7c224bb77dcd138168933a9dd5d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df7c224bb77dcd138168933a9dd5d80">&#9670;&nbsp;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Handlebody::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this handlebody is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this handlebody is orientable, or <code>false</code> if this handlebody is non-orientable. </dd></dl>

</div>
</div>
<a id="ga2b4ba47c715267c049ba0d89f2aa47a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4ba47c715267c049ba0d89f2aa47a0">&#9670;&nbsp;</a></span>LensSpace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LensSpace::LensSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given lens space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the lens space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e8629f2603226ac93f0bd2dc2ab4e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e8629f2603226ac93f0bd2dc2ab4e01">&#9670;&nbsp;</a></span>LensSpace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LensSpace::LensSpace </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new lens space with the given parameters. </p>
<p>See the class notes for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given parameters are coprime (have a gcd of 1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newP</td><td>the first parameter <em>p</em> of the lens space L(p,q). </td></tr>
    <tr><td class="paramname">newQ</td><td>the second parameter <em>q</em> of the lens space L(p,q). Note that there are no range restrictions whatsoever on this parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2607f6946aac50ea7dbbc3a15b36b539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2607f6946aac50ea7dbbc3a15b36b539">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::GraphLoop::matchingReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two boundary tori of the Seifert fibred space are joined together. </p>
<p>See the class notes for details on precisely how this matrix is represented.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the matching matrix. </dd></dl>

</div>
</div>
<a id="ga2536896983d3901423486e38ec34c11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2536896983d3901423486e38ec34c11f">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::GraphPair::matchingReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two Seifert fibred spaces are joined together. </p>
<p>See the class notes for details on precisely how this matrix is represented.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the matching matrix. </dd></dl>

</div>
</div>
<a id="gafeb6f89ae0521582c9e7aaab3376ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb6f89ae0521582c9e7aaab3376ae80">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::GraphTriple::matchingReln </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the 2-by-2 matrix describing how the two requested bounded Seifert fibred spaces are joined together. </p>
<p>See the class notes for details on precisely how these matrices are represented.</p>
<p>The argument <em>which</em> indicates which particular join should be examined. A value of 0 denotes the join between the central space and the first end space (corresponding to matrix <em>M</em> in the class notes), whereas a value of 1 denotes the join between the central space and the second end space (corresponding to matrix <em>M'</em> in the class notes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which particular join should be examined; this should be 0 or 1 as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested matching matrix. </dd></dl>

</div>
</div>
<a id="gae8868c54bd08f80546e4778ba2957845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8868c54bd08f80546e4778ba2957845">&#9670;&nbsp;</a></span>monodromy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::TorusBundle::monodromy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the monodromy describing how the upper and lower torus boundaries are identified. </p>
<p>See the class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the monodromy for this torus bundle. </dd></dl>

</div>
</div>
<a id="ga93d702e878c4a5e17dc17245b8e3d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d702e878c4a5e17dc17245b8e3d667">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold. </dd></dl>

</div>
</div>
<a id="ga96f1c254d3237073e5ba12978162ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f1c254d3237073e5ba12978162ad76">&#9670;&nbsp;</a></span>obstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SFSpace::obstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the obstruction constant <em>b</em> for this Seifert fibred space. </p>
<p>The obstruction constant corresponds to the insertion of an additional (1,<em>b</em>) fibre. It can be modified by calling <a class="el" href="group__manifold.html#ga9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> with a value of <em>alpha</em> = 1. It will also be modified whenever <a class="el" href="group__manifold.html#ga9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> is called with <em>beta</em> out of range (<em>beta</em> &lt; 0 or <em>beta</em> &gt;= <em>alpha</em>), since each exceptional fibre must be stored in standard form (0 &lt;= <em>beta</em> &lt; <em>alpha</em>).</p>
<dl class="section return"><dt>Returns</dt><dd>the obstruction constant <em>b</em>. </dd></dl>

</div>
</div>
<a id="gab7a00f69681b2014d863b207ce8ffcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7a00f69681b2014d863b207ce8ffcb8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Handlebody::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given handlebody represent different 3-manifolds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the handlebody with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given handlebody are not homeomorphic. </dd></dl>

</div>
</div>
<a id="gafc1a3d58ad3c68b272b76e87c3cf4827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc1a3d58ad3c68b272b76e87c3cf4827">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LensSpace::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given lens space are non-homeomorphic 3-manifolds. </p>
<p>Note that the manifolds may be homeomorphic even if they were initialised with different parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the lens space with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given lens space are non-homeomorphic. </dd></dl>

</div>
</div>
<a id="ga41830f0ddc7c4dd0f7c99892ea8205b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41830f0ddc7c4dd0f7c99892ea8205b9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSFibre::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given exceptional fibre are different. </p>
<p>This requires the fibres to have different values for <em>alpha</em> and/or to have different values for <em>beta</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the fibre with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given fibre are different. </dd></dl>

</div>
</div>
<a id="ga12e3a984ec3bceb32a8ada29ff58460b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e3a984ec3bceb32a8ada29ff58460b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure do not contain precisely the same representations of precisely the same Seifert fibred spaces. </p>
<p>Note that this routine examines the particular representation of the Seifert fibred space. Different Seifert parameters that give the same 3-manifold will be regarded as different by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given Seifert fibred space representations are different. </dd></dl>

</div>
</div>
<a id="gac7592ba0cc76eeeda17f5e2f65f0065e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7592ba0cc76eeeda17f5e2f65f0065e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SimpleSurfaceBundle::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given surface bundle represent different 3-manifolds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the surface bundle with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given surface bundle are non-homeomorphic. </dd></dl>

</div>
</div>
<a id="ga941ba295f49ba52c60bfa032e95878d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941ba295f49ba52c60bfa032e95878d8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaCensusManifold::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure represent different 3-manifolds from the SnapPea census. </p>
<p>As of Regina 5.0, this test respects the recent discovery that the manifolds <code>x101</code> and <code>x103</code> are homeomorphic. For details, see B.B., <em>A duplicate pair in the SnapPea census</em>, Experimental Mathematics, 23:170-173, 2014.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the structure with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given structure represent different SnapPea census manifolds. </dd></dl>

</div>
</div>
<a id="ga9cdd3197e500785d4fa121017fb3a32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cdd3197e500785d4fa121017fb3a32d">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphLoop::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p>The ordering imposed on graph manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering graph manifold representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given graph manifold representation. </dd></dl>

</div>
</div>
<a id="ga57e32f429e559ea70083658941011709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e32f429e559ea70083658941011709">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphPair::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p>The ordering imposed on graph manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering graph manifold representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given graph manifold representation. </dd></dl>

</div>
</div>
<a id="ga08caf6d804e672207554d2c0117caab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08caf6d804e672207554d2c0117caab7">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GraphTriple::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p>The ordering imposed on graph manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering graph manifold representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given graph manifold representation. </dd></dl>

</div>
</div>
<a id="ga340ae7f9e981a404667a1383366c114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga340ae7f9e981a404667a1383366c114c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Manifold::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold. </p>
<p>The ordering imposed on 3-manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<p>The ordering also depends on the particular representation of the 3-manifold that is used. As an example, different representations of the same Seifert fibred space might well be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering 3-manifold representations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine is only implemented in full for closed 3-manifolds. For most classes of bounded 3-manifolds, this routine simply compares the strings returned by <a class="el" href="group__manifold.html#ga93d702e878c4a5e17dc17245b8e3d667" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the 3-manifold representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given 3-manifold representation. </dd></dl>

</div>
</div>
<a id="ga0106e32932c0d909d3feb53d50d257c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0106e32932c0d909d3feb53d50d257c8">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSFibre::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this exceptional fibre is smaller than the given fibre. </p>
<p>Fibres are sorted by <em>alpha</em> and then by <em>beta</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the fibre with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is smaller than the given fibre. </dd></dl>

</div>
</div>
<a id="gade28e31e2a1e6c0cafb39c26213c6055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade28e31e2a1e6c0cafb39c26213c6055">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p>The ordering imposed on Seifert fibred space representations is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering Seifert fibred space representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given Seifert fibred space representation. </dd></dl>

</div>
</div>
<a id="ga683c84ac8fd61583bfad01fafc841f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga683c84ac8fd61583bfad01fafc841f17">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given fibre in human-readable format to the given output stream. </p>
<p>The fibre will be written in the format <code>(alpha,beta)</code> with no newline appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">f</td><td>the fibre to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga5f074d89faba1e24f513eda9443e90df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f074d89faba1e24f513eda9443e90df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp; regina::GraphLoop::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphLoop.html">GraphLoop</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8646039c075fdad840d32f0385f54330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8646039c075fdad840d32f0385f54330">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp; regina::GraphPair::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphPair.html">GraphPair</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac12f618fcbfd1d3307a6775a1fe3abfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12f618fcbfd1d3307a6775a1fe3abfd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp; regina::GraphTriple::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GraphTriple.html">GraphTriple</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given graph manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga10e380b4b6af7328945d815e1b9b9976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e380b4b6af7328945d815e1b9b9976">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Handlebody.html">Handlebody</a>&amp; regina::Handlebody::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given handlebody. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the handlebody to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5a59f70cecedbb3cc5b9fac7d79c74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a59f70cecedbb3cc5b9fac7d79c74e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a>&amp; regina::LensSpace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given lens space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the lens space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b1bf46bca6c71c817c6d1d0c87540d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1bf46bca6c71c817c6d1d0c87540d7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>&amp; regina::Manifold::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default assignment operator. </p>
<p>For the base <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a> class, this operator does nothing. It is provided so that derived classes can, if they wish, declare a default assignment operator (whereupon the compiler will automatically include a call to this base class operator). It is protected so that external users do not accidentally call it (since every <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a> really belongs to a subclass of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>, but this operator does not copy any subclass data). </p>

</div>
</div>
<a id="gaa81a55ece00f7240cee18cd05858cb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa81a55ece00f7240cee18cd05858cb2e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a>&amp; regina::SFSFibre::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this exceptional fibre a clone of the given fibre. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the exceptional fibre to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3478de5619322ae10f4b768dba68840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3478de5619322ae10f4b768dba68840">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a>&amp; regina::SFSpace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies this Seifert fibred space to be a clone of the given space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the Seifert fibred space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f13da5a80fcf204935b2692c1df8209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f13da5a80fcf204935b2692c1df8209">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a>&amp; regina::SimpleSurfaceBundle::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given surface bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the surface bundle to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga582d1b7b3013b7a206155ddeb4811b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582d1b7b3013b7a206155ddeb4811b92">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a>&amp; regina::SnapPeaCensusManifold::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given SnapPea census manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the census manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5dc437edaf8510f6144b7a7b961f078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc437edaf8510f6144b7a7b961f078f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a>&amp; regina::TorusBundle::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given torus bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the torus bundle to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99ea9b6e63f0ea2ca950363b7cb17965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ea9b6e63f0ea2ca950363b7cb17965">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Handlebody::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Handlebody.html">Handlebody</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given handlebody represent the same 3-manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the handlebody with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given handlebody are homeomorphic. </dd></dl>

</div>
</div>
<a id="gade50f94cb7b964ece12406e27204b386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade50f94cb7b964ece12406e27204b386">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LensSpace::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given lens space are homeomorphic 3-manifolds. </p>
<p>Note that this may be true even if they were initialised with different parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the lens space with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given lens space are homeomorphic. </dd></dl>

</div>
</div>
<a id="gadc3c3ff9d49e0e8bbb0191bc2e36f40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc3c3ff9d49e0e8bbb0191bc2e36f40c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSFibre::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given exceptional fibre are identical. </p>
<p>This requires both fibres to have the same values for <em>alpha</em> and the same values for <em>beta</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the fibre with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given fibre are identical. </dd></dl>

</div>
</div>
<a id="ga55dbc5a9fa80611d6cff6724ead915be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55dbc5a9fa80611d6cff6724ead915be">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given structure contain precisely the same representations of precisely the same Seifert fibred spaces. </p>
<p>Note that this routine examines the particular representation of the Seifert fibred space. Different Seifert parameters that give the same 3-manifold will be regarded as not equal by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given Seifert fibred space representations are identical. </dd></dl>

</div>
</div>
<a id="ga9b5486c515b1ed76d9295bd9aca904a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5486c515b1ed76d9295bd9aca904a0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SimpleSurfaceBundle::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given surface bundle represent the same 3-manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the surface bundle with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given surface bundle are homeomorphic. </dd></dl>

</div>
</div>
<a id="ga3692b8b34fae273766c40801a67009e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3692b8b34fae273766c40801a67009e0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaCensusManifold::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure represent the same 3-manifold from the SnapPea census. </p>
<p>As of Regina 5.0, this test respects the recent discovery that the manifolds <code>x101</code> and <code>x103</code> are homeomorphic. For details, see B.B., <em>A duplicate pair in the SnapPea census</em>, Experimental Mathematics, 23:170-173, 2014.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the structure with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given structure represent the same SnapPea census manifold. </dd></dl>

</div>
</div>
<a id="ga6a583800775800d36f4bce133109fd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a583800775800d36f4bce133109fd07">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> * regina::SFSAltSet::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested alternative space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the alternatives should be returned; this must be between 0 and <a class="el" href="group__manifold.html#ga29657c6df170a281b70b597c9d10901f" title="Returns the number of alternative spaces in this set.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested alternative space. </dd></dl>

</div>
</div>
<a id="gaaf31f26ecb2df3f75201f94c58a451df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf31f26ecb2df3f75201f94c58a451df">&#9670;&nbsp;</a></span>p()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LensSpace::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first parameter <em>p</em> of this lens space L(p,q). </p>
<p>See the class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the first parameter. </dd></dl>

</div>
</div>
<a id="ga5543c0208bf70b3209cfa5baa741c67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5543c0208bf70b3209cfa5baa741c67f">&#9670;&nbsp;</a></span>punctures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of punctures in the base orbifold. </p>
<p>In other words, this routine returns the total number of real torus or Klein bottle boundary components in the overall 3-manifold.</p>
<p>Note that reflector boundaries on the base orbifold are <em>not</em> counted here; only the ordinary boundary components that give rise to real 3-manifold boundaries are included.</p>
<p>Both untwisted and twisted punctures (giving rise to torus and Klein bottle boundaries respectively in the 3-manifold) are counted by this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of punctures. </dd></dl>

</div>
</div>
<a id="ga2995dbf0df3c0d89a1af68bec6cc6003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2995dbf0df3c0d89a1af68bec6cc6003">&#9670;&nbsp;</a></span>punctures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of punctures of the given type in the base orbifold. </p>
<p>In other words, this routine returns the number of real boundary components of the given type in the overall 3-manifold.</p>
<p>This routine either counts only twisted punctures (which give rise to Klein bottle boundaries), or only untwisted punctures (which give rise to torus boundaries).</p>
<p>Either way, reflector boundaries on the base orbifold are <em>not</em> counted here; only ordinary boundary components that give rise to real 3-manifold boundaries are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted punctures should be counted (those that give fibre-reversing paths and Klein bottle boundaries), or <code>false</code> if only untwisted punctures should be counted (those that are fibre-preserving and give torus boundaries). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of punctures of the given type. </dd></dl>

</div>
</div>
<a id="ga606a94b07140f5f5920fdabea6a8f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606a94b07140f5f5920fdabea6a8f993">&#9670;&nbsp;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LensSpace::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second parameter <em>q</em> of this lens space L(p,q). </p>
<p>See the class notes for details.</p>
<p>The value of <em>q</em> returned will be the smallest <em>q</em> between 0 and <em>p</em>-1 inclusive that produces the same 3-manifold as this lens space. This means it might not be the value of <em>q</em> that was used to initialise this lens space. </p>

</div>
</div>
<a id="gab28f4b1aeac0b2105233f4293509c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28f4b1aeac0b2105233f4293509c492">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reduce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mayReflect</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration. </p>
<p>In some cases the parameters of the Seifert fibred space may be simplified by taking a mirror image of the entire 3-manifold. The argument <em>mayReflect</em> signifies whether this is allowed.</p>
<p>This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold).</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>mayReflect</em> is <code>true</code> then the entire 3-manifold might be replaced with its mirror image, in which case any subsequent modifications (such as inserting additional fibres or altering the base orbifold) may give unexpected results.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mayReflect</td><td><code>true</code> if we are allowed to take a mirror image of the entire 3-manifold, or <code>false</code> if we are not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga070e0759c61a8b7d8816ca10bbee42a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070e0759c61a8b7d8816ca10bbee42a8">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces this space with its mirror image. </p>
<p>Specifically, all exceptional fibres and the obstruction constant <em>b</em> will be negated. Note that the obstruction constant will generally undergo further change as the exceptional fibres are standardised into the usual 0 &lt;= <em>beta</em> &lt; <em>alpha</em> form.</p>
<p>This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold), with the exception that each base curve will be reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>The space is <em>not</em> reduced after reflecting. It may be that the space can be further simplified (especially in the case of non-orientable manifolds). </dd></dl>

</div>
</div>
<a id="gab02c3ca656eba9eff9b8df5144b6aa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab02c3ca656eba9eff9b8df5144b6aa31">&#9670;&nbsp;</a></span>reflected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSAltSet::reflected </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not a reflection was used when creating the requested alternative space. </p>
<p>This determines the conversion between boundary curves for all boundary tori after the first.</p>
<p>More specifically, if no reflection was used then the directed fibre and base curves are identical for the original and alternative spaces. If a reflection was used, then the directed fibres are identical but the directed base curves are reversed.</p>
<p>The conversion between curves on the first boundary torus is generally more complex, and is returned as a matrix by the <a class="el" href="group__manifold.html#ga169540a1535da6422acd8b73e5bbc4f1" title="Returns the conversion matrix for the requested alternative space.">conversion()</a> routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the alternatives is being queried; this must be between 0 and <a class="el" href="group__manifold.html#ga29657c6df170a281b70b597c9d10901f" title="Returns the number of alternative spaces in this set.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a reflection was used in creating the requested alternative space, or <code>false</code> if no reflection was used. </dd></dl>

</div>
</div>
<a id="ga3c825b5e07e3899d32f02f5fbdcb7268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c825b5e07e3899d32f02f5fbdcb7268">&#9670;&nbsp;</a></span>reflectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of reflector boundary components of the base orbifold. </p>
<p>This includes both twisted and untwisted reflector boundaries.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of reflector boundary components. </dd></dl>

</div>
</div>
<a id="gac45bd427305037e276106095cec3c62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac45bd427305037e276106095cec3c62b">&#9670;&nbsp;</a></span>reflectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of reflector boundary components of the given type in the base orbifold. </p>
<p>This either counts only twisted reflector boundaries, or only untwisted reflector boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted reflector boundaries should be counted (those that give fibre-reversing paths), or <code>false</code> if only untwisted reflector boundaries should be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of reflector boundaries of the given type. </dd></dl>

</div>
</div>
<a id="ga207ba183a13ed70b5e07ee6602e4f1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga207ba183a13ed70b5e07ee6602e4f1b3">&#9670;&nbsp;</a></span>section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::SnapPeaCensusManifold::section </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the section of the SnapPea census to which this manifold belongs. </p>
<p>This will be one of the section constants defined in this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the section of the SnapPea census. </dd></dl>

</div>
</div>
<a id="ga27d583b84cda44e83ef019ec6d84bac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d583b84cda44e83ef019ec6d84bac9">&#9670;&nbsp;</a></span>sfs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::GraphLoop::sfs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the bounded Seifert fibred space that is joined to itself. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the bounded Seifert fibred space. </dd></dl>

</div>
</div>
<a id="gacc0d787b77c643cd4e16d0528368aa60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc0d787b77c643cd4e16d0528368aa60">&#9670;&nbsp;</a></span>sfs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::GraphPair::sfs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to one of the two bounded Seifert fibred spaces that are joined together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>0 if the first Seifert fibred space is to be returned, or 1 if the second space is to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested Seifert fibred space. </dd></dl>

</div>
</div>
<a id="ga74d1d768c185e9762aa44962c0050aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d1d768c185e9762aa44962c0050aad">&#9670;&nbsp;</a></span>SFSAltSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSAltSet::SFSAltSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td>
          <td class="paramname"><em>sfs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of alternatives for the given Seifert fibred space. </p>
<p>Note that in general, none of the alternatives will have a representation identical to the given space (generally these alternative representations will be simpler if possible).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has at least one torus boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the original Seifert fibred space for which we are creating a set of alternative representations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e5479049508d41b3f07b54380f76b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e5479049508d41b3f07b54380f76b33">&#9670;&nbsp;</a></span>SFSFibre() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSFibre::SFSFibre </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised exceptional fibre. </p>

</div>
</div>
<a id="ga1c41cab79157a8eefcaddd7db0980844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c41cab79157a8eefcaddd7db0980844">&#9670;&nbsp;</a></span>SFSFibre() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSFibre::SFSFibre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new exceptional fibre that is a clone of the given fibre. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the exceptional fibre to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51d5836d6d325155e74c1008a6977278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d5836d6d325155e74c1008a6977278">&#9670;&nbsp;</a></span>SFSFibre() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSFibre::SFSFibre </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newBeta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new exceptional fibre with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAlpha</td><td>the first parameter (the index) of this exceptional fibre; this must be strictly positive. </td></tr>
    <tr><td class="paramname">newBeta</td><td>the second parameter of this exceptional fibre; this must have no common factors with the first parameter <em>newAlpha</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga577f3044abc53a580a0bf8e7c2c072d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577f3044abc53a580a0bf8e7c2c072d0">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres. </p>

</div>
</div>
<a id="ga9fad6e2b785d4a98f21cdfba570992f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fad6e2b785d4a98f21cdfba570992f7">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__manifold.html#ga8ca6dbe82be7c2f77c480e5ad720f451">SFSpace::classType</a>&#160;</td>
          <td class="paramname"><em>useClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>genus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>punctures</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>puncturesTwisted</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectorsTwisted</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres. </p>
<dl class="section pre"><dt>Precondition</dt><dd>If there are no punctures or reflector boundary components, then <em>useClass</em> is one of the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code> or <code>n4</code>. Likewise, if there are punctures and/or reflector boundary components, then <em>useClass</em> is one of the five classes <code>bo1</code>, <code>bo2</code>, <code>bn1</code>, <code>bn2</code> or <code>bn3</code>. </dd>
<dd>
If there are any twisted punctures or reflector boundary components, then <em>useClass</em> is either <code>bo2</code> or <code>bn3</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useClass</td><td>indicates whether the base orbifold is closed and/or orientable, and gives information about fibre-reversing paths in the 3-manifold. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes and the classType enumeration notes for details. </td></tr>
    <tr><td class="paramname">genus</td><td>the genus of the base orbifold (the number of tori or projective planes that it contains). Note that for non-orientable base surfaces, this is the non-orientable genus. </td></tr>
    <tr><td class="paramname">punctures</td><td>the number of untwisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">puncturesTwisted</td><td>the number of twisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">reflectors</td><td>the number of untwisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>punctures</em>. </td></tr>
    <tr><td class="paramname">reflectorsTwisted</td><td>the number of twisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>puncturesTwisted</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4193594b1d8fea9930b1539491a9b268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4193594b1d8fea9930b1539491a9b268">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space that is a clone of the given space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the Seifert fibred space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga897973553716a18080964dc2753b27ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga897973553716a18080964dc2753b27ae">&#9670;&nbsp;</a></span>SimpleSurfaceBundle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SimpleSurfaceBundle::SimpleSurfaceBundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SimpleSurfaceBundle.html">SimpleSurfaceBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given surface bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the surface bundle to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga938bde5b5a7ee989ea34c308ff694ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938bde5b5a7ee989ea34c308ff694ef0">&#9670;&nbsp;</a></span>SimpleSurfaceBundle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SimpleSurfaceBundle::SimpleSurfaceBundle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface bundle of the given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newType</td><td>the specific type of surface bundle to represent. This must be one of the 3-manifold constants defined in this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29657c6df170a281b70b597c9d10901f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29657c6df170a281b70b597c9d10901f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SFSAltSet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of alternative spaces in this set. </p>

</div>
</div>
<a id="gae6b44d420c71fa2a65510eed408720a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b44d420c71fa2a65510eed408720a9">&#9670;&nbsp;</a></span>SnapPeaCensusManifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaCensusManifold::SnapPeaCensusManifold </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>newSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new SnapPea census manifold with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSection</td><td>the section of the SnapPea census to which this manifold belongs. This must be one of the section constants defined in this class. </td></tr>
    <tr><td class="paramname">newIndex</td><td>specifies which particular manifold within the given section is represented. The indices for each section begin counting at zero, and so this index must be between 0 and <em>k</em>-1, where <em>k</em> is the total number of manifolds in the given section. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8bf9b13564f6da0567ecd7853dde87e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf9b13564f6da0567ecd7853dde87e8">&#9670;&nbsp;</a></span>SnapPeaCensusManifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaCensusManifold::SnapPeaCensusManifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusManifold.html">SnapPeaCensusManifold</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given SnapPea census manifold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the census manifold to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5c9d3c3cbce470e4ecb69e91384d02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c9d3c3cbce470e4ecb69e91384d02c">&#9670;&nbsp;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::structure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the structure of this 3-manifold that might not be evident from its common name. </p>
<p>For instance, for an orbit space S^3/G this routine might return the full Seifert structure.</p>
<p>This routine may return the empty string if no additional details are deemed necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>a string describing additional structural details. </dd></dl>

</div>
</div>
<a id="ga0e9282f7e1b3d5e1e0ebb4343614fd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e9282f7e1b3d5e1e0ebb4343614fd70">&#9670;&nbsp;</a></span>TeXName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold in TeX format. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold in TeX format. </dd></dl>

</div>
</div>
<a id="gadf4422bf183660e7207a9363315c186b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf4422bf183660e7207a9363315c186b">&#9670;&nbsp;</a></span>TorusBundle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TorusBundle::TorusBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial torus bundle over the circle. </p>
<p>In other words, this routine creates a torus bundle with the identity monodromy. </p>

</div>
</div>
<a id="ga9fddffefd3e013319469f044b4e5a15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fddffefd3e013319469f044b4e5a15c">&#9670;&nbsp;</a></span>TorusBundle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TorusBundle::TorusBundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>newMonodromy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new torus bundle over the circle using the given monodromy. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has determinant +1 or -1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newMonodromy</td><td>describes precisely how the upper and lower torus boundaries are identified. See the class notes for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a2ce9258d5e6dacdc15f1f773f3f362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2ce9258d5e6dacdc15f1f773f3f362">&#9670;&nbsp;</a></span>TorusBundle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TorusBundle::TorusBundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TorusBundle.html">TorusBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given torus bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the torus bundle to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga002e9a568313e13691cbb3e762fa0af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002e9a568313e13691cbb3e762fa0af2">&#9670;&nbsp;</a></span>TorusBundle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TorusBundle::TorusBundle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mon00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mon01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mon10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mon11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new torus bundle over the circle using the given monodromy. </p>
<p>The four elements of the monodromy matrix are passed separately. They combine to give the full monodromy matrix <em>M</em> as follows:</p>
<pre>
          [ mon00  mon01 ]
    M  =  [              ]
          [ mon10  mon11 ]
</pre><dl class="section pre"><dt>Precondition</dt><dd>The monodromy matrix formed from the given parameters has determinant +1 or -1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mon00</td><td>the (0,0) element of the monodromy matrix. </td></tr>
    <tr><td class="paramname">mon01</td><td>the (0,1) element of the monodromy matrix. </td></tr>
    <tr><td class="paramname">mon10</td><td>the (1,0) element of the monodromy matrix. </td></tr>
    <tr><td class="paramname">mon11</td><td>the (1,1) element of the monodromy matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga919f1bb75e707dffcc4448eee8aba0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga919f1bb75e707dffcc4448eee8aba0d1">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SimpleSurfaceBundle::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific type of surface bundle being represented. </p>
<dl class="section return"><dt>Returns</dt><dd>the type of surface bundle. This will be one of the 3-manifold constants defined in this class. </dd></dl>

</div>
</div>
<a id="ga8a0411f3eb6409674e448dfe4a6b682f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0411f3eb6409674e448dfe4a6b682f">&#9670;&nbsp;</a></span>writeName() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::Manifold::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__manifold.html#gaac184a5f21ecf986a59f3b963b343b02">regina::TorusBundle</a>, <a class="el" href="group__manifold.html#ga81374205db85899342d817b61e7ba97c">regina::SnapPeaCensusManifold</a>, <a class="el" href="group__manifold.html#ga9906fdefac544ff508b78b99274a2036">regina::SimpleSurfaceBundle</a>, <a class="el" href="group__manifold.html#ga370fcf932fcdb4beacf04e4e0bdfc123">regina::SFSpace</a>, <a class="el" href="group__manifold.html#gaee1cf361521fe9874da5a5e233e9c317">regina::LensSpace</a>, <a class="el" href="group__manifold.html#ga36a4ea39d9e1a1cd1da69548dacb4a12">regina::Handlebody</a>, <a class="el" href="group__manifold.html#ga633be92056ea45baeab5105937064012">regina::GraphTriple</a>, <a class="el" href="group__manifold.html#gaaa96f0a2a5eb90bebd10defe4eb1ba7a">regina::GraphPair</a>, and <a class="el" href="group__manifold.html#gadb8b6a036b9ce8163a9ede2a79f696f8">regina::GraphLoop</a>.</p>

</div>
</div>
<a id="gadb8b6a036b9ce8163a9ede2a79f696f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8b6a036b9ce8163a9ede2a79f696f8">&#9670;&nbsp;</a></span>writeName() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphLoop::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaaa96f0a2a5eb90bebd10defe4eb1ba7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa96f0a2a5eb90bebd10defe4eb1ba7a">&#9670;&nbsp;</a></span>writeName() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphPair::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga633be92056ea45baeab5105937064012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633be92056ea45baeab5105937064012">&#9670;&nbsp;</a></span>writeName() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphTriple::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga36a4ea39d9e1a1cd1da69548dacb4a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a4ea39d9e1a1cd1da69548dacb4a12">&#9670;&nbsp;</a></span>writeName() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::Handlebody::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaee1cf361521fe9874da5a5e233e9c317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1cf361521fe9874da5a5e233e9c317">&#9670;&nbsp;</a></span>writeName() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::LensSpace::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga370fcf932fcdb4beacf04e4e0bdfc123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370fcf932fcdb4beacf04e4e0bdfc123">&#9670;&nbsp;</a></span>writeName() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga9906fdefac544ff508b78b99274a2036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9906fdefac544ff508b78b99274a2036">&#9670;&nbsp;</a></span>writeName() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SimpleSurfaceBundle::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga81374205db85899342d817b61e7ba97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81374205db85899342d817b61e7ba97c">&#9670;&nbsp;</a></span>writeName() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SnapPeaCensusManifold::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="gaac184a5f21ecf986a59f3b963b343b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac184a5f21ecf986a59f3b963b343b02">&#9670;&nbsp;</a></span>writeName() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::TorusBundle::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga6629373d88ce55bc4a3e12d3cd64a481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6629373d88ce55bc4a3e12d3cd64a481">&#9670;&nbsp;</a></span>writeStructure() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::Manifold::writeStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream. </p>
<p>For instance, for an orbit space S^3/G this routine might write the full Seifert structure.</p>
<p>This routine may write nothing if no additional details are deemed necessary. The default implementation of this routine behaves in this way.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Reimplemented in <a class="el" href="group__manifold.html#ga6f72895eef2fe3db29cc75069d1fe92e">regina::SnapPeaCensusManifold</a>, and <a class="el" href="group__manifold.html#gaa4246776c806d4bf771067bf1d956500">regina::SFSpace</a>.</p>

</div>
</div>
<a id="gaa4246776c806d4bf771067bf1d956500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4246776c806d4bf771067bf1d956500">&#9670;&nbsp;</a></span>writeStructure() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream. </p>
<p>For instance, for an orbit space S^3/G this routine might write the full Seifert structure.</p>
<p>This routine may write nothing if no additional details are deemed necessary. The default implementation of this routine behaves in this way.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#ga6629373d88ce55bc4a3e12d3cd64a481">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga6f72895eef2fe3db29cc75069d1fe92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f72895eef2fe3db29cc75069d1fe92e">&#9670;&nbsp;</a></span>writeStructure() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SnapPeaCensusManifold::writeStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream. </p>
<p>For instance, for an orbit space S^3/G this routine might write the full Seifert structure.</p>
<p>This routine may write nothing if no additional details are deemed necessary. The default implementation of this routine behaves in this way.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#ga6629373d88ce55bc4a3e12d3cd64a481">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga48689f189a77113323a55eb8029e3c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48689f189a77113323a55eb8029e3c61">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::Manifold::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__manifold.html#gae9758acb6b91326b9aaa10162f90e7a8">regina::TorusBundle</a>, <a class="el" href="group__manifold.html#ga8e7678c760733081ce68726950819bad">regina::SnapPeaCensusManifold</a>, <a class="el" href="group__manifold.html#ga9e4fd10178c878c632793e24537f9957">regina::SimpleSurfaceBundle</a>, <a class="el" href="group__manifold.html#ga74307d1ef9a53354aacb00e32fde0555">regina::SFSpace</a>, <a class="el" href="group__manifold.html#gabbcd7f9332609c117ed9abdb1b18b34a">regina::LensSpace</a>, <a class="el" href="group__manifold.html#gad7840044ad08449dcc4ba76765f3046c">regina::Handlebody</a>, <a class="el" href="group__manifold.html#ga6313dbdeac312a51f9799e3062e42eb2">regina::GraphTriple</a>, <a class="el" href="group__manifold.html#gac2be30e9d1ca7aa1e5e0e1738b94cecd">regina::GraphPair</a>, and <a class="el" href="group__manifold.html#ga75ff49eed11ad6fb791446a3910ec5f3">regina::GraphLoop</a>.</p>

</div>
</div>
<a id="ga75ff49eed11ad6fb791446a3910ec5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ff49eed11ad6fb791446a3910ec5f3">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphLoop::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="gac2be30e9d1ca7aa1e5e0e1738b94cecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2be30e9d1ca7aa1e5e0e1738b94cecd">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphPair::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga6313dbdeac312a51f9799e3062e42eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6313dbdeac312a51f9799e3062e42eb2">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::GraphTriple::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="gad7840044ad08449dcc4ba76765f3046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7840044ad08449dcc4ba76765f3046c">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::Handlebody::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="gabbcd7f9332609c117ed9abdb1b18b34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbcd7f9332609c117ed9abdb1b18b34a">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::LensSpace::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga74307d1ef9a53354aacb00e32fde0555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74307d1ef9a53354aacb00e32fde0555">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga9e4fd10178c878c632793e24537f9957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e4fd10178c878c632793e24537f9957">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SimpleSurfaceBundle::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga8e7678c760733081ce68726950819bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7678c760733081ce68726950819bad">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SnapPeaCensusManifold::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="gae9758acb6b91326b9aaa10162f90e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9758acb6b91326b9aaa10162f90e7a8">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::TorusBundle::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__manifold.html#ga48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a id="ga9c18dbf18c57378e979f81220ebd6eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c18dbf18c57378e979f81220ebd6eb9">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>Subclasses must not override this routine. They should override <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream.">writeName()</a> and <a class="el" href="group__manifold.html#ga6629373d88ce55bc4a3e12d3cd64a481" title="Writes details of the structure of this 3-manifold that might not be evident from its common name to ...">writeStructure()</a> instead.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga239a494eef37497d14d963ab2d0ad9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239a494eef37497d14d963ab2d0ad9f9">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>Subclasses must not override this routine. They should override <a class="el" href="group__manifold.html#ga8a0411f3eb6409674e448dfe4a6b682f" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream.">writeName()</a> instead.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga520bc025de7c0ed30a9ad4cf042731c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga520bc025de7c0ed30a9ad4cf042731c7">&#9670;&nbsp;</a></span>~GraphLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphLoop::~GraphLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure along with the bounded Seifert fibred space and the matching matrix. </p>

</div>
</div>
<a id="ga07b821994aa5e8ae77671ac2ac57ba42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b821994aa5e8ae77671ac2ac57ba42">&#9670;&nbsp;</a></span>~GraphPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphPair::~GraphPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure along with the component Seifert fibred spaces and the matching matrix. </p>

</div>
</div>
<a id="ga93a7f89be8d544d53880a843db75d55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a7f89be8d544d53880a843db75d55b">&#9670;&nbsp;</a></span>~GraphTriple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GraphTriple::~GraphTriple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure along with the component Seifert fibred spaces and matching matrices. </p>

</div>
</div>
<a id="gac6b27b4c688347c3992ad41d62e15a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b27b4c688347c3992ad41d62e15a88">&#9670;&nbsp;</a></span>~Handlebody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Handlebody::~Handlebody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this handlebody. </p>

</div>
</div>
<a id="ga7bedd7c9c070c6b4dffebdfb7d84736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bedd7c9c070c6b4dffebdfb7d84736f">&#9670;&nbsp;</a></span>~LensSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LensSpace::~LensSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this lens space. </p>

</div>
</div>
<a id="ga0165b4ca5ec15a50152cc965ad6ee317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0165b4ca5ec15a50152cc965ad6ee317">&#9670;&nbsp;</a></span>~Manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Manifold::~Manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A destructor that does nothing. </p>

</div>
</div>
<a id="ga7dc6b7476178bdec9fd20d809c6f3fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc6b7476178bdec9fd20d809c6f3fa2">&#9670;&nbsp;</a></span>~SFSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::~SFSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this Seifert fibred space. </p>

</div>
</div>
<a id="ga429d071d3555d590014da022430cdbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga429d071d3555d590014da022430cdbd4">&#9670;&nbsp;</a></span>~SnapPeaCensusManifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnapPeaCensusManifold::~SnapPeaCensusManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this structure. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae8a5c0cf36831268fb877ed7806f6d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8a5c0cf36831268fb877ed7806f6d12">&#9670;&nbsp;</a></span>alpha</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SFSFibre::alpha</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first parameter of this (<em>alpha</em>, <em>beta</em>) fibre. </p>
<p>Note that this is the index of the exceptional fibre. This parameter must always be strictly positive. </p>

</div>
</div>
<a id="gad8f305e9c7282333f0f008162d56d447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f305e9c7282333f0f008162d56d447">&#9670;&nbsp;</a></span>beta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SFSFibre::beta</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The second parameter of this (<em>alpha</em>, <em>beta</em>) fibre. </p>
<p>This parameter must have no common factors with <em>alpha</em>. </p>

</div>
</div>
<a id="gaebcb8b384b20e437b262c2d864a32a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebcb8b384b20e437b262c2d864a32a4a">&#9670;&nbsp;</a></span>RP2xS1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::SimpleSurfaceBundle::RP2xS1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the projective plane bundle over the circle. </p>

</div>
</div>
<a id="ga9a880f8b91d709a4d280489ccc85f255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a880f8b91d709a4d280489ccc85f255">&#9670;&nbsp;</a></span>S2xS1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::SimpleSurfaceBundle::S2xS1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the orientable 2-sphere bundle over the circle. </p>

</div>
</div>
<a id="ga77e1f2620c31263fc67d133b6266c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e1f2620c31263fc67d133b6266c68c">&#9670;&nbsp;</a></span>S2xS1_TWISTED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::SimpleSurfaceBundle::S2xS1_TWISTED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the non-orientable twisted 2-sphere bundle over the circle. </p>

</div>
</div>
<a id="ga37bcfb6c1cec7dc4bb8199fb03d782f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37bcfb6c1cec7dc4bb8199fb03d782f1">&#9670;&nbsp;</a></span>SEC_5</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusManifold::SEC_5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of manifolds formed from five or fewer tetrahedra (both orientable and non-orientable). </p>
<p>There are 415 manifolds in this section. </p>

</div>
</div>
<a id="ga8a18ef0b5db749a6cf7c111135960644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a18ef0b5db749a6cf7c111135960644">&#9670;&nbsp;</a></span>SEC_6_NOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusManifold::SEC_6_NOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of non-orientable manifolds formed from six tetrahedra. </p>
<p>There are 259 manifolds in this section. </p>

</div>
</div>
<a id="ga79ea1a993d4098c8c2b813012c41b59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79ea1a993d4098c8c2b813012c41b59d">&#9670;&nbsp;</a></span>SEC_6_OR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusManifold::SEC_6_OR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of orientable manifolds formed from six tetrahedra. </p>
<p>There are 962 manifolds in this section. </p>

</div>
</div>
<a id="gaa971f8ef4bab8396c10873afced27edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa971f8ef4bab8396c10873afced27edd">&#9670;&nbsp;</a></span>SEC_7_NOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusManifold::SEC_7_NOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of non-orientable manifolds formed from seven tetrahedra. </p>
<p>There are 887 manifolds in this section. </p>

</div>
</div>
<a id="ga15ee140169d03c2ded606ab80e886d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ee140169d03c2ded606ab80e886d60">&#9670;&nbsp;</a></span>SEC_7_OR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusManifold::SEC_7_OR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of orientable manifolds formed from seven tetrahedra. </p>
<p>There are 3552 manifolds in this section. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
