<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Standard Triangulations and Subcomplexes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Standard Triangulations and Subcomplexes</div>  </div>
</div><!--header-->
<div class="contents">

<p>Standard triangulations and subcomplexes of triangulations whose structures are well-understood.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AugTriSolidTorus.html">regina::AugTriSolidTorus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an augmented triangular solid torus component of a triangulation.  <a href="classregina_1_1AugTriSolidTorus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BlockedSFS.html">regina::BlockedSFS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a blocked Seifert fibred space (possibly with boundary).  <a href="classregina_1_1BlockedSFS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BlockedSFSLoop.html">regina::BlockedSFSLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a blocked Seifert fibred space with two boundary tori that are joined together.  <a href="classregina_1_1BlockedSFSLoop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BlockedSFSPair.html">regina::BlockedSFSPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a blocked pair of Seifert fibred spaces joined along a single connecting torus.  <a href="classregina_1_1BlockedSFSPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BlockedSFSTriple.html">regina::BlockedSFSTriple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a blocked sequence of three Seifert fibred spaces joined along connecting tori.  <a href="classregina_1_1BlockedSFSTriple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1L31Pillow.html">regina::L31Pillow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a triangular pillow L(3,1) component of a triangulation.  <a href="classregina_1_1L31Pillow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredChain.html">regina::LayeredChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layered chain in a triangulation.  <a href="classregina_1_1LayeredChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredChainPair.html">regina::LayeredChainPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layered chain pair component of a triangulation.  <a href="classregina_1_1LayeredChainPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredLensSpace.html">regina::LayeredLensSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layered lens space component of a triangulation.  <a href="classregina_1_1LayeredLensSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredLoop.html">regina::LayeredLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layered loop component of a triangulation.  <a href="classregina_1_1LayeredLoop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html">regina::LayeredSolidTorus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layered solid torus in a triangulation.  <a href="classregina_1_1LayeredSolidTorus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredTorusBundle.html">regina::LayeredTorusBundle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a layered torus bundle.  <a href="classregina_1_1LayeredTorusBundle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html">regina::Layering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layering of zero or more tetrahedra upon a torus boundary.  <a href="classregina_1_1Layering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PillowTwoSphere.html">regina::PillowTwoSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-sphere made from two triangles glued together along their three edges.  <a href="classregina_1_1PillowTwoSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PluggedTorusBundle.html">regina::PluggedTorusBundle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a triangulation of a graph manifold formed by joining a bounded saturated region with a thin I-bundle over the torus, possibly with layerings in between.  <a href="classregina_1_1PluggedTorusBundle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PlugTriSolidTorus.html">regina::PlugTriSolidTorus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a plugged triangular solid torus component of a triangulation.  <a href="classregina_1_1PlugTriSolidTorus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatAnnulus.html">regina::SatAnnulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an annulus formed from a pair of triangles in a Seifert fibred space.  <a href="structregina_1_1SatAnnulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlock.html">regina::SatBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a saturated block in a Seifert fibred space.  <a href="classregina_1_1SatBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlockStarter.html">regina::SatBlockStarter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a triangulation of a saturated block along with the accompanying saturated block description.  <a href="classregina_1_1SatBlockStarter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlockStarterSet.html">regina::SatBlockStarterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of starter blocks that can be used for identifying triangulations of Seifert fibred spaces.  <a href="classregina_1_1SatBlockStarterSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatBlockStarterSearcher.html">regina::SatBlockStarterSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for locating and using starter blocks within a triangulation.  <a href="classregina_1_1SatBlockStarterSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatMobius.html">regina::SatMobius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A degenerate zero-tetrahedron saturated block that corresponds to attaching a Mobius band to a single annulus boundary.  <a href="classregina_1_1SatMobius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatLST.html">regina::SatLST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A saturated block that is a layered solid torus.  <a href="classregina_1_1SatLST.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatTriPrism.html">regina::SatTriPrism</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A saturated block that is a three-tetrahedron triangular prism.  <a href="classregina_1_1SatTriPrism.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatCube.html">regina::SatCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A saturated block that is a six-tetrahedron cube.  <a href="classregina_1_1SatCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatReflectorStrip.html">regina::SatReflectorStrip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A saturated block that is a reflector strip.  <a href="classregina_1_1SatReflectorStrip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatLayering.html">regina::SatLayering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A degenerate saturated block that is a single tetrahedron wrapped around so that two opposite edges touch.  <a href="classregina_1_1SatLayering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SatBlockSpec.html">regina::SatBlockSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how a single saturated block forms a part of a larger saturated region.  <a href="structregina_1_1SatBlockSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SatRegion.html">regina::SatRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A large saturated region in a Seifert fibred space formed by joining together saturated blocks.  <a href="classregina_1_1SatRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapPeaCensusTri.html">regina::SnapPeaCensusTri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3-manifold triangulation from the SnapPea cusped census.  <a href="classregina_1_1SnapPeaCensusTri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnappedBall.html">regina::SnappedBall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a snapped 3-ball in a triangulation.  <a href="classregina_1_1SnappedBall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnappedTwoSphere.html">regina::SnappedTwoSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-sphere made from two snapped 3-balls in a triangulation.  <a href="classregina_1_1SnappedTwoSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SpiralSolidTorus.html">regina::SpiralSolidTorus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a spiralled solid torus in a triangulation.  <a href="classregina_1_1SpiralSolidTorus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html">regina::StandardTriangulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.  <a href="classregina_1_1StandardTriangulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TriSolidTorus.html">regina::TriSolidTorus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a three-tetrahedron triangular solid torus in a triangulation.  <a href="classregina_1_1TriSolidTorus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrivialTri.html">regina::TrivialTri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents one of a few particular hard-coded trivial triangulations that do not belong to any of the other larger families.  <a href="classregina_1_1TrivialTri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TxICore.html">regina::TxICore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a triangulation of the product <code>T x I</code> (the product of the torus and the interval).  <a href="classregina_1_1TxICore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TxIDiagonalCore.html">regina::TxIDiagonalCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of a family of thin <code>T x I</code> triangulations that typically appear at the centres of layered torus bundles.  <a href="classregina_1_1TxIDiagonalCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TxIParallelCore.html">regina::TxIParallelCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specific six-tetrahedron <a class="el" href="classregina_1_1TxICore.html" title="Provides a triangulation of the product T x I (the product of the torus and the interval).">TxICore</a> triangulation that does not fit neatly into other families.  <a href="classregina_1_1TxIParallelCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a49a458761be1b59e37276e89d1ae86"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9a49a458761be1b59e37276e89d1ae86">regina::NAugTriSolidTorus</a></td></tr>
<tr class="memdesc:ga9a49a458761be1b59e37276e89d1ae86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga9a49a458761be1b59e37276e89d1ae86">More...</a><br /></td></tr>
<tr class="separator:ga9a49a458761be1b59e37276e89d1ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7a4d83d46bd4c97e43611e15be0ee4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BlockedSFS.html">BlockedSFS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9a7a4d83d46bd4c97e43611e15be0ee4">regina::NBlockedSFS</a></td></tr>
<tr class="memdesc:ga9a7a4d83d46bd4c97e43611e15be0ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga9a7a4d83d46bd4c97e43611e15be0ee4">More...</a><br /></td></tr>
<tr class="separator:ga9a7a4d83d46bd4c97e43611e15be0ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e37593682757f02cefefcc6c60c57a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BlockedSFSLoop.html">BlockedSFSLoop</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga73e37593682757f02cefefcc6c60c57a">regina::NBlockedSFSLoop</a></td></tr>
<tr class="memdesc:ga73e37593682757f02cefefcc6c60c57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga73e37593682757f02cefefcc6c60c57a">More...</a><br /></td></tr>
<tr class="separator:ga73e37593682757f02cefefcc6c60c57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf44ad2e030908702508c3ba13e7af2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BlockedSFSPair.html">BlockedSFSPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2bf44ad2e030908702508c3ba13e7af2">regina::NBlockedSFSPair</a></td></tr>
<tr class="memdesc:ga2bf44ad2e030908702508c3ba13e7af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga2bf44ad2e030908702508c3ba13e7af2">More...</a><br /></td></tr>
<tr class="separator:ga2bf44ad2e030908702508c3ba13e7af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222097bdc1c05fa443d2d6de80c58d3d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BlockedSFSTriple.html">BlockedSFSTriple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga222097bdc1c05fa443d2d6de80c58d3d">regina::NBlockedSFSTriple</a></td></tr>
<tr class="memdesc:ga222097bdc1c05fa443d2d6de80c58d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga222097bdc1c05fa443d2d6de80c58d3d">More...</a><br /></td></tr>
<tr class="separator:ga222097bdc1c05fa443d2d6de80c58d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1099ab7910d12bfb1573bd7522662e9e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1099ab7910d12bfb1573bd7522662e9e">regina::NL31Pillow</a></td></tr>
<tr class="memdesc:ga1099ab7910d12bfb1573bd7522662e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga1099ab7910d12bfb1573bd7522662e9e">More...</a><br /></td></tr>
<tr class="separator:ga1099ab7910d12bfb1573bd7522662e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06af284ff78f9ca984abb353843586d2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga06af284ff78f9ca984abb353843586d2">regina::NLayeredChain</a></td></tr>
<tr class="memdesc:ga06af284ff78f9ca984abb353843586d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga06af284ff78f9ca984abb353843586d2">More...</a><br /></td></tr>
<tr class="separator:ga06af284ff78f9ca984abb353843586d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded95a56308a6bc0e53b98807ee20735"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaded95a56308a6bc0e53b98807ee20735">regina::NLayeredChainPair</a></td></tr>
<tr class="memdesc:gaded95a56308a6bc0e53b98807ee20735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gaded95a56308a6bc0e53b98807ee20735">More...</a><br /></td></tr>
<tr class="separator:gaded95a56308a6bc0e53b98807ee20735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1308182b7c6d60625ecb052088fef757"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1308182b7c6d60625ecb052088fef757">regina::NLayeredLensSpace</a></td></tr>
<tr class="memdesc:ga1308182b7c6d60625ecb052088fef757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga1308182b7c6d60625ecb052088fef757">More...</a><br /></td></tr>
<tr class="separator:ga1308182b7c6d60625ecb052088fef757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5917ee3101b277110877f0d45d16163f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5917ee3101b277110877f0d45d16163f">regina::NLayeredLoop</a></td></tr>
<tr class="memdesc:ga5917ee3101b277110877f0d45d16163f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga5917ee3101b277110877f0d45d16163f">More...</a><br /></td></tr>
<tr class="separator:ga5917ee3101b277110877f0d45d16163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba585c8865999aba5c08556b11a4309a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaba585c8865999aba5c08556b11a4309a">regina::NLayeredSolidTorus</a></td></tr>
<tr class="memdesc:gaba585c8865999aba5c08556b11a4309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gaba585c8865999aba5c08556b11a4309a">More...</a><br /></td></tr>
<tr class="separator:gaba585c8865999aba5c08556b11a4309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10a2c301c82833390f320700bf5d45b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1LayeredTorusBundle.html">LayeredTorusBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf10a2c301c82833390f320700bf5d45b">regina::NLayeredTorusBundle</a></td></tr>
<tr class="memdesc:gaf10a2c301c82833390f320700bf5d45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gaf10a2c301c82833390f320700bf5d45b">More...</a><br /></td></tr>
<tr class="separator:gaf10a2c301c82833390f320700bf5d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8bb15ab88b1ede974226ee7ff26924f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Layering.html">Layering</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac8bb15ab88b1ede974226ee7ff26924f">regina::NLayering</a></td></tr>
<tr class="memdesc:gac8bb15ab88b1ede974226ee7ff26924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gac8bb15ab88b1ede974226ee7ff26924f">More...</a><br /></td></tr>
<tr class="separator:gac8bb15ab88b1ede974226ee7ff26924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4594049e397b0e1235a0a5744eb548"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafe4594049e397b0e1235a0a5744eb548">regina::NPillowTwoSphere</a></td></tr>
<tr class="memdesc:gafe4594049e397b0e1235a0a5744eb548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gafe4594049e397b0e1235a0a5744eb548">More...</a><br /></td></tr>
<tr class="separator:gafe4594049e397b0e1235a0a5744eb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffe4c7b0f46040f384853fa2dcb13ef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PluggedTorusBundle.html">PluggedTorusBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadffe4c7b0f46040f384853fa2dcb13ef">regina::NPluggedTorusBundle</a></td></tr>
<tr class="memdesc:gadffe4c7b0f46040f384853fa2dcb13ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gadffe4c7b0f46040f384853fa2dcb13ef">More...</a><br /></td></tr>
<tr class="separator:gadffe4c7b0f46040f384853fa2dcb13ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe23ed73f99c78efbb79931bcc0f3aef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafe23ed73f99c78efbb79931bcc0f3aef">regina::NPlugTriSolidTorus</a></td></tr>
<tr class="memdesc:gafe23ed73f99c78efbb79931bcc0f3aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gafe23ed73f99c78efbb79931bcc0f3aef">More...</a><br /></td></tr>
<tr class="separator:gafe23ed73f99c78efbb79931bcc0f3aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae998f895fbe64984de46cfe67b049976"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae998f895fbe64984de46cfe67b049976">regina::NSatAnnulus</a></td></tr>
<tr class="memdesc:gae998f895fbe64984de46cfe67b049976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gae998f895fbe64984de46cfe67b049976">More...</a><br /></td></tr>
<tr class="separator:gae998f895fbe64984de46cfe67b049976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4ac64f5f274a2dd743ce10ce533303"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">regina::SatBlock::TetList</a></td></tr>
<tr class="memdesc:ga3f4ac64f5f274a2dd743ce10ce533303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>.  <a href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">More...</a><br /></td></tr>
<tr class="separator:ga3f4ac64f5f274a2dd743ce10ce533303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009d5797cec6f76f86a450932444b130"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga009d5797cec6f76f86a450932444b130">regina::NSatBlock</a></td></tr>
<tr class="memdesc:ga009d5797cec6f76f86a450932444b130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga009d5797cec6f76f86a450932444b130">More...</a><br /></td></tr>
<tr class="separator:ga009d5797cec6f76f86a450932444b130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e25496e87fac92ec953143d6209832"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga76e25496e87fac92ec953143d6209832">regina::NSatBlockStarter</a></td></tr>
<tr class="memdesc:ga76e25496e87fac92ec953143d6209832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga76e25496e87fac92ec953143d6209832">More...</a><br /></td></tr>
<tr class="separator:ga76e25496e87fac92ec953143d6209832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ec02399fc8c577957bc02912f5db87"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a>&lt; <a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a> &gt;::<a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">regina::SatBlockStarterSet::iterator</a></td></tr>
<tr class="memdesc:gaa9ec02399fc8c577957bc02912f5db87"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the starter blocks in this list.  <a href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">More...</a><br /></td></tr>
<tr class="separator:gaa9ec02399fc8c577957bc02912f5db87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc77905a0cb3031388a4f7da90a68cd9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatBlockStarterSet.html">SatBlockStarterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafc77905a0cb3031388a4f7da90a68cd9">regina::NSatBlockStarterSet</a></td></tr>
<tr class="memdesc:gafc77905a0cb3031388a4f7da90a68cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gafc77905a0cb3031388a4f7da90a68cd9">More...</a><br /></td></tr>
<tr class="separator:gafc77905a0cb3031388a4f7da90a68cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114a3242d4456f6a6c6fc00df25202a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatBlockStarterSearcher.html">SatBlockStarterSearcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga114a3242d4456f6a6c6fc00df25202a7">regina::NSatBlockStarterSearcher</a></td></tr>
<tr class="memdesc:ga114a3242d4456f6a6c6fc00df25202a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga114a3242d4456f6a6c6fc00df25202a7">More...</a><br /></td></tr>
<tr class="separator:ga114a3242d4456f6a6c6fc00df25202a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476e2021ecb97066efa5f9fa275a6af5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga476e2021ecb97066efa5f9fa275a6af5">regina::NSatMobius</a></td></tr>
<tr class="memdesc:ga476e2021ecb97066efa5f9fa275a6af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga476e2021ecb97066efa5f9fa275a6af5">More...</a><br /></td></tr>
<tr class="separator:ga476e2021ecb97066efa5f9fa275a6af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae615b949668ddd2c794e793f25f6719f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatLST.html">SatLST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae615b949668ddd2c794e793f25f6719f">regina::NSatLST</a></td></tr>
<tr class="memdesc:gae615b949668ddd2c794e793f25f6719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gae615b949668ddd2c794e793f25f6719f">More...</a><br /></td></tr>
<tr class="separator:gae615b949668ddd2c794e793f25f6719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf414bc395f88373374dc9d1a0a0b94a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabf414bc395f88373374dc9d1a0a0b94a">regina::NSatTriPrism</a></td></tr>
<tr class="memdesc:gabf414bc395f88373374dc9d1a0a0b94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gabf414bc395f88373374dc9d1a0a0b94a">More...</a><br /></td></tr>
<tr class="separator:gabf414bc395f88373374dc9d1a0a0b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c3fcee108f3cf20200ca45bbb1336d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatCube.html">SatCube</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac8c3fcee108f3cf20200ca45bbb1336d">regina::NSatCube</a></td></tr>
<tr class="memdesc:gac8c3fcee108f3cf20200ca45bbb1336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gac8c3fcee108f3cf20200ca45bbb1336d">More...</a><br /></td></tr>
<tr class="separator:gac8c3fcee108f3cf20200ca45bbb1336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1227ac6ee656c8b8846cf556dc0d1c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2a1227ac6ee656c8b8846cf556dc0d1c">regina::NSatReflectorStrip</a></td></tr>
<tr class="memdesc:ga2a1227ac6ee656c8b8846cf556dc0d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga2a1227ac6ee656c8b8846cf556dc0d1c">More...</a><br /></td></tr>
<tr class="separator:ga2a1227ac6ee656c8b8846cf556dc0d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17357d22df175514fb748e80fcaace52"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga17357d22df175514fb748e80fcaace52">regina::NSatLayering</a></td></tr>
<tr class="memdesc:ga17357d22df175514fb748e80fcaace52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga17357d22df175514fb748e80fcaace52">More...</a><br /></td></tr>
<tr class="separator:ga17357d22df175514fb748e80fcaace52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c">regina::NSatBlockSpec</a></td></tr>
<tr class="memdesc:ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c">More...</a><br /></td></tr>
<tr class="separator:ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495fb7fd03c7e32a17177ff94a916548"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga495fb7fd03c7e32a17177ff94a916548">regina::NSatRegion</a></td></tr>
<tr class="memdesc:ga495fb7fd03c7e32a17177ff94a916548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga495fb7fd03c7e32a17177ff94a916548">More...</a><br /></td></tr>
<tr class="separator:ga495fb7fd03c7e32a17177ff94a916548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709627fd20b7434819e10b13ec36bb52"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga709627fd20b7434819e10b13ec36bb52">regina::NSnapPeaCensusTri</a></td></tr>
<tr class="memdesc:ga709627fd20b7434819e10b13ec36bb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga709627fd20b7434819e10b13ec36bb52">More...</a><br /></td></tr>
<tr class="separator:ga709627fd20b7434819e10b13ec36bb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebe6a5dbd35db1177c423b09e5d129c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9ebe6a5dbd35db1177c423b09e5d129c">regina::NSnappedBall</a></td></tr>
<tr class="memdesc:ga9ebe6a5dbd35db1177c423b09e5d129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga9ebe6a5dbd35db1177c423b09e5d129c">More...</a><br /></td></tr>
<tr class="separator:ga9ebe6a5dbd35db1177c423b09e5d129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e88641c3c1e91db6fd7a34d71c927e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga31e88641c3c1e91db6fd7a34d71c927e">regina::NSnappedTwoSphere</a></td></tr>
<tr class="memdesc:ga31e88641c3c1e91db6fd7a34d71c927e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga31e88641c3c1e91db6fd7a34d71c927e">More...</a><br /></td></tr>
<tr class="separator:ga31e88641c3c1e91db6fd7a34d71c927e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb7b268ff161272c3beaea6659738bca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadb7b268ff161272c3beaea6659738bca">regina::NSpiralSolidTorus</a></td></tr>
<tr class="memdesc:gadb7b268ff161272c3beaea6659738bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gadb7b268ff161272c3beaea6659738bca">More...</a><br /></td></tr>
<tr class="separator:gadb7b268ff161272c3beaea6659738bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49fb6472b768481fce376ffc1953d6d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga49fb6472b768481fce376ffc1953d6d5">regina::NStandardTriangulation</a></td></tr>
<tr class="memdesc:ga49fb6472b768481fce376ffc1953d6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga49fb6472b768481fce376ffc1953d6d5">More...</a><br /></td></tr>
<tr class="separator:ga49fb6472b768481fce376ffc1953d6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc6847a2cb8b03b03126e48a1f2a5fe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8fc6847a2cb8b03b03126e48a1f2a5fe">regina::NTriSolidTorus</a></td></tr>
<tr class="memdesc:ga8fc6847a2cb8b03b03126e48a1f2a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga8fc6847a2cb8b03b03126e48a1f2a5fe">More...</a><br /></td></tr>
<tr class="separator:ga8fc6847a2cb8b03b03126e48a1f2a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4e9b40795c5598110fcb080823e852"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3c4e9b40795c5598110fcb080823e852">regina::NTrivialTri</a></td></tr>
<tr class="memdesc:ga3c4e9b40795c5598110fcb080823e852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga3c4e9b40795c5598110fcb080823e852">More...</a><br /></td></tr>
<tr class="separator:ga3c4e9b40795c5598110fcb080823e852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc12c6707d11efda95914013d9c15de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TxICore.html">TxICore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6cc12c6707d11efda95914013d9c15de">regina::NTxICore</a></td></tr>
<tr class="memdesc:ga6cc12c6707d11efda95914013d9c15de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga6cc12c6707d11efda95914013d9c15de">More...</a><br /></td></tr>
<tr class="separator:ga6cc12c6707d11efda95914013d9c15de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f0107c915117f29b5bce21046bad4c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TxIDiagonalCore.html">TxIDiagonalCore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa4f0107c915117f29b5bce21046bad4c">regina::NTxIDiagonalCore</a></td></tr>
<tr class="memdesc:gaa4f0107c915117f29b5bce21046bad4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#gaa4f0107c915117f29b5bce21046bad4c">More...</a><br /></td></tr>
<tr class="separator:gaa4f0107c915117f29b5bce21046bad4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c1bda2e27635f7e5e1e448ffbd2be2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TxIParallelCore.html">TxIParallelCore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga88c1bda2e27635f7e5e1e448ffbd2be2">regina::NTxIParallelCore</a></td></tr>
<tr class="memdesc:ga88c1bda2e27635f7e5e1e448ffbd2be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__subcomplex.html#ga88c1bda2e27635f7e5e1e448ffbd2be2">More...</a><br /></td></tr>
<tr class="separator:ga88c1bda2e27635f7e5e1e448ffbd2be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga29844946ea9d17f3e52920501708641f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga29844946ea9d17f3e52920501708641f">regina::AugTriSolidTorus::~AugTriSolidTorus</a> ()</td></tr>
<tr class="memdesc:ga29844946ea9d17f3e52920501708641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this augmented solid torus; note that the corresponding triangular and layered solid tori will also be destroyed.  <a href="group__subcomplex.html#ga29844946ea9d17f3e52920501708641f">More...</a><br /></td></tr>
<tr class="separator:ga29844946ea9d17f3e52920501708641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ef70acb636d8db01ae0a11937cab05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga94ef70acb636d8db01ae0a11937cab05">regina::AugTriSolidTorus::clone</a> () const</td></tr>
<tr class="memdesc:ga94ef70acb636d8db01ae0a11937cab05"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga94ef70acb636d8db01ae0a11937cab05">More...</a><br /></td></tr>
<tr class="separator:ga94ef70acb636d8db01ae0a11937cab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9d3e437d412922ef79246561d4bd4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacc9d3e437d412922ef79246561d4bd4a">regina::AugTriSolidTorus::core</a> () const</td></tr>
<tr class="memdesc:gacc9d3e437d412922ef79246561d4bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangular solid torus at the core of this triangulation.  <a href="group__subcomplex.html#gacc9d3e437d412922ef79246561d4bd4a">More...</a><br /></td></tr>
<tr class="separator:gacc9d3e437d412922ef79246561d4bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0bd603756efd481bf9bd828a4c0d19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7a0bd603756efd481bf9bd828a4c0d19">regina::AugTriSolidTorus::augTorus</a> (int annulus) const</td></tr>
<tr class="memdesc:ga7a0bd603756efd481bf9bd828a4c0d19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus attached to the requested annulus on the boundary of the core triangular solid torus.  <a href="group__subcomplex.html#ga7a0bd603756efd481bf9bd828a4c0d19">More...</a><br /></td></tr>
<tr class="separator:ga7a0bd603756efd481bf9bd828a4c0d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f54cccdd60ed0a22113f25e23b553b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0f54cccdd60ed0a22113f25e23b553b1">regina::AugTriSolidTorus::edgeGroupRoles</a> (int annulus) const</td></tr>
<tr class="memdesc:ga0f54cccdd60ed0a22113f25e23b553b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation describing the role played by each top level edge group of the layered solid torus glued to the requested annulus of the core triangular solid torus.  <a href="group__subcomplex.html#ga0f54cccdd60ed0a22113f25e23b553b1">More...</a><br /></td></tr>
<tr class="separator:ga0f54cccdd60ed0a22113f25e23b553b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc7d27e0a787d3cd3b18cbc14ee40e0"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacfc7d27e0a787d3cd3b18cbc14ee40e0">regina::AugTriSolidTorus::chainLength</a> () const</td></tr>
<tr class="memdesc:gacfc7d27e0a787d3cd3b18cbc14ee40e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the layered chain linking two of the boundary annuli of the core triangular solid torus.  <a href="group__subcomplex.html#gacfc7d27e0a787d3cd3b18cbc14ee40e0">More...</a><br /></td></tr>
<tr class="separator:gacfc7d27e0a787d3cd3b18cbc14ee40e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf374a74840cc6785167ed475ac919dd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf374a74840cc6785167ed475ac919dd2">regina::AugTriSolidTorus::chainType</a> () const</td></tr>
<tr class="memdesc:gaf374a74840cc6785167ed475ac919dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the way in which a layered chain links two of the boundary annuli of the core triangular solid torus.  <a href="group__subcomplex.html#gaf374a74840cc6785167ed475ac919dd2">More...</a><br /></td></tr>
<tr class="separator:gaf374a74840cc6785167ed475ac919dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7446d154dc67c10d6b04eef8ea7aef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gada7446d154dc67c10d6b04eef8ea7aef">regina::AugTriSolidTorus::torusAnnulus</a> () const</td></tr>
<tr class="memdesc:gada7446d154dc67c10d6b04eef8ea7aef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the single boundary annulus of the core triangular solid torus to which a layered solid torus is attached.  <a href="group__subcomplex.html#gada7446d154dc67c10d6b04eef8ea7aef">More...</a><br /></td></tr>
<tr class="separator:gada7446d154dc67c10d6b04eef8ea7aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1254c105ca00c41987059ace85036d46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1254c105ca00c41987059ace85036d46">regina::AugTriSolidTorus::hasLayeredChain</a> () const</td></tr>
<tr class="memdesc:ga1254c105ca00c41987059ace85036d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the core triangular solid torus has two of its boundary annuli linked by a layered chain as described in the general class notes.  <a href="group__subcomplex.html#ga1254c105ca00c41987059ace85036d46">More...</a><br /></td></tr>
<tr class="separator:ga1254c105ca00c41987059ace85036d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d65869bc7a3bad2123ec14c724a357"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga36d65869bc7a3bad2123ec14c724a357">regina::AugTriSolidTorus::isAugTriSolidTorus</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga36d65869bc7a3bad2123ec14c724a357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is an augmented triangular solid torus.  <a href="group__subcomplex.html#ga36d65869bc7a3bad2123ec14c724a357">More...</a><br /></td></tr>
<tr class="separator:ga36d65869bc7a3bad2123ec14c724a357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb28c773dc5aad2dd02cd7267372c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadeb28c773dc5aad2dd02cd7267372c7b">regina::AugTriSolidTorus::manifold</a> () const override</td></tr>
<tr class="memdesc:gadeb28c773dc5aad2dd02cd7267372c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gadeb28c773dc5aad2dd02cd7267372c7b">More...</a><br /></td></tr>
<tr class="separator:gadeb28c773dc5aad2dd02cd7267372c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775f6ef15a3dd8b66fcc72870e0dc2ab"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga775f6ef15a3dd8b66fcc72870e0dc2ab">regina::AugTriSolidTorus::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga775f6ef15a3dd8b66fcc72870e0dc2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga775f6ef15a3dd8b66fcc72870e0dc2ab">More...</a><br /></td></tr>
<tr class="separator:ga775f6ef15a3dd8b66fcc72870e0dc2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb5555a5884d986589593215b531be5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafeb5555a5884d986589593215b531be5">regina::AugTriSolidTorus::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gafeb5555a5884d986589593215b531be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#gafeb5555a5884d986589593215b531be5">More...</a><br /></td></tr>
<tr class="separator:gafeb5555a5884d986589593215b531be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62bf0dddd611fb1ac1b0d05f79f50f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga62bf0dddd611fb1ac1b0d05f79f50f51">regina::AugTriSolidTorus::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga62bf0dddd611fb1ac1b0d05f79f50f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga62bf0dddd611fb1ac1b0d05f79f50f51">More...</a><br /></td></tr>
<tr class="separator:ga62bf0dddd611fb1ac1b0d05f79f50f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911e5655dafe570fcee17d589ae84584"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga911e5655dafe570fcee17d589ae84584">regina::BlockedSFS::~BlockedSFS</a> ()</td></tr>
<tr class="memdesc:ga911e5655dafe570fcee17d589ae84584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its constituent components.  <a href="group__subcomplex.html#ga911e5655dafe570fcee17d589ae84584">More...</a><br /></td></tr>
<tr class="separator:ga911e5655dafe570fcee17d589ae84584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de7f534b82eadd85b8ce9e775a35d8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4de7f534b82eadd85b8ce9e775a35d8c">regina::BlockedSFS::region</a> () const</td></tr>
<tr class="memdesc:ga4de7f534b82eadd85b8ce9e775a35d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the single saturated region that fills this triangulation.  <a href="group__subcomplex.html#ga4de7f534b82eadd85b8ce9e775a35d8c">More...</a><br /></td></tr>
<tr class="separator:ga4de7f534b82eadd85b8ce9e775a35d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67b119a4c528622846ffc50270cbfea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa67b119a4c528622846ffc50270cbfea">regina::BlockedSFS::isPluggedIBundle</a> (std::string &amp;<a class="el" href="group__subcomplex.html#ga62f318c415f2ec73916cc6c3aa669d8a">name</a>) const</td></tr>
<tr class="memdesc:gaa67b119a4c528622846ffc50270cbfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is a plugged thin I-bundle or a plugged thick I-bundle.  <a href="group__subcomplex.html#gaa67b119a4c528622846ffc50270cbfea">More...</a><br /></td></tr>
<tr class="separator:gaa67b119a4c528622846ffc50270cbfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8a8201cecd98cc61c4f4023a3df03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9e8a8201cecd98cc61c4f4023a3df03b">regina::BlockedSFS::manifold</a> () const override</td></tr>
<tr class="memdesc:ga9e8a8201cecd98cc61c4f4023a3df03b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga9e8a8201cecd98cc61c4f4023a3df03b">More...</a><br /></td></tr>
<tr class="separator:ga9e8a8201cecd98cc61c4f4023a3df03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02dd77d605d672d2fede888dd198834"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf02dd77d605d672d2fede888dd198834">regina::BlockedSFS::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf02dd77d605d672d2fede888dd198834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gaf02dd77d605d672d2fede888dd198834">More...</a><br /></td></tr>
<tr class="separator:gaf02dd77d605d672d2fede888dd198834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb433562e1873d79049ec7b57848d55e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacb433562e1873d79049ec7b57848d55e">regina::BlockedSFS::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gacb433562e1873d79049ec7b57848d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#gacb433562e1873d79049ec7b57848d55e">More...</a><br /></td></tr>
<tr class="separator:gacb433562e1873d79049ec7b57848d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf88cb11f0dc3fa4717cfe0970b0671b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaf88cb11f0dc3fa4717cfe0970b0671b">regina::BlockedSFS::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaaf88cb11f0dc3fa4717cfe0970b0671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gaaf88cb11f0dc3fa4717cfe0970b0671b">More...</a><br /></td></tr>
<tr class="separator:gaaf88cb11f0dc3fa4717cfe0970b0671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c43d8cbb034623e886011cad85520c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1BlockedSFS.html">BlockedSFS</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga20c43d8cbb034623e886011cad85520c">regina::BlockedSFS::isBlockedSFS</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga20c43d8cbb034623e886011cad85520c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a blocked Seifert fibred space.  <a href="group__subcomplex.html#ga20c43d8cbb034623e886011cad85520c">More...</a><br /></td></tr>
<tr class="separator:ga20c43d8cbb034623e886011cad85520c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04350ba48303730ce71487a4a08c5320"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga04350ba48303730ce71487a4a08c5320">regina::BlockedSFSLoop::~BlockedSFSLoop</a> ()</td></tr>
<tr class="memdesc:ga04350ba48303730ce71487a4a08c5320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its constituent components.  <a href="group__subcomplex.html#ga04350ba48303730ce71487a4a08c5320">More...</a><br /></td></tr>
<tr class="separator:ga04350ba48303730ce71487a4a08c5320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca70a6716fa34ba23c83667d1b5bafe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8ca70a6716fa34ba23c83667d1b5bafe">regina::BlockedSFSLoop::region</a> () const</td></tr>
<tr class="memdesc:ga8ca70a6716fa34ba23c83667d1b5bafe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the saturated region from which this triangulation is formed.  <a href="group__subcomplex.html#ga8ca70a6716fa34ba23c83667d1b5bafe">More...</a><br /></td></tr>
<tr class="separator:ga8ca70a6716fa34ba23c83667d1b5bafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700ac73cf8df31fafb66394a8a6468d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga700ac73cf8df31fafb66394a8a6468d9">regina::BlockedSFSLoop::matchingReln</a> () const</td></tr>
<tr class="memdesc:ga700ac73cf8df31fafb66394a8a6468d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two torus boundaries of the saturated region are joined.  <a href="group__subcomplex.html#ga700ac73cf8df31fafb66394a8a6468d9">More...</a><br /></td></tr>
<tr class="separator:ga700ac73cf8df31fafb66394a8a6468d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b581576665e5909a2fbb75f8c9611c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab3b581576665e5909a2fbb75f8c9611c">regina::BlockedSFSLoop::manifold</a> () const override</td></tr>
<tr class="memdesc:gab3b581576665e5909a2fbb75f8c9611c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gab3b581576665e5909a2fbb75f8c9611c">More...</a><br /></td></tr>
<tr class="separator:gab3b581576665e5909a2fbb75f8c9611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94a79bcee7ed6a6ba814b1051ed33d9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae94a79bcee7ed6a6ba814b1051ed33d9">regina::BlockedSFSLoop::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gae94a79bcee7ed6a6ba814b1051ed33d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gae94a79bcee7ed6a6ba814b1051ed33d9">More...</a><br /></td></tr>
<tr class="separator:gae94a79bcee7ed6a6ba814b1051ed33d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9751385499fdd8e89ca8d02b0095e9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabb9751385499fdd8e89ca8d02b0095e9">regina::BlockedSFSLoop::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gabb9751385499fdd8e89ca8d02b0095e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#gabb9751385499fdd8e89ca8d02b0095e9">More...</a><br /></td></tr>
<tr class="separator:gabb9751385499fdd8e89ca8d02b0095e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed6371374a10a805c612b5f82eef296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2ed6371374a10a805c612b5f82eef296">regina::BlockedSFSLoop::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga2ed6371374a10a805c612b5f82eef296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga2ed6371374a10a805c612b5f82eef296">More...</a><br /></td></tr>
<tr class="separator:ga2ed6371374a10a805c612b5f82eef296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1896c923afd5b415b7667fbb7b733ce2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1BlockedSFSLoop.html">BlockedSFSLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1896c923afd5b415b7667fbb7b733ce2">regina::BlockedSFSLoop::isBlockedSFSLoop</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga1896c923afd5b415b7667fbb7b733ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a blocked Seifert fibred space with identified boundaries, as described by this class.  <a href="group__subcomplex.html#ga1896c923afd5b415b7667fbb7b733ce2">More...</a><br /></td></tr>
<tr class="separator:ga1896c923afd5b415b7667fbb7b733ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d106ce2902b57c3bd52639322d005b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga71d106ce2902b57c3bd52639322d005b">regina::BlockedSFSPair::~BlockedSFSPair</a> ()</td></tr>
<tr class="memdesc:ga71d106ce2902b57c3bd52639322d005b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its constituent components.  <a href="group__subcomplex.html#ga71d106ce2902b57c3bd52639322d005b">More...</a><br /></td></tr>
<tr class="separator:ga71d106ce2902b57c3bd52639322d005b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a17c8ef49b0ddef5dccd37d954f65e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga13a17c8ef49b0ddef5dccd37d954f65e">regina::BlockedSFSPair::region</a> (int which) const</td></tr>
<tr class="memdesc:ga13a17c8ef49b0ddef5dccd37d954f65e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of one of the two bounded saturated regions that form this triangulation.  <a href="group__subcomplex.html#ga13a17c8ef49b0ddef5dccd37d954f65e">More...</a><br /></td></tr>
<tr class="separator:ga13a17c8ef49b0ddef5dccd37d954f65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f426a237c0308b53471c651d8102b40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2f426a237c0308b53471c651d8102b40">regina::BlockedSFSPair::matchingReln</a> () const</td></tr>
<tr class="memdesc:ga2f426a237c0308b53471c651d8102b40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two saturated region boundaries are joined.  <a href="group__subcomplex.html#ga2f426a237c0308b53471c651d8102b40">More...</a><br /></td></tr>
<tr class="separator:ga2f426a237c0308b53471c651d8102b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cac0e968863ec7fff63d6475f1e8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac7cac0e968863ec7fff63d6475f1e8ae">regina::BlockedSFSPair::manifold</a> () const override</td></tr>
<tr class="memdesc:gac7cac0e968863ec7fff63d6475f1e8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gac7cac0e968863ec7fff63d6475f1e8ae">More...</a><br /></td></tr>
<tr class="separator:gac7cac0e968863ec7fff63d6475f1e8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecafe5270c65cf39f36ae25b75d2269e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaecafe5270c65cf39f36ae25b75d2269e">regina::BlockedSFSPair::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaecafe5270c65cf39f36ae25b75d2269e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gaecafe5270c65cf39f36ae25b75d2269e">More...</a><br /></td></tr>
<tr class="separator:gaecafe5270c65cf39f36ae25b75d2269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42bd0a8dc34b89a0ac20f96d0616f657"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga42bd0a8dc34b89a0ac20f96d0616f657">regina::BlockedSFSPair::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga42bd0a8dc34b89a0ac20f96d0616f657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga42bd0a8dc34b89a0ac20f96d0616f657">More...</a><br /></td></tr>
<tr class="separator:ga42bd0a8dc34b89a0ac20f96d0616f657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44d8e2931379c7b16b1df400205363e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf44d8e2931379c7b16b1df400205363e">regina::BlockedSFSPair::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf44d8e2931379c7b16b1df400205363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gaf44d8e2931379c7b16b1df400205363e">More...</a><br /></td></tr>
<tr class="separator:gaf44d8e2931379c7b16b1df400205363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f31f0afd954c6a3ec73dd9c421c7b5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1BlockedSFSPair.html">BlockedSFSPair</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga16f31f0afd954c6a3ec73dd9c421c7b5">regina::BlockedSFSPair::isBlockedSFSPair</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga16f31f0afd954c6a3ec73dd9c421c7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a blocked pair of Seifert fibred spaces, as described by this class.  <a href="group__subcomplex.html#ga16f31f0afd954c6a3ec73dd9c421c7b5">More...</a><br /></td></tr>
<tr class="separator:ga16f31f0afd954c6a3ec73dd9c421c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257511835ac6ed0ff98e4ddf34a22b9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga257511835ac6ed0ff98e4ddf34a22b9e">regina::BlockedSFSTriple::~BlockedSFSTriple</a> ()</td></tr>
<tr class="memdesc:ga257511835ac6ed0ff98e4ddf34a22b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its constituent components.  <a href="group__subcomplex.html#ga257511835ac6ed0ff98e4ddf34a22b9e">More...</a><br /></td></tr>
<tr class="separator:ga257511835ac6ed0ff98e4ddf34a22b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c00920c51d6bda6c447107c43065b32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1c00920c51d6bda6c447107c43065b32">regina::BlockedSFSTriple::end</a> (int which) const</td></tr>
<tr class="memdesc:ga1c00920c51d6bda6c447107c43065b32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested end region, as described in the class notes above.  <a href="group__subcomplex.html#ga1c00920c51d6bda6c447107c43065b32">More...</a><br /></td></tr>
<tr class="separator:ga1c00920c51d6bda6c447107c43065b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d837a20c3e34cba43b4042a31d579e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4d837a20c3e34cba43b4042a31d579e3">regina::BlockedSFSTriple::centre</a> () const</td></tr>
<tr class="memdesc:ga4d837a20c3e34cba43b4042a31d579e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the central saturated region, as described in the class notes above.  <a href="group__subcomplex.html#ga4d837a20c3e34cba43b4042a31d579e3">More...</a><br /></td></tr>
<tr class="separator:ga4d837a20c3e34cba43b4042a31d579e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cb3062e81744d647f61d33e105ca3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga09cb3062e81744d647f61d33e105ca3f">regina::BlockedSFSTriple::matchingReln</a> (int which) const</td></tr>
<tr class="memdesc:ga09cb3062e81744d647f61d33e105ca3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the given end region is joined to the central region.  <a href="group__subcomplex.html#ga09cb3062e81744d647f61d33e105ca3f">More...</a><br /></td></tr>
<tr class="separator:ga09cb3062e81744d647f61d33e105ca3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b816d801e761d91593aa46733f33b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1b816d801e761d91593aa46733f33b6d">regina::BlockedSFSTriple::manifold</a> () const override</td></tr>
<tr class="memdesc:ga1b816d801e761d91593aa46733f33b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga1b816d801e761d91593aa46733f33b6d">More...</a><br /></td></tr>
<tr class="separator:ga1b816d801e761d91593aa46733f33b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5bc7667dbbe53c399f1cf9eeef3080"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaf5bc7667dbbe53c399f1cf9eeef3080">regina::BlockedSFSTriple::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaaf5bc7667dbbe53c399f1cf9eeef3080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gaaf5bc7667dbbe53c399f1cf9eeef3080">More...</a><br /></td></tr>
<tr class="separator:gaaf5bc7667dbbe53c399f1cf9eeef3080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29abbf245780e0394b9495c4472faf5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa29abbf245780e0394b9495c4472faf5">regina::BlockedSFSTriple::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaa29abbf245780e0394b9495c4472faf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#gaa29abbf245780e0394b9495c4472faf5">More...</a><br /></td></tr>
<tr class="separator:gaa29abbf245780e0394b9495c4472faf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1204d734453ff396ed67e8d4932638c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1204d734453ff396ed67e8d4932638c7">regina::BlockedSFSTriple::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga1204d734453ff396ed67e8d4932638c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga1204d734453ff396ed67e8d4932638c7">More...</a><br /></td></tr>
<tr class="separator:ga1204d734453ff396ed67e8d4932638c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0405ab30711d5dcf81cee91157ebce92"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1BlockedSFSTriple.html">BlockedSFSTriple</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0405ab30711d5dcf81cee91157ebce92">regina::BlockedSFSTriple::isBlockedSFSTriple</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga0405ab30711d5dcf81cee91157ebce92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a blocked sequence of three Seifert fibred spaces, as described in the class notes above.  <a href="group__subcomplex.html#ga0405ab30711d5dcf81cee91157ebce92">More...</a><br /></td></tr>
<tr class="separator:ga0405ab30711d5dcf81cee91157ebce92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac67160931a1cc60efdccbc4134694a46"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac67160931a1cc60efdccbc4134694a46">regina::L31Pillow::~L31Pillow</a> ()</td></tr>
<tr class="memdesc:gac67160931a1cc60efdccbc4134694a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure.  <a href="group__subcomplex.html#gac67160931a1cc60efdccbc4134694a46">More...</a><br /></td></tr>
<tr class="separator:gac67160931a1cc60efdccbc4134694a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8a3de489a4aab63f5e4f87f389618d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6f8a3de489a4aab63f5e4f87f389618d">regina::L31Pillow::clone</a> () const</td></tr>
<tr class="memdesc:ga6f8a3de489a4aab63f5e4f87f389618d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga6f8a3de489a4aab63f5e4f87f389618d">More...</a><br /></td></tr>
<tr class="separator:ga6f8a3de489a4aab63f5e4f87f389618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c00c92de980b307b8c862b4a7c17ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa8c00c92de980b307b8c862b4a7c17ce">regina::L31Pillow::tetrahedron</a> (int whichTet) const</td></tr>
<tr class="memdesc:gaa8c00c92de980b307b8c862b4a7c17ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedra involved in this structure.  <a href="group__subcomplex.html#gaa8c00c92de980b307b8c862b4a7c17ce">More...</a><br /></td></tr>
<tr class="separator:gaa8c00c92de980b307b8c862b4a7c17ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2aea7f8ba81fb76dd3e4c9ed264dee5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae2aea7f8ba81fb76dd3e4c9ed264dee5">regina::L31Pillow::interiorVertex</a> (int whichTet) const</td></tr>
<tr class="memdesc:gae2aea7f8ba81fb76dd3e4c9ed264dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the vertex number of the given tetrahedron corresponding to the degree three vertex in the interior of the triangular pillow.  <a href="group__subcomplex.html#gae2aea7f8ba81fb76dd3e4c9ed264dee5">More...</a><br /></td></tr>
<tr class="separator:gae2aea7f8ba81fb76dd3e4c9ed264dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046d6f000ee834ef3093443b91a954be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga046d6f000ee834ef3093443b91a954be">regina::L31Pillow::isL31Pillow</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga046d6f000ee834ef3093443b91a954be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is a triangular pillow L(3,1).  <a href="group__subcomplex.html#ga046d6f000ee834ef3093443b91a954be">More...</a><br /></td></tr>
<tr class="separator:ga046d6f000ee834ef3093443b91a954be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f6501798e8c61766612e83153eddb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa3f6501798e8c61766612e83153eddb4">regina::L31Pillow::manifold</a> () const override</td></tr>
<tr class="memdesc:gaa3f6501798e8c61766612e83153eddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gaa3f6501798e8c61766612e83153eddb4">More...</a><br /></td></tr>
<tr class="separator:gaa3f6501798e8c61766612e83153eddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bcee0e29af6eec7a506247a092ad8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac5bcee0e29af6eec7a506247a092ad8d">regina::L31Pillow::homology</a> () const override</td></tr>
<tr class="memdesc:gac5bcee0e29af6eec7a506247a092ad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gac5bcee0e29af6eec7a506247a092ad8d">More...</a><br /></td></tr>
<tr class="separator:gac5bcee0e29af6eec7a506247a092ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc8652135bc2920f809dd59bba7ffc6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5fc8652135bc2920f809dd59bba7ffc6">regina::L31Pillow::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga5fc8652135bc2920f809dd59bba7ffc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga5fc8652135bc2920f809dd59bba7ffc6">More...</a><br /></td></tr>
<tr class="separator:ga5fc8652135bc2920f809dd59bba7ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36eb0e668f12d2f02420c7fd647f8478"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga36eb0e668f12d2f02420c7fd647f8478">regina::L31Pillow::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga36eb0e668f12d2f02420c7fd647f8478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga36eb0e668f12d2f02420c7fd647f8478">More...</a><br /></td></tr>
<tr class="separator:ga36eb0e668f12d2f02420c7fd647f8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e886cf39d12c090959c64ab4787a883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0e886cf39d12c090959c64ab4787a883">regina::L31Pillow::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0e886cf39d12c090959c64ab4787a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga0e886cf39d12c090959c64ab4787a883">More...</a><br /></td></tr>
<tr class="separator:ga0e886cf39d12c090959c64ab4787a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5449fe384c23e2b570fa76000b25bbe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5449fe384c23e2b570fa76000b25bbe4">regina::LayeredChain::LayeredChain</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; vertexRoles)</td></tr>
<tr class="memdesc:ga5449fe384c23e2b570fa76000b25bbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new layered chain containing only the given tetrahedron.  <a href="group__subcomplex.html#ga5449fe384c23e2b570fa76000b25bbe4">More...</a><br /></td></tr>
<tr class="separator:ga5449fe384c23e2b570fa76000b25bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36031be7947e57d48376bc1728b9a0b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga36031be7947e57d48376bc1728b9a0b5">regina::LayeredChain::LayeredChain</a> (const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga36031be7947e57d48376bc1728b9a0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new layered chain that is a clone of the given structure.  <a href="group__subcomplex.html#ga36031be7947e57d48376bc1728b9a0b5">More...</a><br /></td></tr>
<tr class="separator:ga36031be7947e57d48376bc1728b9a0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c5f5c6057993baac2a5d54c745bfcb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab2c5f5c6057993baac2a5d54c745bfcb">regina::LayeredChain::~LayeredChain</a> ()</td></tr>
<tr class="memdesc:gab2c5f5c6057993baac2a5d54c745bfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this layered chain.  <a href="group__subcomplex.html#gab2c5f5c6057993baac2a5d54c745bfcb">More...</a><br /></td></tr>
<tr class="separator:gab2c5f5c6057993baac2a5d54c745bfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ebf8a8cdd78af3af5cc97999ed96cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4ebf8a8cdd78af3af5cc97999ed96cee">regina::LayeredChain::bottom</a> () const</td></tr>
<tr class="memdesc:ga4ebf8a8cdd78af3af5cc97999ed96cee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bottom tetrahedron of this layered chain.  <a href="group__subcomplex.html#ga4ebf8a8cdd78af3af5cc97999ed96cee">More...</a><br /></td></tr>
<tr class="separator:ga4ebf8a8cdd78af3af5cc97999ed96cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb73be0df49c8de341997dcc3f77306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaacb73be0df49c8de341997dcc3f77306">regina::LayeredChain::top</a> () const</td></tr>
<tr class="memdesc:gaacb73be0df49c8de341997dcc3f77306"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top tetrahedron of this layered chain.  <a href="group__subcomplex.html#gaacb73be0df49c8de341997dcc3f77306">More...</a><br /></td></tr>
<tr class="separator:gaacb73be0df49c8de341997dcc3f77306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0ac74262853d183cb0bc125a83b2c4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaca0ac74262853d183cb0bc125a83b2c4">regina::LayeredChain::index</a> () const</td></tr>
<tr class="memdesc:gaca0ac74262853d183cb0bc125a83b2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this layered chain.  <a href="group__subcomplex.html#gaca0ac74262853d183cb0bc125a83b2c4">More...</a><br /></td></tr>
<tr class="separator:gaca0ac74262853d183cb0bc125a83b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63c20b1c4b1ab485ba73af93e5f4fa09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga63c20b1c4b1ab485ba73af93e5f4fa09">regina::LayeredChain::bottomVertexRoles</a> () const</td></tr>
<tr class="memdesc:ga63c20b1c4b1ab485ba73af93e5f4fa09"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the bottom tetrahedron plays in the layered chain.  <a href="group__subcomplex.html#ga63c20b1c4b1ab485ba73af93e5f4fa09">More...</a><br /></td></tr>
<tr class="separator:ga63c20b1c4b1ab485ba73af93e5f4fa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7604b4366f6cecd2df0bcf81d67852fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7604b4366f6cecd2df0bcf81d67852fe">regina::LayeredChain::topVertexRoles</a> () const</td></tr>
<tr class="memdesc:ga7604b4366f6cecd2df0bcf81d67852fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the top tetrahedron plays in the layered chain.  <a href="group__subcomplex.html#ga7604b4366f6cecd2df0bcf81d67852fe">More...</a><br /></td></tr>
<tr class="separator:ga7604b4366f6cecd2df0bcf81d67852fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf39b2d736d35ab0be374d191a68f1951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf39b2d736d35ab0be374d191a68f1951">regina::LayeredChain::extendAbove</a> ()</td></tr>
<tr class="memdesc:gaf39b2d736d35ab0be374d191a68f1951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether this layered chain can be extended to include the tetrahedron above the top tetrahedron (and still remain a layered chain).  <a href="group__subcomplex.html#gaf39b2d736d35ab0be374d191a68f1951">More...</a><br /></td></tr>
<tr class="separator:gaf39b2d736d35ab0be374d191a68f1951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5977fb7fe0cabde3a8712327b7434ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5977fb7fe0cabde3a8712327b7434ba0">regina::LayeredChain::extendBelow</a> ()</td></tr>
<tr class="memdesc:ga5977fb7fe0cabde3a8712327b7434ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether this layered chain can be extended to include the tetrahedron below the bottom tetrahedron (and still remain a layered chain).  <a href="group__subcomplex.html#ga5977fb7fe0cabde3a8712327b7434ba0">More...</a><br /></td></tr>
<tr class="separator:ga5977fb7fe0cabde3a8712327b7434ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed0c53621cb17684707a65e59229771"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabed0c53621cb17684707a65e59229771">regina::LayeredChain::extendMaximal</a> ()</td></tr>
<tr class="memdesc:gabed0c53621cb17684707a65e59229771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends this layered chain to a maximal length layered chain.  <a href="group__subcomplex.html#gabed0c53621cb17684707a65e59229771">More...</a><br /></td></tr>
<tr class="separator:gabed0c53621cb17684707a65e59229771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42388f03d605c4700f94a68c1003a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga42388f03d605c4700f94a68c1003a104">regina::LayeredChain::reverse</a> ()</td></tr>
<tr class="memdesc:ga42388f03d605c4700f94a68c1003a104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses this layered chain so the top tetrahedron becomes the bottom and vice versa.  <a href="group__subcomplex.html#ga42388f03d605c4700f94a68c1003a104">More...</a><br /></td></tr>
<tr class="separator:ga42388f03d605c4700f94a68c1003a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9b727fc646ae10eeb1cab0c1bf9f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9d9b727fc646ae10eeb1cab0c1bf9f1a">regina::LayeredChain::invert</a> ()</td></tr>
<tr class="memdesc:ga9d9b727fc646ae10eeb1cab0c1bf9f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts this layered chain so the upper hinge becomes the lower and vice versa.  <a href="group__subcomplex.html#ga9d9b727fc646ae10eeb1cab0c1bf9f1a">More...</a><br /></td></tr>
<tr class="separator:ga9d9b727fc646ae10eeb1cab0c1bf9f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c63608de42c66a9b33385a30e911b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac7c63608de42c66a9b33385a30e911b8">regina::LayeredChain::manifold</a> () const override</td></tr>
<tr class="memdesc:gac7c63608de42c66a9b33385a30e911b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gac7c63608de42c66a9b33385a30e911b8">More...</a><br /></td></tr>
<tr class="separator:gac7c63608de42c66a9b33385a30e911b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60751ca7ff06b9ec2ceb3efc80c8d468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga60751ca7ff06b9ec2ceb3efc80c8d468">regina::LayeredChain::homology</a> () const override</td></tr>
<tr class="memdesc:ga60751ca7ff06b9ec2ceb3efc80c8d468"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga60751ca7ff06b9ec2ceb3efc80c8d468">More...</a><br /></td></tr>
<tr class="separator:ga60751ca7ff06b9ec2ceb3efc80c8d468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146ca193c489eed78b7b26ffeb830576"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga146ca193c489eed78b7b26ffeb830576">regina::LayeredChain::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga146ca193c489eed78b7b26ffeb830576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga146ca193c489eed78b7b26ffeb830576">More...</a><br /></td></tr>
<tr class="separator:ga146ca193c489eed78b7b26ffeb830576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475bb023d836a974f69721e3646d6018"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga475bb023d836a974f69721e3646d6018">regina::LayeredChain::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga475bb023d836a974f69721e3646d6018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga475bb023d836a974f69721e3646d6018">More...</a><br /></td></tr>
<tr class="separator:ga475bb023d836a974f69721e3646d6018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc747857e0e15305fd7e7f59754cd4d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadc747857e0e15305fd7e7f59754cd4d8">regina::LayeredChain::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gadc747857e0e15305fd7e7f59754cd4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gadc747857e0e15305fd7e7f59754cd4d8">More...</a><br /></td></tr>
<tr class="separator:gadc747857e0e15305fd7e7f59754cd4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628b9acf04b84e7a07e99cc2884f4ec5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga628b9acf04b84e7a07e99cc2884f4ec5">regina::LayeredChainPair::~LayeredChainPair</a> ()</td></tr>
<tr class="memdesc:ga628b9acf04b84e7a07e99cc2884f4ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this layered chain pair.  <a href="group__subcomplex.html#ga628b9acf04b84e7a07e99cc2884f4ec5">More...</a><br /></td></tr>
<tr class="separator:ga628b9acf04b84e7a07e99cc2884f4ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce208542994a4f477d41358d639e706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6ce208542994a4f477d41358d639e706">regina::LayeredChainPair::clone</a> () const</td></tr>
<tr class="memdesc:ga6ce208542994a4f477d41358d639e706"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga6ce208542994a4f477d41358d639e706">More...</a><br /></td></tr>
<tr class="separator:ga6ce208542994a4f477d41358d639e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5eb96cc71beb6bc77b4f482348dcad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4a5eb96cc71beb6bc77b4f482348dcad">regina::LayeredChainPair::chain</a> (int which) const</td></tr>
<tr class="memdesc:ga4a5eb96cc71beb6bc77b4f482348dcad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested layered chain used to form this structure.  <a href="group__subcomplex.html#ga4a5eb96cc71beb6bc77b4f482348dcad">More...</a><br /></td></tr>
<tr class="separator:ga4a5eb96cc71beb6bc77b4f482348dcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccec6e8eca529ae81cda400e014823d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaccec6e8eca529ae81cda400e014823d1">regina::LayeredChainPair::isLayeredChainPair</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:gaccec6e8eca529ae81cda400e014823d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is a layered chain pair.  <a href="group__subcomplex.html#gaccec6e8eca529ae81cda400e014823d1">More...</a><br /></td></tr>
<tr class="separator:gaccec6e8eca529ae81cda400e014823d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76605d4e5441075637634e6204f8e0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga76605d4e5441075637634e6204f8e0a1">regina::LayeredChainPair::manifold</a> () const override</td></tr>
<tr class="memdesc:ga76605d4e5441075637634e6204f8e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga76605d4e5441075637634e6204f8e0a1">More...</a><br /></td></tr>
<tr class="separator:ga76605d4e5441075637634e6204f8e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085eee274563501755e876261eaae243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga085eee274563501755e876261eaae243">regina::LayeredChainPair::homology</a> () const override</td></tr>
<tr class="memdesc:ga085eee274563501755e876261eaae243"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga085eee274563501755e876261eaae243">More...</a><br /></td></tr>
<tr class="separator:ga085eee274563501755e876261eaae243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8b36a4a2e18d04270e9daed8e30b2e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gace8b36a4a2e18d04270e9daed8e30b2e">regina::LayeredChainPair::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gace8b36a4a2e18d04270e9daed8e30b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gace8b36a4a2e18d04270e9daed8e30b2e">More...</a><br /></td></tr>
<tr class="separator:gace8b36a4a2e18d04270e9daed8e30b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dabc2ccc16d5da29f3efc549354e86"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga47dabc2ccc16d5da29f3efc549354e86">regina::LayeredChainPair::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga47dabc2ccc16d5da29f3efc549354e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga47dabc2ccc16d5da29f3efc549354e86">More...</a><br /></td></tr>
<tr class="separator:ga47dabc2ccc16d5da29f3efc549354e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd44940e8690d4efa5fead8c5b8de349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacd44940e8690d4efa5fead8c5b8de349">regina::LayeredChainPair::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gacd44940e8690d4efa5fead8c5b8de349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gacd44940e8690d4efa5fead8c5b8de349">More...</a><br /></td></tr>
<tr class="separator:gacd44940e8690d4efa5fead8c5b8de349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89826ae497eab85ee80cf649bd4cfd36"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga89826ae497eab85ee80cf649bd4cfd36">regina::LayeredLensSpace::~LayeredLensSpace</a> ()</td></tr>
<tr class="memdesc:ga89826ae497eab85ee80cf649bd4cfd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this lens space; note that the corresponding layered solid torus will also be destroyed.  <a href="group__subcomplex.html#ga89826ae497eab85ee80cf649bd4cfd36">More...</a><br /></td></tr>
<tr class="separator:ga89826ae497eab85ee80cf649bd4cfd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f74c6d8c8449fec6c443db265e2424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa1f74c6d8c8449fec6c443db265e2424">regina::LayeredLensSpace::clone</a> () const</td></tr>
<tr class="memdesc:gaa1f74c6d8c8449fec6c443db265e2424"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#gaa1f74c6d8c8449fec6c443db265e2424">More...</a><br /></td></tr>
<tr class="separator:gaa1f74c6d8c8449fec6c443db265e2424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bcc7a4e0c35b841f20cc0bd43f008aa"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1bcc7a4e0c35b841f20cc0bd43f008aa">regina::LayeredLensSpace::p</a> () const</td></tr>
<tr class="memdesc:ga1bcc7a4e0c35b841f20cc0bd43f008aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first parameter <em>p</em> of this lens space L(p,q).  <a href="group__subcomplex.html#ga1bcc7a4e0c35b841f20cc0bd43f008aa">More...</a><br /></td></tr>
<tr class="separator:ga1bcc7a4e0c35b841f20cc0bd43f008aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cfb30b05a416384a2d076ed26ea335b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7cfb30b05a416384a2d076ed26ea335b">regina::LayeredLensSpace::q</a> () const</td></tr>
<tr class="memdesc:ga7cfb30b05a416384a2d076ed26ea335b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second parameter <em>q</em> of this lens space L(p,q).  <a href="group__subcomplex.html#ga7cfb30b05a416384a2d076ed26ea335b">More...</a><br /></td></tr>
<tr class="separator:ga7cfb30b05a416384a2d076ed26ea335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5106950b750dde99e7894722b1fd20fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5106950b750dde99e7894722b1fd20fd">regina::LayeredLensSpace::torus</a> () const</td></tr>
<tr class="memdesc:ga5106950b750dde99e7894722b1fd20fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus to which the mobius strip is glued.  <a href="group__subcomplex.html#ga5106950b750dde99e7894722b1fd20fd">More...</a><br /></td></tr>
<tr class="separator:ga5106950b750dde99e7894722b1fd20fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d2e5fc3f15883cb14082366e55a570"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab9d2e5fc3f15883cb14082366e55a570">regina::LayeredLensSpace::mobiusBoundaryGroup</a> () const</td></tr>
<tr class="memdesc:gab9d2e5fc3f15883cb14082366e55a570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which edge of the layered solid torus is glued to the boundary of the mobius strip (i.e., the weight 2 edge of the degenerate (2,1,1) layered solid torus).  <a href="group__subcomplex.html#gab9d2e5fc3f15883cb14082366e55a570">More...</a><br /></td></tr>
<tr class="separator:gab9d2e5fc3f15883cb14082366e55a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad921715bbfd71029a4cbf9c76ba262"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaad921715bbfd71029a4cbf9c76ba262">regina::LayeredLensSpace::isSnapped</a> () const</td></tr>
<tr class="memdesc:gaaad921715bbfd71029a4cbf9c76ba262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the layered solid torus that forms the basis for this lens space is snapped shut (folded closed without a twist).  <a href="group__subcomplex.html#gaaad921715bbfd71029a4cbf9c76ba262">More...</a><br /></td></tr>
<tr class="separator:gaaad921715bbfd71029a4cbf9c76ba262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3f7665028d10ea46d5319cbb1a74da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafa3f7665028d10ea46d5319cbb1a74da">regina::LayeredLensSpace::isTwisted</a> () const</td></tr>
<tr class="memdesc:gafa3f7665028d10ea46d5319cbb1a74da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the layered solid torus that forms the basis for this lens space is twisted shut (folded closed with a twist).  <a href="group__subcomplex.html#gafa3f7665028d10ea46d5319cbb1a74da">More...</a><br /></td></tr>
<tr class="separator:gafa3f7665028d10ea46d5319cbb1a74da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c0886d3844794432f2fe3305c6d062"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga10c0886d3844794432f2fe3305c6d062">regina::LayeredLensSpace::isLayeredLensSpace</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga10c0886d3844794432f2fe3305c6d062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is a layered lens space.  <a href="group__subcomplex.html#ga10c0886d3844794432f2fe3305c6d062">More...</a><br /></td></tr>
<tr class="separator:ga10c0886d3844794432f2fe3305c6d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace21293e5bd3bc8eeffef8f53748b294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gace21293e5bd3bc8eeffef8f53748b294">regina::LayeredLensSpace::manifold</a> () const override</td></tr>
<tr class="memdesc:gace21293e5bd3bc8eeffef8f53748b294"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gace21293e5bd3bc8eeffef8f53748b294">More...</a><br /></td></tr>
<tr class="separator:gace21293e5bd3bc8eeffef8f53748b294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72695e0f78b243ab581e5f1668bb7f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga72695e0f78b243ab581e5f1668bb7f75">regina::LayeredLensSpace::homology</a> () const override</td></tr>
<tr class="memdesc:ga72695e0f78b243ab581e5f1668bb7f75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga72695e0f78b243ab581e5f1668bb7f75">More...</a><br /></td></tr>
<tr class="separator:ga72695e0f78b243ab581e5f1668bb7f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b991706522516fdc20d939bbb38acc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga31b991706522516fdc20d939bbb38acc">regina::LayeredLensSpace::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga31b991706522516fdc20d939bbb38acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga31b991706522516fdc20d939bbb38acc">More...</a><br /></td></tr>
<tr class="separator:ga31b991706522516fdc20d939bbb38acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3009d8827ebbcec49fcafb89c3ea06ca"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3009d8827ebbcec49fcafb89c3ea06ca">regina::LayeredLensSpace::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga3009d8827ebbcec49fcafb89c3ea06ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga3009d8827ebbcec49fcafb89c3ea06ca">More...</a><br /></td></tr>
<tr class="separator:ga3009d8827ebbcec49fcafb89c3ea06ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc54288677ea5caef65896ad25f4e95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadc54288677ea5caef65896ad25f4e95b">regina::LayeredLensSpace::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gadc54288677ea5caef65896ad25f4e95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gadc54288677ea5caef65896ad25f4e95b">More...</a><br /></td></tr>
<tr class="separator:gadc54288677ea5caef65896ad25f4e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c59674afef403d5c3bc034d299a2cc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga53c59674afef403d5c3bc034d299a2cc">regina::LayeredLoop::~LayeredLoop</a> ()</td></tr>
<tr class="memdesc:ga53c59674afef403d5c3bc034d299a2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this layered loop.  <a href="group__subcomplex.html#ga53c59674afef403d5c3bc034d299a2cc">More...</a><br /></td></tr>
<tr class="separator:ga53c59674afef403d5c3bc034d299a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd935f8b7f591edef5f3e3724ff8702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1fd935f8b7f591edef5f3e3724ff8702">regina::LayeredLoop::clone</a> () const</td></tr>
<tr class="memdesc:ga1fd935f8b7f591edef5f3e3724ff8702"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga1fd935f8b7f591edef5f3e3724ff8702">More...</a><br /></td></tr>
<tr class="separator:ga1fd935f8b7f591edef5f3e3724ff8702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f45c7012d837efbd29b227795a27e8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad5f45c7012d837efbd29b227795a27e8">regina::LayeredLoop::length</a> () const</td></tr>
<tr class="memdesc:gad5f45c7012d837efbd29b227795a27e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of this layered loop.  <a href="group__subcomplex.html#gad5f45c7012d837efbd29b227795a27e8">More...</a><br /></td></tr>
<tr class="separator:gad5f45c7012d837efbd29b227795a27e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga158132bf103660b079000084423e54c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga158132bf103660b079000084423e54c6">regina::LayeredLoop::isTwisted</a> () const</td></tr>
<tr class="memdesc:ga158132bf103660b079000084423e54c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this layered loop contains a twist.  <a href="group__subcomplex.html#ga158132bf103660b079000084423e54c6">More...</a><br /></td></tr>
<tr class="separator:ga158132bf103660b079000084423e54c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5337de9a6540d096f7b91ae7353d7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacb5337de9a6540d096f7b91ae7353d7f">regina::LayeredLoop::hinge</a> (int which) const</td></tr>
<tr class="memdesc:gacb5337de9a6540d096f7b91ae7353d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested hinge edge of this layered loop.  <a href="group__subcomplex.html#gacb5337de9a6540d096f7b91ae7353d7f">More...</a><br /></td></tr>
<tr class="separator:gacb5337de9a6540d096f7b91ae7353d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02fd4f302e6956248be614064c37c182"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga02fd4f302e6956248be614064c37c182">regina::LayeredLoop::isLayeredLoop</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga02fd4f302e6956248be614064c37c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is a layered loop.  <a href="group__subcomplex.html#ga02fd4f302e6956248be614064c37c182">More...</a><br /></td></tr>
<tr class="separator:ga02fd4f302e6956248be614064c37c182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd1a02ce36d5400809d861c87a91558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaadd1a02ce36d5400809d861c87a91558">regina::LayeredLoop::manifold</a> () const override</td></tr>
<tr class="memdesc:gaadd1a02ce36d5400809d861c87a91558"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gaadd1a02ce36d5400809d861c87a91558">More...</a><br /></td></tr>
<tr class="separator:gaadd1a02ce36d5400809d861c87a91558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0181ec84dab4d3a390ace2ebe0639e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae0181ec84dab4d3a390ace2ebe0639e2">regina::LayeredLoop::homology</a> () const override</td></tr>
<tr class="memdesc:gae0181ec84dab4d3a390ace2ebe0639e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gae0181ec84dab4d3a390ace2ebe0639e2">More...</a><br /></td></tr>
<tr class="separator:gae0181ec84dab4d3a390ace2ebe0639e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be965e2c0456e2d5c88f09dd897baf9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1be965e2c0456e2d5c88f09dd897baf9">regina::LayeredLoop::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga1be965e2c0456e2d5c88f09dd897baf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga1be965e2c0456e2d5c88f09dd897baf9">More...</a><br /></td></tr>
<tr class="separator:ga1be965e2c0456e2d5c88f09dd897baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a24af535d51502874624ed86aefb4f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga38a24af535d51502874624ed86aefb4f">regina::LayeredLoop::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga38a24af535d51502874624ed86aefb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga38a24af535d51502874624ed86aefb4f">More...</a><br /></td></tr>
<tr class="separator:ga38a24af535d51502874624ed86aefb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566d5c530d931e15893ca17018b2f216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga566d5c530d931e15893ca17018b2f216">regina::LayeredLoop::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga566d5c530d931e15893ca17018b2f216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga566d5c530d931e15893ca17018b2f216">More...</a><br /></td></tr>
<tr class="separator:ga566d5c530d931e15893ca17018b2f216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38473265bdeebb5764c212fec1836f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga38473265bdeebb5764c212fec1836f1c">regina::LayeredSolidTorus::clone</a> () const</td></tr>
<tr class="memdesc:ga38473265bdeebb5764c212fec1836f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga38473265bdeebb5764c212fec1836f1c">More...</a><br /></td></tr>
<tr class="separator:ga38473265bdeebb5764c212fec1836f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19bebe108f5548a9a54906ff125eea76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga19bebe108f5548a9a54906ff125eea76">regina::LayeredSolidTorus::size</a> () const</td></tr>
<tr class="memdesc:ga19bebe108f5548a9a54906ff125eea76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this layered solid torus.  <a href="group__subcomplex.html#ga19bebe108f5548a9a54906ff125eea76">More...</a><br /></td></tr>
<tr class="separator:ga19bebe108f5548a9a54906ff125eea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd296866ba8065dac9502f99296f28bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadd296866ba8065dac9502f99296f28bb">regina::LayeredSolidTorus::base</a> () const</td></tr>
<tr class="memdesc:gadd296866ba8065dac9502f99296f28bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedron that is glued to itself at the base of this layered solid torus.  <a href="group__subcomplex.html#gadd296866ba8065dac9502f99296f28bb">More...</a><br /></td></tr>
<tr class="separator:gadd296866ba8065dac9502f99296f28bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe4f467fdcdf10f93cfa51add967408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1fe4f467fdcdf10f93cfa51add967408">regina::LayeredSolidTorus::baseEdge</a> (int group, int index) const</td></tr>
<tr class="memdesc:ga1fe4f467fdcdf10f93cfa51add967408"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested edge of the base tetrahedron belonging to the given group.  <a href="group__subcomplex.html#ga1fe4f467fdcdf10f93cfa51add967408">More...</a><br /></td></tr>
<tr class="separator:ga1fe4f467fdcdf10f93cfa51add967408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bef8d63cbb68b084b6f83eee9e4b46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae4bef8d63cbb68b084b6f83eee9e4b46">regina::LayeredSolidTorus::baseEdgeGroup</a> (int edge) const</td></tr>
<tr class="memdesc:gae4bef8d63cbb68b084b6f83eee9e4b46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the group that the given edge of the base tetrahedron belongs to.  <a href="group__subcomplex.html#gae4bef8d63cbb68b084b6f83eee9e4b46">More...</a><br /></td></tr>
<tr class="separator:gae4bef8d63cbb68b084b6f83eee9e4b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbc6675863e3d5b646ee2da41dd0c1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2cbc6675863e3d5b646ee2da41dd0c1c">regina::LayeredSolidTorus::baseFace</a> (int index) const</td></tr>
<tr class="memdesc:ga2cbc6675863e3d5b646ee2da41dd0c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two faces of the base tetrahedron that are glued to each other.  <a href="group__subcomplex.html#ga2cbc6675863e3d5b646ee2da41dd0c1c">More...</a><br /></td></tr>
<tr class="separator:ga2cbc6675863e3d5b646ee2da41dd0c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8b86fc53f94266fc2420df6aeb7361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5c8b86fc53f94266fc2420df6aeb7361">regina::LayeredSolidTorus::topLevel</a> () const</td></tr>
<tr class="memdesc:ga5c8b86fc53f94266fc2420df6aeb7361"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top level tetrahedron in this layered solid torus.  <a href="group__subcomplex.html#ga5c8b86fc53f94266fc2420df6aeb7361">More...</a><br /></td></tr>
<tr class="separator:ga5c8b86fc53f94266fc2420df6aeb7361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3b241365315391145ebe5fb7f7ad3c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1e3b241365315391145ebe5fb7f7ad3c">regina::LayeredSolidTorus::meridinalCuts</a> (int group) const</td></tr>
<tr class="memdesc:ga1e3b241365315391145ebe5fb7f7ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times the meridinal disc of the torus cuts the top level tetrahedron edges in the given group.  <a href="group__subcomplex.html#ga1e3b241365315391145ebe5fb7f7ad3c">More...</a><br /></td></tr>
<tr class="separator:ga1e3b241365315391145ebe5fb7f7ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8910645cf2e930df846536098d9a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34">regina::LayeredSolidTorus::topEdge</a> (int group, int index) const</td></tr>
<tr class="memdesc:ga0b8910645cf2e930df846536098d9a34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested edge of the top level tetrahedron belonging to the given group.  <a href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34">More...</a><br /></td></tr>
<tr class="separator:ga0b8910645cf2e930df846536098d9a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ba8a45362bc1ef93195913c4cc6b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga52ba8a45362bc1ef93195913c4cc6b9e">regina::LayeredSolidTorus::topEdgeGroup</a> (int edge) const</td></tr>
<tr class="memdesc:ga52ba8a45362bc1ef93195913c4cc6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the group that the given edge of the top level tetrahedron belongs to.  <a href="group__subcomplex.html#ga52ba8a45362bc1ef93195913c4cc6b9e">More...</a><br /></td></tr>
<tr class="separator:ga52ba8a45362bc1ef93195913c4cc6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba992cb747e96fe1da6ec884daffa4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafba992cb747e96fe1da6ec884daffa4d">regina::LayeredSolidTorus::topFace</a> (int index) const</td></tr>
<tr class="memdesc:gafba992cb747e96fe1da6ec884daffa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two faces of the top level tetrahedron that form the boundary of this layered solid torus.  <a href="group__subcomplex.html#gafba992cb747e96fe1da6ec884daffa4d">More...</a><br /></td></tr>
<tr class="separator:gafba992cb747e96fe1da6ec884daffa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27eeec34e19d156fad9d9e6ebc0032f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf27eeec34e19d156fad9d9e6ebc0032f">regina::LayeredSolidTorus::flatten</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *original, int mobiusBandBdry) const</td></tr>
<tr class="memdesc:gaf27eeec34e19d156fad9d9e6ebc0032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens this layered solid torus to a Mobius band.  <a href="group__subcomplex.html#gaf27eeec34e19d156fad9d9e6ebc0032f">More...</a><br /></td></tr>
<tr class="separator:gaf27eeec34e19d156fad9d9e6ebc0032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5a80dbeae803934a49a7be23241a55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacf5a80dbeae803934a49a7be23241a55">regina::LayeredSolidTorus::transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:gacf5a80dbeae803934a49a7be23241a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the details of this layered solid torus according to the given isomorphism between triangulations.  <a href="group__subcomplex.html#gacf5a80dbeae803934a49a7be23241a55">More...</a><br /></td></tr>
<tr class="separator:gacf5a80dbeae803934a49a7be23241a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a35647727585b3f7b7966cb0306205"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga34a35647727585b3f7b7966cb0306205">regina::LayeredSolidTorus::formsLayeredSolidTorusBase</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:ga34a35647727585b3f7b7966cb0306205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation.  <a href="group__subcomplex.html#ga34a35647727585b3f7b7966cb0306205">More...</a><br /></td></tr>
<tr class="separator:ga34a35647727585b3f7b7966cb0306205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e1fd9570fe5a2b7ed87c4a39dd73bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab5e1fd9570fe5a2b7ed87c4a39dd73bd">regina::LayeredSolidTorus::formsLayeredSolidTorusTop</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, unsigned topFace1, unsigned topFace2)</td></tr>
<tr class="memdesc:gab5e1fd9570fe5a2b7ed87c4a39dd73bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms the top level tetrahedron of a layered solid torus, with the two given faces of this tetrahedron representing the boundary of the layered solid torus.  <a href="group__subcomplex.html#gab5e1fd9570fe5a2b7ed87c4a39dd73bd">More...</a><br /></td></tr>
<tr class="separator:gab5e1fd9570fe5a2b7ed87c4a39dd73bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c732226884181905286eba38ab4817"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga80c732226884181905286eba38ab4817">regina::LayeredSolidTorus::isLayeredSolidTorus</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga80c732226884181905286eba38ab4817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component forms a layered solid torus in its entirity.  <a href="group__subcomplex.html#ga80c732226884181905286eba38ab4817">More...</a><br /></td></tr>
<tr class="separator:ga80c732226884181905286eba38ab4817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5567379e82bc16c285e8e2d332a404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gada5567379e82bc16c285e8e2d332a404">regina::LayeredSolidTorus::manifold</a> () const override</td></tr>
<tr class="memdesc:gada5567379e82bc16c285e8e2d332a404"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gada5567379e82bc16c285e8e2d332a404">More...</a><br /></td></tr>
<tr class="separator:gada5567379e82bc16c285e8e2d332a404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef96ee65b9fc3f337606d6eaaa96a869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaef96ee65b9fc3f337606d6eaaa96a869">regina::LayeredSolidTorus::homology</a> () const override</td></tr>
<tr class="memdesc:gaef96ee65b9fc3f337606d6eaaa96a869"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gaef96ee65b9fc3f337606d6eaaa96a869">More...</a><br /></td></tr>
<tr class="separator:gaef96ee65b9fc3f337606d6eaaa96a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d03cc2acaae8ef46a0c64d311b0e04"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga77d03cc2acaae8ef46a0c64d311b0e04">regina::LayeredSolidTorus::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga77d03cc2acaae8ef46a0c64d311b0e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga77d03cc2acaae8ef46a0c64d311b0e04">More...</a><br /></td></tr>
<tr class="separator:ga77d03cc2acaae8ef46a0c64d311b0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b26b8de06723564d00d023362df52a0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7b26b8de06723564d00d023362df52a0">regina::LayeredSolidTorus::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga7b26b8de06723564d00d023362df52a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga7b26b8de06723564d00d023362df52a0">More...</a><br /></td></tr>
<tr class="separator:ga7b26b8de06723564d00d023362df52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ef1bccde86445eb106d3bd1d866599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa8ef1bccde86445eb106d3bd1d866599">regina::LayeredSolidTorus::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaa8ef1bccde86445eb106d3bd1d866599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gaa8ef1bccde86445eb106d3bd1d866599">More...</a><br /></td></tr>
<tr class="separator:gaa8ef1bccde86445eb106d3bd1d866599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9534d53ae665aeb124ee7a6d18a4897"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac9534d53ae665aeb124ee7a6d18a4897">regina::LayeredTorusBundle::~LayeredTorusBundle</a> ()</td></tr>
<tr class="memdesc:gac9534d53ae665aeb124ee7a6d18a4897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this layered torus bundle and all of its internal components.  <a href="group__subcomplex.html#gac9534d53ae665aeb124ee7a6d18a4897">More...</a><br /></td></tr>
<tr class="separator:gac9534d53ae665aeb124ee7a6d18a4897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad714490fe0e05e211c3e72b968f679c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1">regina::LayeredTorusBundle::core</a> () const</td></tr>
<tr class="memdesc:gad714490fe0e05e211c3e72b968f679c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <code>T x I</code> triangulation at the core of this layered surface bundle.  <a href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1">More...</a><br /></td></tr>
<tr class="separator:gad714490fe0e05e211c3e72b968f679c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b20f538a0786df8458eb77c897fe4c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6b20f538a0786df8458eb77c897fe4c3">regina::LayeredTorusBundle::coreIso</a> () const</td></tr>
<tr class="memdesc:ga6b20f538a0786df8458eb77c897fe4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the isomorphism describing how the core <code>T x I</code> appears as a subcomplex of this layered surface bundle.  <a href="group__subcomplex.html#ga6b20f538a0786df8458eb77c897fe4c3">More...</a><br /></td></tr>
<tr class="separator:ga6b20f538a0786df8458eb77c897fe4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100043ce6619933fce5a17e15c2dfbef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga100043ce6619933fce5a17e15c2dfbef">regina::LayeredTorusBundle::layeringReln</a> () const</td></tr>
<tr class="memdesc:ga100043ce6619933fce5a17e15c2dfbef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing how the layering of tetrahedra relates curves on the two torus boundaries of the core <code>T x I</code>.  <a href="group__subcomplex.html#ga100043ce6619933fce5a17e15c2dfbef">More...</a><br /></td></tr>
<tr class="separator:ga100043ce6619933fce5a17e15c2dfbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cca6c475d77e161fcd280d0a13da420"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1LayeredTorusBundle.html">LayeredTorusBundle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8cca6c475d77e161fcd280d0a13da420">regina::LayeredTorusBundle::isLayeredTorusBundle</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga8cca6c475d77e161fcd280d0a13da420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a layered surface bundle.  <a href="group__subcomplex.html#ga8cca6c475d77e161fcd280d0a13da420">More...</a><br /></td></tr>
<tr class="separator:ga8cca6c475d77e161fcd280d0a13da420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeaf5e9116be3125f8bef1fa36b6c5d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaeaf5e9116be3125f8bef1fa36b6c5d2">regina::LayeredTorusBundle::manifold</a> () const override</td></tr>
<tr class="memdesc:gaaeaf5e9116be3125f8bef1fa36b6c5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gaaeaf5e9116be3125f8bef1fa36b6c5d2">More...</a><br /></td></tr>
<tr class="separator:gaaeaf5e9116be3125f8bef1fa36b6c5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c426c8fc83e6eab4585e63bd9dcb39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae4c426c8fc83e6eab4585e63bd9dcb39">regina::LayeredTorusBundle::homology</a> () const override</td></tr>
<tr class="memdesc:gae4c426c8fc83e6eab4585e63bd9dcb39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gae4c426c8fc83e6eab4585e63bd9dcb39">More...</a><br /></td></tr>
<tr class="separator:gae4c426c8fc83e6eab4585e63bd9dcb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7030c630c47f79f355fff640be314a4c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7030c630c47f79f355fff640be314a4c">regina::LayeredTorusBundle::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga7030c630c47f79f355fff640be314a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga7030c630c47f79f355fff640be314a4c">More...</a><br /></td></tr>
<tr class="separator:ga7030c630c47f79f355fff640be314a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d5a208bec81a4a28c68e24424f7b41"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga50d5a208bec81a4a28c68e24424f7b41">regina::LayeredTorusBundle::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga50d5a208bec81a4a28c68e24424f7b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga50d5a208bec81a4a28c68e24424f7b41">More...</a><br /></td></tr>
<tr class="separator:ga50d5a208bec81a4a28c68e24424f7b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08de39903d5532b0957df84fbcae493e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga08de39903d5532b0957df84fbcae493e">regina::LayeredTorusBundle::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga08de39903d5532b0957df84fbcae493e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga08de39903d5532b0957df84fbcae493e">More...</a><br /></td></tr>
<tr class="separator:ga08de39903d5532b0957df84fbcae493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7f0bc2712667f34a4b59f830dc2b60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaac7f0bc2712667f34a4b59f830dc2b60">regina::Layering::Layering</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *bdry0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; roles0, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *bdry1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; roles1)</td></tr>
<tr class="memdesc:gaac7f0bc2712667f34a4b59f830dc2b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial (zero-tetrahedron) layering upon the given boundary.  <a href="group__subcomplex.html#gaac7f0bc2712667f34a4b59f830dc2b60">More...</a><br /></td></tr>
<tr class="separator:gaac7f0bc2712667f34a4b59f830dc2b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4217f6e46d0713d1af3b26ba6970c14"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac4217f6e46d0713d1af3b26ba6970c14">regina::Layering::size</a> () const</td></tr>
<tr class="memdesc:gac4217f6e46d0713d1af3b26ba6970c14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of individual tetrahedra that have been layered onto the original boundary, according to the data stored in this structure.  <a href="group__subcomplex.html#gac4217f6e46d0713d1af3b26ba6970c14">More...</a><br /></td></tr>
<tr class="separator:gac4217f6e46d0713d1af3b26ba6970c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27c6b14e099411beda83a195c068ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad27c6b14e099411beda83a195c068ebc">regina::Layering::oldBoundaryTet</a> (unsigned which) const</td></tr>
<tr class="memdesc:gad27c6b14e099411beda83a195c068ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedra that provide the old boundary triangles.  <a href="group__subcomplex.html#gad27c6b14e099411beda83a195c068ebc">More...</a><br /></td></tr>
<tr class="separator:gad27c6b14e099411beda83a195c068ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df4641fc7b186beed57c6d94a31675a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5df4641fc7b186beed57c6d94a31675a">regina::Layering::oldBoundaryRoles</a> (unsigned which) const</td></tr>
<tr class="memdesc:ga5df4641fc7b186beed57c6d94a31675a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutations that describe the old boundary triangles.  <a href="group__subcomplex.html#ga5df4641fc7b186beed57c6d94a31675a">More...</a><br /></td></tr>
<tr class="separator:ga5df4641fc7b186beed57c6d94a31675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0fcd20ed86c84df7a654cd9cfce074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafe0fcd20ed86c84df7a654cd9cfce074">regina::Layering::newBoundaryTet</a> (unsigned which) const</td></tr>
<tr class="memdesc:gafe0fcd20ed86c84df7a654cd9cfce074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedra that provide the new boundary triangles.  <a href="group__subcomplex.html#gafe0fcd20ed86c84df7a654cd9cfce074">More...</a><br /></td></tr>
<tr class="separator:gafe0fcd20ed86c84df7a654cd9cfce074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d707028b14c22101af674b7c599dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac4d707028b14c22101af674b7c599dd9">regina::Layering::newBoundaryRoles</a> (unsigned which) const</td></tr>
<tr class="memdesc:gac4d707028b14c22101af674b7c599dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutations that describe the new boundary triangles.  <a href="group__subcomplex.html#gac4d707028b14c22101af674b7c599dd9">More...</a><br /></td></tr>
<tr class="separator:gac4d707028b14c22101af674b7c599dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf0c3a388a6b8ed9320553a4660c151"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaedf0c3a388a6b8ed9320553a4660c151">regina::Layering::boundaryReln</a> () const</td></tr>
<tr class="memdesc:gaedf0c3a388a6b8ed9320553a4660c151"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the relationship between curves on the old and new boundary tori.  <a href="group__subcomplex.html#gaedf0c3a388a6b8ed9320553a4660c151">More...</a><br /></td></tr>
<tr class="separator:gaedf0c3a388a6b8ed9320553a4660c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a97df250ac597168260389eb2c6edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga45a97df250ac597168260389eb2c6edc">regina::Layering::extendOne</a> ()</td></tr>
<tr class="memdesc:ga45a97df250ac597168260389eb2c6edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines whether a single additional tetrahedron has been layered upon the current new boundary.  <a href="group__subcomplex.html#ga45a97df250ac597168260389eb2c6edc">More...</a><br /></td></tr>
<tr class="separator:ga45a97df250ac597168260389eb2c6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48e1aabed68a1a39cd69a5c016533d9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa48e1aabed68a1a39cd69a5c016533d9">regina::Layering::extend</a> ()</td></tr>
<tr class="memdesc:gaa48e1aabed68a1a39cd69a5c016533d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines whether one or more additional tetrahedra have been layered upon the current new boundary.  <a href="group__subcomplex.html#gaa48e1aabed68a1a39cd69a5c016533d9">More...</a><br /></td></tr>
<tr class="separator:gaa48e1aabed68a1a39cd69a5c016533d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe01df349467b1d0752c80361c6e77c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacbe01df349467b1d0752c80361c6e77c">regina::Layering::matchesTop</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *upperBdry0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; upperRoles0, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *upperBdry1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; upperRoles1, <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;upperReln) const</td></tr>
<tr class="memdesc:gacbe01df349467b1d0752c80361c6e77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the new torus boundary of this structure is identified with the given torus boundary.  <a href="group__subcomplex.html#gacbe01df349467b1d0752c80361c6e77c">More...</a><br /></td></tr>
<tr class="separator:gacbe01df349467b1d0752c80361c6e77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab143302f5b2cdb1f4dde6fdcfc2de5"><td class="memItemLeft" align="right" valign="top"><a id="ga3ab143302f5b2cdb1f4dde6fdcfc2de5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Layering::Layering</b> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;)=delete</td></tr>
<tr class="separator:ga3ab143302f5b2cdb1f4dde6fdcfc2de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1a937d5ffb7b2bebb03305bcfcb69d"><td class="memItemLeft" align="right" valign="top"><a id="ga2f1a937d5ffb7b2bebb03305bcfcb69d"></a>
<a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Layering::operator=</b> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;)=delete</td></tr>
<tr class="separator:ga2f1a937d5ffb7b2bebb03305bcfcb69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30aefbe9594bdc07398419b9677e413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa30aefbe9594bdc07398419b9677e413">regina::PillowTwoSphere::clone</a> () const</td></tr>
<tr class="memdesc:gaa30aefbe9594bdc07398419b9677e413"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#gaa30aefbe9594bdc07398419b9677e413">More...</a><br /></td></tr>
<tr class="separator:gaa30aefbe9594bdc07398419b9677e413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff35702b155b794c798c001d7011b27d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaff35702b155b794c798c001d7011b27d">regina::PillowTwoSphere::triangle</a> (int index) const</td></tr>
<tr class="memdesc:gaff35702b155b794c798c001d7011b27d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two triangles whose boundaries are joined.  <a href="group__subcomplex.html#gaff35702b155b794c798c001d7011b27d">More...</a><br /></td></tr>
<tr class="separator:gaff35702b155b794c798c001d7011b27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8de3b8afb69ec0e133509f0c888dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafd8de3b8afb69ec0e133509f0c888dd9">regina::PillowTwoSphere::triangleMapping</a> () const</td></tr>
<tr class="memdesc:gafd8de3b8afb69ec0e133509f0c888dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation describing how the boundaries of the two triangles are joined.  <a href="group__subcomplex.html#gafd8de3b8afb69ec0e133509f0c888dd9">More...</a><br /></td></tr>
<tr class="separator:gafd8de3b8afb69ec0e133509f0c888dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80b056ef66285ed510a777cd6969ee7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae80b056ef66285ed510a777cd6969ee7">regina::PillowTwoSphere::formsPillowTwoSphere</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *tri1, <a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *tri2)</td></tr>
<tr class="memdesc:gae80b056ef66285ed510a777cd6969ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the two given triangles together form a pillow 2-sphere.  <a href="group__subcomplex.html#gae80b056ef66285ed510a777cd6969ee7">More...</a><br /></td></tr>
<tr class="separator:gae80b056ef66285ed510a777cd6969ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba11bed9dd6975d36eb65aa3cf3022fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaba11bed9dd6975d36eb65aa3cf3022fa">regina::PillowTwoSphere::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaba11bed9dd6975d36eb65aa3cf3022fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#gaba11bed9dd6975d36eb65aa3cf3022fa">More...</a><br /></td></tr>
<tr class="separator:gaba11bed9dd6975d36eb65aa3cf3022fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab475ff52ddc1c35c6c43ee05f02db5ac"><td class="memItemLeft" align="right" valign="top"><a id="gab475ff52ddc1c35c6c43ee05f02db5ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PillowTwoSphere::PillowTwoSphere</b> (const <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> &amp;)=delete</td></tr>
<tr class="separator:gab475ff52ddc1c35c6c43ee05f02db5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c533eb5fb578051ff42ee4ed2ca34d"><td class="memItemLeft" align="right" valign="top"><a id="gae5c533eb5fb578051ff42ee4ed2ca34d"></a>
<a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PillowTwoSphere::operator=</b> (const <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> &amp;)=delete</td></tr>
<tr class="separator:gae5c533eb5fb578051ff42ee4ed2ca34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb14a78f6e6b457e58202fb87f0a17e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3cb14a78f6e6b457e58202fb87f0a17e">regina::PluggedTorusBundle::~PluggedTorusBundle</a> ()</td></tr>
<tr class="memdesc:ga3cb14a78f6e6b457e58202fb87f0a17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its constituent components.  <a href="group__subcomplex.html#ga3cb14a78f6e6b457e58202fb87f0a17e">More...</a><br /></td></tr>
<tr class="separator:ga3cb14a78f6e6b457e58202fb87f0a17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e7a9fdb3b392e267d13ee0097aed2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga50e7a9fdb3b392e267d13ee0097aed2f">regina::PluggedTorusBundle::bundle</a> () const</td></tr>
<tr class="memdesc:ga50e7a9fdb3b392e267d13ee0097aed2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an isomorphic copy of the thin I-bundle that forms part of this triangulation.  <a href="group__subcomplex.html#ga50e7a9fdb3b392e267d13ee0097aed2f">More...</a><br /></td></tr>
<tr class="separator:ga50e7a9fdb3b392e267d13ee0097aed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de0997eb055634ef733278f36565c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5de0997eb055634ef733278f36565c3d">regina::PluggedTorusBundle::bundleIso</a> () const</td></tr>
<tr class="memdesc:ga5de0997eb055634ef733278f36565c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an isomorphism describing how the thin I-bundle forms a subcomplex of this triangulation.  <a href="group__subcomplex.html#ga5de0997eb055634ef733278f36565c3d">More...</a><br /></td></tr>
<tr class="separator:ga5de0997eb055634ef733278f36565c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d2b41297a9db787e7863c76c32628d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga21d2b41297a9db787e7863c76c32628d">regina::PluggedTorusBundle::region</a> () const</td></tr>
<tr class="memdesc:ga21d2b41297a9db787e7863c76c32628d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated region that forms part of this triangulation.  <a href="group__subcomplex.html#ga21d2b41297a9db787e7863c76c32628d">More...</a><br /></td></tr>
<tr class="separator:ga21d2b41297a9db787e7863c76c32628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88ddf03fb89d727059cf9105f7022300"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga88ddf03fb89d727059cf9105f7022300">regina::PluggedTorusBundle::matchingReln</a> () const</td></tr>
<tr class="memdesc:ga88ddf03fb89d727059cf9105f7022300"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two torus boundaries of the saturated region are joined by the thin I-bundle and layerings.  <a href="group__subcomplex.html#ga88ddf03fb89d727059cf9105f7022300">More...</a><br /></td></tr>
<tr class="separator:ga88ddf03fb89d727059cf9105f7022300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd42ca7b753e17f010cc763bf410521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaddd42ca7b753e17f010cc763bf410521">regina::PluggedTorusBundle::manifold</a> () const override</td></tr>
<tr class="memdesc:gaddd42ca7b753e17f010cc763bf410521"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gaddd42ca7b753e17f010cc763bf410521">More...</a><br /></td></tr>
<tr class="separator:gaddd42ca7b753e17f010cc763bf410521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f73d0f600679abb6ad8bcd8c847609"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac6f73d0f600679abb6ad8bcd8c847609">regina::PluggedTorusBundle::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gac6f73d0f600679abb6ad8bcd8c847609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gac6f73d0f600679abb6ad8bcd8c847609">More...</a><br /></td></tr>
<tr class="separator:gac6f73d0f600679abb6ad8bcd8c847609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b5f03cbfa4337fddcfbc43bd002204"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga81b5f03cbfa4337fddcfbc43bd002204">regina::PluggedTorusBundle::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga81b5f03cbfa4337fddcfbc43bd002204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga81b5f03cbfa4337fddcfbc43bd002204">More...</a><br /></td></tr>
<tr class="separator:ga81b5f03cbfa4337fddcfbc43bd002204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4278557170643a37470486a03599153d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4278557170643a37470486a03599153d">regina::PluggedTorusBundle::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4278557170643a37470486a03599153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga4278557170643a37470486a03599153d">More...</a><br /></td></tr>
<tr class="separator:ga4278557170643a37470486a03599153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813230a5189e44593250f80d4ba333c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1PluggedTorusBundle.html">PluggedTorusBundle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga813230a5189e44593250f80d4ba333c0">regina::PluggedTorusBundle::isPluggedTorusBundle</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga813230a5189e44593250f80d4ba333c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation is a saturated region joined to a thin I-bundle via optional layerings, as described in the class notes above.  <a href="group__subcomplex.html#ga813230a5189e44593250f80d4ba333c0">More...</a><br /></td></tr>
<tr class="separator:ga813230a5189e44593250f80d4ba333c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370899baafd7e4781742ba91af04d472"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga370899baafd7e4781742ba91af04d472">regina::PlugTriSolidTorus::~PlugTriSolidTorus</a> ()</td></tr>
<tr class="memdesc:ga370899baafd7e4781742ba91af04d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this plugged solid torus; note that the corresponding triangular solid torus and layered chains will also be destroyed.  <a href="group__subcomplex.html#ga370899baafd7e4781742ba91af04d472">More...</a><br /></td></tr>
<tr class="separator:ga370899baafd7e4781742ba91af04d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c7ec831a9c0bd0f8e7faf8b6494001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf1c7ec831a9c0bd0f8e7faf8b6494001">regina::PlugTriSolidTorus::clone</a> () const</td></tr>
<tr class="memdesc:gaf1c7ec831a9c0bd0f8e7faf8b6494001"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#gaf1c7ec831a9c0bd0f8e7faf8b6494001">More...</a><br /></td></tr>
<tr class="separator:gaf1c7ec831a9c0bd0f8e7faf8b6494001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d6069b0832a167da36842f4fee138b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab0d6069b0832a167da36842f4fee138b">regina::PlugTriSolidTorus::core</a> () const</td></tr>
<tr class="memdesc:gab0d6069b0832a167da36842f4fee138b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangular solid torus at the core of this triangulation.  <a href="group__subcomplex.html#gab0d6069b0832a167da36842f4fee138b">More...</a><br /></td></tr>
<tr class="separator:gab0d6069b0832a167da36842f4fee138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7673c896771526a9b54fb8248a54d057"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7673c896771526a9b54fb8248a54d057">regina::PlugTriSolidTorus::chain</a> (int annulus) const</td></tr>
<tr class="memdesc:ga7673c896771526a9b54fb8248a54d057"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered chain attached to the requested annulus on the boundary of the core triangular solid torus.  <a href="group__subcomplex.html#ga7673c896771526a9b54fb8248a54d057">More...</a><br /></td></tr>
<tr class="separator:ga7673c896771526a9b54fb8248a54d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd25d2ffd7fb549ababf0733f18041c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadd25d2ffd7fb549ababf0733f18041c2">regina::PlugTriSolidTorus::chainType</a> (int annulus) const</td></tr>
<tr class="memdesc:gadd25d2ffd7fb549ababf0733f18041c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the way in which a layered chain is attached to the requested annulus on the boundary of the core triangular solid torus.  <a href="group__subcomplex.html#gadd25d2ffd7fb549ababf0733f18041c2">More...</a><br /></td></tr>
<tr class="separator:gadd25d2ffd7fb549ababf0733f18041c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c1dcd8b4e1181fe0481f35b1aff83b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga43c1dcd8b4e1181fe0481f35b1aff83b">regina::PlugTriSolidTorus::equatorType</a> () const</td></tr>
<tr class="memdesc:ga43c1dcd8b4e1181fe0481f35b1aff83b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which types of edges form the equator of the plug.  <a href="group__subcomplex.html#ga43c1dcd8b4e1181fe0481f35b1aff83b">More...</a><br /></td></tr>
<tr class="separator:ga43c1dcd8b4e1181fe0481f35b1aff83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2324ae3d08a9c0e00e1b6f521b335dc9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2324ae3d08a9c0e00e1b6f521b335dc9">regina::PlugTriSolidTorus::isPlugTriSolidTorus</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga2324ae3d08a9c0e00e1b6f521b335dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is a plugged triangular solid torus.  <a href="group__subcomplex.html#ga2324ae3d08a9c0e00e1b6f521b335dc9">More...</a><br /></td></tr>
<tr class="separator:ga2324ae3d08a9c0e00e1b6f521b335dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a698d8b6a5e6d422d8c0762e532e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga42a698d8b6a5e6d422d8c0762e532e29">regina::PlugTriSolidTorus::manifold</a> () const override</td></tr>
<tr class="memdesc:ga42a698d8b6a5e6d422d8c0762e532e29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga42a698d8b6a5e6d422d8c0762e532e29">More...</a><br /></td></tr>
<tr class="separator:ga42a698d8b6a5e6d422d8c0762e532e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6294c946a4a3bc67f788875b161a69cf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6294c946a4a3bc67f788875b161a69cf">regina::PlugTriSolidTorus::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga6294c946a4a3bc67f788875b161a69cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga6294c946a4a3bc67f788875b161a69cf">More...</a><br /></td></tr>
<tr class="separator:ga6294c946a4a3bc67f788875b161a69cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6e754b606f22e7274b16c2b2e168cc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2f6e754b606f22e7274b16c2b2e168cc">regina::PlugTriSolidTorus::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga2f6e754b606f22e7274b16c2b2e168cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga2f6e754b606f22e7274b16c2b2e168cc">More...</a><br /></td></tr>
<tr class="separator:ga2f6e754b606f22e7274b16c2b2e168cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62026c61dc76949cc5ce03dea53f70b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga62026c61dc76949cc5ce03dea53f70b0">regina::PlugTriSolidTorus::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga62026c61dc76949cc5ce03dea53f70b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga62026c61dc76949cc5ce03dea53f70b0">More...</a><br /></td></tr>
<tr class="separator:ga62026c61dc76949cc5ce03dea53f70b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a81c2692c140b8ed46d060fcc62fffa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3a81c2692c140b8ed46d060fcc62fffa">regina::SatAnnulus::SatAnnulus</a> ()</td></tr>
<tr class="memdesc:ga3a81c2692c140b8ed46d060fcc62fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised structure.  <a href="group__subcomplex.html#ga3a81c2692c140b8ed46d060fcc62fffa">More...</a><br /></td></tr>
<tr class="separator:ga3a81c2692c140b8ed46d060fcc62fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf020064341a684f10ed73f7d0720ee6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf020064341a684f10ed73f7d0720ee6e">regina::SatAnnulus::SatAnnulus</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gaf020064341a684f10ed73f7d0720ee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given structure.  <a href="group__subcomplex.html#gaf020064341a684f10ed73f7d0720ee6e">More...</a><br /></td></tr>
<tr class="separator:gaf020064341a684f10ed73f7d0720ee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90ba5f29977e590d5cd897ce07ec61c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf90ba5f29977e590d5cd897ce07ec61c">regina::SatAnnulus::SatAnnulus</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r0, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; r1)</td></tr>
<tr class="memdesc:gaf90ba5f29977e590d5cd897ce07ec61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure initialised to the given values.  <a href="group__subcomplex.html#gaf90ba5f29977e590d5cd897ce07ec61c">More...</a><br /></td></tr>
<tr class="separator:gaf90ba5f29977e590d5cd897ce07ec61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593529f0a73e5d27cb720676f9432a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga593529f0a73e5d27cb720676f9432a14">regina::SatAnnulus::operator=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga593529f0a73e5d27cb720676f9432a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this equal to a clone of the given structure.  <a href="group__subcomplex.html#ga593529f0a73e5d27cb720676f9432a14">More...</a><br /></td></tr>
<tr class="separator:ga593529f0a73e5d27cb720676f9432a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422274dc01b3829898fc5bd9912c887e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga422274dc01b3829898fc5bd9912c887e">regina::SatAnnulus::operator==</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:ga422274dc01b3829898fc5bd9912c887e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe the same annulus with the same representation.  <a href="group__subcomplex.html#ga422274dc01b3829898fc5bd9912c887e">More...</a><br /></td></tr>
<tr class="separator:ga422274dc01b3829898fc5bd9912c887e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9a3e17d58f8a53930d74b2511f64fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3f9a3e17d58f8a53930d74b2511f64fd">regina::SatAnnulus::operator!=</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other) const</td></tr>
<tr class="memdesc:ga3f9a3e17d58f8a53930d74b2511f64fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this and the given structure describe the same annulus with the same representation.  <a href="group__subcomplex.html#ga3f9a3e17d58f8a53930d74b2511f64fd">More...</a><br /></td></tr>
<tr class="separator:ga3f9a3e17d58f8a53930d74b2511f64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8efd019dec98bc14e74e6290ce7d5f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaee8efd019dec98bc14e74e6290ce7d5f">regina::SatAnnulus::meetsBoundary</a> () const</td></tr>
<tr class="memdesc:gaee8efd019dec98bc14e74e6290ce7d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many triangles of this annulus lie on the boundary of the triangulation.  <a href="group__subcomplex.html#gaee8efd019dec98bc14e74e6290ce7d5f">More...</a><br /></td></tr>
<tr class="separator:gaee8efd019dec98bc14e74e6290ce7d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3314169287c13371d490bfe8f156c2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3314169287c13371d490bfe8f156c2e8">regina::SatAnnulus::switchSides</a> ()</td></tr>
<tr class="memdesc:ga3314169287c13371d490bfe8f156c2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a representation of the same annulus from the other side.  <a href="group__subcomplex.html#ga3314169287c13371d490bfe8f156c2e8">More...</a><br /></td></tr>
<tr class="separator:ga3314169287c13371d490bfe8f156c2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1a05d4855418a5e4de2261f93ae9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabe1a05d4855418a5e4de2261f93ae9ec">regina::SatAnnulus::otherSide</a> () const</td></tr>
<tr class="memdesc:gabe1a05d4855418a5e4de2261f93ae9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of the same annulus from the other side.  <a href="group__subcomplex.html#gabe1a05d4855418a5e4de2261f93ae9ec">More...</a><br /></td></tr>
<tr class="separator:gabe1a05d4855418a5e4de2261f93ae9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb14f03e956c6a208d02226a4a684c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8cb14f03e956c6a208d02226a4a684c2">regina::SatAnnulus::reflectVertical</a> ()</td></tr>
<tr class="memdesc:ga8cb14f03e956c6a208d02226a4a684c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the direction of the vertical fibres in this annulus representation.  <a href="group__subcomplex.html#ga8cb14f03e956c6a208d02226a4a684c2">More...</a><br /></td></tr>
<tr class="separator:ga8cb14f03e956c6a208d02226a4a684c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cc54b9dfdf84f901beacaab63b9f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac1cc54b9dfdf84f901beacaab63b9f39">regina::SatAnnulus::verticalReflection</a> () const</td></tr>
<tr class="memdesc:gac1cc54b9dfdf84f901beacaab63b9f39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of this annulus in which the vertical direction of the fibres has been reversed.  <a href="group__subcomplex.html#gac1cc54b9dfdf84f901beacaab63b9f39">More...</a><br /></td></tr>
<tr class="separator:gac1cc54b9dfdf84f901beacaab63b9f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d10195c977f38a583700303629ebc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga53d10195c977f38a583700303629ebc8">regina::SatAnnulus::reflectHorizontal</a> ()</td></tr>
<tr class="memdesc:ga53d10195c977f38a583700303629ebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left-to-right reflection of this annulus representation.  <a href="group__subcomplex.html#ga53d10195c977f38a583700303629ebc8">More...</a><br /></td></tr>
<tr class="separator:ga53d10195c977f38a583700303629ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa7c5947d121ebf8a25e0849bdf5a7f7e">regina::SatAnnulus::horizontalReflection</a> () const</td></tr>
<tr class="memdesc:gaa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a left-to-right reflected representation of this annulus.  <a href="group__subcomplex.html#gaa7c5947d121ebf8a25e0849bdf5a7f7e">More...</a><br /></td></tr>
<tr class="separator:gaa7c5947d121ebf8a25e0849bdf5a7f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea9c67b200888b3aeb42251ee31c3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaeea9c67b200888b3aeb42251ee31c3cc">regina::SatAnnulus::rotateHalfTurn</a> ()</td></tr>
<tr class="memdesc:gaeea9c67b200888b3aeb42251ee31c3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the representation of this annulus by 180 degrees.  <a href="group__subcomplex.html#gaeea9c67b200888b3aeb42251ee31c3cc">More...</a><br /></td></tr>
<tr class="separator:gaeea9c67b200888b3aeb42251ee31c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2540d455af75c2d5d736267d4b78ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3c2540d455af75c2d5d736267d4b78ff">regina::SatAnnulus::halfTurnRotation</a> () const</td></tr>
<tr class="memdesc:ga3c2540d455af75c2d5d736267d4b78ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 180 degree rotated representation of this annulus.  <a href="group__subcomplex.html#ga3c2540d455af75c2d5d736267d4b78ff">More...</a><br /></td></tr>
<tr class="separator:ga3c2540d455af75c2d5d736267d4b78ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18b751a2ac184f75c42ee18d6cde745"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab18b751a2ac184f75c42ee18d6cde745">regina::SatAnnulus::isAdjacent</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other, bool *refVert, bool *refHoriz) const</td></tr>
<tr class="memdesc:gab18b751a2ac184f75c42ee18d6cde745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections.  <a href="group__subcomplex.html#gab18b751a2ac184f75c42ee18d6cde745">More...</a><br /></td></tr>
<tr class="separator:gab18b751a2ac184f75c42ee18d6cde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab166da7e172160fef0a9f818823a2c4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab166da7e172160fef0a9f818823a2c4d">regina::SatAnnulus::isJoined</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;other, <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;matching) const</td></tr>
<tr class="memdesc:gab166da7e172160fef0a9f818823a2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent.  <a href="group__subcomplex.html#gab166da7e172160fef0a9f818823a2c4d">More...</a><br /></td></tr>
<tr class="separator:gab166da7e172160fef0a9f818823a2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92bb7286c0fb03b929257a7bc4888f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab92bb7286c0fb03b929257a7bc4888f1">regina::SatAnnulus::isTwoSidedTorus</a> () const</td></tr>
<tr class="memdesc:gab92bb7286c0fb03b929257a7bc4888f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation.  <a href="group__subcomplex.html#gab92bb7286c0fb03b929257a7bc4888f1">More...</a><br /></td></tr>
<tr class="separator:gab92bb7286c0fb03b929257a7bc4888f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb34c281222b5a95a4d3a2bd4206fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaadb34c281222b5a95a4d3a2bd4206fcf">regina::SatAnnulus::transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:gaadb34c281222b5a95a4d3a2bd4206fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts this annulus representation according to the given isomorphism between triangulations.  <a href="group__subcomplex.html#gaadb34c281222b5a95a4d3a2bd4206fcf">More...</a><br /></td></tr>
<tr class="separator:gaadb34c281222b5a95a4d3a2bd4206fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae35b903051842517e0c3be39eae2cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaae35b903051842517e0c3be39eae2cee">regina::SatAnnulus::image</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri) const</td></tr>
<tr class="memdesc:gaae35b903051842517e0c3be39eae2cee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this annulus representation under the given isomorphism between triangulations.  <a href="group__subcomplex.html#gaae35b903051842517e0c3be39eae2cee">More...</a><br /></td></tr>
<tr class="separator:gaae35b903051842517e0c3be39eae2cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ef9c6ac88ca6201299c32c99b6924a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga42ef9c6ac88ca6201299c32c99b6924a">regina::SatAnnulus::attachLST</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, long alpha, long beta) const</td></tr>
<tr class="memdesc:ga42ef9c6ac88ca6201299c32c99b6924a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a layered solid torus to the this saturated annulus.  <a href="group__subcomplex.html#ga42ef9c6ac88ca6201299c32c99b6924a">More...</a><br /></td></tr>
<tr class="separator:ga42ef9c6ac88ca6201299c32c99b6924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5e2d7590e6821abcb395a4788a7f66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2f5e2d7590e6821abcb395a4788a7f66">regina::SatBlock::SatBlock</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga2f5e2d7590e6821abcb395a4788a7f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new clone of the given block.  <a href="group__subcomplex.html#ga2f5e2d7590e6821abcb395a4788a7f66">More...</a><br /></td></tr>
<tr class="separator:ga2f5e2d7590e6821abcb395a4788a7f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1626a88050fce82a844bb7258b20c3e3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1626a88050fce82a844bb7258b20c3e3">regina::SatBlock::~SatBlock</a> ()</td></tr>
<tr class="memdesc:ga1626a88050fce82a844bb7258b20c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all internal arrays.  <a href="group__subcomplex.html#ga1626a88050fce82a844bb7258b20c3e3">More...</a><br /></td></tr>
<tr class="separator:ga1626a88050fce82a844bb7258b20c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de55d177752158147c2375271a71359"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock::clone</a> () const =0</td></tr>
<tr class="memdesc:ga2de55d177752158147c2375271a71359"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">More...</a><br /></td></tr>
<tr class="separator:ga2de55d177752158147c2375271a71359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6315fa72abebfdd6c03f4ed5ea68bab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab">regina::SatBlock::nAnnuli</a> () const</td></tr>
<tr class="memdesc:gab6315fa72abebfdd6c03f4ed5ea68bab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block.  <a href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab">More...</a><br /></td></tr>
<tr class="separator:gab6315fa72abebfdd6c03f4ed5ea68bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed25d82f9b29328fb95f0ccb15e81d8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">regina::SatBlock::annulus</a> (unsigned which) const</td></tr>
<tr class="memdesc:gaed25d82f9b29328fb95f0ccb15e81d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block.  <a href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">More...</a><br /></td></tr>
<tr class="separator:gaed25d82f9b29328fb95f0ccb15e81d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1893440bbd41f62a28f1c49f7d3bfae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad1893440bbd41f62a28f1c49f7d3bfae">regina::SatBlock::twistedBoundary</a> () const</td></tr>
<tr class="memdesc:gad1893440bbd41f62a28f1c49f7d3bfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a long Mobius strip?  <a href="group__subcomplex.html#gad1893440bbd41f62a28f1c49f7d3bfae">More...</a><br /></td></tr>
<tr class="separator:gad1893440bbd41f62a28f1c49f7d3bfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d78eef4a11ec11260bb000eaa5a056"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga70d78eef4a11ec11260bb000eaa5a056">regina::SatBlock::hasAdjacentBlock</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:ga70d78eef4a11ec11260bb000eaa5a056"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="group__subcomplex.html#ga70d78eef4a11ec11260bb000eaa5a056">More...</a><br /></td></tr>
<tr class="separator:ga70d78eef4a11ec11260bb000eaa5a056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71720ca0e1d2c086f532416a5522c60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga71720ca0e1d2c086f532416a5522c60a">regina::SatBlock::adjacentBlock</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:ga71720ca0e1d2c086f532416a5522c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="group__subcomplex.html#ga71720ca0e1d2c086f532416a5522c60a">More...</a><br /></td></tr>
<tr class="separator:ga71720ca0e1d2c086f532416a5522c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2ca004164b67a9e91dbdc652ba86b0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabb2ca004164b67a9e91dbdc652ba86b0">regina::SatBlock::adjacentAnnulus</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:gabb2ca004164b67a9e91dbdc652ba86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block.  <a href="group__subcomplex.html#gabb2ca004164b67a9e91dbdc652ba86b0">More...</a><br /></td></tr>
<tr class="separator:gabb2ca004164b67a9e91dbdc652ba86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af146659a1b983afa6eb4776d409011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5af146659a1b983afa6eb4776d409011">regina::SatBlock::adjacentReflected</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:ga5af146659a1b983afa6eb4776d409011"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected.  <a href="group__subcomplex.html#ga5af146659a1b983afa6eb4776d409011">More...</a><br /></td></tr>
<tr class="separator:ga5af146659a1b983afa6eb4776d409011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae091e96247b17a9bfbee97e4187750e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae091e96247b17a9bfbee97e4187750e9">regina::SatBlock::adjacentBackwards</a> (unsigned whichAnnulus) const</td></tr>
<tr class="memdesc:gae091e96247b17a9bfbee97e4187750e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards.  <a href="group__subcomplex.html#gae091e96247b17a9bfbee97e4187750e9">More...</a><br /></td></tr>
<tr class="separator:gae091e96247b17a9bfbee97e4187750e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43412c3c8b26ef6dee3ed83bfeb5f004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga43412c3c8b26ef6dee3ed83bfeb5f004">regina::SatBlock::setAdjacent</a> (unsigned whichAnnulus, <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *adjBlock, unsigned adjAnnulus, bool adjReflected, bool adjBackwards)</td></tr>
<tr class="memdesc:ga43412c3c8b26ef6dee3ed83bfeb5f004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the given saturated block as being adjacent to the given boundary annulus of this block.  <a href="group__subcomplex.html#ga43412c3c8b26ef6dee3ed83bfeb5f004">More...</a><br /></td></tr>
<tr class="separator:ga43412c3c8b26ef6dee3ed83bfeb5f004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f34b5e1c93a1785b1c60cb443b5413c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const =0</td></tr>
<tr class="memdesc:ga0f34b5e1c93a1785b1c60cb443b5413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">More...</a><br /></td></tr>
<tr class="separator:ga0f34b5e1c93a1785b1c60cb443b5413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d565eec762b612fbf72b3f41e26dce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa4d565eec762b612fbf72b3f41e26dce">regina::SatBlock::transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:gaa4d565eec762b612fbf72b3f41e26dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the structure of this block according to the given isomorphism between triangulations.  <a href="group__subcomplex.html#gaa4d565eec762b612fbf72b3f41e26dce">More...</a><br /></td></tr>
<tr class="separator:gaa4d565eec762b612fbf72b3f41e26dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5dfbf2105ead4220eee5c49e08ff1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3b5dfbf2105ead4220eee5c49e08ff1b">regina::SatBlock::nextBoundaryAnnulus</a> (unsigned thisAnnulus, <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;nextBlock, unsigned &amp;nextAnnulus, bool &amp;refVert, bool &amp;refHoriz, bool followPrev)</td></tr>
<tr class="memdesc:ga3b5dfbf2105ead4220eee5c49e08ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region.  <a href="group__subcomplex.html#ga3b5dfbf2105ead4220eee5c49e08ff1b">More...</a><br /></td></tr>
<tr class="separator:ga3b5dfbf2105ead4220eee5c49e08ff1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7192ac0dfb2fd6c156ab9aa48d2c9570">regina::SatBlock::abbr</a> (bool tex=false) const</td></tr>
<tr class="memdesc:ga7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block.  <a href="group__subcomplex.html#ga7192ac0dfb2fd6c156ab9aa48d2c9570">More...</a><br /></td></tr>
<tr class="separator:ga7192ac0dfb2fd6c156ab9aa48d2c9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81d8335c3999dfea5665b9d2b21134f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const =0</td></tr>
<tr class="memdesc:gab81d8335c3999dfea5665b9d2b21134f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">More...</a><br /></td></tr>
<tr class="separator:gab81d8335c3999dfea5665b9d2b21134f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076736b6fe8a23d801e9bd5179aaf205"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga076736b6fe8a23d801e9bd5179aaf205">regina::SatBlock::operator&lt;</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga076736b6fe8a23d801e9bd5179aaf205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a consistent ordering of saturated blocks.  <a href="group__subcomplex.html#ga076736b6fe8a23d801e9bd5179aaf205">More...</a><br /></td></tr>
<tr class="separator:ga076736b6fe8a23d801e9bd5179aaf205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24eeb48f535c22b24dc25699981e38d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4">regina::SatBlock::isBlock</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga24eeb48f535c22b24dc25699981e38d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block.  <a href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4">More...</a><br /></td></tr>
<tr class="separator:ga24eeb48f535c22b24dc25699981e38d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27450164476537cc702924e8f039947f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock::writeTextShort</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga27450164476537cc702924e8f039947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">More...</a><br /></td></tr>
<tr class="separator:ga27450164476537cc702924e8f039947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130a8ba7b087b1a560891f9f075d443c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga130a8ba7b087b1a560891f9f075d443c">regina::SatBlock::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga130a8ba7b087b1a560891f9f075d443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga130a8ba7b087b1a560891f9f075d443c">More...</a><br /></td></tr>
<tr class="separator:ga130a8ba7b087b1a560891f9f075d443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa0a60870e487452e26ee2f0d13a6ff"><td class="memItemLeft" align="right" valign="top"><a id="ga1aa0a60870e487452e26ee2f0d13a6ff"></a>
<a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlock::operator=</b> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;)=delete</td></tr>
<tr class="separator:ga1aa0a60870e487452e26ee2f0d13a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3e6b4ec2c84ec3e3af1b90f2bb797a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabb3e6b4ec2c84ec3e3af1b90f2bb797a">regina::SatBlock::SatBlock</a> (unsigned <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab">nAnnuli</a>, bool <a class="el" href="group__subcomplex.html#gad1893440bbd41f62a28f1c49f7d3bfae">twistedBoundary</a>=false)</td></tr>
<tr class="memdesc:gabb3e6b4ec2c84ec3e3af1b90f2bb797a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a block with the given number of annuli on the boundary.  <a href="group__subcomplex.html#gabb3e6b4ec2c84ec3e3af1b90f2bb797a">More...</a><br /></td></tr>
<tr class="separator:gabb3e6b4ec2c84ec3e3af1b90f2bb797a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1705b0b0d6a48822121a699d8e0ffb9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab1705b0b0d6a48822121a699d8e0ffb9">regina::SatBlock::isBad</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, const <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;list)</td></tr>
<tr class="memdesc:gab1705b0b0d6a48822121a699d8e0ffb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="group__subcomplex.html#gab1705b0b0d6a48822121a699d8e0ffb9">More...</a><br /></td></tr>
<tr class="separator:gab1705b0b0d6a48822121a699d8e0ffb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256141cc960c800628d726ec268ebfd0"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:ga256141cc960c800628d726ec268ebfd0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga256141cc960c800628d726ec268ebfd0">regina::SatBlock::isBad</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, const List &amp;list)</td></tr>
<tr class="memdesc:ga256141cc960c800628d726ec268ebfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="group__subcomplex.html#ga256141cc960c800628d726ec268ebfd0">More...</a><br /></td></tr>
<tr class="separator:ga256141cc960c800628d726ec268ebfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d32449ef8e48dcf87e24c10bef03f2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae5d32449ef8e48dcf87e24c10bef03f2">regina::SatBlock::notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test)</td></tr>
<tr class="memdesc:gae5d32449ef8e48dcf87e24c10bef03f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null.  <a href="group__subcomplex.html#gae5d32449ef8e48dcf87e24c10bef03f2">More...</a><br /></td></tr>
<tr class="separator:gae5d32449ef8e48dcf87e24c10bef03f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4dd0f929b39e314a96e2c99c699ce85"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab4dd0f929b39e314a96e2c99c699ce85">regina::SatBlock::notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1)</td></tr>
<tr class="memdesc:gab4dd0f929b39e314a96e2c99c699ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="group__subcomplex.html#gab4dd0f929b39e314a96e2c99c699ce85">More...</a><br /></td></tr>
<tr class="separator:gab4dd0f929b39e314a96e2c99c699ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45574f81ee799875b38ad24e3c87e777"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga45574f81ee799875b38ad24e3c87e777">regina::SatBlock::notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2)</td></tr>
<tr class="memdesc:ga45574f81ee799875b38ad24e3c87e777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="group__subcomplex.html#ga45574f81ee799875b38ad24e3c87e777">More...</a><br /></td></tr>
<tr class="separator:ga45574f81ee799875b38ad24e3c87e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd16a7f145941c3270d2eb37b015e968"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacd16a7f145941c3270d2eb37b015e968">regina::SatBlock::notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other3)</td></tr>
<tr class="memdesc:gacd16a7f145941c3270d2eb37b015e968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="group__subcomplex.html#gacd16a7f145941c3270d2eb37b015e968">More...</a><br /></td></tr>
<tr class="separator:gacd16a7f145941c3270d2eb37b015e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8d8b87118dd4442251a5a040612b41"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3b8d8b87118dd4442251a5a040612b41">regina::SatBlock::notUnique</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *test, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other2, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other3, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *other4)</td></tr>
<tr class="memdesc:ga3b8d8b87118dd4442251a5a040612b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="group__subcomplex.html#ga3b8d8b87118dd4442251a5a040612b41">More...</a><br /></td></tr>
<tr class="separator:ga3b8d8b87118dd4442251a5a040612b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e7a6b43fc0465af1ddaca4d02d8ab9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga96e7a6b43fc0465af1ddaca4d02d8ab9">regina::SatBlockStarter::~SatBlockStarter</a> ()</td></tr>
<tr class="memdesc:ga96e7a6b43fc0465af1ddaca4d02d8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys both the internal triangulation and block structure.  <a href="group__subcomplex.html#ga96e7a6b43fc0465af1ddaca4d02d8ab9">More...</a><br /></td></tr>
<tr class="separator:ga96e7a6b43fc0465af1ddaca4d02d8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf162c1569d051d46056867a4125bf522"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf162c1569d051d46056867a4125bf522">regina::SatBlockStarter::triangulation</a> () const</td></tr>
<tr class="memdesc:gaf162c1569d051d46056867a4125bf522"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the triangulation of the saturated block.  <a href="group__subcomplex.html#gaf162c1569d051d46056867a4125bf522">More...</a><br /></td></tr>
<tr class="separator:gaf162c1569d051d46056867a4125bf522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4246d1d98f6ecd84692a8d5f4e12da6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4246d1d98f6ecd84692a8d5f4e12da6e">regina::SatBlockStarter::block</a> () const</td></tr>
<tr class="memdesc:ga4246d1d98f6ecd84692a8d5f4e12da6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details that describe the structure of the saturated block.  <a href="group__subcomplex.html#ga4246d1d98f6ecd84692a8d5f4e12da6e">More...</a><br /></td></tr>
<tr class="separator:ga4246d1d98f6ecd84692a8d5f4e12da6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994a2dfe3c32f134514586c2b74f7e57"><td class="memItemLeft" align="right" valign="top"><a id="ga994a2dfe3c32f134514586c2b74f7e57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlockStarter::SatBlockStarter</b> (const <a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a> &amp;)=delete</td></tr>
<tr class="separator:ga994a2dfe3c32f134514586c2b74f7e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a8075055b25301f6917275a99dc80c"><td class="memItemLeft" align="right" valign="top"><a id="ga79a8075055b25301f6917275a99dc80c"></a>
<a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlockStarter::operator=</b> (const <a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a> &amp;)=delete</td></tr>
<tr class="separator:ga79a8075055b25301f6917275a99dc80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2edd99bee25ef747da8a1ba916bd7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaab2edd99bee25ef747da8a1ba916bd7a">regina::SatBlockStarterSet::begin</a> ()</td></tr>
<tr class="memdesc:gaab2edd99bee25ef747da8a1ba916bd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first block in the hard-coded list.  <a href="group__subcomplex.html#gaab2edd99bee25ef747da8a1ba916bd7a">More...</a><br /></td></tr>
<tr class="separator:gaab2edd99bee25ef747da8a1ba916bd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6878f15e256657c3e022422b1c265be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae6878f15e256657c3e022422b1c265be">regina::SatBlockStarterSet::end</a> ()</td></tr>
<tr class="memdesc:gae6878f15e256657c3e022422b1c265be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing past the end of the hard-coded list (i.e., just after the last item).  <a href="group__subcomplex.html#gae6878f15e256657c3e022422b1c265be">More...</a><br /></td></tr>
<tr class="separator:gae6878f15e256657c3e022422b1c265be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52db0ca1eb1e56f93cf656dccb182db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga52db0ca1eb1e56f93cf656dccb182db1">regina::SatBlockStarterSet::initialise</a> () override</td></tr>
<tr class="memdesc:ga52db0ca1eb1e56f93cf656dccb182db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this list with items.  <a href="group__subcomplex.html#ga52db0ca1eb1e56f93cf656dccb182db1">More...</a><br /></td></tr>
<tr class="separator:ga52db0ca1eb1e56f93cf656dccb182db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652694021bc1c0507f24fd7d2450e7c9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga652694021bc1c0507f24fd7d2450e7c9">regina::SatBlockStarterSearcher::~SatBlockStarterSearcher</a> ()</td></tr>
<tr class="memdesc:ga652694021bc1c0507f24fd7d2450e7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object and its internal structures.  <a href="group__subcomplex.html#ga652694021bc1c0507f24fd7d2450e7c9">More...</a><br /></td></tr>
<tr class="separator:ga652694021bc1c0507f24fd7d2450e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211f6cc1476b89316c4f5670a67e2fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga211f6cc1476b89316c4f5670a67e2fa2">regina::SatBlockStarterSearcher::findStarterBlocks</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga211f6cc1476b89316c4f5670a67e2fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a search for every isomorphic embedding of every starter block from the global <a class="el" href="classregina_1_1SatBlockStarterSet.html" title="Represents a set of starter blocks that can be used for identifying triangulations of Seifert fibred ...">SatBlockStarterSet</a> within the given triangulation.  <a href="group__subcomplex.html#ga211f6cc1476b89316c4f5670a67e2fa2">More...</a><br /></td></tr>
<tr class="separator:ga211f6cc1476b89316c4f5670a67e2fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ab3dc893e56fdef71b3b57f611b6bd"><td class="memItemLeft" align="right" valign="top"><a id="gae2ab3dc893e56fdef71b3b57f611b6bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlockStarterSearcher::SatBlockStarterSearcher</b> (const <a class="el" href="classregina_1_1SatBlockStarterSearcher.html">SatBlockStarterSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:gae2ab3dc893e56fdef71b3b57f611b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1fe14f5bbe873d104c37699cb0f6ca"><td class="memItemLeft" align="right" valign="top"><a id="gacf1fe14f5bbe873d104c37699cb0f6ca"></a>
<a class="el" href="classregina_1_1SatBlockStarterSearcher.html">SatBlockStarterSearcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlockStarterSearcher::operator=</b> (const <a class="el" href="classregina_1_1SatBlockStarterSearcher.html">SatBlockStarterSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:gacf1fe14f5bbe873d104c37699cb0f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d06980180f54d84eec4500301063f8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8d06980180f54d84eec4500301063f8b">regina::SatBlockStarterSearcher::SatBlockStarterSearcher</a> ()=default</td></tr>
<tr class="memdesc:ga8d06980180f54d84eec4500301063f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, for use by subclasses.  <a href="group__subcomplex.html#ga8d06980180f54d84eec4500301063f8b">More...</a><br /></td></tr>
<tr class="separator:ga8d06980180f54d84eec4500301063f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b34926e074563265cddbf5c1a4c05c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0">regina::SatBlockStarterSearcher::useStarterBlock</a> (<a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *starter)=0</td></tr>
<tr class="memdesc:ga3b34926e074563265cddbf5c1a4c05c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by subclasses to process each starter block embedding that is found.  <a href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0">More...</a><br /></td></tr>
<tr class="separator:ga3b34926e074563265cddbf5c1a4c05c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd62a0d376212810d909a31fe6215c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1dd62a0d376212810d909a31fe6215c1">regina::SatMobius::SatMobius</a> (const <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga1dd62a0d376212810d909a31fe6215c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#ga1dd62a0d376212810d909a31fe6215c1">More...</a><br /></td></tr>
<tr class="separator:ga1dd62a0d376212810d909a31fe6215c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c2aa660f6fcd2cecceef46521e7560"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga90c2aa660f6fcd2cecceef46521e7560">regina::SatMobius::position</a> () const</td></tr>
<tr class="memdesc:ga90c2aa660f6fcd2cecceef46521e7560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how the Mobius band is attached to the boundary annulus.  <a href="group__subcomplex.html#ga90c2aa660f6fcd2cecceef46521e7560">More...</a><br /></td></tr>
<tr class="separator:ga90c2aa660f6fcd2cecceef46521e7560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabff7831bf78f47b456d85d237b61738"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaabff7831bf78f47b456d85d237b61738">regina::SatMobius::clone</a> () const override</td></tr>
<tr class="memdesc:gaabff7831bf78f47b456d85d237b61738"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#gaabff7831bf78f47b456d85d237b61738">More...</a><br /></td></tr>
<tr class="separator:gaabff7831bf78f47b456d85d237b61738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92b01b2051711e192eca3b334e34007"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae92b01b2051711e192eca3b334e34007">regina::SatMobius::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:gae92b01b2051711e192eca3b334e34007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#gae92b01b2051711e192eca3b334e34007">More...</a><br /></td></tr>
<tr class="separator:gae92b01b2051711e192eca3b334e34007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09aa0f965390a7234762f90a5f0d633"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab09aa0f965390a7234762f90a5f0d633">regina::SatMobius::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gab09aa0f965390a7234762f90a5f0d633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#gab09aa0f965390a7234762f90a5f0d633">More...</a><br /></td></tr>
<tr class="separator:gab09aa0f965390a7234762f90a5f0d633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8430b475c80a072f8a18788492f9171c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8430b475c80a072f8a18788492f9171c">regina::SatMobius::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:ga8430b475c80a072f8a18788492f9171c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#ga8430b475c80a072f8a18788492f9171c">More...</a><br /></td></tr>
<tr class="separator:ga8430b475c80a072f8a18788492f9171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3293151da99685206c9f487e538415"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8f3293151da99685206c9f487e538415">regina::SatMobius::isBlockMobius</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga8f3293151da99685206c9f487e538415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (Mobius band).  <a href="group__subcomplex.html#ga8f3293151da99685206c9f487e538415">More...</a><br /></td></tr>
<tr class="separator:ga8f3293151da99685206c9f487e538415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6c6f88585b9a1fded80949dc5170ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafc6c6f88585b9a1fded80949dc5170ff">regina::SatLST::SatLST</a> (const <a class="el" href="classregina_1_1SatLST.html">SatLST</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gafc6c6f88585b9a1fded80949dc5170ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#gafc6c6f88585b9a1fded80949dc5170ff">More...</a><br /></td></tr>
<tr class="separator:gafc6c6f88585b9a1fded80949dc5170ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049df8deb0c85fc99539209e07494b7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga049df8deb0c85fc99539209e07494b7a">regina::SatLST::~SatLST</a> ()</td></tr>
<tr class="memdesc:ga049df8deb0c85fc99539209e07494b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and its internal components.  <a href="group__subcomplex.html#ga049df8deb0c85fc99539209e07494b7a">More...</a><br /></td></tr>
<tr class="separator:ga049df8deb0c85fc99539209e07494b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab930708bfe45d0c6b107477d3e90370b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab930708bfe45d0c6b107477d3e90370b">regina::SatLST::lst</a> () const</td></tr>
<tr class="memdesc:gab930708bfe45d0c6b107477d3e90370b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the layered solid torus that this block represents.  <a href="group__subcomplex.html#gab930708bfe45d0c6b107477d3e90370b">More...</a><br /></td></tr>
<tr class="separator:gab930708bfe45d0c6b107477d3e90370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1fc56873ff14590241f70e4387adffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa1fc56873ff14590241f70e4387adffa">regina::SatLST::roles</a> () const</td></tr>
<tr class="memdesc:gaa1fc56873ff14590241f70e4387adffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how the layered solid torus is attached to the boundary annulus.  <a href="group__subcomplex.html#gaa1fc56873ff14590241f70e4387adffa">More...</a><br /></td></tr>
<tr class="separator:gaa1fc56873ff14590241f70e4387adffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed63303e680ec48e1e342c9cd8a0bd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5ed63303e680ec48e1e342c9cd8a0bd0">regina::SatLST::clone</a> () const override</td></tr>
<tr class="memdesc:ga5ed63303e680ec48e1e342c9cd8a0bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga5ed63303e680ec48e1e342c9cd8a0bd0">More...</a><br /></td></tr>
<tr class="separator:ga5ed63303e680ec48e1e342c9cd8a0bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7186370470f3f18d5ec009b4e8cca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga63f7186370470f3f18d5ec009b4e8cca">regina::SatLST::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:ga63f7186370470f3f18d5ec009b4e8cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#ga63f7186370470f3f18d5ec009b4e8cca">More...</a><br /></td></tr>
<tr class="separator:ga63f7186370470f3f18d5ec009b4e8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8a6cf454d624c3457b9e57c8595e6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gada8a6cf454d624c3457b9e57c8595e6d">regina::SatLST::transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *iso, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri) override</td></tr>
<tr class="memdesc:gada8a6cf454d624c3457b9e57c8595e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the structure of this block according to the given isomorphism between triangulations.  <a href="group__subcomplex.html#gada8a6cf454d624c3457b9e57c8595e6d">More...</a><br /></td></tr>
<tr class="separator:gada8a6cf454d624c3457b9e57c8595e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4573ce98a10aee74114308c0676a0d32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4573ce98a10aee74114308c0676a0d32">regina::SatLST::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4573ce98a10aee74114308c0676a0d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga4573ce98a10aee74114308c0676a0d32">More...</a><br /></td></tr>
<tr class="separator:ga4573ce98a10aee74114308c0676a0d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84879d9a184d6561ab0d8d786642910"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa84879d9a184d6561ab0d8d786642910">regina::SatLST::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:gaa84879d9a184d6561ab0d8d786642910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#gaa84879d9a184d6561ab0d8d786642910">More...</a><br /></td></tr>
<tr class="separator:gaa84879d9a184d6561ab0d8d786642910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3607a9b334b63c9801dc21e48c4aa2a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatLST.html">SatLST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3607a9b334b63c9801dc21e48c4aa2a8">regina::SatLST::isBlockLST</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga3607a9b334b63c9801dc21e48c4aa2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (layered solid torus).  <a href="group__subcomplex.html#ga3607a9b334b63c9801dc21e48c4aa2a8">More...</a><br /></td></tr>
<tr class="separator:ga3607a9b334b63c9801dc21e48c4aa2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab2cd63212fd6becd41c3cfa250b619"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacab2cd63212fd6becd41c3cfa250b619">regina::SatTriPrism::SatTriPrism</a> (const <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gacab2cd63212fd6becd41c3cfa250b619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#gacab2cd63212fd6becd41c3cfa250b619">More...</a><br /></td></tr>
<tr class="separator:gacab2cd63212fd6becd41c3cfa250b619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c139ffaa27cd2ec950ec6df4f2a0dab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9c139ffaa27cd2ec950ec6df4f2a0dab">regina::SatTriPrism::isMajor</a> () const</td></tr>
<tr class="memdesc:ga9c139ffaa27cd2ec950ec6df4f2a0dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this prism of major type or minor type? See the class notes for further details.  <a href="group__subcomplex.html#ga9c139ffaa27cd2ec950ec6df4f2a0dab">More...</a><br /></td></tr>
<tr class="separator:ga9c139ffaa27cd2ec950ec6df4f2a0dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a6fe9a00b3a689f4d871d5a41d2f45"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga87a6fe9a00b3a689f4d871d5a41d2f45">regina::SatTriPrism::clone</a> () const override</td></tr>
<tr class="memdesc:ga87a6fe9a00b3a689f4d871d5a41d2f45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga87a6fe9a00b3a689f4d871d5a41d2f45">More...</a><br /></td></tr>
<tr class="separator:ga87a6fe9a00b3a689f4d871d5a41d2f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922755a5529f149de9886a0aaef5fd7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga922755a5529f149de9886a0aaef5fd7f">regina::SatTriPrism::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:ga922755a5529f149de9886a0aaef5fd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#ga922755a5529f149de9886a0aaef5fd7f">More...</a><br /></td></tr>
<tr class="separator:ga922755a5529f149de9886a0aaef5fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac988f9304e4a52b69df5ffc232ec34a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac988f9304e4a52b69df5ffc232ec34a1">regina::SatTriPrism::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gac988f9304e4a52b69df5ffc232ec34a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#gac988f9304e4a52b69df5ffc232ec34a1">More...</a><br /></td></tr>
<tr class="separator:gac988f9304e4a52b69df5ffc232ec34a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723ccdc7de49209c5bf7b3a4977c17e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga723ccdc7de49209c5bf7b3a4977c17e3">regina::SatTriPrism::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:ga723ccdc7de49209c5bf7b3a4977c17e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#ga723ccdc7de49209c5bf7b3a4977c17e3">More...</a><br /></td></tr>
<tr class="separator:ga723ccdc7de49209c5bf7b3a4977c17e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63e3437f4ff479e36494fa15aedb0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadd63e3437f4ff479e36494fa15aedb0d">regina::SatTriPrism::isBlockTriPrism</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:gadd63e3437f4ff479e36494fa15aedb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (triangular prism).  <a href="group__subcomplex.html#gadd63e3437f4ff479e36494fa15aedb0d">More...</a><br /></td></tr>
<tr class="separator:gadd63e3437f4ff479e36494fa15aedb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ae6234b5c89b74cb2937d7d31c2306"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga40ae6234b5c89b74cb2937d7d31c2306">regina::SatTriPrism::insertBlock</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, bool major)</td></tr>
<tr class="memdesc:ga40ae6234b5c89b74cb2937d7d31c2306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new copy of a triangular prism block into the given triangulation, and returns the corresponding block structure.  <a href="group__subcomplex.html#ga40ae6234b5c89b74cb2937d7d31c2306">More...</a><br /></td></tr>
<tr class="separator:ga40ae6234b5c89b74cb2937d7d31c2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a180fa33809948d8269c3b19fbef12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa3a180fa33809948d8269c3b19fbef12">regina::SatTriPrism::SatTriPrism</a> (bool major)</td></tr>
<tr class="memdesc:gaa3a180fa33809948d8269c3b19fbef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a partially initialised block.  <a href="group__subcomplex.html#gaa3a180fa33809948d8269c3b19fbef12">More...</a><br /></td></tr>
<tr class="separator:gaa3a180fa33809948d8269c3b19fbef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fda8e4ab7cb99ae6fcb0622f2fa2a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac4fda8e4ab7cb99ae6fcb0622f2fa2a8">regina::SatCube::SatCube</a> (const <a class="el" href="classregina_1_1SatCube.html">SatCube</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gac4fda8e4ab7cb99ae6fcb0622f2fa2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#gac4fda8e4ab7cb99ae6fcb0622f2fa2a8">More...</a><br /></td></tr>
<tr class="separator:gac4fda8e4ab7cb99ae6fcb0622f2fa2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9a05297dcb7dab0014f54b888c6665"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4c9a05297dcb7dab0014f54b888c6665">regina::SatCube::clone</a> () const override</td></tr>
<tr class="memdesc:ga4c9a05297dcb7dab0014f54b888c6665"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga4c9a05297dcb7dab0014f54b888c6665">More...</a><br /></td></tr>
<tr class="separator:ga4c9a05297dcb7dab0014f54b888c6665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d652cc01691163ee861c895408705e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga40d652cc01691163ee861c895408705e">regina::SatCube::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:ga40d652cc01691163ee861c895408705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#ga40d652cc01691163ee861c895408705e">More...</a><br /></td></tr>
<tr class="separator:ga40d652cc01691163ee861c895408705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25aceb80b2d715df1fda912b17e3f9ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga25aceb80b2d715df1fda912b17e3f9ad">regina::SatCube::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga25aceb80b2d715df1fda912b17e3f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga25aceb80b2d715df1fda912b17e3f9ad">More...</a><br /></td></tr>
<tr class="separator:ga25aceb80b2d715df1fda912b17e3f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a75bc834917cbc4dea03ab41f055f37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3a75bc834917cbc4dea03ab41f055f37">regina::SatCube::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:ga3a75bc834917cbc4dea03ab41f055f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#ga3a75bc834917cbc4dea03ab41f055f37">More...</a><br /></td></tr>
<tr class="separator:ga3a75bc834917cbc4dea03ab41f055f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6fb4982be0f7854335dda6b9e75ce6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatCube.html">SatCube</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8d6fb4982be0f7854335dda6b9e75ce6">regina::SatCube::isBlockCube</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga8d6fb4982be0f7854335dda6b9e75ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (cube).  <a href="group__subcomplex.html#ga8d6fb4982be0f7854335dda6b9e75ce6">More...</a><br /></td></tr>
<tr class="separator:ga8d6fb4982be0f7854335dda6b9e75ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e482d39394655f8ad0f2e35b9c67186"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatCube.html">SatCube</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6e482d39394655f8ad0f2e35b9c67186">regina::SatCube::insertBlock</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:ga6e482d39394655f8ad0f2e35b9c67186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new copy of a cube block into the given triangulation, and returns the corresponding block structure.  <a href="group__subcomplex.html#ga6e482d39394655f8ad0f2e35b9c67186">More...</a><br /></td></tr>
<tr class="separator:ga6e482d39394655f8ad0f2e35b9c67186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a02dbeb316e2c64816ed381d0f9714f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2a02dbeb316e2c64816ed381d0f9714f">regina::SatCube::SatCube</a> ()</td></tr>
<tr class="memdesc:ga2a02dbeb316e2c64816ed381d0f9714f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninitialised block.  <a href="group__subcomplex.html#ga2a02dbeb316e2c64816ed381d0f9714f">More...</a><br /></td></tr>
<tr class="separator:ga2a02dbeb316e2c64816ed381d0f9714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d17a2ced5d69e3cf56847a80f0d9dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga30d17a2ced5d69e3cf56847a80f0d9dd">regina::SatReflectorStrip::SatReflectorStrip</a> (const <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga30d17a2ced5d69e3cf56847a80f0d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#ga30d17a2ced5d69e3cf56847a80f0d9dd">More...</a><br /></td></tr>
<tr class="separator:ga30d17a2ced5d69e3cf56847a80f0d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aea1ca51b8b1f1141c2e1c05a821b54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3aea1ca51b8b1f1141c2e1c05a821b54">regina::SatReflectorStrip::clone</a> () const override</td></tr>
<tr class="memdesc:ga3aea1ca51b8b1f1141c2e1c05a821b54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga3aea1ca51b8b1f1141c2e1c05a821b54">More...</a><br /></td></tr>
<tr class="separator:ga3aea1ca51b8b1f1141c2e1c05a821b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30a730e9aa139ef5b4693859b34366f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad30a730e9aa139ef5b4693859b34366f">regina::SatReflectorStrip::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:gad30a730e9aa139ef5b4693859b34366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#gad30a730e9aa139ef5b4693859b34366f">More...</a><br /></td></tr>
<tr class="separator:gad30a730e9aa139ef5b4693859b34366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ae58723734d89763e3cd684b89e352"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga30ae58723734d89763e3cd684b89e352">regina::SatReflectorStrip::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga30ae58723734d89763e3cd684b89e352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga30ae58723734d89763e3cd684b89e352">More...</a><br /></td></tr>
<tr class="separator:ga30ae58723734d89763e3cd684b89e352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf1d38319376efdada01acf757fa342"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaacf1d38319376efdada01acf757fa342">regina::SatReflectorStrip::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:gaacf1d38319376efdada01acf757fa342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#gaacf1d38319376efdada01acf757fa342">More...</a><br /></td></tr>
<tr class="separator:gaacf1d38319376efdada01acf757fa342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420ee40707aea3e946614ef3947d72b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga420ee40707aea3e946614ef3947d72b9">regina::SatReflectorStrip::isBlockReflectorStrip</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga420ee40707aea3e946614ef3947d72b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (reflector strip).  <a href="group__subcomplex.html#ga420ee40707aea3e946614ef3947d72b9">More...</a><br /></td></tr>
<tr class="separator:ga420ee40707aea3e946614ef3947d72b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d402821b887395f10cc0812fd236c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga92d402821b887395f10cc0812fd236c7">regina::SatReflectorStrip::insertBlock</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, unsigned length, bool twisted)</td></tr>
<tr class="memdesc:ga92d402821b887395f10cc0812fd236c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new reflector strip into the given triangulation, and returns the corresponding block structure.  <a href="group__subcomplex.html#ga92d402821b887395f10cc0812fd236c7">More...</a><br /></td></tr>
<tr class="separator:ga92d402821b887395f10cc0812fd236c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbd29f8ddad38991a3f2209a1ba3974"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaefbd29f8ddad38991a3f2209a1ba3974">regina::SatReflectorStrip::SatReflectorStrip</a> (unsigned length, bool twisted)</td></tr>
<tr class="memdesc:gaefbd29f8ddad38991a3f2209a1ba3974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a partially initialised block of the given length.  <a href="group__subcomplex.html#gaefbd29f8ddad38991a3f2209a1ba3974">More...</a><br /></td></tr>
<tr class="separator:gaefbd29f8ddad38991a3f2209a1ba3974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a4b982a78589a71112bbfd3d7fa9e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad5a4b982a78589a71112bbfd3d7fa9e7">regina::SatLayering::SatLayering</a> (const <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gad5a4b982a78589a71112bbfd3d7fa9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="group__subcomplex.html#gad5a4b982a78589a71112bbfd3d7fa9e7">More...</a><br /></td></tr>
<tr class="separator:gad5a4b982a78589a71112bbfd3d7fa9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3ca5778e03c7d378bcc271fcc2e78e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4c3ca5778e03c7d378bcc271fcc2e78e">regina::SatLayering::overHorizontal</a> () const</td></tr>
<tr class="memdesc:ga4c3ca5778e03c7d378bcc271fcc2e78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this describe a layering over the horizontal edge of the boundary annulus, or a layering over the diagonal edge?  <a href="group__subcomplex.html#ga4c3ca5778e03c7d378bcc271fcc2e78e">More...</a><br /></td></tr>
<tr class="separator:ga4c3ca5778e03c7d378bcc271fcc2e78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d114838d339ea034a03facda36ba05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga32d114838d339ea034a03facda36ba05">regina::SatLayering::clone</a> () const override</td></tr>
<tr class="memdesc:ga32d114838d339ea034a03facda36ba05"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="group__subcomplex.html#ga32d114838d339ea034a03facda36ba05">More...</a><br /></td></tr>
<tr class="separator:ga32d114838d339ea034a03facda36ba05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb585b3971ab31f1f94bf2fbd676cd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabbb585b3971ab31f1f94bf2fbd676cd6">regina::SatLayering::adjustSFS</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs, bool reflect) const override</td></tr>
<tr class="memdesc:gabbb585b3971ab31f1f94bf2fbd676cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="group__subcomplex.html#gabbb585b3971ab31f1f94bf2fbd676cd6">More...</a><br /></td></tr>
<tr class="separator:gabbb585b3971ab31f1f94bf2fbd676cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd63b216e4e5eb3c9a609f5e8dc8855"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadbd63b216e4e5eb3c9a609f5e8dc8855">regina::SatLayering::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gadbd63b216e4e5eb3c9a609f5e8dc8855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#gadbd63b216e4e5eb3c9a609f5e8dc8855">More...</a><br /></td></tr>
<tr class="separator:gadbd63b216e4e5eb3c9a609f5e8dc8855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265e7b7e42b84115fc9a99bfa6322120"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga265e7b7e42b84115fc9a99bfa6322120">regina::SatLayering::writeAbbr</a> (std::ostream &amp;out, bool tex=false) const override</td></tr>
<tr class="memdesc:ga265e7b7e42b84115fc9a99bfa6322120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="group__subcomplex.html#ga265e7b7e42b84115fc9a99bfa6322120">More...</a><br /></td></tr>
<tr class="separator:ga265e7b7e42b84115fc9a99bfa6322120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8acdf15bb66805a4252669d00c21b12e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8acdf15bb66805a4252669d00c21b12e">regina::SatLayering::isBlockLayering</a> (const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;<a class="el" href="group__subcomplex.html#gaed25d82f9b29328fb95f0ccb15e81d8b">annulus</a>, <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:ga8acdf15bb66805a4252669d00c21b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (single layering).  <a href="group__subcomplex.html#ga8acdf15bb66805a4252669d00c21b12e">More...</a><br /></td></tr>
<tr class="separator:ga8acdf15bb66805a4252669d00c21b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae52a083ecd4d15166786f2e4892aad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1ae52a083ecd4d15166786f2e4892aad">regina::SatLayering::SatLayering</a> (bool <a class="el" href="group__subcomplex.html#ga4c3ca5778e03c7d378bcc271fcc2e78e">overHorizontal</a>)</td></tr>
<tr class="memdesc:ga1ae52a083ecd4d15166786f2e4892aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a partially initialised block.  <a href="group__subcomplex.html#ga1ae52a083ecd4d15166786f2e4892aad">More...</a><br /></td></tr>
<tr class="separator:ga1ae52a083ecd4d15166786f2e4892aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1595d36f7a05e067e20d2f4013af2d7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1595d36f7a05e067e20d2f4013af2d7d">regina::SatBlockSpec::SatBlockSpec</a> ()</td></tr>
<tr class="memdesc:ga1595d36f7a05e067e20d2f4013af2d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure that is completely uninitialised.  <a href="group__subcomplex.html#ga1595d36f7a05e067e20d2f4013af2d7d">More...</a><br /></td></tr>
<tr class="separator:ga1595d36f7a05e067e20d2f4013af2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b20151cc890847526af91ee8f0b0a1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2b20151cc890847526af91ee8f0b0a1d">regina::SatBlockSpec::SatBlockSpec</a> (<a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *useBlock, bool useRefVert, bool useRefHoriz)</td></tr>
<tr class="memdesc:ga2b20151cc890847526af91ee8f0b0a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure that is initialised to the given set of values.  <a href="group__subcomplex.html#ga2b20151cc890847526af91ee8f0b0a1d">More...</a><br /></td></tr>
<tr class="separator:ga2b20151cc890847526af91ee8f0b0a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b46832a3c372b4568d1844e40fa0449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2b46832a3c372b4568d1844e40fa0449">regina::SatBlockSpec::SatBlockSpec</a> (const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;)=default</td></tr>
<tr class="memdesc:ga2b46832a3c372b4568d1844e40fa0449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new structure that is a clone of the given structure.  <a href="group__subcomplex.html#ga2b46832a3c372b4568d1844e40fa0449">More...</a><br /></td></tr>
<tr class="separator:ga2b46832a3c372b4568d1844e40fa0449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e603f6a52be2e34ca2f62a2336bdbda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4e603f6a52be2e34ca2f62a2336bdbda">regina::SatBlockSpec::operator==</a> (const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:ga4e603f6a52be2e34ca2f62a2336bdbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure contain identical information.  <a href="group__subcomplex.html#ga4e603f6a52be2e34ca2f62a2336bdbda">More...</a><br /></td></tr>
<tr class="separator:ga4e603f6a52be2e34ca2f62a2336bdbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62bfa152b7cf206ed5b3f0b83d767294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga62bfa152b7cf206ed5b3f0b83d767294">regina::SatBlockSpec::operator!=</a> (const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:ga62bfa152b7cf206ed5b3f0b83d767294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure contain different information.  <a href="group__subcomplex.html#ga62bfa152b7cf206ed5b3f0b83d767294">More...</a><br /></td></tr>
<tr class="separator:ga62bfa152b7cf206ed5b3f0b83d767294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1944cb6dd1237ba9eeb41e348e24e904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1944cb6dd1237ba9eeb41e348e24e904">regina::SatBlockSpec::operator=</a> (const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;)=default</td></tr>
<tr class="memdesc:ga1944cb6dd1237ba9eeb41e348e24e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given structure.  <a href="group__subcomplex.html#ga1944cb6dd1237ba9eeb41e348e24e904">More...</a><br /></td></tr>
<tr class="separator:ga1944cb6dd1237ba9eeb41e348e24e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5307cfd3f28b9a737c9bc56587f3882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac5307cfd3f28b9a737c9bc56587f3882">regina::SatRegion::SatRegion</a> (<a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *starter)</td></tr>
<tr class="memdesc:gac5307cfd3f28b9a737c9bc56587f3882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new region containing just the given block.  <a href="group__subcomplex.html#gac5307cfd3f28b9a737c9bc56587f3882">More...</a><br /></td></tr>
<tr class="separator:gac5307cfd3f28b9a737c9bc56587f3882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38c590b25c141dd36cc47b64db6588c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab38c590b25c141dd36cc47b64db6588c">regina::SatRegion::~SatRegion</a> ()</td></tr>
<tr class="memdesc:gab38c590b25c141dd36cc47b64db6588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this structure and all of its internal data, including the individual blocks that make up this region.  <a href="group__subcomplex.html#gab38c590b25c141dd36cc47b64db6588c">More...</a><br /></td></tr>
<tr class="separator:gab38c590b25c141dd36cc47b64db6588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2e43b86fa0d683fdfd5c4b03a023ec"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gada2e43b86fa0d683fdfd5c4b03a023ec">regina::SatRegion::numberOfBlocks</a> () const</td></tr>
<tr class="memdesc:gada2e43b86fa0d683fdfd5c4b03a023ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated blocks that come together to form this saturated region.  <a href="group__subcomplex.html#gada2e43b86fa0d683fdfd5c4b03a023ec">More...</a><br /></td></tr>
<tr class="separator:gada2e43b86fa0d683fdfd5c4b03a023ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab741d4cfcf8d8450dadff066b7f57f25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab741d4cfcf8d8450dadff066b7f57f25">regina::SatRegion::block</a> (unsigned long which) const</td></tr>
<tr class="memdesc:gab741d4cfcf8d8450dadff066b7f57f25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested saturated block within this region.  <a href="group__subcomplex.html#gab741d4cfcf8d8450dadff066b7f57f25">More...</a><br /></td></tr>
<tr class="separator:gab741d4cfcf8d8450dadff066b7f57f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ef8dd460a89b382fc69595f8c9a63d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga59ef8dd460a89b382fc69595f8c9a63d">regina::SatRegion::blockIndex</a> (const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *<a class="el" href="group__subcomplex.html#gab741d4cfcf8d8450dadff066b7f57f25">block</a>) const</td></tr>
<tr class="memdesc:ga59ef8dd460a89b382fc69595f8c9a63d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the given block within this region.  <a href="group__subcomplex.html#ga59ef8dd460a89b382fc69595f8c9a63d">More...</a><br /></td></tr>
<tr class="separator:ga59ef8dd460a89b382fc69595f8c9a63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eab8ca2776c0047b5f25c2aad047ad1"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0eab8ca2776c0047b5f25c2aad047ad1">regina::SatRegion::numberOfBoundaryAnnuli</a> () const</td></tr>
<tr class="memdesc:ga0eab8ca2776c0047b5f25c2aad047ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated annuli that together form the boundary components of this region.  <a href="group__subcomplex.html#ga0eab8ca2776c0047b5f25c2aad047ad1">More...</a><br /></td></tr>
<tr class="separator:ga0eab8ca2776c0047b5f25c2aad047ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b71f8fb8bb29e4cb4347fd25b6e1f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad5b71f8fb8bb29e4cb4347fd25b6e1f4">regina::SatRegion::boundaryAnnulus</a> (unsigned long which, bool &amp;blockRefVert, bool &amp;blockRefHoriz) const</td></tr>
<tr class="memdesc:gad5b71f8fb8bb29e4cb4347fd25b6e1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested saturated annulus on the boundary of this region.  <a href="group__subcomplex.html#gad5b71f8fb8bb29e4cb4347fd25b6e1f4">More...</a><br /></td></tr>
<tr class="separator:gad5b71f8fb8bb29e4cb4347fd25b6e1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b7ed753341ef750439c01a945eb2d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa2b7ed753341ef750439c01a945eb2d9">regina::SatRegion::boundaryAnnulus</a> (unsigned long which, <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;<a class="el" href="group__subcomplex.html#gab741d4cfcf8d8450dadff066b7f57f25">block</a>, unsigned &amp;annulus, bool &amp;blockRefVert, bool &amp;blockRefHoriz) const</td></tr>
<tr class="memdesc:gaa2b7ed753341ef750439c01a945eb2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> fine details of the requested saturated annulus on the boundary of this region.  <a href="group__subcomplex.html#gaa2b7ed753341ef750439c01a945eb2d9">More...</a><br /></td></tr>
<tr class="separator:gaa2b7ed753341ef750439c01a945eb2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1e8d3b599c58464e73ddf594630f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6e1e8d3b599c58464e73ddf594630f22">regina::SatRegion::createSFS</a> (bool reflect) const</td></tr>
<tr class="memdesc:ga6e1e8d3b599c58464e73ddf594630f22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the Seifert fibred space represented by this region.  <a href="group__subcomplex.html#ga6e1e8d3b599c58464e73ddf594630f22">More...</a><br /></td></tr>
<tr class="separator:ga6e1e8d3b599c58464e73ddf594630f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737839a4e297056cf8328c03a86b57b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga737839a4e297056cf8328c03a86b57b5">regina::SatRegion::expand</a> (<a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">SatBlock::TetList</a> &amp;avoidTets, bool stopIfIncomplete=false)</td></tr>
<tr class="memdesc:ga737839a4e297056cf8328c03a86b57b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands this region as far as possible within the overall triangulation.  <a href="group__subcomplex.html#ga737839a4e297056cf8328c03a86b57b5">More...</a><br /></td></tr>
<tr class="separator:ga737839a4e297056cf8328c03a86b57b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09d512dd41181f4bb0394281d7623fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa09d512dd41181f4bb0394281d7623fa">regina::SatRegion::writeBlockAbbrs</a> (std::ostream &amp;out, bool tex=false) const</td></tr>
<tr class="memdesc:gaa09d512dd41181f4bb0394281d7623fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated list of blocks within this region to the given output stream.  <a href="group__subcomplex.html#gaa09d512dd41181f4bb0394281d7623fa">More...</a><br /></td></tr>
<tr class="separator:gaa09d512dd41181f4bb0394281d7623fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0913963357b5660ea996226a70ce91a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0913963357b5660ea996226a70ce91a0">regina::SatRegion::writeDetail</a> (std::ostream &amp;out, const std::string &amp;title) const</td></tr>
<tr class="memdesc:ga0913963357b5660ea996226a70ce91a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the composition of this region to the given output stream.  <a href="group__subcomplex.html#ga0913963357b5660ea996226a70ce91a0">More...</a><br /></td></tr>
<tr class="separator:ga0913963357b5660ea996226a70ce91a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556a1ced4a7a188ecc761e6f12f068cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga556a1ced4a7a188ecc761e6f12f068cf">regina::SatRegion::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga556a1ced4a7a188ecc761e6f12f068cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga556a1ced4a7a188ecc761e6f12f068cf">More...</a><br /></td></tr>
<tr class="separator:ga556a1ced4a7a188ecc761e6f12f068cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad76b1305eb7d9115e0aac71432b983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0ad76b1305eb7d9115e0aac71432b983">regina::SatRegion::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0ad76b1305eb7d9115e0aac71432b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga0ad76b1305eb7d9115e0aac71432b983">More...</a><br /></td></tr>
<tr class="separator:ga0ad76b1305eb7d9115e0aac71432b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d7948da6fd80ecadd64856922d2c07"><td class="memItemLeft" align="right" valign="top"><a id="ga12d7948da6fd80ecadd64856922d2c07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatRegion::SatRegion</b> (const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;)=delete</td></tr>
<tr class="separator:ga12d7948da6fd80ecadd64856922d2c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9943fb4e094774bd517e54c7658d775e"><td class="memItemLeft" align="right" valign="top"><a id="ga9943fb4e094774bd517e54c7658d775e"></a>
<a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatRegion::operator=</b> (const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp;)=delete</td></tr>
<tr class="separator:ga9943fb4e094774bd517e54c7658d775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f25902d2536efeede4853644ead22b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0f25902d2536efeede4853644ead22b6">regina::SnapPeaCensusTri::clone</a> () const</td></tr>
<tr class="memdesc:ga0f25902d2536efeede4853644ead22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga0f25902d2536efeede4853644ead22b6">More...</a><br /></td></tr>
<tr class="separator:ga0f25902d2536efeede4853644ead22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17cbcc61d020779e77970ed6399ec925"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga17cbcc61d020779e77970ed6399ec925">regina::SnapPeaCensusTri::section</a> () const</td></tr>
<tr class="memdesc:ga17cbcc61d020779e77970ed6399ec925"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the section of the SnapPea census to which this triangulation belongs.  <a href="group__subcomplex.html#ga17cbcc61d020779e77970ed6399ec925">More...</a><br /></td></tr>
<tr class="separator:ga17cbcc61d020779e77970ed6399ec925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0653a0c75bc408a2e5cb9e9a44bb7225"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0653a0c75bc408a2e5cb9e9a44bb7225">regina::SnapPeaCensusTri::index</a> () const</td></tr>
<tr class="memdesc:ga0653a0c75bc408a2e5cb9e9a44bb7225"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this triangulation within its particular section of the SnapPea census.  <a href="group__subcomplex.html#ga0653a0c75bc408a2e5cb9e9a44bb7225">More...</a><br /></td></tr>
<tr class="separator:ga0653a0c75bc408a2e5cb9e9a44bb7225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba8c9b131485a0771c6027d12ffac66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2ba8c9b131485a0771c6027d12ffac66">regina::SnapPeaCensusTri::operator==</a> (const <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga2ba8c9b131485a0771c6027d12ffac66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure represent the same triangulation from the SnapPea census.  <a href="group__subcomplex.html#ga2ba8c9b131485a0771c6027d12ffac66">More...</a><br /></td></tr>
<tr class="separator:ga2ba8c9b131485a0771c6027d12ffac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94cbf3a6227144003d05e64410a24f9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga94cbf3a6227144003d05e64410a24f9a">regina::SnapPeaCensusTri::operator!=</a> (const <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga94cbf3a6227144003d05e64410a24f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure represent different triangulations from the SnapPea census.  <a href="group__subcomplex.html#ga94cbf3a6227144003d05e64410a24f9a">More...</a><br /></td></tr>
<tr class="separator:ga94cbf3a6227144003d05e64410a24f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c5f53e8a166590e1cc6db486a7e075"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga51c5f53e8a166590e1cc6db486a7e075">regina::SnapPeaCensusTri::isSmallSnapPeaCensusTri</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:ga51c5f53e8a166590e1cc6db486a7e075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is one of the smallest SnapPea census triangulations.  <a href="group__subcomplex.html#ga51c5f53e8a166590e1cc6db486a7e075">More...</a><br /></td></tr>
<tr class="separator:ga51c5f53e8a166590e1cc6db486a7e075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29db744b46a69f7518e60b75d4d66f25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga29db744b46a69f7518e60b75d4d66f25">regina::SnapPeaCensusTri::manifold</a> () const override</td></tr>
<tr class="memdesc:ga29db744b46a69f7518e60b75d4d66f25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga29db744b46a69f7518e60b75d4d66f25">More...</a><br /></td></tr>
<tr class="separator:ga29db744b46a69f7518e60b75d4d66f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed042ff18db35d0d6c83b457dbb1ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabed042ff18db35d0d6c83b457dbb1ff0">regina::SnapPeaCensusTri::homology</a> () const override</td></tr>
<tr class="memdesc:gabed042ff18db35d0d6c83b457dbb1ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gabed042ff18db35d0d6c83b457dbb1ff0">More...</a><br /></td></tr>
<tr class="separator:gabed042ff18db35d0d6c83b457dbb1ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00867f9d2da120606eabc5107478e2ee"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga00867f9d2da120606eabc5107478e2ee">regina::SnapPeaCensusTri::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga00867f9d2da120606eabc5107478e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga00867f9d2da120606eabc5107478e2ee">More...</a><br /></td></tr>
<tr class="separator:ga00867f9d2da120606eabc5107478e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85df37685a1d128fb6fda90f3a77360b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga85df37685a1d128fb6fda90f3a77360b">regina::SnapPeaCensusTri::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga85df37685a1d128fb6fda90f3a77360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga85df37685a1d128fb6fda90f3a77360b">More...</a><br /></td></tr>
<tr class="separator:ga85df37685a1d128fb6fda90f3a77360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff7e1d816cd0bc98b75c4e10e166692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3ff7e1d816cd0bc98b75c4e10e166692">regina::SnappedBall::clone</a> () const</td></tr>
<tr class="memdesc:ga3ff7e1d816cd0bc98b75c4e10e166692"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga3ff7e1d816cd0bc98b75c4e10e166692">More...</a><br /></td></tr>
<tr class="separator:ga3ff7e1d816cd0bc98b75c4e10e166692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1065793a1b9ed62f334863727145159b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1065793a1b9ed62f334863727145159b">regina::SnappedBall::tetrahedron</a> () const</td></tr>
<tr class="memdesc:ga1065793a1b9ed62f334863727145159b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedron that forms this snapped ball.  <a href="group__subcomplex.html#ga1065793a1b9ed62f334863727145159b">More...</a><br /></td></tr>
<tr class="separator:ga1065793a1b9ed62f334863727145159b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f4e5a563cfba364f78c9a389a7acd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga14f4e5a563cfba364f78c9a389a7acd8">regina::SnappedBall::boundaryFace</a> (int index) const</td></tr>
<tr class="memdesc:ga14f4e5a563cfba364f78c9a389a7acd8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedron faces that forms the boundary of this snapped ball.  <a href="group__subcomplex.html#ga14f4e5a563cfba364f78c9a389a7acd8">More...</a><br /></td></tr>
<tr class="separator:ga14f4e5a563cfba364f78c9a389a7acd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf016c5430a4f92c7ed3699a43ee6fae1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf016c5430a4f92c7ed3699a43ee6fae1">regina::SnappedBall::internalFace</a> (int index) const</td></tr>
<tr class="memdesc:gaf016c5430a4f92c7ed3699a43ee6fae1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedron faces internal to this snapped ball.  <a href="group__subcomplex.html#gaf016c5430a4f92c7ed3699a43ee6fae1">More...</a><br /></td></tr>
<tr class="separator:gaf016c5430a4f92c7ed3699a43ee6fae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce9a454ef99df52f433e3535c178cae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadce9a454ef99df52f433e3535c178cae">regina::SnappedBall::equatorEdge</a> () const</td></tr>
<tr class="memdesc:gadce9a454ef99df52f433e3535c178cae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge that forms the equator of the boundary sphere of this ball.  <a href="group__subcomplex.html#gadce9a454ef99df52f433e3535c178cae">More...</a><br /></td></tr>
<tr class="separator:gadce9a454ef99df52f433e3535c178cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cebd232bb0c1b83011051a869e8406"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga30cebd232bb0c1b83011051a869e8406">regina::SnappedBall::internalEdge</a> () const</td></tr>
<tr class="memdesc:ga30cebd232bb0c1b83011051a869e8406"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge internal to this snapped ball.  <a href="group__subcomplex.html#ga30cebd232bb0c1b83011051a869e8406">More...</a><br /></td></tr>
<tr class="separator:ga30cebd232bb0c1b83011051a869e8406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fef6a2032d2a78de6739e15c05c5e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac5fef6a2032d2a78de6739e15c05c5e1">regina::SnappedBall::formsSnappedBall</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:gac5fef6a2032d2a78de6739e15c05c5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms a snapped 3-ball within a triangulation.  <a href="group__subcomplex.html#gac5fef6a2032d2a78de6739e15c05c5e1">More...</a><br /></td></tr>
<tr class="separator:gac5fef6a2032d2a78de6739e15c05c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaefad8c7de255a9bf0854e00faf79c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaefad8c7de255a9bf0854e00faf79c06">regina::SnappedBall::manifold</a> () const override</td></tr>
<tr class="memdesc:gaaefad8c7de255a9bf0854e00faf79c06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gaaefad8c7de255a9bf0854e00faf79c06">More...</a><br /></td></tr>
<tr class="separator:gaaefad8c7de255a9bf0854e00faf79c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f94395d258660b3b027bad5868f7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga43f94395d258660b3b027bad5868f7e6">regina::SnappedBall::homology</a> () const override</td></tr>
<tr class="memdesc:ga43f94395d258660b3b027bad5868f7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga43f94395d258660b3b027bad5868f7e6">More...</a><br /></td></tr>
<tr class="separator:ga43f94395d258660b3b027bad5868f7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1acb9738f55ad2fac5f297af4774906"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab1acb9738f55ad2fac5f297af4774906">regina::SnappedBall::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gab1acb9738f55ad2fac5f297af4774906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gab1acb9738f55ad2fac5f297af4774906">More...</a><br /></td></tr>
<tr class="separator:gab1acb9738f55ad2fac5f297af4774906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855f2eed086762360c249660ad634109"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga855f2eed086762360c249660ad634109">regina::SnappedBall::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga855f2eed086762360c249660ad634109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga855f2eed086762360c249660ad634109">More...</a><br /></td></tr>
<tr class="separator:ga855f2eed086762360c249660ad634109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb63dc3d3295836b75aaa1303f013921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadb63dc3d3295836b75aaa1303f013921">regina::SnappedBall::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gadb63dc3d3295836b75aaa1303f013921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gadb63dc3d3295836b75aaa1303f013921">More...</a><br /></td></tr>
<tr class="separator:gadb63dc3d3295836b75aaa1303f013921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562cdb2d0d0fedcafd311649a8188366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga562cdb2d0d0fedcafd311649a8188366">regina::SnappedTwoSphere::~SnappedTwoSphere</a> ()</td></tr>
<tr class="memdesc:ga562cdb2d0d0fedcafd311649a8188366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this snapped 2-sphere; note that the corresponding snapped 3-balls will also be destroyed.  <a href="group__subcomplex.html#ga562cdb2d0d0fedcafd311649a8188366">More...</a><br /></td></tr>
<tr class="separator:ga562cdb2d0d0fedcafd311649a8188366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ca13de2b3ad244568a9e150b8ae63e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga92ca13de2b3ad244568a9e150b8ae63e">regina::SnappedTwoSphere::clone</a> () const</td></tr>
<tr class="memdesc:ga92ca13de2b3ad244568a9e150b8ae63e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga92ca13de2b3ad244568a9e150b8ae63e">More...</a><br /></td></tr>
<tr class="separator:ga92ca13de2b3ad244568a9e150b8ae63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031db144e9f041c06efb12d9b0029c68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga031db144e9f041c06efb12d9b0029c68">regina::SnappedTwoSphere::snappedBall</a> (int index) const</td></tr>
<tr class="memdesc:ga031db144e9f041c06efb12d9b0029c68"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two snapped 3-balls whose equators are joined.  <a href="group__subcomplex.html#ga031db144e9f041c06efb12d9b0029c68">More...</a><br /></td></tr>
<tr class="separator:ga031db144e9f041c06efb12d9b0029c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98381218f472fe7a31b3c26e56f7187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae98381218f472fe7a31b3c26e56f7187">regina::SnappedTwoSphere::formsSnappedTwoSphere</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet1, <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet2)</td></tr>
<tr class="memdesc:gae98381218f472fe7a31b3c26e56f7187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the two given tetrahedra together form a snapped 2-sphere.  <a href="group__subcomplex.html#gae98381218f472fe7a31b3c26e56f7187">More...</a><br /></td></tr>
<tr class="separator:gae98381218f472fe7a31b3c26e56f7187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46967e3d94d0bff13708e1677332c5c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga46967e3d94d0bff13708e1677332c5c3">regina::SnappedTwoSphere::formsSnappedTwoSphere</a> (<a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *ball1, <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *ball2)</td></tr>
<tr class="memdesc:ga46967e3d94d0bff13708e1677332c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the two given snapped 3-balls together form a snapped 2-sphere.  <a href="group__subcomplex.html#ga46967e3d94d0bff13708e1677332c5c3">More...</a><br /></td></tr>
<tr class="separator:ga46967e3d94d0bff13708e1677332c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e231086b93a4e355f4ead409dfbbe05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6e231086b93a4e355f4ead409dfbbe05">regina::SnappedTwoSphere::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga6e231086b93a4e355f4ead409dfbbe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga6e231086b93a4e355f4ead409dfbbe05">More...</a><br /></td></tr>
<tr class="separator:ga6e231086b93a4e355f4ead409dfbbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5044620a32b420401164997a6e9f28c9"><td class="memItemLeft" align="right" valign="top"><a id="ga5044620a32b420401164997a6e9f28c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SnappedTwoSphere::SnappedTwoSphere</b> (const <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> &amp;)=delete</td></tr>
<tr class="separator:ga5044620a32b420401164997a6e9f28c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd0135a3910b37d4f54f5daee01a809"><td class="memItemLeft" align="right" valign="top"><a id="gabbd0135a3910b37d4f54f5daee01a809"></a>
<a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SnappedTwoSphere::operator=</b> (const <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> &amp;)=delete</td></tr>
<tr class="separator:gabbd0135a3910b37d4f54f5daee01a809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8408a546f06acc1d53b4710fe4c9062"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae8408a546f06acc1d53b4710fe4c9062">regina::SpiralSolidTorus::~SpiralSolidTorus</a> ()</td></tr>
<tr class="memdesc:gae8408a546f06acc1d53b4710fe4c9062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this spiralled solid torus.  <a href="group__subcomplex.html#gae8408a546f06acc1d53b4710fe4c9062">More...</a><br /></td></tr>
<tr class="separator:gae8408a546f06acc1d53b4710fe4c9062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7fd7ae82a49b944aba728d975648ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac7fd7ae82a49b944aba728d975648ed8">regina::SpiralSolidTorus::clone</a> () const</td></tr>
<tr class="memdesc:gac7fd7ae82a49b944aba728d975648ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#gac7fd7ae82a49b944aba728d975648ed8">More...</a><br /></td></tr>
<tr class="separator:gac7fd7ae82a49b944aba728d975648ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31ed2050238c4e835689fff87956227"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227">regina::SpiralSolidTorus::size</a> () const</td></tr>
<tr class="memdesc:gac31ed2050238c4e835689fff87956227"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this spiralled solid torus.  <a href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227">More...</a><br /></td></tr>
<tr class="separator:gac31ed2050238c4e835689fff87956227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc085c61267bac6e531bee325f44031e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabc085c61267bac6e531bee325f44031e">regina::SpiralSolidTorus::tetrahedron</a> (size_t index) const</td></tr>
<tr class="memdesc:gabc085c61267bac6e531bee325f44031e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this spiralled solid torus.  <a href="group__subcomplex.html#gabc085c61267bac6e531bee325f44031e">More...</a><br /></td></tr>
<tr class="separator:gabc085c61267bac6e531bee325f44031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f4e19343a3c7ff83b2d401ba2bc575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab5f4e19343a3c7ff83b2d401ba2bc575">regina::SpiralSolidTorus::vertexRoles</a> (size_t index) const</td></tr>
<tr class="memdesc:gab5f4e19343a3c7ff83b2d401ba2bc575"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus.  <a href="group__subcomplex.html#gab5f4e19343a3c7ff83b2d401ba2bc575">More...</a><br /></td></tr>
<tr class="separator:gab5f4e19343a3c7ff83b2d401ba2bc575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0025e7cff79ec36c33d6236a3dd3f699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0025e7cff79ec36c33d6236a3dd3f699">regina::SpiralSolidTorus::reverse</a> ()</td></tr>
<tr class="memdesc:ga0025e7cff79ec36c33d6236a3dd3f699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses this spiralled solid torus.  <a href="group__subcomplex.html#ga0025e7cff79ec36c33d6236a3dd3f699">More...</a><br /></td></tr>
<tr class="separator:ga0025e7cff79ec36c33d6236a3dd3f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc353661dbe3b81afa1187dd049c4d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaadc353661dbe3b81afa1187dd049c4d2">regina::SpiralSolidTorus::cycle</a> (size_t k)</td></tr>
<tr class="memdesc:gaadc353661dbe3b81afa1187dd049c4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this spiralled solid torus by the given number of tetrahedra.  <a href="group__subcomplex.html#gaadc353661dbe3b81afa1187dd049c4d2">More...</a><br /></td></tr>
<tr class="separator:gaadc353661dbe3b81afa1187dd049c4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8837a636d54f38151e0d793fd5e04f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8837a636d54f38151e0d793fd5e04f00">regina::SpiralSolidTorus::makeCanonical</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga8837a636d54f38151e0d793fd5e04f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this spiralled solid torus into its canonical representation.  <a href="group__subcomplex.html#ga8837a636d54f38151e0d793fd5e04f00">More...</a><br /></td></tr>
<tr class="separator:ga8837a636d54f38151e0d793fd5e04f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267a2decfeb911ff176bb19aa19f2fe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga267a2decfeb911ff176bb19aa19f2fe0">regina::SpiralSolidTorus::isCanonical</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri) const</td></tr>
<tr class="memdesc:ga267a2decfeb911ff176bb19aa19f2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this spiralled solid torus is in canonical form.  <a href="group__subcomplex.html#ga267a2decfeb911ff176bb19aa19f2fe0">More...</a><br /></td></tr>
<tr class="separator:ga267a2decfeb911ff176bb19aa19f2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f071e44a208be72fe4c9d5a2375e3ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0f071e44a208be72fe4c9d5a2375e3ec">regina::SpiralSolidTorus::formsSpiralSolidTorus</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; useVertexRoles)</td></tr>
<tr class="memdesc:ga0f071e44a208be72fe4c9d5a2375e3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms part of a spiralled solid torus with its vertices playing the given roles in the solid torus.  <a href="group__subcomplex.html#ga0f071e44a208be72fe4c9d5a2375e3ec">More...</a><br /></td></tr>
<tr class="separator:ga0f071e44a208be72fe4c9d5a2375e3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f35ec11ed58654c673972ae683072c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab0f35ec11ed58654c673972ae683072c">regina::SpiralSolidTorus::manifold</a> () const override</td></tr>
<tr class="memdesc:gab0f35ec11ed58654c673972ae683072c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gab0f35ec11ed58654c673972ae683072c">More...</a><br /></td></tr>
<tr class="separator:gab0f35ec11ed58654c673972ae683072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa50b78ce48118418a74156102c148c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaaa50b78ce48118418a74156102c148c0">regina::SpiralSolidTorus::homology</a> () const override</td></tr>
<tr class="memdesc:gaaa50b78ce48118418a74156102c148c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gaaa50b78ce48118418a74156102c148c0">More...</a><br /></td></tr>
<tr class="separator:gaaa50b78ce48118418a74156102c148c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ebbeb5ae8293c3e6ccfb13902d4dd7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab3ebbeb5ae8293c3e6ccfb13902d4dd7">regina::SpiralSolidTorus::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gab3ebbeb5ae8293c3e6ccfb13902d4dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gab3ebbeb5ae8293c3e6ccfb13902d4dd7">More...</a><br /></td></tr>
<tr class="separator:gab3ebbeb5ae8293c3e6ccfb13902d4dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb7aedbf38fd0e8a5fadf13256acc87"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5fb7aedbf38fd0e8a5fadf13256acc87">regina::SpiralSolidTorus::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga5fb7aedbf38fd0e8a5fadf13256acc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga5fb7aedbf38fd0e8a5fadf13256acc87">More...</a><br /></td></tr>
<tr class="separator:ga5fb7aedbf38fd0e8a5fadf13256acc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c0b0517a7e5d1dc6b2c3f9c7ff2818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga77c0b0517a7e5d1dc6b2c3f9c7ff2818">regina::SpiralSolidTorus::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga77c0b0517a7e5d1dc6b2c3f9c7ff2818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga77c0b0517a7e5d1dc6b2c3f9c7ff2818">More...</a><br /></td></tr>
<tr class="separator:ga77c0b0517a7e5d1dc6b2c3f9c7ff2818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae151285bffbeaa55a7fc0ed1db4e0ff8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae151285bffbeaa55a7fc0ed1db4e0ff8">regina::StandardTriangulation::~StandardTriangulation</a> ()</td></tr>
<tr class="memdesc:gae151285bffbeaa55a7fc0ed1db4e0ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor that does nothing.  <a href="group__subcomplex.html#gae151285bffbeaa55a7fc0ed1db4e0ff8">More...</a><br /></td></tr>
<tr class="separator:gae151285bffbeaa55a7fc0ed1db4e0ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f318c415f2ec73916cc6c3aa669d8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga62f318c415f2ec73916cc6c3aa669d8a">regina::StandardTriangulation::name</a> () const</td></tr>
<tr class="memdesc:ga62f318c415f2ec73916cc6c3aa669d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation as a human-readable string.  <a href="group__subcomplex.html#ga62f318c415f2ec73916cc6c3aa669d8a">More...</a><br /></td></tr>
<tr class="separator:ga62f318c415f2ec73916cc6c3aa669d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad060bab2f08b1e5881d25b2291d8e09c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad060bab2f08b1e5881d25b2291d8e09c">regina::StandardTriangulation::TeXName</a> () const</td></tr>
<tr class="memdesc:gad060bab2f08b1e5881d25b2291d8e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation in TeX format.  <a href="group__subcomplex.html#gad060bab2f08b1e5881d25b2291d8e09c">More...</a><br /></td></tr>
<tr class="separator:gad060bab2f08b1e5881d25b2291d8e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50ffb2c3d335dad75a45f1f8c4d9a4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation::manifold</a> () const</td></tr>
<tr class="memdesc:gac50ffb2c3d335dad75a45f1f8c4d9a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">More...</a><br /></td></tr>
<tr class="separator:gac50ffb2c3d335dad75a45f1f8c4d9a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca65a2083031bd2bc8cb2a2565004570"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation::homology</a> () const</td></tr>
<tr class="memdesc:gaca65a2083031bd2bc8cb2a2565004570"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">More...</a><br /></td></tr>
<tr class="separator:gaca65a2083031bd2bc8cb2a2565004570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbd1c110caa1deb5e1ce0e58665bb573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573">regina::StandardTriangulation::homologyH1</a> () const</td></tr>
<tr class="memdesc:gacbd1c110caa1deb5e1ce0e58665bb573"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573">More...</a><br /></td></tr>
<tr class="separator:gacbd1c110caa1deb5e1ce0e58665bb573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd4f6240a77f6148c66b16dc94922da"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation::writeName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga4dd4f6240a77f6148c66b16dc94922da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">More...</a><br /></td></tr>
<tr class="separator:ga4dd4f6240a77f6148c66b16dc94922da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7acaa9c2c1a8abaf4b0f6639fe413037"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation::writeTeXName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga7acaa9c2c1a8abaf4b0f6639fe413037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">More...</a><br /></td></tr>
<tr class="separator:ga7acaa9c2c1a8abaf4b0f6639fe413037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11da317c33469df8b5518cecb60b2109"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga11da317c33469df8b5518cecb60b2109">regina::StandardTriangulation::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga11da317c33469df8b5518cecb60b2109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga11da317c33469df8b5518cecb60b2109">More...</a><br /></td></tr>
<tr class="separator:ga11da317c33469df8b5518cecb60b2109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a933ec0aad81b4560f574f4f2e15813"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga1a933ec0aad81b4560f574f4f2e15813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">More...</a><br /></td></tr>
<tr class="separator:ga1a933ec0aad81b4560f574f4f2e15813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c589e3471255c2cf81a9da2ab6e214a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1c589e3471255c2cf81a9da2ab6e214a">regina::StandardTriangulation::isStandardTriangulation</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *component)</td></tr>
<tr class="memdesc:ga1c589e3471255c2cf81a9da2ab6e214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given component represents one of the standard triangulations understood by Regina.  <a href="group__subcomplex.html#ga1c589e3471255c2cf81a9da2ab6e214a">More...</a><br /></td></tr>
<tr class="separator:ga1c589e3471255c2cf81a9da2ab6e214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e665c2d5ba2cb29947962c2e176bfd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga08e665c2d5ba2cb29947962c2e176bfd">regina::StandardTriangulation::isStandardTriangulation</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga08e665c2d5ba2cb29947962c2e176bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given triangulation represents one of the standard triangulations understood by Regina.  <a href="group__subcomplex.html#ga08e665c2d5ba2cb29947962c2e176bfd">More...</a><br /></td></tr>
<tr class="separator:ga08e665c2d5ba2cb29947962c2e176bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a145181a8373c373f0a917b7c086ea7"><td class="memItemLeft" align="right" valign="top"><a id="ga0a145181a8373c373f0a917b7c086ea7"></a>
<a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::StandardTriangulation::operator=</b> (const <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &amp;)=delete</td></tr>
<tr class="separator:ga0a145181a8373c373f0a917b7c086ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2f26731dc597e075130299d5d520ce1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa2f26731dc597e075130299d5d520ce1">regina::StandardTriangulation::StandardTriangulation</a> ()=default</td></tr>
<tr class="memdesc:gaa2f26731dc597e075130299d5d520ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__subcomplex.html#gaa2f26731dc597e075130299d5d520ce1">More...</a><br /></td></tr>
<tr class="separator:gaa2f26731dc597e075130299d5d520ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0384e9bcbb4e02ad62708cdafbf4bf9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0384e9bcbb4e02ad62708cdafbf4bf9a">regina::StandardTriangulation::StandardTriangulation</a> (const <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &amp;)=default</td></tr>
<tr class="memdesc:ga0384e9bcbb4e02ad62708cdafbf4bf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do-nothing copy constructor.  <a href="group__subcomplex.html#ga0384e9bcbb4e02ad62708cdafbf4bf9a">More...</a><br /></td></tr>
<tr class="separator:ga0384e9bcbb4e02ad62708cdafbf4bf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b53a3215c260f91b3f0b8c51688f02"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga70b53a3215c260f91b3f0b8c51688f02">regina::TriSolidTorus::~TriSolidTorus</a> ()</td></tr>
<tr class="memdesc:ga70b53a3215c260f91b3f0b8c51688f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this solid torus.  <a href="group__subcomplex.html#ga70b53a3215c260f91b3f0b8c51688f02">More...</a><br /></td></tr>
<tr class="separator:ga70b53a3215c260f91b3f0b8c51688f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3db9c62e7aae094162936494a2b6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3f3db9c62e7aae094162936494a2b6ed">regina::TriSolidTorus::clone</a> () const</td></tr>
<tr class="memdesc:ga3f3db9c62e7aae094162936494a2b6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga3f3db9c62e7aae094162936494a2b6ed">More...</a><br /></td></tr>
<tr class="separator:ga3f3db9c62e7aae094162936494a2b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6309e86d2d4d03d34cc5d750bd1fc393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6309e86d2d4d03d34cc5d750bd1fc393">regina::TriSolidTorus::tetrahedron</a> (int index) const</td></tr>
<tr class="memdesc:ga6309e86d2d4d03d34cc5d750bd1fc393"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this solid torus.  <a href="group__subcomplex.html#ga6309e86d2d4d03d34cc5d750bd1fc393">More...</a><br /></td></tr>
<tr class="separator:ga6309e86d2d4d03d34cc5d750bd1fc393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a73c2957fd960d42c0b493726f7f994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7a73c2957fd960d42c0b493726f7f994">regina::TriSolidTorus::vertexRoles</a> (int index) const</td></tr>
<tr class="memdesc:ga7a73c2957fd960d42c0b493726f7f994"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus.  <a href="group__subcomplex.html#ga7a73c2957fd960d42c0b493726f7f994">More...</a><br /></td></tr>
<tr class="separator:ga7a73c2957fd960d42c0b493726f7f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6ad5bd5c7d85cb3b617d5a8c3572d1a5">regina::TriSolidTorus::isAnnulusSelfIdentified</a> (int index, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; *roleMap) const</td></tr>
<tr class="memdesc:ga6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two triangles of the requested annulus are glued to each other.  <a href="group__subcomplex.html#ga6ad5bd5c7d85cb3b617d5a8c3572d1a5">More...</a><br /></td></tr>
<tr class="separator:ga6ad5bd5c7d85cb3b617d5a8c3572d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646e2a25cdee5230abff81fe108b54ed"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga646e2a25cdee5230abff81fe108b54ed">regina::TriSolidTorus::areAnnuliLinkedMajor</a> (int otherAnnulus) const</td></tr>
<tr class="memdesc:ga646e2a25cdee5230abff81fe108b54ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given annuli are linked in a particular fashion by a layered chain.  <a href="group__subcomplex.html#ga646e2a25cdee5230abff81fe108b54ed">More...</a><br /></td></tr>
<tr class="separator:ga646e2a25cdee5230abff81fe108b54ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3126bafc3f63fb842e54a0bf9aa814dd"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3126bafc3f63fb842e54a0bf9aa814dd">regina::TriSolidTorus::areAnnuliLinkedAxis</a> (int otherAnnulus) const</td></tr>
<tr class="memdesc:ga3126bafc3f63fb842e54a0bf9aa814dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the two given annuli are linked in a particular fashion by a layered chain.  <a href="group__subcomplex.html#ga3126bafc3f63fb842e54a0bf9aa814dd">More...</a><br /></td></tr>
<tr class="separator:ga3126bafc3f63fb842e54a0bf9aa814dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcbf6dc2a01ca7ac4375f281201a8b7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafcbf6dc2a01ca7ac4375f281201a8b7e">regina::TriSolidTorus::formsTriSolidTorus</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; useVertexRoles)</td></tr>
<tr class="memdesc:gafcbf6dc2a01ca7ac4375f281201a8b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms part of a three-tetrahedron triangular solid torus with its vertices playing the given roles in the solid torus.  <a href="group__subcomplex.html#gafcbf6dc2a01ca7ac4375f281201a8b7e">More...</a><br /></td></tr>
<tr class="separator:gafcbf6dc2a01ca7ac4375f281201a8b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3acbf6ce44a7908fe2c00e706c59ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac3acbf6ce44a7908fe2c00e706c59ba0">regina::TriSolidTorus::manifold</a> () const override</td></tr>
<tr class="memdesc:gac3acbf6ce44a7908fe2c00e706c59ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#gac3acbf6ce44a7908fe2c00e706c59ba0">More...</a><br /></td></tr>
<tr class="separator:gac3acbf6ce44a7908fe2c00e706c59ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6561d6eeb5f18705335ad19b10530942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6561d6eeb5f18705335ad19b10530942">regina::TriSolidTorus::homology</a> () const override</td></tr>
<tr class="memdesc:ga6561d6eeb5f18705335ad19b10530942"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga6561d6eeb5f18705335ad19b10530942">More...</a><br /></td></tr>
<tr class="separator:ga6561d6eeb5f18705335ad19b10530942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45703ff36060192b4d248e30d9eb20cb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga45703ff36060192b4d248e30d9eb20cb">regina::TriSolidTorus::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga45703ff36060192b4d248e30d9eb20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#ga45703ff36060192b4d248e30d9eb20cb">More...</a><br /></td></tr>
<tr class="separator:ga45703ff36060192b4d248e30d9eb20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42be4348d68170c65a146398cc246eb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf42be4348d68170c65a146398cc246eb">regina::TriSolidTorus::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf42be4348d68170c65a146398cc246eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#gaf42be4348d68170c65a146398cc246eb">More...</a><br /></td></tr>
<tr class="separator:gaf42be4348d68170c65a146398cc246eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0460017e67a7ddfc3a9af80b3a5a9df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0460017e67a7ddfc3a9af80b3a5a9df2">regina::TriSolidTorus::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0460017e67a7ddfc3a9af80b3a5a9df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga0460017e67a7ddfc3a9af80b3a5a9df2">More...</a><br /></td></tr>
<tr class="separator:ga0460017e67a7ddfc3a9af80b3a5a9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312e34c2ec292bd20c4d3bd1b0b9a02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga312e34c2ec292bd20c4d3bd1b0b9a02e">regina::TrivialTri::clone</a> () const</td></tr>
<tr class="memdesc:ga312e34c2ec292bd20c4d3bd1b0b9a02e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure.  <a href="group__subcomplex.html#ga312e34c2ec292bd20c4d3bd1b0b9a02e">More...</a><br /></td></tr>
<tr class="separator:ga312e34c2ec292bd20c4d3bd1b0b9a02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bef4097fcca559268c5b629015ff2ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga1bef4097fcca559268c5b629015ff2ee">regina::TrivialTri::type</a> () const</td></tr>
<tr class="memdesc:ga1bef4097fcca559268c5b629015ff2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific trivial triangulation being represented.  <a href="group__subcomplex.html#ga1bef4097fcca559268c5b629015ff2ee">More...</a><br /></td></tr>
<tr class="separator:ga1bef4097fcca559268c5b629015ff2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf190c12434f07e0f4807922ce4cd0b37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf190c12434f07e0f4807922ce4cd0b37">regina::TrivialTri::isTrivialTriangulation</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:gaf190c12434f07e0f4807922ce4cd0b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component is one of the trivial triangulations recognised by this class.  <a href="group__subcomplex.html#gaf190c12434f07e0f4807922ce4cd0b37">More...</a><br /></td></tr>
<tr class="separator:gaf190c12434f07e0f4807922ce4cd0b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9736cda87b31806f62187a9bbc2017fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9736cda87b31806f62187a9bbc2017fa">regina::TrivialTri::manifold</a> () const override</td></tr>
<tr class="memdesc:ga9736cda87b31806f62187a9bbc2017fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="group__subcomplex.html#ga9736cda87b31806f62187a9bbc2017fa">More...</a><br /></td></tr>
<tr class="separator:ga9736cda87b31806f62187a9bbc2017fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d35ca33ad85aac7d50a449d53e9bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga76d35ca33ad85aac7d50a449d53e9bdb">regina::TrivialTri::homology</a> () const override</td></tr>
<tr class="memdesc:ga76d35ca33ad85aac7d50a449d53e9bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="group__subcomplex.html#ga76d35ca33ad85aac7d50a449d53e9bdb">More...</a><br /></td></tr>
<tr class="separator:ga76d35ca33ad85aac7d50a449d53e9bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1b90a2eb4bc4680081fd927f265078"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gafe1b90a2eb4bc4680081fd927f265078">regina::TrivialTri::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gafe1b90a2eb4bc4680081fd927f265078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="group__subcomplex.html#gafe1b90a2eb4bc4680081fd927f265078">More...</a><br /></td></tr>
<tr class="separator:gafe1b90a2eb4bc4680081fd927f265078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6b86dba9f72df48e1c55cb265e9de9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga2c6b86dba9f72df48e1c55cb265e9de9">regina::TrivialTri::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga2c6b86dba9f72df48e1c55cb265e9de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="group__subcomplex.html#ga2c6b86dba9f72df48e1c55cb265e9de9">More...</a><br /></td></tr>
<tr class="separator:ga2c6b86dba9f72df48e1c55cb265e9de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fec3514968e13c7ff4b8f900be4c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga78fec3514968e13c7ff4b8f900be4c0b">regina::TrivialTri::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga78fec3514968e13c7ff4b8f900be4c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga78fec3514968e13c7ff4b8f900be4c0b">More...</a><br /></td></tr>
<tr class="separator:ga78fec3514968e13c7ff4b8f900be4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850d79cfe4c9848a42087d5e0f2e707"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga9850d79cfe4c9848a42087d5e0f2e707">regina::TxICore::~TxICore</a> ()</td></tr>
<tr class="memdesc:ga9850d79cfe4c9848a42087d5e0f2e707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object.  <a href="group__subcomplex.html#ga9850d79cfe4c9848a42087d5e0f2e707">More...</a><br /></td></tr>
<tr class="separator:ga9850d79cfe4c9848a42087d5e0f2e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad740d388b1d8826a092c2d898eafd70d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d">regina::TxICore::core</a> () const</td></tr>
<tr class="memdesc:gad740d388b1d8826a092c2d898eafd70d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full copy of the <code>T x I</code> triangulation that this object describes.  <a href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d">More...</a><br /></td></tr>
<tr class="separator:gad740d388b1d8826a092c2d898eafd70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ce48c06e18758687bb6ab9e45dda28"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga20ce48c06e18758687bb6ab9e45dda28">regina::TxICore::bdryTet</a> (unsigned whichBdry, unsigned whichTri) const</td></tr>
<tr class="memdesc:ga20ce48c06e18758687bb6ab9e45dda28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which tetrahedron provides the requested boundary triangle.  <a href="group__subcomplex.html#ga20ce48c06e18758687bb6ab9e45dda28">More...</a><br /></td></tr>
<tr class="separator:ga20ce48c06e18758687bb6ab9e45dda28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf88a3493c1bccb2599849f69f9f2ad9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf88a3493c1bccb2599849f69f9f2ad9d">regina::TxICore::bdryRoles</a> (unsigned whichBdry, unsigned whichTri) const</td></tr>
<tr class="memdesc:gaf88a3493c1bccb2599849f69f9f2ad9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which tetrahedron vertices play which roles in the upper and lower boundary triangles.  <a href="group__subcomplex.html#gaf88a3493c1bccb2599849f69f9f2ad9d">More...</a><br /></td></tr>
<tr class="separator:gaf88a3493c1bccb2599849f69f9f2ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946dfcbcf575fc6bdadfcd62cb3fdccb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga946dfcbcf575fc6bdadfcd62cb3fdccb">regina::TxICore::bdryReln</a> (unsigned whichBdry) const</td></tr>
<tr class="memdesc:ga946dfcbcf575fc6bdadfcd62cb3fdccb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the <em>alpha</em> and <em>beta</em> curves on a torus boundary in terms of specific tetrahedron edges.  <a href="group__subcomplex.html#ga946dfcbcf575fc6bdadfcd62cb3fdccb">More...</a><br /></td></tr>
<tr class="separator:ga946dfcbcf575fc6bdadfcd62cb3fdccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3daec5c7c16c43b461d123cdf37fd66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66">regina::TxICore::parallelReln</a> () const</td></tr>
<tr class="memdesc:gae3daec5c7c16c43b461d123cdf37fd66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary curves.  <a href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66">More...</a><br /></td></tr>
<tr class="separator:gae3daec5c7c16c43b461d123cdf37fd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e0abc543b918e79d0d8a733e921c96"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga11e0abc543b918e79d0d8a733e921c96">regina::TxICore::name</a> () const</td></tr>
<tr class="memdesc:ga11e0abc543b918e79d0d8a733e921c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation of <code>T x I</code> as a human-readable string.  <a href="group__subcomplex.html#ga11e0abc543b918e79d0d8a733e921c96">More...</a><br /></td></tr>
<tr class="separator:ga11e0abc543b918e79d0d8a733e921c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a0bfc69007e1d3aa8c9e63cdff5fe1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga21a0bfc69007e1d3aa8c9e63cdff5fe1">regina::TxICore::TeXName</a> () const</td></tr>
<tr class="memdesc:ga21a0bfc69007e1d3aa8c9e63cdff5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation of <code>T x I</code> in TeX format.  <a href="group__subcomplex.html#ga21a0bfc69007e1d3aa8c9e63cdff5fe1">More...</a><br /></td></tr>
<tr class="separator:ga21a0bfc69007e1d3aa8c9e63cdff5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22d4aaa8783b92d1634170799e703926"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga22d4aaa8783b92d1634170799e703926">regina::TxICore::writeName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga22d4aaa8783b92d1634170799e703926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> to the given output stream.  <a href="group__subcomplex.html#ga22d4aaa8783b92d1634170799e703926">More...</a><br /></td></tr>
<tr class="separator:ga22d4aaa8783b92d1634170799e703926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f870c1e82a584830858fb1ebb13e62c"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7f870c1e82a584830858fb1ebb13e62c">regina::TxICore::writeTeXName</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga7f870c1e82a584830858fb1ebb13e62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream.  <a href="group__subcomplex.html#ga7f870c1e82a584830858fb1ebb13e62c">More...</a><br /></td></tr>
<tr class="separator:ga7f870c1e82a584830858fb1ebb13e62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53538bb8ef322ca252e9b9c99119defb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga53538bb8ef322ca252e9b9c99119defb">regina::TxICore::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga53538bb8ef322ca252e9b9c99119defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__subcomplex.html#ga53538bb8ef322ca252e9b9c99119defb">More...</a><br /></td></tr>
<tr class="separator:ga53538bb8ef322ca252e9b9c99119defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73ec7df4dd1aad29cdffc5ecbf4eca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaa73ec7df4dd1aad29cdffc5ecbf4eca1">regina::TxICore::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaa73ec7df4dd1aad29cdffc5ecbf4eca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__subcomplex.html#gaa73ec7df4dd1aad29cdffc5ecbf4eca1">More...</a><br /></td></tr>
<tr class="separator:gaa73ec7df4dd1aad29cdffc5ecbf4eca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d845b35895967d5148ee5b9e89859a7"><td class="memItemLeft" align="right" valign="top"><a id="ga3d845b35895967d5148ee5b9e89859a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TxICore::TxICore</b> (const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp;)=delete</td></tr>
<tr class="separator:ga3d845b35895967d5148ee5b9e89859a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0856e56a8f8801439dc144ce7789e7b8"><td class="memItemLeft" align="right" valign="top"><a id="ga0856e56a8f8801439dc144ce7789e7b8"></a>
<a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TxICore::operator=</b> (const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp;)=delete</td></tr>
<tr class="separator:ga0856e56a8f8801439dc144ce7789e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf574a77b04122f2e651b9bd8aeeac3d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf574a77b04122f2e651b9bd8aeeac3d8">regina::TxICore::TxICore</a> ()</td></tr>
<tr class="memdesc:gaf574a77b04122f2e651b9bd8aeeac3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that performs no initialisation.  <a href="group__subcomplex.html#gaf574a77b04122f2e651b9bd8aeeac3d8">More...</a><br /></td></tr>
<tr class="separator:gaf574a77b04122f2e651b9bd8aeeac3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c62f61f1241df737f5e9cc2c317341"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaf7c62f61f1241df737f5e9cc2c317341">regina::TxIDiagonalCore::TxIDiagonalCore</a> (unsigned long newSize, unsigned long newK)</td></tr>
<tr class="memdesc:gaf7c62f61f1241df737f5e9cc2c317341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>T x I</code> triangulation with the given parameters.  <a href="group__subcomplex.html#gaf7c62f61f1241df737f5e9cc2c317341">More...</a><br /></td></tr>
<tr class="separator:gaf7c62f61f1241df737f5e9cc2c317341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d7205d82b28024ea4d48564a3fbc4a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac0d7205d82b28024ea4d48564a3fbc4a">regina::TxIDiagonalCore::size</a> () const</td></tr>
<tr class="memdesc:gac0d7205d82b28024ea4d48564a3fbc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra in this <code>T x I</code> triangulation.  <a href="group__subcomplex.html#gac0d7205d82b28024ea4d48564a3fbc4a">More...</a><br /></td></tr>
<tr class="separator:gac0d7205d82b28024ea4d48564a3fbc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc94fa314e6f5be566c2a83876a9f94e"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gabc94fa314e6f5be566c2a83876a9f94e">regina::TxIDiagonalCore::k</a> () const</td></tr>
<tr class="memdesc:gabc94fa314e6f5be566c2a83876a9f94e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the additional parameter <em>k</em> as described in the class notes.  <a href="group__subcomplex.html#gabc94fa314e6f5be566c2a83876a9f94e">More...</a><br /></td></tr>
<tr class="separator:gabc94fa314e6f5be566c2a83876a9f94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d926daf31520d463bb9722e24d64e7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga71d926daf31520d463bb9722e24d64e7">regina::TxIDiagonalCore::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga71d926daf31520d463bb9722e24d64e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> to the given output stream.  <a href="group__subcomplex.html#ga71d926daf31520d463bb9722e24d64e7">More...</a><br /></td></tr>
<tr class="separator:ga71d926daf31520d463bb9722e24d64e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d04cae182aa78d8ea98dcac2ee0591"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad2d04cae182aa78d8ea98dcac2ee0591">regina::TxIDiagonalCore::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gad2d04cae182aa78d8ea98dcac2ee0591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream.  <a href="group__subcomplex.html#gad2d04cae182aa78d8ea98dcac2ee0591">More...</a><br /></td></tr>
<tr class="separator:gad2d04cae182aa78d8ea98dcac2ee0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198aea2fa58aa22b469b68151c4df3f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga198aea2fa58aa22b469b68151c4df3f5">regina::TxIParallelCore::TxIParallelCore</a> ()</td></tr>
<tr class="memdesc:ga198aea2fa58aa22b469b68151c4df3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of this <code>T x I</code> triangulation.  <a href="group__subcomplex.html#ga198aea2fa58aa22b469b68151c4df3f5">More...</a><br /></td></tr>
<tr class="separator:ga198aea2fa58aa22b469b68151c4df3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8019ca7edb50fbe10f92372be137b277"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8019ca7edb50fbe10f92372be137b277">regina::TxIParallelCore::writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga8019ca7edb50fbe10f92372be137b277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> to the given output stream.  <a href="group__subcomplex.html#ga8019ca7edb50fbe10f92372be137b277">More...</a><br /></td></tr>
<tr class="separator:ga8019ca7edb50fbe10f92372be137b277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4355651bc847facab8d3781a3b6b6740"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4355651bc847facab8d3781a3b6b6740">regina::TxIParallelCore::writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4355651bc847facab8d3781a3b6b6740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream.  <a href="group__subcomplex.html#ga4355651bc847facab8d3781a3b6b6740">More...</a><br /></td></tr>
<tr class="separator:ga4355651bc847facab8d3781a3b6b6740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8f4588843946303e81dcf3389053551a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8f4588843946303e81dcf3389053551a">regina::AugTriSolidTorus::CHAIN_NONE</a></td></tr>
<tr class="memdesc:ga8f4588843946303e81dcf3389053551a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that this augmented triangular solid torus contains no layered chain.  <a href="group__subcomplex.html#ga8f4588843946303e81dcf3389053551a">More...</a><br /></td></tr>
<tr class="separator:ga8f4588843946303e81dcf3389053551a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a8a06e97b050a573b90a0bfe3297bf"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gae8a8a06e97b050a573b90a0bfe3297bf">regina::AugTriSolidTorus::CHAIN_MAJOR</a></td></tr>
<tr class="memdesc:gae8a8a06e97b050a573b90a0bfe3297bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that this augmented triangular solid torus contains a layered chain attached as described by <a class="el" href="group__subcomplex.html#ga646e2a25cdee5230abff81fe108b54ed" title="Determines whether the two given annuli are linked in a particular fashion by a layered chain.">TriSolidTorus::areAnnuliLinkedMajor()</a>.  <a href="group__subcomplex.html#gae8a8a06e97b050a573b90a0bfe3297bf">More...</a><br /></td></tr>
<tr class="separator:gae8a8a06e97b050a573b90a0bfe3297bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41597d71000c96063637a84f1f6c3604"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga41597d71000c96063637a84f1f6c3604">regina::AugTriSolidTorus::CHAIN_AXIS</a></td></tr>
<tr class="memdesc:ga41597d71000c96063637a84f1f6c3604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that this augmented triangular solid torus contains a layered chain attached as described by <a class="el" href="group__subcomplex.html#ga3126bafc3f63fb842e54a0bf9aa814dd" title="Determines whether the two given annuli are linked in a particular fashion by a layered chain.">TriSolidTorus::areAnnuliLinkedAxis()</a>.  <a href="group__subcomplex.html#ga41597d71000c96063637a84f1f6c3604">More...</a><br /></td></tr>
<tr class="separator:ga41597d71000c96063637a84f1f6c3604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafc2cafca8f5176e96f515a03f2673a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gadafc2cafca8f5176e96f515a03f2673a">regina::PlugTriSolidTorus::CHAIN_NONE</a></td></tr>
<tr class="memdesc:gadafc2cafca8f5176e96f515a03f2673a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates an annulus on the triangular solid torus boundary with no attached layered chain.  <a href="group__subcomplex.html#gadafc2cafca8f5176e96f515a03f2673a">More...</a><br /></td></tr>
<tr class="separator:gadafc2cafca8f5176e96f515a03f2673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ae24f77c013e50bf815baf85de650a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gad0ae24f77c013e50bf815baf85de650a">regina::PlugTriSolidTorus::CHAIN_MAJOR</a></td></tr>
<tr class="memdesc:gad0ae24f77c013e50bf815baf85de650a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates an annulus on the triangular solid torus boundary with an attached layered chain layered over the major edge of the annulus.  <a href="group__subcomplex.html#gad0ae24f77c013e50bf815baf85de650a">More...</a><br /></td></tr>
<tr class="separator:gad0ae24f77c013e50bf815baf85de650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e748de2c6f928a14e4a338d068884c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga04e748de2c6f928a14e4a338d068884c">regina::PlugTriSolidTorus::CHAIN_MINOR</a></td></tr>
<tr class="memdesc:ga04e748de2c6f928a14e4a338d068884c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates an annulus on the triangular solid torus boundary with an attached layered chain layered over the minor edge of the annulus.  <a href="group__subcomplex.html#ga04e748de2c6f928a14e4a338d068884c">More...</a><br /></td></tr>
<tr class="separator:ga04e748de2c6f928a14e4a338d068884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3581a2811f95bc535e9222537d59bb9c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga3581a2811f95bc535e9222537d59bb9c">regina::PlugTriSolidTorus::EQUATOR_MAJOR</a></td></tr>
<tr class="memdesc:ga3581a2811f95bc535e9222537d59bb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that, if no layered chains were present, the equator of the plug would consist of major edges of the core triangular solid torus.  <a href="group__subcomplex.html#ga3581a2811f95bc535e9222537d59bb9c">More...</a><br /></td></tr>
<tr class="separator:ga3581a2811f95bc535e9222537d59bb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f37b28522211bad751741c1c5ceb01e"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0f37b28522211bad751741c1c5ceb01e">regina::PlugTriSolidTorus::EQUATOR_MINOR</a></td></tr>
<tr class="memdesc:ga0f37b28522211bad751741c1c5ceb01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that, if no layered chains were present, the equator of the plug would consist of minor edges of the core triangular solid torus.  <a href="group__subcomplex.html#ga0f37b28522211bad751741c1c5ceb01e">More...</a><br /></td></tr>
<tr class="separator:ga0f37b28522211bad751741c1c5ceb01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4e63bfd1ccfca9404d9af26e0f5bcfb3">regina::SatAnnulus::tet</a> [2]</td></tr>
<tr class="memdesc:ga4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which tetrahedra provide the first and second triangles.  <a href="group__subcomplex.html#ga4e63bfd1ccfca9404d9af26e0f5bcfb3">More...</a><br /></td></tr>
<tr class="separator:ga4e63bfd1ccfca9404d9af26e0f5bcfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561aae549a9dc09de541ea0b76dfcc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga561aae549a9dc09de541ea0b76dfcc7a">regina::SatAnnulus::roles</a> [2]</td></tr>
<tr class="memdesc:ga561aae549a9dc09de541ea0b76dfcc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how the first and second triangles match up with individual tetrahedron vertices.  <a href="group__subcomplex.html#ga561aae549a9dc09de541ea0b76dfcc7a">More...</a><br /></td></tr>
<tr class="separator:ga561aae549a9dc09de541ea0b76dfcc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca51e567fe4ca52128747f0ea2c6cf4c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaca51e567fe4ca52128747f0ea2c6cf4c">regina::SatBlock::nAnnuli_</a></td></tr>
<tr class="memdesc:gaca51e567fe4ca52128747f0ea2c6cf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary annuli.  <a href="group__subcomplex.html#gaca51e567fe4ca52128747f0ea2c6cf4c">More...</a><br /></td></tr>
<tr class="separator:gaca51e567fe4ca52128747f0ea2c6cf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a97514c4f3ee1dea5a0331e1161417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga66a97514c4f3ee1dea5a0331e1161417">regina::SatBlock::annulus_</a></td></tr>
<tr class="memdesc:ga66a97514c4f3ee1dea5a0331e1161417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of each boundary annulus, as seen from the inside of this saturated block.  <a href="group__subcomplex.html#ga66a97514c4f3ee1dea5a0331e1161417">More...</a><br /></td></tr>
<tr class="separator:ga66a97514c4f3ee1dea5a0331e1161417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46bf466819a76108db37eb218c4a458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gab46bf466819a76108db37eb218c4a458">regina::SatBlock::twistedBoundary_</a></td></tr>
<tr class="memdesc:gab46bf466819a76108db37eb218c4a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a Mobius band?  <a href="group__subcomplex.html#gab46bf466819a76108db37eb218c4a458">More...</a><br /></td></tr>
<tr class="separator:gab46bf466819a76108db37eb218c4a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb04cbf5461053c069fe67c54584c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6fb04cbf5461053c069fe67c54584c04">regina::SatBlock::adjBlock_</a></td></tr>
<tr class="memdesc:ga6fb04cbf5461053c069fe67c54584c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known.  <a href="group__subcomplex.html#ga6fb04cbf5461053c069fe67c54584c04">More...</a><br /></td></tr>
<tr class="separator:ga6fb04cbf5461053c069fe67c54584c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbbe922c434c19fc44f84efe43beb89"><td class="memItemLeft" align="right" valign="top">unsigned *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8cbbe922c434c19fc44f84efe43beb89">regina::SatBlock::adjAnnulus_</a></td></tr>
<tr class="memdesc:ga8cbbe922c434c19fc44f84efe43beb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block.  <a href="group__subcomplex.html#ga8cbbe922c434c19fc44f84efe43beb89">More...</a><br /></td></tr>
<tr class="separator:ga8cbbe922c434c19fc44f84efe43beb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f9015c09cdd1987f7c3d1af08bf777"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga88f9015c09cdd1987f7c3d1af08bf777">regina::SatBlock::adjReflected_</a></td></tr>
<tr class="memdesc:ga88f9015c09cdd1987f7c3d1af08bf777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is reflected (see the class notes above).  <a href="group__subcomplex.html#ga88f9015c09cdd1987f7c3d1af08bf777">More...</a><br /></td></tr>
<tr class="separator:ga88f9015c09cdd1987f7c3d1af08bf777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcda28943ad300bcfd713f8bb4f59a8"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaafcda28943ad300bcfd713f8bb4f59a8">regina::SatBlock::adjBackwards_</a></td></tr>
<tr class="memdesc:gaafcda28943ad300bcfd713f8bb4f59a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is backwards (see the class notes above).  <a href="group__subcomplex.html#gaafcda28943ad300bcfd713f8bb4f59a8">More...</a><br /></td></tr>
<tr class="separator:gaafcda28943ad300bcfd713f8bb4f59a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510583f2a4753522bcc088fe980440af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">SatBlock::TetList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga510583f2a4753522bcc088fe980440af">regina::SatBlockStarterSearcher::usedTets</a></td></tr>
<tr class="memdesc:ga510583f2a4753522bcc088fe980440af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of which tetrahedra have used by the current embedding of the current starter block.  <a href="group__subcomplex.html#ga510583f2a4753522bcc088fe980440af">More...</a><br /></td></tr>
<tr class="separator:ga510583f2a4753522bcc088fe980440af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e16981731ba029e6f8f35979bbfd940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga7e16981731ba029e6f8f35979bbfd940">regina::SatBlockSpec::block</a></td></tr>
<tr class="memdesc:ga7e16981731ba029e6f8f35979bbfd940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of the saturated block structure.  <a href="group__subcomplex.html#ga7e16981731ba029e6f8f35979bbfd940">More...</a><br /></td></tr>
<tr class="separator:ga7e16981731ba029e6f8f35979bbfd940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf57ea9d6d91f042edc88fa87f25362e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gacf57ea9d6d91f042edc88fa87f25362e">regina::SatBlockSpec::refVert</a></td></tr>
<tr class="memdesc:gacf57ea9d6d91f042edc88fa87f25362e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the block is reflected vertically within the larger region.  <a href="group__subcomplex.html#gacf57ea9d6d91f042edc88fa87f25362e">More...</a><br /></td></tr>
<tr class="separator:gacf57ea9d6d91f042edc88fa87f25362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c8a8aa4ea84450e7ee5d00a1f00c201"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4c8a8aa4ea84450e7ee5d00a1f00c201">regina::SatBlockSpec::refHoriz</a></td></tr>
<tr class="memdesc:ga4c8a8aa4ea84450e7ee5d00a1f00c201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the block is reflected horizontally within the larger region.  <a href="group__subcomplex.html#ga4c8a8aa4ea84450e7ee5d00a1f00c201">More...</a><br /></td></tr>
<tr class="separator:ga4c8a8aa4ea84450e7ee5d00a1f00c201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7e98565057fa204a67b74f6a5b7eac"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4d7e98565057fa204a67b74f6a5b7eac">regina::SnapPeaCensusTri::SEC_5</a></td></tr>
<tr class="memdesc:ga4d7e98565057fa204a67b74f6a5b7eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of triangulations formed from five or fewer tetrahedra (both orientable and non-orientable).  <a href="group__subcomplex.html#ga4d7e98565057fa204a67b74f6a5b7eac">More...</a><br /></td></tr>
<tr class="separator:ga4d7e98565057fa204a67b74f6a5b7eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c625971e3eee4d78ea43e94464ab3f"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga51c625971e3eee4d78ea43e94464ab3f">regina::SnapPeaCensusTri::SEC_6_OR</a></td></tr>
<tr class="memdesc:ga51c625971e3eee4d78ea43e94464ab3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of orientable triangulations formed from six tetrahedra.  <a href="group__subcomplex.html#ga51c625971e3eee4d78ea43e94464ab3f">More...</a><br /></td></tr>
<tr class="separator:ga51c625971e3eee4d78ea43e94464ab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6a591789471ebf9ea0783f88dbc9ff"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga8c6a591789471ebf9ea0783f88dbc9ff">regina::SnapPeaCensusTri::SEC_6_NOR</a></td></tr>
<tr class="memdesc:ga8c6a591789471ebf9ea0783f88dbc9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of non-orientable triangulations formed from six tetrahedra.  <a href="group__subcomplex.html#ga8c6a591789471ebf9ea0783f88dbc9ff">More...</a><br /></td></tr>
<tr class="separator:ga8c6a591789471ebf9ea0783f88dbc9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c7ea5e086fa20f70d69bec9ce9642a"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga33c7ea5e086fa20f70d69bec9ce9642a">regina::SnapPeaCensusTri::SEC_7_OR</a></td></tr>
<tr class="memdesc:ga33c7ea5e086fa20f70d69bec9ce9642a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of orientable triangulations formed from seven tetrahedra.  <a href="group__subcomplex.html#ga33c7ea5e086fa20f70d69bec9ce9642a">More...</a><br /></td></tr>
<tr class="separator:ga33c7ea5e086fa20f70d69bec9ce9642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b03ab09b3cf522bb398cd545b653e32"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4b03ab09b3cf522bb398cd545b653e32">regina::SnapPeaCensusTri::SEC_7_NOR</a></td></tr>
<tr class="memdesc:ga4b03ab09b3cf522bb398cd545b653e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the collection of non-orientable triangulations formed from seven tetrahedra.  <a href="group__subcomplex.html#ga4b03ab09b3cf522bb398cd545b653e32">More...</a><br /></td></tr>
<tr class="separator:ga4b03ab09b3cf522bb398cd545b653e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93bae69ab4116d0b4ca42d56a8eda10a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga93bae69ab4116d0b4ca42d56a8eda10a">regina::TrivialTri::SPHERE_4_VERTEX</a></td></tr>
<tr class="memdesc:ga93bae69ab4116d0b4ca42d56a8eda10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the two-tetrahedron four-vertex triangulation of the 3-sphere.  <a href="group__subcomplex.html#ga93bae69ab4116d0b4ca42d56a8eda10a">More...</a><br /></td></tr>
<tr class="separator:ga93bae69ab4116d0b4ca42d56a8eda10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b687c152c73ab8b8adc240a23cf4f2"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga59b687c152c73ab8b8adc240a23cf4f2">regina::TrivialTri::BALL_3_VERTEX</a></td></tr>
<tr class="memdesc:ga59b687c152c73ab8b8adc240a23cf4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the one-tetrahedron three-vertex triangulation of the ball.  <a href="group__subcomplex.html#ga59b687c152c73ab8b8adc240a23cf4f2">More...</a><br /></td></tr>
<tr class="separator:ga59b687c152c73ab8b8adc240a23cf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b125d48f87efab2d32aa80052ac1fef"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga5b125d48f87efab2d32aa80052ac1fef">regina::TrivialTri::BALL_4_VERTEX</a></td></tr>
<tr class="memdesc:ga5b125d48f87efab2d32aa80052ac1fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the one-tetrahedron four-vertex triangulation of the ball.  <a href="group__subcomplex.html#ga5b125d48f87efab2d32aa80052ac1fef">More...</a><br /></td></tr>
<tr class="separator:ga5b125d48f87efab2d32aa80052ac1fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7951dbfdbe4e28bd2f4843068ecc03c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gac7951dbfdbe4e28bd2f4843068ecc03c">regina::TrivialTri::N2</a></td></tr>
<tr class="memdesc:gac7951dbfdbe4e28bd2f4843068ecc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the two-tetrahedron triangulation N(2) of the twisted 2-sphere bundle over the circle.  <a href="group__subcomplex.html#gac7951dbfdbe4e28bd2f4843068ecc03c">More...</a><br /></td></tr>
<tr class="separator:gac7951dbfdbe4e28bd2f4843068ecc03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eda6b8d1897102416697ad2c3dcf382"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4eda6b8d1897102416697ad2c3dcf382">regina::TrivialTri::N3_1</a></td></tr>
<tr class="memdesc:ga4eda6b8d1897102416697ad2c3dcf382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the three-tetrahedron triangulation N(3,1) of the projective plane bundle over the circle.  <a href="group__subcomplex.html#ga4eda6b8d1897102416697ad2c3dcf382">More...</a><br /></td></tr>
<tr class="separator:ga4eda6b8d1897102416697ad2c3dcf382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fc47119509108a4e501e61a849917d"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga93fc47119509108a4e501e61a849917d">regina::TrivialTri::N3_2</a></td></tr>
<tr class="memdesc:ga93fc47119509108a4e501e61a849917d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the three-tetrahedron triangulation N(3,2) of the projective plane bundle over the circle.  <a href="group__subcomplex.html#ga93fc47119509108a4e501e61a849917d">More...</a><br /></td></tr>
<tr class="separator:ga93fc47119509108a4e501e61a849917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6481f02fef54047d443ad6b2e03caf32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga6481f02fef54047d443ad6b2e03caf32">regina::TxICore::core_</a></td></tr>
<tr class="memdesc:ga6481f02fef54047d443ad6b2e03caf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A full copy of the <code>T x I</code> triangulation that is described.  <a href="group__subcomplex.html#ga6481f02fef54047d443ad6b2e03caf32">More...</a><br /></td></tr>
<tr class="separator:ga6481f02fef54047d443ad6b2e03caf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe7fec4109bf0087d816d05dae09ca7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga4fe7fec4109bf0087d816d05dae09ca7">regina::TxICore::bdryTet_</a> [2][2]</td></tr>
<tr class="memdesc:ga4fe7fec4109bf0087d816d05dae09ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tetrahedra that provide the upper and lower boundary triangles.  <a href="group__subcomplex.html#ga4fe7fec4109bf0087d816d05dae09ca7">More...</a><br /></td></tr>
<tr class="separator:ga4fe7fec4109bf0087d816d05dae09ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81976d1f21f260327f4597cff60ac386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga81976d1f21f260327f4597cff60ac386">regina::TxICore::bdryRoles_</a> [2][2]</td></tr>
<tr class="memdesc:ga81976d1f21f260327f4597cff60ac386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which tetrahedron vertices play which roles in the upper and lower boundary triangles.  <a href="group__subcomplex.html#ga81976d1f21f260327f4597cff60ac386">More...</a><br /></td></tr>
<tr class="separator:ga81976d1f21f260327f4597cff60ac386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba82836fafd0b2d378bca3f6c15e7e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#gaba82836fafd0b2d378bca3f6c15e7e81">regina::TxICore::bdryReln_</a> [2]</td></tr>
<tr class="memdesc:gaba82836fafd0b2d378bca3f6c15e7e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the <em>alpha</em> and <em>beta</em> curves for each torus boundary in terms of specific tetrahedron edges and vertices.  <a href="group__subcomplex.html#gaba82836fafd0b2d378bca3f6c15e7e81">More...</a><br /></td></tr>
<tr class="separator:gaba82836fafd0b2d378bca3f6c15e7e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0354d7f37aa48d265bdc514787dcf781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__subcomplex.html#ga0354d7f37aa48d265bdc514787dcf781">regina::TxICore::parallelReln_</a></td></tr>
<tr class="memdesc:ga0354d7f37aa48d265bdc514787dcf781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the lower <em>alpha</em> and <em>beta</em> curves in terms of the upper <em>alpha</em> and <em>beta</em> curves.  <a href="group__subcomplex.html#ga0354d7f37aa48d265bdc514787dcf781">More...</a><br /></td></tr>
<tr class="separator:ga0354d7f37aa48d265bdc514787dcf781"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gabbc3c2e106f8153981b89439b7e186c5"><td class="memItemLeft" align="right" valign="top"><a id="gabbc3c2e106f8153981b89439b7e186c5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SatBlockStarter::SatBlockStarterSet</b></td></tr>
<tr class="separator:gabbc3c2e106f8153981b89439b7e186c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0e87939d22b675e8ca30cacf784594"><td class="memItemLeft" align="right" valign="top"><a id="gafa0e87939d22b675e8ca30cacf784594"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SnapPeaCensusTri::SnapPeaCensusManifold</b></td></tr>
<tr class="separator:gafa0e87939d22b675e8ca30cacf784594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Standard triangulations and subcomplexes of triangulations whose structures are well-understood. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa9ec02399fc8c577957bc02912f5db87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ec02399fc8c577957bc02912f5db87">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1ListOnCall.html">ListOnCall</a>&lt;<a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a>&gt;::<a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">iterator</a> <a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">regina::SatBlockStarterSet::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator over the starter blocks in this list. </p>
<p>This operates as a forward iterator in a manner consistent with the standard C++ library. </p>

</div>
</div>
<a id="ga9a49a458761be1b59e37276e89d1ae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a49a458761be1b59e37276e89d1ae86">&#9670;&nbsp;</a></span>NAugTriSolidTorus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a> <a class="el" href="group__subcomplex.html#ga9a49a458761be1b59e37276e89d1ae86">regina::NAugTriSolidTorus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>The class NAugTriSolidTorus has now been renamed to <a class="el" href="classregina_1_1AugTriSolidTorus.html" title="Represents an augmented triangular solid torus component of a triangulation.">AugTriSolidTorus</a>. </dd></dl>

</div>
</div>
<a id="ga9a7a4d83d46bd4c97e43611e15be0ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7a4d83d46bd4c97e43611e15be0ee4">&#9670;&nbsp;</a></span>NBlockedSFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BlockedSFS.html">BlockedSFS</a> <a class="el" href="group__subcomplex.html#ga9a7a4d83d46bd4c97e43611e15be0ee4">regina::NBlockedSFS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>The class NBlockedSFS has now been renamed to <a class="el" href="classregina_1_1BlockedSFS.html" title="Represents a blocked Seifert fibred space (possibly with boundary).">BlockedSFS</a>. </dd></dl>

</div>
</div>
<a id="ga73e37593682757f02cefefcc6c60c57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e37593682757f02cefefcc6c60c57a">&#9670;&nbsp;</a></span>NBlockedSFSLoop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BlockedSFSLoop.html">BlockedSFSLoop</a> <a class="el" href="group__subcomplex.html#ga73e37593682757f02cefefcc6c60c57a">regina::NBlockedSFSLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>The class NBlockedSFSLoop has now been renamed to <a class="el" href="classregina_1_1BlockedSFSLoop.html" title="Represents a blocked Seifert fibred space with two boundary tori that are joined together.">BlockedSFSLoop</a>. </dd></dl>

</div>
</div>
<a id="ga2bf44ad2e030908702508c3ba13e7af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf44ad2e030908702508c3ba13e7af2">&#9670;&nbsp;</a></span>NBlockedSFSPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BlockedSFSPair.html">BlockedSFSPair</a> <a class="el" href="group__subcomplex.html#ga2bf44ad2e030908702508c3ba13e7af2">regina::NBlockedSFSPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>The class NBlockedSFSPair has now been renamed to <a class="el" href="classregina_1_1BlockedSFSPair.html" title="Represents a blocked pair of Seifert fibred spaces joined along a single connecting torus.">BlockedSFSPair</a>. </dd></dl>

</div>
</div>
<a id="ga222097bdc1c05fa443d2d6de80c58d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga222097bdc1c05fa443d2d6de80c58d3d">&#9670;&nbsp;</a></span>NBlockedSFSTriple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BlockedSFSTriple.html">BlockedSFSTriple</a> <a class="el" href="group__subcomplex.html#ga222097bdc1c05fa443d2d6de80c58d3d">regina::NBlockedSFSTriple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000118">Deprecated:</a></b></dt><dd>The class NBlockedSFSTriple has now been renamed to <a class="el" href="classregina_1_1BlockedSFSTriple.html" title="Represents a blocked sequence of three Seifert fibred spaces joined along connecting tori.">BlockedSFSTriple</a>. </dd></dl>

</div>
</div>
<a id="ga1099ab7910d12bfb1573bd7522662e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1099ab7910d12bfb1573bd7522662e9e">&#9670;&nbsp;</a></span>NL31Pillow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a> <a class="el" href="group__subcomplex.html#ga1099ab7910d12bfb1573bd7522662e9e">regina::NL31Pillow</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000119">Deprecated:</a></b></dt><dd>The class NL31Pillow has now been renamed to <a class="el" href="classregina_1_1L31Pillow.html" title="Represents a triangular pillow L(3,1) component of a triangulation.">L31Pillow</a>. </dd></dl>

</div>
</div>
<a id="ga06af284ff78f9ca984abb353843586d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06af284ff78f9ca984abb353843586d2">&#9670;&nbsp;</a></span>NLayeredChain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> <a class="el" href="group__subcomplex.html#ga06af284ff78f9ca984abb353843586d2">regina::NLayeredChain</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000120">Deprecated:</a></b></dt><dd>The class NLayeredChain has now been renamed to <a class="el" href="classregina_1_1LayeredChain.html" title="Represents a layered chain in a triangulation.">LayeredChain</a>. </dd></dl>

</div>
</div>
<a id="gaded95a56308a6bc0e53b98807ee20735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded95a56308a6bc0e53b98807ee20735">&#9670;&nbsp;</a></span>NLayeredChainPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a> <a class="el" href="group__subcomplex.html#gaded95a56308a6bc0e53b98807ee20735">regina::NLayeredChainPair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000121">Deprecated:</a></b></dt><dd>The class NLayeredChainPair has now been renamed to <a class="el" href="classregina_1_1LayeredChainPair.html" title="Represents a layered chain pair component of a triangulation.">LayeredChainPair</a>. </dd></dl>

</div>
</div>
<a id="ga1308182b7c6d60625ecb052088fef757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1308182b7c6d60625ecb052088fef757">&#9670;&nbsp;</a></span>NLayeredLensSpace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a> <a class="el" href="group__subcomplex.html#ga1308182b7c6d60625ecb052088fef757">regina::NLayeredLensSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000122">Deprecated:</a></b></dt><dd>The class NLayeredLensSpace has now been renamed to <a class="el" href="classregina_1_1LayeredLensSpace.html" title="Represents a layered lens space component of a triangulation.">LayeredLensSpace</a>. </dd></dl>

</div>
</div>
<a id="ga5917ee3101b277110877f0d45d16163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5917ee3101b277110877f0d45d16163f">&#9670;&nbsp;</a></span>NLayeredLoop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a> <a class="el" href="group__subcomplex.html#ga5917ee3101b277110877f0d45d16163f">regina::NLayeredLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000123">Deprecated:</a></b></dt><dd>The class NLayeredLoop has now been renamed to <a class="el" href="classregina_1_1LayeredLoop.html" title="Represents a layered loop component of a triangulation.">LayeredLoop</a>. </dd></dl>

</div>
</div>
<a id="gaba585c8865999aba5c08556b11a4309a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba585c8865999aba5c08556b11a4309a">&#9670;&nbsp;</a></span>NLayeredSolidTorus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> <a class="el" href="group__subcomplex.html#gaba585c8865999aba5c08556b11a4309a">regina::NLayeredSolidTorus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000124">Deprecated:</a></b></dt><dd>The class NLayeredSolidTorus has now been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html" title="Represents a layered solid torus in a triangulation.">LayeredSolidTorus</a>. </dd></dl>

</div>
</div>
<a id="gaf10a2c301c82833390f320700bf5d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10a2c301c82833390f320700bf5d45b">&#9670;&nbsp;</a></span>NLayeredTorusBundle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1LayeredTorusBundle.html">LayeredTorusBundle</a> <a class="el" href="group__subcomplex.html#gaf10a2c301c82833390f320700bf5d45b">regina::NLayeredTorusBundle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000125">Deprecated:</a></b></dt><dd>The class NLayeredTorusBundle has now been renamed to <a class="el" href="classregina_1_1LayeredTorusBundle.html" title="Describes a layered torus bundle.">LayeredTorusBundle</a>. </dd></dl>

</div>
</div>
<a id="gac8bb15ab88b1ede974226ee7ff26924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8bb15ab88b1ede974226ee7ff26924f">&#9670;&nbsp;</a></span>NLayering</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Layering.html">Layering</a> <a class="el" href="group__subcomplex.html#gac8bb15ab88b1ede974226ee7ff26924f">regina::NLayering</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000126">Deprecated:</a></b></dt><dd>The class NLayering has now been renamed to * <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a>. </dd></dl>

</div>
</div>
<a id="gafe4594049e397b0e1235a0a5744eb548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe4594049e397b0e1235a0a5744eb548">&#9670;&nbsp;</a></span>NPillowTwoSphere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a> <a class="el" href="group__subcomplex.html#gafe4594049e397b0e1235a0a5744eb548">regina::NPillowTwoSphere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000127">Deprecated:</a></b></dt><dd>The class NPillowTwoSphere has now been renamed to <a class="el" href="classregina_1_1PillowTwoSphere.html" title="Represents a 2-sphere made from two triangles glued together along their three edges.">PillowTwoSphere</a>. </dd></dl>

</div>
</div>
<a id="gadffe4c7b0f46040f384853fa2dcb13ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffe4c7b0f46040f384853fa2dcb13ef">&#9670;&nbsp;</a></span>NPluggedTorusBundle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PluggedTorusBundle.html">PluggedTorusBundle</a> <a class="el" href="group__subcomplex.html#gadffe4c7b0f46040f384853fa2dcb13ef">regina::NPluggedTorusBundle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000128">Deprecated:</a></b></dt><dd>The class NPluggedTorusBundle has now been renamed to <a class="el" href="classregina_1_1PluggedTorusBundle.html" title="Describes a triangulation of a graph manifold formed by joining a bounded saturated region with a thi...">PluggedTorusBundle</a>. </dd></dl>

</div>
</div>
<a id="gafe23ed73f99c78efbb79931bcc0f3aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe23ed73f99c78efbb79931bcc0f3aef">&#9670;&nbsp;</a></span>NPlugTriSolidTorus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a> <a class="el" href="group__subcomplex.html#gafe23ed73f99c78efbb79931bcc0f3aef">regina::NPlugTriSolidTorus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000129">Deprecated:</a></b></dt><dd>The class NPlugTriSolidTorus has now been renamed to <a class="el" href="classregina_1_1PlugTriSolidTorus.html" title="Represents a plugged triangular solid torus component of a triangulation.">PlugTriSolidTorus</a>. </dd></dl>

</div>
</div>
<a id="gae998f895fbe64984de46cfe67b049976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae998f895fbe64984de46cfe67b049976">&#9670;&nbsp;</a></span>NSatAnnulus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> <a class="el" href="group__subcomplex.html#gae998f895fbe64984de46cfe67b049976">regina::NSatAnnulus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000130">Deprecated:</a></b></dt><dd>The class NSatAnnulus has now been renamed to <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a>. </dd></dl>

</div>
</div>
<a id="ga009d5797cec6f76f86a450932444b130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga009d5797cec6f76f86a450932444b130">&#9670;&nbsp;</a></span>NSatBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> <a class="el" href="group__subcomplex.html#ga009d5797cec6f76f86a450932444b130">regina::NSatBlock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000131">Deprecated:</a></b></dt><dd>The class NSatBlock has now been renamed to <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a>. </dd></dl>

</div>
</div>
<a id="ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c">&#9670;&nbsp;</a></span>NSatBlockSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> <a class="el" href="group__subcomplex.html#ga4f4c8e0c33b4c7c2fe96d3c2e896cb3c">regina::NSatBlockSpec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000141">Deprecated:</a></b></dt><dd>The class NSatBlockSpec has now been renamed to <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a>. </dd></dl>

</div>
</div>
<a id="ga76e25496e87fac92ec953143d6209832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e25496e87fac92ec953143d6209832">&#9670;&nbsp;</a></span>NSatBlockStarter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatBlockStarter.html">SatBlockStarter</a> <a class="el" href="group__subcomplex.html#ga76e25496e87fac92ec953143d6209832">regina::NSatBlockStarter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000132">Deprecated:</a></b></dt><dd>The class NSatBlockStarter has now been renamed to <a class="el" href="classregina_1_1SatBlockStarter.html" title="Contains a triangulation of a saturated block along with the accompanying saturated block description...">SatBlockStarter</a>. </dd></dl>

</div>
</div>
<a id="ga114a3242d4456f6a6c6fc00df25202a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114a3242d4456f6a6c6fc00df25202a7">&#9670;&nbsp;</a></span>NSatBlockStarterSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatBlockStarterSearcher.html">SatBlockStarterSearcher</a> <a class="el" href="group__subcomplex.html#ga114a3242d4456f6a6c6fc00df25202a7">regina::NSatBlockStarterSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000134">Deprecated:</a></b></dt><dd>The class NSatBlockStarterSearcher has now been renamed to <a class="el" href="classregina_1_1SatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">SatBlockStarterSearcher</a>. </dd></dl>

</div>
</div>
<a id="gafc77905a0cb3031388a4f7da90a68cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc77905a0cb3031388a4f7da90a68cd9">&#9670;&nbsp;</a></span>NSatBlockStarterSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatBlockStarterSet.html">SatBlockStarterSet</a> <a class="el" href="group__subcomplex.html#gafc77905a0cb3031388a4f7da90a68cd9">regina::NSatBlockStarterSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000133">Deprecated:</a></b></dt><dd>The class NSatBlockStarterSet has now been renamed to <a class="el" href="classregina_1_1SatBlockStarterSet.html" title="Represents a set of starter blocks that can be used for identifying triangulations of Seifert fibred ...">SatBlockStarterSet</a>. </dd></dl>

</div>
</div>
<a id="gac8c3fcee108f3cf20200ca45bbb1336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8c3fcee108f3cf20200ca45bbb1336d">&#9670;&nbsp;</a></span>NSatCube</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatCube.html">SatCube</a> <a class="el" href="group__subcomplex.html#gac8c3fcee108f3cf20200ca45bbb1336d">regina::NSatCube</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000138">Deprecated:</a></b></dt><dd>The class NSatCube has now been renamed to <a class="el" href="classregina_1_1SatCube.html" title="A saturated block that is a six-tetrahedron cube.">SatCube</a>. </dd></dl>

</div>
</div>
<a id="ga17357d22df175514fb748e80fcaace52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17357d22df175514fb748e80fcaace52">&#9670;&nbsp;</a></span>NSatLayering</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a> <a class="el" href="group__subcomplex.html#ga17357d22df175514fb748e80fcaace52">regina::NSatLayering</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000140">Deprecated:</a></b></dt><dd>The class NSatLayering has now been renamed to <a class="el" href="classregina_1_1SatLayering.html" title="A degenerate saturated block that is a single tetrahedron wrapped around so that two opposite edges t...">SatLayering</a>. </dd></dl>

</div>
</div>
<a id="gae615b949668ddd2c794e793f25f6719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae615b949668ddd2c794e793f25f6719f">&#9670;&nbsp;</a></span>NSatLST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatLST.html">SatLST</a> <a class="el" href="group__subcomplex.html#gae615b949668ddd2c794e793f25f6719f">regina::NSatLST</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000136">Deprecated:</a></b></dt><dd>The class NSatLST has now been renamed to <a class="el" href="classregina_1_1SatLST.html" title="A saturated block that is a layered solid torus.">SatLST</a>. </dd></dl>

</div>
</div>
<a id="ga476e2021ecb97066efa5f9fa275a6af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476e2021ecb97066efa5f9fa275a6af5">&#9670;&nbsp;</a></span>NSatMobius</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a> <a class="el" href="group__subcomplex.html#ga476e2021ecb97066efa5f9fa275a6af5">regina::NSatMobius</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000135">Deprecated:</a></b></dt><dd>The class NSatMobius has now been renamed to <a class="el" href="classregina_1_1SatMobius.html" title="A degenerate zero-tetrahedron saturated block that corresponds to attaching a Mobius band to a single...">SatMobius</a>. </dd></dl>

</div>
</div>
<a id="ga2a1227ac6ee656c8b8846cf556dc0d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1227ac6ee656c8b8846cf556dc0d1c">&#9670;&nbsp;</a></span>NSatReflectorStrip</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> <a class="el" href="group__subcomplex.html#ga2a1227ac6ee656c8b8846cf556dc0d1c">regina::NSatReflectorStrip</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000139">Deprecated:</a></b></dt><dd>The class NSatReflectorStrip has now been renamed to <a class="el" href="classregina_1_1SatReflectorStrip.html" title="A saturated block that is a reflector strip.">SatReflectorStrip</a>. </dd></dl>

</div>
</div>
<a id="ga495fb7fd03c7e32a17177ff94a916548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495fb7fd03c7e32a17177ff94a916548">&#9670;&nbsp;</a></span>NSatRegion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> <a class="el" href="group__subcomplex.html#ga495fb7fd03c7e32a17177ff94a916548">regina::NSatRegion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000142">Deprecated:</a></b></dt><dd>The class NSatRegion has now been renamed to <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a>. </dd></dl>

</div>
</div>
<a id="gabf414bc395f88373374dc9d1a0a0b94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf414bc395f88373374dc9d1a0a0b94a">&#9670;&nbsp;</a></span>NSatTriPrism</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a> <a class="el" href="group__subcomplex.html#gabf414bc395f88373374dc9d1a0a0b94a">regina::NSatTriPrism</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000137">Deprecated:</a></b></dt><dd>The class NSatTriPrism has now been renamed to <a class="el" href="classregina_1_1SatTriPrism.html" title="A saturated block that is a three-tetrahedron triangular prism.">SatTriPrism</a>. </dd></dl>

</div>
</div>
<a id="ga709627fd20b7434819e10b13ec36bb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709627fd20b7434819e10b13ec36bb52">&#9670;&nbsp;</a></span>NSnapPeaCensusTri</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> <a class="el" href="group__subcomplex.html#ga709627fd20b7434819e10b13ec36bb52">regina::NSnapPeaCensusTri</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000143">Deprecated:</a></b></dt><dd>The class NSnapPeaCensusTri has now been renamed to <a class="el" href="classregina_1_1SnapPeaCensusTri.html" title="Represents a 3-manifold triangulation from the SnapPea cusped census.">SnapPeaCensusTri</a>. </dd></dl>

</div>
</div>
<a id="ga9ebe6a5dbd35db1177c423b09e5d129c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebe6a5dbd35db1177c423b09e5d129c">&#9670;&nbsp;</a></span>NSnappedBall</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> <a class="el" href="group__subcomplex.html#ga9ebe6a5dbd35db1177c423b09e5d129c">regina::NSnappedBall</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000144">Deprecated:</a></b></dt><dd>The class NSnappedBall has now been renamed to <a class="el" href="classregina_1_1SnappedBall.html" title="Represents a snapped 3-ball in a triangulation.">SnappedBall</a>. </dd></dl>

</div>
</div>
<a id="ga31e88641c3c1e91db6fd7a34d71c927e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e88641c3c1e91db6fd7a34d71c927e">&#9670;&nbsp;</a></span>NSnappedTwoSphere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a> <a class="el" href="group__subcomplex.html#ga31e88641c3c1e91db6fd7a34d71c927e">regina::NSnappedTwoSphere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000145">Deprecated:</a></b></dt><dd>The class NSnappedTwoSphere has now been renamed to <a class="el" href="classregina_1_1SnappedTwoSphere.html" title="Represents a 2-sphere made from two snapped 3-balls in a triangulation.">SnappedTwoSphere</a>. </dd></dl>

</div>
</div>
<a id="gadb7b268ff161272c3beaea6659738bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb7b268ff161272c3beaea6659738bca">&#9670;&nbsp;</a></span>NSpiralSolidTorus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a> <a class="el" href="group__subcomplex.html#gadb7b268ff161272c3beaea6659738bca">regina::NSpiralSolidTorus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000146">Deprecated:</a></b></dt><dd>The class NSpiralSolidTorus has now been renamed to <a class="el" href="classregina_1_1SpiralSolidTorus.html" title="Represents a spiralled solid torus in a triangulation.">SpiralSolidTorus</a>. </dd></dl>

</div>
</div>
<a id="ga49fb6472b768481fce376ffc1953d6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49fb6472b768481fce376ffc1953d6d5">&#9670;&nbsp;</a></span>NStandardTriangulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> <a class="el" href="group__subcomplex.html#ga49fb6472b768481fce376ffc1953d6d5">regina::NStandardTriangulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000147">Deprecated:</a></b></dt><dd>The class NStandardTriangulation has now been renamed to <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. </dd></dl>

</div>
</div>
<a id="ga8fc6847a2cb8b03b03126e48a1f2a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc6847a2cb8b03b03126e48a1f2a5fe">&#9670;&nbsp;</a></span>NTriSolidTorus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> <a class="el" href="group__subcomplex.html#ga8fc6847a2cb8b03b03126e48a1f2a5fe">regina::NTriSolidTorus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000148">Deprecated:</a></b></dt><dd>The class NTriSolidTorus has now been renamed to <a class="el" href="classregina_1_1TriSolidTorus.html" title="Represents a three-tetrahedron triangular solid torus in a triangulation.">TriSolidTorus</a>. </dd></dl>

</div>
</div>
<a id="ga3c4e9b40795c5598110fcb080823e852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4e9b40795c5598110fcb080823e852">&#9670;&nbsp;</a></span>NTrivialTri</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a> <a class="el" href="group__subcomplex.html#ga3c4e9b40795c5598110fcb080823e852">regina::NTrivialTri</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000149">Deprecated:</a></b></dt><dd>The class NTrivialTri has now been renamed to <a class="el" href="classregina_1_1TrivialTri.html" title="Represents one of a few particular hard-coded trivial triangulations that do not belong to any of the...">TrivialTri</a>. </dd></dl>

</div>
</div>
<a id="ga6cc12c6707d11efda95914013d9c15de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc12c6707d11efda95914013d9c15de">&#9670;&nbsp;</a></span>NTxICore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TxICore.html">TxICore</a> <a class="el" href="group__subcomplex.html#ga6cc12c6707d11efda95914013d9c15de">regina::NTxICore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000150">Deprecated:</a></b></dt><dd>The class NTxICore has now been renamed to <a class="el" href="classregina_1_1TxICore.html" title="Provides a triangulation of the product T x I (the product of the torus and the interval).">TxICore</a>. </dd></dl>

</div>
</div>
<a id="gaa4f0107c915117f29b5bce21046bad4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f0107c915117f29b5bce21046bad4c">&#9670;&nbsp;</a></span>NTxIDiagonalCore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TxIDiagonalCore.html">TxIDiagonalCore</a> <a class="el" href="group__subcomplex.html#gaa4f0107c915117f29b5bce21046bad4c">regina::NTxIDiagonalCore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000151">Deprecated:</a></b></dt><dd>The class NTxIDiagonalCore has now been renamed to <a class="el" href="classregina_1_1TxIDiagonalCore.html" title="One of a family of thin T x I triangulations that typically appear at the centres of layered torus bu...">TxIDiagonalCore</a>. </dd></dl>

</div>
</div>
<a id="ga88c1bda2e27635f7e5e1e448ffbd2be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88c1bda2e27635f7e5e1e448ffbd2be2">&#9670;&nbsp;</a></span>NTxIParallelCore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TxIParallelCore.html">TxIParallelCore</a> <a class="el" href="group__subcomplex.html#ga88c1bda2e27635f7e5e1e448ffbd2be2">regina::NTxIParallelCore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000152">Deprecated:</a></b></dt><dd>The class NTxIParallelCore has now been renamed to <a class="el" href="classregina_1_1TxIParallelCore.html" title="A specific six-tetrahedron TxICore triangulation that does not fit neatly into other families.">TxIParallelCore</a>. </dd></dl>

</div>
</div>
<a id="ga3f4ac64f5f274a2dd743ce10ce533303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4ac64f5f274a2dd743ce10ce533303">&#9670;&nbsp;</a></span>TetList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;*&gt; <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">regina::SatBlock::TetList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7192ac0dfb2fd6c156ab9aa48d2c9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7192ac0dfb2fd6c156ab9aa48d2c9570">&#9670;&nbsp;</a></span>abbr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SatBlock::abbr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block. </p>
<p>This name will reflect the particular block type, but may not provide thorough details.</p>
<p>The name will be no more than a handful of characters long, and will not include a newline (or surrounding dollar signs in TeX mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td><code>true</code> if the name should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abbreviated name for this block. </dd></dl>

</div>
</div>
<a id="gabb2ca004164b67a9e91dbdc652ba86b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2ca004164b67a9e91dbdc652ba86b0">&#9670;&nbsp;</a></span>adjacentAnnulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::adjacentAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding annulus number on the other block that is adjacent along this annulus. </dd></dl>

</div>
</div>
<a id="gae091e96247b17a9bfbee97e4187750e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae091e96247b17a9bfbee97e4187750e9">&#9670;&nbsp;</a></span>adjacentBackwards()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentBackwards </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards. </p>
<p>See the class notes for a discussion of backwards adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is backwards, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="ga71720ca0e1d2c086f532416a5522c60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71720ca0e1d2c086f532416a5522c60a">&#9670;&nbsp;</a></span>adjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatBlock::adjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other block adjacent along this annulus, or 0 if there is no adjacent block listed. </dd></dl>

</div>
</div>
<a id="ga5af146659a1b983afa6eb4776d409011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af146659a1b983afa6eb4776d409011">&#9670;&nbsp;</a></span>adjacentReflected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::adjacentReflected </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected. </p>
<p>See the class notes for a discussion of reflected adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is reflected, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="ga0f34b5e1c93a1785b1c60cb443b5413c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f34b5e1c93a1785b1c60cb443b5413c">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#gabbb585b3971ab31f1f94bf2fbd676cd6">regina::SatLayering</a>, <a class="el" href="group__subcomplex.html#gad30a730e9aa139ef5b4693859b34366f">regina::SatReflectorStrip</a>, <a class="el" href="group__subcomplex.html#ga40d652cc01691163ee861c895408705e">regina::SatCube</a>, <a class="el" href="group__subcomplex.html#ga922755a5529f149de9886a0aaef5fd7f">regina::SatTriPrism</a>, <a class="el" href="group__subcomplex.html#ga63f7186370470f3f18d5ec009b4e8cca">regina::SatLST</a>, and <a class="el" href="group__subcomplex.html#gae92b01b2051711e192eca3b334e34007">regina::SatMobius</a>.</p>

</div>
</div>
<a id="gae92b01b2051711e192eca3b334e34007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92b01b2051711e192eca3b334e34007">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatMobius::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga63f7186370470f3f18d5ec009b4e8cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f7186370470f3f18d5ec009b4e8cca">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatLST::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga922755a5529f149de9886a0aaef5fd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga922755a5529f149de9886a0aaef5fd7f">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatTriPrism::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga40d652cc01691163ee861c895408705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d652cc01691163ee861c895408705e">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatCube::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gad30a730e9aa139ef5b4693859b34366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad30a730e9aa139ef5b4693859b34366f">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatReflectorStrip::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gabbb585b3971ab31f1f94bf2fbd676cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb585b3971ab31f1f94bf2fbd676cd6">&#9670;&nbsp;</a></span>adjustSFS() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatLayering::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga0f34b5e1c93a1785b1c60cb443b5413c">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gaed25d82f9b29328fb95f0ccb15e81d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed25d82f9b29328fb95f0ccb15e81d8b">&#9670;&nbsp;</a></span>annulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatBlock::annulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block. </p>
<p>Annuli are numbered from 0 to <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 as described in the class notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which boundary annulus is requested; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested boundary annulus. </dd></dl>

</div>
</div>
<a id="ga3126bafc3f63fb842e54a0bf9aa814dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3126bafc3f63fb842e54a0bf9aa814dd">&#9670;&nbsp;</a></span>areAnnuliLinkedAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TriSolidTorus::areAnnuliLinkedAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>otherAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given annuli are linked in a particular fashion by a layered chain. </p>
<p>In this scenario, one of the given annuli meets both faces of the top tetrahedron and the other annulus meets both faces of the bottom tetrahedron of the layered chain.</p>
<p>To be identified by this routine, the layered chain (described by <a class="el" href="classregina_1_1LayeredChain.html" title="Represents a layered chain in a triangulation.">LayeredChain</a>) must be attached as follows. We shall refer to the two hinge edges of the layered chain as <em>first</em> and <em>second</em>.</p>
<p>The two diagonals of the layered chain (between the two top faces and between the two bottom faces) should correspond to the two directed major edges of the two annuli, with the major edges both pointing from top hinge edge to bottom hinge edge. The other boundary edges of the layered chain that are not hinge edges should correspond to the two directed minor edges of the two annuli, with the minor edges both pointing from bottom hinge edge to top hinge edge. The hinge edges themselves should correspond to the axis edges of the triangular solid torus (this correspondence is determined by the previous identifications; the axis edge between the two annuli will be identified to both of the others in reverse).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherAnnulus</td><td>the annulus on the solid torus boundary <em>not</em> to be examined; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra in the layered chain if the two annuli are linked as described, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga646e2a25cdee5230abff81fe108b54ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646e2a25cdee5230abff81fe108b54ed">&#9670;&nbsp;</a></span>areAnnuliLinkedMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TriSolidTorus::areAnnuliLinkedMajor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>otherAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two given annuli are linked in a particular fashion by a layered chain. </p>
<p>In this scenario, both of the given annuli meet one face of the top tetrahedron and one face of the bottom tetrahedron of the layered chain.</p>
<p>To be identified by this routine, the layered chain (described by <a class="el" href="classregina_1_1LayeredChain.html" title="Represents a layered chain in a triangulation.">LayeredChain</a>) must be attached as follows. The two directed major edges of the two annuli should correspond to the two hinge edges of the layered chain (with both hinge edges pointing in the same direction around the solid torus formed by the layered chain). The two directed diagonals of the layered chain (between the two top faces and between the two bottom faces, each pointing in the opposite direction to the hinge edges around the solid torus formed by the layered chain) should be identified and must correspond to the (identified) two directed minor edges of the two annuli. The remaining boundary edges of the layered chain should correspond to the axis edges of the triangular solid torus (this correspondence is determined by the previous identifications).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherAnnulus</td><td>the annulus on the solid torus boundary <em>not</em> to be examined; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra in the layered chain if the two annuli are linked as described, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga42ef9c6ac88ca6201299c32c99b6924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ef9c6ac88ca6201299c32c99b6924a">&#9670;&nbsp;</a></span>attachLST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::attachLST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a layered solid torus to the this saturated annulus. </p>
<p>The layered solid torus will be attached so that the given values <em>alpha</em> and <em>beta</em> describe how the meridinal disc cuts the vertical and horizontal edges of the annulus respectively.</p>
<p>The result will effectively insert an (<em>alpha</em>, <em>beta</em>) exceptional fibre into the Seifert fibred space space, where the vertical edges run parallel to the fibres and the horizontal edges represent the base orbifold. The sign of the fibre is consistent with the fibre inserted by <a class="el" href="group__subcomplex.html#ga63f7186370470f3f18d5ec009b4e8cca" title="Adjusts the given Seifert fibred space to insert the contents of this saturated block.">SatLST::adjustSFS()</a> (in particular, negating <em>beta</em> will negate the fibre).</p>
<p>In the case of a (2,1) fibre, the layered solid torus will be degenerate (i.e., the two triangles of the annulus will simply be joined together).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given value <em>alpha</em> is not zero. </dd>
<dd>
The given values <em>alpha</em> and <em>beta</em> are coprime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new tetrahedra should be inserted. </td></tr>
    <tr><td class="paramname">alpha</td><td>describes how the meridinal disc of the torus should cut the vertical edges. This may be positive or negative. </td></tr>
    <tr><td class="paramname">beta</td><td>describes how the meridinal disc of the torus should cut the horizontal edges. Again this may be positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a0bd603756efd481bf9bd828a4c0d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0bd603756efd481bf9bd828a4c0d19">&#9670;&nbsp;</a></span>augTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> * regina::AugTriSolidTorus::augTorus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus attached to the requested annulus on the boundary of the core triangular solid torus. </p>
<p>If the layered solid torus is a degenerate (2,1,1) mobius band (i.e., the two triangles of the corresponding annulus have simply been glued together), <code>null</code> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>specifies which annulus to examine; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding layered solid torus. </dd></dl>

</div>
</div>
<a id="gadd296866ba8065dac9502f99296f28bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd296866ba8065dac9502f99296f28bb">&#9670;&nbsp;</a></span>base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredSolidTorus::base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedron that is glued to itself at the base of this layered solid torus. </p>
<dl class="section return"><dt>Returns</dt><dd>the base tetrahedron. </dd></dl>

</div>
</div>
<a id="ga1fe4f467fdcdf10f93cfa51add967408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe4f467fdcdf10f93cfa51add967408">&#9670;&nbsp;</a></span>baseEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested edge of the base tetrahedron belonging to the given group. </p>
<p>The layering identifies the six edges of the base tetrahedron into a group of three, a group of two and a single unidentified edge; these are referred to as groups 3, 2 and 1 respectively.</p>
<p>Note that <code>baseEdgeGroup(baseEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code>.</p>
<p>Edges <code>baseEdge(2,0)</code> and <code>baseEdge(3,0)</code> will both belong to face <code>baseFace(0)</code>. Edges <code>baseEdge(2,1)</code> and <code>baseEdge(3,2)</code> will both belong to face <code>baseFace(1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group that the requested edge should belong to; this must be 1, 2 or 3. </td></tr>
    <tr><td class="paramname">index</td><td>the index within the given group of the requested edge; this must be between 0 and <em>group</em>-1 inclusive. Note that in group 3 the edge at index 1 is adjacent to both the edges at indexes 0 and 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge number in the base tetrahedron of the requested edge; this will be between 0 and 5 inclusive. </dd></dl>

</div>
</div>
<a id="gae4bef8d63cbb68b084b6f83eee9e4b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4bef8d63cbb68b084b6f83eee9e4b46">&#9670;&nbsp;</a></span>baseEdgeGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseEdgeGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the group that the given edge of the base tetrahedron belongs to. </p>
<p>See <a class="el" href="group__subcomplex.html#ga1fe4f467fdcdf10f93cfa51add967408" title="Returns the requested edge of the base tetrahedron belonging to the given group.">baseEdge()</a> for further details about groups.</p>
<p>Note that <code>baseEdgeGroup(baseEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the edge number in the base tetrahedron of the given edge; this must be between 0 and 5 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group to which the given edge belongs; this will be 1, 2 or 3. </dd></dl>

</div>
</div>
<a id="ga2cbc6675863e3d5b646ee2da41dd0c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbc6675863e3d5b646ee2da41dd0c1c">&#9670;&nbsp;</a></span>baseFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two faces of the base tetrahedron that are glued to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two faces to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face number in the base tetrahedron; this will be between 0 and 3 inclusive. </dd></dl>

</div>
</div>
<a id="ga946dfcbcf575fc6bdadfcd62cb3fdccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga946dfcbcf575fc6bdadfcd62cb3fdccb">&#9670;&nbsp;</a></span>bdryReln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::TxICore::bdryReln </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichBdry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the <em>alpha</em> and <em>beta</em> curves on a torus boundary in terms of specific tetrahedron edges. </p>
<p>Consider the first triangle of the given boundary. Let <em>t</em> be the tetrahedron returned by bdryTet(<em>whichBdry</em>, 0) and let <em>p</em> be the permutation returned by bdryRoles(<em>whichBdry</em>, 0).</p>
<p>Let <em>edge01</em> be the directed edge from vertex <em>p</em>[0] to <em>p</em>[1] of tetrahedron <em>t</em>, and let <em>edge02</em> be the directed edge from vertex <em>p</em>[0] to <em>p</em>[2] of tetrahedron <em>t</em>. Then the matrix returned by this routine describes how the directed edges <em>edge01</em> and <em>edge02</em> relate to the <em>alpha</em> and <em>beta</em> curves on the given boundary. Specifically:</p>
<pre>
    [ alpha ]                  [ edge01 ]
    [       ]  =  <a class="el" href="group__subcomplex.html#ga946dfcbcf575fc6bdadfcd62cb3fdccb" title="Returns a 2-by-2 matrix describing the alpha and beta curves on a torus boundary in terms of specific...">bdryReln()</a> * [        ] .
    [ beta  ]                  [ edge02 ]
</pre><p>It is guaranteed that this matrix has determinant +1 or -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichBdry</td><td>0 if the upper boundary should be examined, or 1 if the lower boundary should be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the relationship between the boundary curves and tetrahedron edges. </dd></dl>

</div>
</div>
<a id="gaf88a3493c1bccb2599849f69f9f2ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf88a3493c1bccb2599849f69f9f2ad9d">&#9670;&nbsp;</a></span>bdryRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::TxICore::bdryRoles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which tetrahedron vertices play which roles in the upper and lower boundary triangles. </p>
<p>Each boundary torus contains two triangles, whose vertices can be numbered 0, 1 and 2 according to the following diagram. This diagram is completely symmetric, in that edges 1-2 are no more special than edges 0-2 or 0-1. The important observations are that edges 1-2 and 2-1 of each triangle are identified, edges 0-2 and 2-0 of each triangle are identified and edges 0-1 and 1-0 of each triangle are identified.</p>
<pre>
          *---&gt;&gt;--*
          |0  2 / |
  First   |    / 1|  Second
 triangle v   /   v triangle
          |1 /    |
          | / 2  0|
          *---&gt;&gt;--*
</pre><p>This routine returns a permutation that maps these integers 0,1,2 to real tetrahedron vertices. Let <em>t</em> be the tetrahedron returned by bdryTet(<em>whichBdry</em>, <em>whichTri</em>) and let <em>p</em> be the permutation returned by bdryRoles(<em>whichBdry</em>, <em>whichTri</em>). Then vertices <em>p</em>[0], <em>p</em>[1] and <em>p</em>[2] of tetrahedron <em>t</em> correspond to the markings 0, 1 and 2 respectively in the diagram above (and therefore the boundary triangle is face <em>p</em>[3] of the tetrahedron).</p>
<p>The arguments to this routine affect whether we examine the upper or lower boundary and whether we examine the first or second triangle of this boundary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichBdry</td><td>0 if the upper boundary should be examined, or 1 if the lower boundary should be examined. </td></tr>
    <tr><td class="paramname">whichTri</td><td>0 if the first boundary triangle should be examined, or 1 if the second boundary triangle should be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation mapping roles 0, 1 and 2 in the diagram above to real tetrahedron vertex numbers. </dd></dl>

</div>
</div>
<a id="ga20ce48c06e18758687bb6ab9e45dda28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20ce48c06e18758687bb6ab9e45dda28">&#9670;&nbsp;</a></span>bdryTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::TxICore::bdryTet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which tetrahedron provides the requested boundary triangle. </p>
<p>Recall that the <code>T x I</code> triangulation has two torus boundaries, each consisting of two boundary triangles. This routine returns the specific tetrahedron that provides the given triangle of the given torus boundary.</p>
<p>What is returned is the index number of the tetrahedron within the triangulation. To access the tetrahedron itself, you may call <code><a class="el" href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d" title="Returns a full copy of the T x I triangulation that this object describes.">core()</a>.tetrahedron(bdryTet(...))</code>.</p>
<p>Note that the same tetrahedron may provide more than one boundary triangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichBdry</td><td>0 if the upper boundary should be examined, or 1 if the lower boundary should be examined. </td></tr>
    <tr><td class="paramname">whichTri</td><td>0 if the first boundary triangle should be examined, or 1 if the second boundary triangle should be examined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab2edd99bee25ef747da8a1ba916bd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab2edd99bee25ef747da8a1ba916bd7a">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">SatBlockStarterSet::iterator</a> regina::SatBlockStarterSet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first block in the hard-coded list. </p>
<p>The very first time this routine is called, the list will be filled with items (and as such the call will be expensive). Every subsequent call will be very cheap.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first starter block. </dd></dl>

</div>
</div>
<a id="ga4246d1d98f6ecd84692a8d5f4e12da6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4246d1d98f6ecd84692a8d5f4e12da6e">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatBlockStarter::block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details that describe the structure of the saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the block structure. </dd></dl>

</div>
</div>
<a id="gab741d4cfcf8d8450dadff066b7f57f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab741d4cfcf8d8450dadff066b7f57f25">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp; regina::SatRegion::block </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested saturated block within this region. </p>
<p>The information will returned will include structural information for the block, along with details of how the block is aligned (e.g., reflected vertically or horizontally) within the larger region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which of the constituent blocks should be returned; this must be between 0 and <a class="el" href="group__subcomplex.html#gada2e43b86fa0d683fdfd5c4b03a023ec" title="Returns the number of saturated blocks that come together to form this saturated region.">numberOfBlocks()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested saturated block. </dd></dl>

</div>
</div>
<a id="ga59ef8dd460a89b382fc69595f8c9a63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59ef8dd460a89b382fc69595f8c9a63d">&#9670;&nbsp;</a></span>blockIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SatRegion::blockIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the given block within this region. </p>
<p>This index corresponds to the integer parameter that is passed to the routine <a class="el" href="group__subcomplex.html#gab741d4cfcf8d8450dadff066b7f57f25" title="Returns details of the requested saturated block within this region.">block()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, since it simply scans through the blocks in this region one by one until the given block is found (or until all blocks are exhausted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the given block (as an integer between 0 and <a class="el" href="group__subcomplex.html#gada2e43b86fa0d683fdfd5c4b03a023ec" title="Returns the number of saturated blocks that come together to form this saturated region.">numberOfBlocks()</a>-1 inclusive), or -1 if the block is not part of this region. </dd></dl>

</div>
</div>
<a id="ga4ebf8a8cdd78af3af5cc97999ed96cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ebf8a8cdd78af3af5cc97999ed96cee">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredChain::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bottom tetrahedron of this layered chain. </p>
<dl class="section return"><dt>Returns</dt><dd>the bottom tetrahedron. </dd></dl>

</div>
</div>
<a id="ga63c20b1c4b1ab485ba73af93e5f4fa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63c20b1c4b1ab485ba73af93e5f4fa09">&#9670;&nbsp;</a></span>bottomVertexRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::LayeredChain::bottomVertexRoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the bottom tetrahedron plays in the layered chain. </p>
<p>The permutation returned (call this <code>p</code>) maps 0, 1, 2 and 3 to the four vertices of the bottom tetrahedron so that the edge from <code>p[0]</code> to <code>p[1]</code> is the top hinge, the edge from <code>p[2]</code> to <code>p[3]</code> is the bottom hinge, faces <code>p[1]</code> and <code>p[2]</code> are the (boundary) bottom faces and faces <code>p[0]</code> and <code>p[3]</code> are the top faces.</p>
<p>See the general class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a permutation representing the roles of the vertices of the bottom tetrahedron. </dd></dl>

</div>
</div>
<a id="gad5b71f8fb8bb29e4cb4347fd25b6e1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b71f8fb8bb29e4cb4347fd25b6e1f4">&#9670;&nbsp;</a></span>boundaryAnnulus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>&amp; regina::SatRegion::boundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested saturated annulus on the boundary of this region. </p>
<p>The saturated annuli that together form the boundary components of this region are numbered from 0 to <a class="el" href="group__subcomplex.html#ga0eab8ca2776c0047b5f25c2aad047ad1" title="Returns the number of saturated annuli that together form the boundary components of this region.">numberOfBoundaryAnnuli()</a>-1 inclusive. The argument <em>which</em> specifies which one of these annuli should be returned.</p>
<p>Currently the annuli are numbered lexicographically by block and then by annulus number within the block, although this ordering is subject to change in future versions of Regina. In particular, the annuli are <em>not</em> necessarily numbered in order around the region boundaries, and each region boundary component might not even be given a consecutive range of numbers.</p>
<p>It is guaranteed however that, if the starter block passed to the <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> constructor provides any boundary annuli for the overall region, then the first such annulus in the starter block will be numbered 0 here.</p>
<p>The structure returned will be the annulus precisely as it appears within its particular saturated block. As discussed in the <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> class notes, the block might be reflected horizontally and/or vertically within the overall region, which will affect how the annulus is positioned as part of the overall region boundary (e.g., the annulus might be positioned upside-down in the overall region boundary, or it might be positioned with its second triangle appearing before its first triangle as one walks around the boundary). To account for this, the two boolean arguments <em>blockRefVert</em> and <em>blockRefHoriz</em> will be modified to indicate if and how the block is reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is quite slow, since it currently scans through every annulus of every saturated block. Use it sparingly!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Both variants of <a class="el" href="group__subcomplex.html#gad5b71f8fb8bb29e4cb4347fd25b6e1f4" title="Returns the requested saturated annulus on the boundary of this region.">boundaryAnnulus()</a> are combined into a single routine, which takes the integer <em>which</em> as its only argument and returns its results as a tuple. See the alternate version of <a class="el" href="group__subcomplex.html#gad5b71f8fb8bb29e4cb4347fd25b6e1f4" title="Returns the requested saturated annulus on the boundary of this region.">boundaryAnnulus()</a> for details on how the return tuple is structured.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which boundary annulus of this region to return; this must be between 0 and <a class="el" href="group__subcomplex.html#ga0eab8ca2776c0047b5f25c2aad047ad1" title="Returns the number of saturated annuli that together form the boundary components of this region.">numberOfBoundaryAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">blockRefVert</td><td>used to return whether the block containing the requested annulus is vertically reflected within this region (see <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for details). This will be set to <code>true</code> if the block is vertically reflected, or <code>false</code> if not. </td></tr>
    <tr><td class="paramname">blockRefHoriz</td><td>used to return whether the block containing the requested annulus is horizontally reflected within this region (see <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for details). This will be set to <code>true</code> if the block is horizontally reflected, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested boundary annulus, precisely as it appears within its particular saturated block. </dd></dl>

</div>
</div>
<a id="gaa2b7ed753341ef750439c01a945eb2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b7ed753341ef750439c01a945eb2d9">&#9670;&nbsp;</a></span>boundaryAnnulus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::boundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>blockRefHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> fine details of the requested saturated annulus on the boundary of this region. </p>
<p>The argument <em>which</em> specifies which one of these annuli should be returned. See the boundaryAnnulus(unsigned long, bool&amp;, bool&amp;) documentation for details on how the boundary annuli are numbered.</p>
<p>Various details of the requested boundary annulus are returned in the various arguments, as described below.</p>
<p>Be aware that the block containing the requested annulus might be reflected horizontally and/or vertically within the overall region, as discussed in the <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> class notes. This will affect how the annulus is positioned as part of the overall region boundary (e.g., the annulus might be positioned upside-down in the overall region boundary, or it might be positioned with its second triangle appearing before its first triangle as one walks around the boundary). The two boolean arguments <em>blockRefVert</em> and <em>blockRefHoriz</em> will be modified to indicate if and how the block is reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is quite slow, since it currently scans through every annulus of every saturated block. Use it sparingly!</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine only takes a single argument (the integer <em>which</em>). The return value is a tuple of four values: the block returned in <em>block</em>, the integer returned in <em>annulus</em>, the boolean returned in <em>blockRefVert</em>, and the boolean returned in <em>blockRefHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which boundary annulus of this region to return; this must be between 0 and <a class="el" href="group__subcomplex.html#ga0eab8ca2776c0047b5f25c2aad047ad1" title="Returns the number of saturated annuli that together form the boundary components of this region.">numberOfBoundaryAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">block</td><td>used to return the particular saturated block containing the requested annulus. </td></tr>
    <tr><td class="paramname">annulus</td><td>used to return which annulus number in the returned block is the requested annulus; this will be between 0 and block-&gt;nAnnuli() inclusive. </td></tr>
    <tr><td class="paramname">blockRefVert</td><td>used to return whether the block containing the requested annulus is vertically reflected within this region (see <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for details). This will be set to <code>true</code> if the block is vertically reflected, or <code>false</code> if not. </td></tr>
    <tr><td class="paramname">blockRefHoriz</td><td>used to return whether the block containing the requested annulus is horizontally reflected within this region (see <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for details). This will be set to <code>true</code> if the block is horizontally reflected, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14f4e5a563cfba364f78c9a389a7acd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f4e5a563cfba364f78c9a389a7acd8">&#9670;&nbsp;</a></span>boundaryFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SnappedBall::boundaryFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedron faces that forms the boundary of this snapped ball. </p>
<p>You are guaranteed that index 0 will return a smaller face number than index 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two boundary faces to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face number in the tetrahedron. </dd></dl>

</div>
</div>
<a id="gaedf0c3a388a6b8ed9320553a4660c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf0c3a388a6b8ed9320553a4660c151">&#9670;&nbsp;</a></span>boundaryReln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::Layering::boundaryReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the relationship between curves on the old and new boundary tori. </p>
<p>Note that this relationship will often be non-trivial, since one of the key reasons for layering is to modify boundary curves.</p>
<p>Let <em>t</em> and <em>p</em> be the first tetrahedron and permutation of the old boundary (as returned by oldBoundaryTet(0) and oldBoundaryRoles(0)), and let <em>old_x</em> and <em>old_y</em> be the directed edges <em>p</em>[0]-<em>p</em>[1] and <em>p</em>[0]-<em>p</em>[2] respectively of tetrahedron <em>t</em> (these are the leftmost and uppermost edges of the diagram below). Likewise, let <em>s</em> and <em>q</em> be the first tetrahedron and permutation of the new boundary (as returned by newBoundaryTet(0) and newBoundaryRoles(0)), and let <em>new_x</em> and <em>new_y</em> be the directed edges <em>q</em>[0]-<em>q</em>[1] and <em>q</em>[0]-<em>q</em>[2] respectively of tetrahedron <em>s</em>.</p>
<pre>
    *---&gt;&gt;--*
    |0  2 / |
    |    / 1|
    v   /   v
    |1 /    |
    | / 2  0|
    *---&gt;&gt;--*
</pre><p>Assuming both boundaries are tori, edges <em>old_x</em> and <em>old_y</em> are generators of the old boundary torus and edges <em>new_x</em> and <em>new_y</em> are generators of the new boundary torus. Suppose that this routine returns the matrix <em>M</em>. This signifies that, using additive notation:</p>
<pre>
    [new_x]         [old_x]
    [     ]  =  M * [     ] .
    [new_y]         [old_y]
</pre><p>In other words, the matrix that is returned expresses the generator curves of the new boundary in terms of the generator curves of the old boundary.</p>
<p>Note that the determinant of this matrix will always be 1.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix relating the old and new boundary curves. </dd></dl>

</div>
</div>
<a id="ga50e7a9fdb3b392e267d13ee0097aed2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e7a9fdb3b392e267d13ee0097aed2f">&#9670;&nbsp;</a></span>bundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp; regina::PluggedTorusBundle::bundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an isomorphic copy of the thin I-bundle that forms part of this triangulation. </p>
<p>Like all objects of class <a class="el" href="classregina_1_1TxICore.html" title="Provides a triangulation of the product T x I (the product of the torus and the interval).">TxICore</a>, the thin I-bundle that is returned is an external object with its own separate triangulation of the product <code>T x I</code>. For information on how the thin I-bundle is embedded within this triangulation, see the routine <a class="el" href="group__subcomplex.html#ga5de0997eb055634ef733278f36565c3d" title="Returns an isomorphism describing how the thin I-bundle forms a subcomplex of this triangulation.">bundleIso()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the an isomorphic copy of the thin I-bundle within this triangulation. </dd></dl>

</div>
</div>
<a id="ga5de0997eb055634ef733278f36565c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5de0997eb055634ef733278f36565c3d">&#9670;&nbsp;</a></span>bundleIso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp; regina::PluggedTorusBundle::bundleIso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an isomorphism describing how the thin I-bundle forms a subcomplex of this triangulation. </p>
<p>The thin I-bundle returned by <a class="el" href="group__subcomplex.html#ga50e7a9fdb3b392e267d13ee0097aed2f" title="Returns an isomorphic copy of the thin I-bundle that forms part of this triangulation.">bundle()</a> does not directly refer to tetrahedra within this triangulation. Instead it contains its own isomorphic copy of the thin I-bundle triangulation (as is usual for objects of class <a class="el" href="classregina_1_1TxICore.html" title="Provides a triangulation of the product T x I (the product of the torus and the interval).">TxICore</a>).</p>
<p>The isomorphism returned by this routine is a mapping from the triangulation <a class="el" href="group__subcomplex.html#ga50e7a9fdb3b392e267d13ee0097aed2f" title="Returns an isomorphic copy of the thin I-bundle that forms part of this triangulation.">bundle()</a>.core() to this triangulation, showing how the thin I-bundle appears as a subcomplex of this structure.</p>
<dl class="section return"><dt>Returns</dt><dd>an isomorphism from the thin I-bundle described by <a class="el" href="group__subcomplex.html#ga50e7a9fdb3b392e267d13ee0097aed2f" title="Returns an isomorphic copy of the thin I-bundle that forms part of this triangulation.">bundle()</a> to the tetrahedra of this triangulation. </dd></dl>

</div>
</div>
<a id="ga4d837a20c3e34cba43b4042a31d579e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d837a20c3e34cba43b4042a31d579e3">&#9670;&nbsp;</a></span>centre()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::BlockedSFSTriple::centre </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the central saturated region, as described in the class notes above. </p>
<p>This is the saturated region with two boundary annuli, each of which is joined to one of the end regions.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the central region. </dd></dl>

</div>
</div>
<a id="ga7673c896771526a9b54fb8248a54d057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7673c896771526a9b54fb8248a54d057">&#9670;&nbsp;</a></span>chain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> * regina::PlugTriSolidTorus::chain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered chain attached to the requested annulus on the boundary of the core triangular solid torus. </p>
<p>If there is no attached layered chain, <code>null</code> will be returned.</p>
<p>Note that the core triangular solid torus will be attached to the bottom (as opposed to the top) of the layered chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>specifies which annulus to examine; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding layered chain. </dd></dl>

</div>
</div>
<a id="ga4a5eb96cc71beb6bc77b4f482348dcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a5eb96cc71beb6bc77b4f482348dcad">&#9670;&nbsp;</a></span>chain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> * regina::LayeredChainPair::chain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested layered chain used to form this structure. </p>
<p>If the two chains have different lengths, the shorter chain will be chain 0 and the longer chain will be chain 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which chain to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested layered chain. </dd></dl>

</div>
</div>
<a id="gacfc7d27e0a787d3cd3b18cbc14ee40e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfc7d27e0a787d3cd3b18cbc14ee40e0">&#9670;&nbsp;</a></span>chainLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::AugTriSolidTorus::chainLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the layered chain linking two of the boundary annuli of the core triangular solid torus. </p>
<p>Note that this count does not include any of the tetrahedra actually belonging to the triangular solid torus.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra in the layered chain, or 0 if there is no layered chain linking two boundary annuli. </dd></dl>

</div>
</div>
<a id="gaf374a74840cc6785167ed475ac919dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf374a74840cc6785167ed475ac919dd2">&#9670;&nbsp;</a></span>chainType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::AugTriSolidTorus::chainType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the way in which a layered chain links two of the boundary annuli of the core triangular solid torus. </p>
<p>This will be one of the chain type constants defined in this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of layered chain, or <em>CHAIN_NONE</em> if there is no layered chain linking two boundary annuli. </dd></dl>

</div>
</div>
<a id="gadd25d2ffd7fb549ababf0733f18041c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd25d2ffd7fb549ababf0733f18041c2">&#9670;&nbsp;</a></span>chainType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::PlugTriSolidTorus::chainType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the way in which a layered chain is attached to the requested annulus on the boundary of the core triangular solid torus. </p>
<p>This will be one of the chain type constants defined in this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>specifies which annulus to examine; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of layered chain, or <em>CHAIN_NONE</em> if there is no layered chain attached to the requested annulus. </dd></dl>

</div>
</div>
<a id="ga94ef70acb636d8db01ae0a11937cab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ef70acb636d8db01ae0a11937cab05">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a>* regina::AugTriSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga6f8a3de489a4aab63f5e4f87f389618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8a3de489a4aab63f5e4f87f389618d">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a>* regina::L31Pillow::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga6ce208542994a4f477d41358d639e706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce208542994a4f477d41358d639e706">&#9670;&nbsp;</a></span>clone() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a>* regina::LayeredChainPair::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="gaa1f74c6d8c8449fec6c443db265e2424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f74c6d8c8449fec6c443db265e2424">&#9670;&nbsp;</a></span>clone() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a>* regina::LayeredLensSpace::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga1fd935f8b7f591edef5f3e3724ff8702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fd935f8b7f591edef5f3e3724ff8702">&#9670;&nbsp;</a></span>clone() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a>* regina::LayeredLoop::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga38473265bdeebb5764c212fec1836f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38473265bdeebb5764c212fec1836f1c">&#9670;&nbsp;</a></span>clone() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a>* regina::LayeredSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="gaa30aefbe9594bdc07398419b9677e413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa30aefbe9594bdc07398419b9677e413">&#9670;&nbsp;</a></span>clone() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a>* regina::PillowTwoSphere::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="gaf1c7ec831a9c0bd0f8e7faf8b6494001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c7ec831a9c0bd0f8e7faf8b6494001">&#9670;&nbsp;</a></span>clone() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a>* regina::PlugTriSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga0f25902d2536efeede4853644ead22b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f25902d2536efeede4853644ead22b6">&#9670;&nbsp;</a></span>clone() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> * regina::SnapPeaCensusTri::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga3ff7e1d816cd0bc98b75c4e10e166692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff7e1d816cd0bc98b75c4e10e166692">&#9670;&nbsp;</a></span>clone() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a>* regina::SnappedBall::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga92ca13de2b3ad244568a9e150b8ae63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ca13de2b3ad244568a9e150b8ae63e">&#9670;&nbsp;</a></span>clone() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a>* regina::SnappedTwoSphere::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="gac7fd7ae82a49b944aba728d975648ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7fd7ae82a49b944aba728d975648ed8">&#9670;&nbsp;</a></span>clone() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a>* regina::SpiralSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga3f3db9c62e7aae094162936494a2b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3db9c62e7aae094162936494a2b6ed">&#9670;&nbsp;</a></span>clone() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a>* regina::TriSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga312e34c2ec292bd20c4d3bd1b0b9a02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312e34c2ec292bd20c4d3bd1b0b9a02e">&#9670;&nbsp;</a></span>clone() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a> * regina::TrivialTri::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ga2de55d177752158147c2375271a71359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de55d177752158147c2375271a71359">&#9670;&nbsp;</a></span>clone() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>* regina::SatBlock::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga32d114838d339ea034a03facda36ba05">regina::SatLayering</a>, <a class="el" href="group__subcomplex.html#ga3aea1ca51b8b1f1141c2e1c05a821b54">regina::SatReflectorStrip</a>, <a class="el" href="group__subcomplex.html#ga4c9a05297dcb7dab0014f54b888c6665">regina::SatCube</a>, <a class="el" href="group__subcomplex.html#ga87a6fe9a00b3a689f4d871d5a41d2f45">regina::SatTriPrism</a>, <a class="el" href="group__subcomplex.html#ga5ed63303e680ec48e1e342c9cd8a0bd0">regina::SatLST</a>, and <a class="el" href="group__subcomplex.html#gaabff7831bf78f47b456d85d237b61738">regina::SatMobius</a>.</p>

</div>
</div>
<a id="gaabff7831bf78f47b456d85d237b61738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabff7831bf78f47b456d85d237b61738">&#9670;&nbsp;</a></span>clone() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatMobius::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga5ed63303e680ec48e1e342c9cd8a0bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed63303e680ec48e1e342c9cd8a0bd0">&#9670;&nbsp;</a></span>clone() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatLST::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga87a6fe9a00b3a689f4d871d5a41d2f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a6fe9a00b3a689f4d871d5a41d2f45">&#9670;&nbsp;</a></span>clone() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatTriPrism::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga4c9a05297dcb7dab0014f54b888c6665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c9a05297dcb7dab0014f54b888c6665">&#9670;&nbsp;</a></span>clone() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatCube::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga3aea1ca51b8b1f1141c2e1c05a821b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aea1ca51b8b1f1141c2e1c05a821b54">&#9670;&nbsp;</a></span>clone() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatReflectorStrip::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga32d114838d339ea034a03facda36ba05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d114838d339ea034a03facda36ba05">&#9670;&nbsp;</a></span>clone() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> * regina::SatLayering::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga2de55d177752158147c2375271a71359">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gacc9d3e437d412922ef79246561d4bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9d3e437d412922ef79246561d4bd4a">&#9670;&nbsp;</a></span>core() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> &amp; regina::AugTriSolidTorus::core </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangular solid torus at the core of this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the core triangular solid torus. </dd></dl>

</div>
</div>
<a id="gad714490fe0e05e211c3e72b968f679c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad714490fe0e05e211c3e72b968f679c1">&#9670;&nbsp;</a></span>core() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TxICore.html">TxICore</a> &amp; regina::LayeredTorusBundle::core </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <code>T x I</code> triangulation at the core of this layered surface bundle. </p>
<p>This is the product <code>T x I</code> whose boundaries are joined (possibly via some layering of tetrahedra).</p>
<p>Note that the triangulation returned by <a class="el" href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d" title="Returns a full copy of the T x I triangulation that this object describes.">TxICore::core()</a> (that is, <a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">LayeredTorusBundle::core()</a>.<a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">core()</a>) may well use different tetrahedron and vertex numbers. That is, an isomorphic copy of it appears within this layered surface bundle but the individual tetrahedra and vertices may have been permuted. For a precise mapping from the <a class="el" href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d" title="Returns a full copy of the T x I triangulation that this object describes.">TxICore::core()</a> triangulation to this triangulation, see the routine <a class="el" href="group__subcomplex.html#ga6b20f538a0786df8458eb77c897fe4c3" title="Returns the isomorphism describing how the core T x I appears as a subcomplex of this layered surface...">coreIso()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the core <code>T x I</code> triangulation. </dd></dl>

</div>
</div>
<a id="gab0d6069b0832a167da36842f4fee138b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d6069b0832a167da36842f4fee138b">&#9670;&nbsp;</a></span>core() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a> &amp; regina::PlugTriSolidTorus::core </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangular solid torus at the core of this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the core triangular solid torus. </dd></dl>

</div>
</div>
<a id="gad740d388b1d8826a092c2d898eafd70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad740d388b1d8826a092c2d898eafd70d">&#9670;&nbsp;</a></span>core() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; regina::TxICore::core </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full copy of the <code>T x I</code> triangulation that this object describes. </p>
<p>Successive calls to this routine will returns the same triangulation (i.e., it is not recreated each time). The triangulation that is returned may not be modified or destroyed.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a new clone of the triangulation each time it is called, since Python will claim ownership of the triangulation that is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the full triangulation. </dd></dl>

</div>
</div>
<a id="ga6b20f538a0786df8458eb77c897fe4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b20f538a0786df8458eb77c897fe4c3">&#9670;&nbsp;</a></span>coreIso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; * regina::LayeredTorusBundle::coreIso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the isomorphism describing how the core <code>T x I</code> appears as a subcomplex of this layered surface bundle. </p>
<p>As described in the <a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">core()</a> notes, the core <code>T x I</code> triangulation returned by <a class="el" href="group__subcomplex.html#gad740d388b1d8826a092c2d898eafd70d" title="Returns a full copy of the T x I triangulation that this object describes.">TxICore::core()</a> appears within this layered surface bundle, but not necessarily with the same tetrahedron or vertex numbers.</p>
<p>This routine returns an isomorphism that maps the tetrahedra and vertices of the core <code>T x I</code> triangulation (as returned by <a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">LayeredTorusBundle::core()</a>.<a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">core()</a>) to the tetrahedra and vertices of this overall layered surface bundle.</p>
<p>The isomorphism that is returned belongs to this object, and should not be modified or destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism from the core <code>T x I</code> to this layered surface bundle. </dd></dl>

</div>
</div>
<a id="ga6e1e8d3b599c58464e73ddf594630f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e1e8d3b599c58464e73ddf594630f22">&#9670;&nbsp;</a></span>createSFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a>* regina::SatRegion::createSFS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the Seifert fibred space represented by this region. </p>
<p>Each boundary component of this region will be formed from a ring of saturated annuli, which together form a torus or a Klein bottle. For torus boundary components, the oriented curves representing the fibres and base orbifold on the boundary (see <a class="el" href="sfsnotation.html">Notation for Seifert fibred spaces</a>) will be as follows.</p>
<ul>
<li>Consider the 0/1/2 markings on the first and second triangles of each saturated annulus, as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes.</li>
<li>The fibres are represented by the oriented edge joining markings 1 and 0 on the first triangle (or 0 and 1 on the second triangle). This is reversed if the block containing the boundary annulus is vertically reflected.</li>
<li>The curve representing the base orbifold run along the oriented edge joining markings 0 and 2 on the first triangle (or 2 and 0 on the second triangle). This is reversed if the block containing the boundary annulus is horizontally reflected.</li>
<li>See the <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> overview for descriptions of horizontal and vertical reflection.</li>
</ul>
<p>If the argument <em>reflect</em> is <code>true</code>, the Seifert fibred space will be created as though the entire region had been reflected. In particular, each twist or exceptional fibre will be negated before being added to the Seifert structure.</p>
<p>For Klein bottle boundary components, these curves must (for now) be analysed by hand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflect</td><td><code>true</code> if this region is to be reflected as the Seifert fibred space is created, or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created structure of the underlying Seifert fibred space. </dd></dl>

</div>
</div>
<a id="gaadc353661dbe3b81afa1187dd049c4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc353661dbe3b81afa1187dd049c4d2">&#9670;&nbsp;</a></span>cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpiralSolidTorus::cycle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this spiralled solid torus by the given number of tetrahedra. </p>
<p>Tetrahedra <em>k</em>, <em>k</em>+1, <em>k</em>+2 and so on will become tetrahedra 0, 1, 2 and so on respectively. Note that this operation will not change the vertex roles.</p>
<p>The underlying triangulation is not changed; all that changes is how this spiralled solid torus is represented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the number of tetrahedra through which we should cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f54cccdd60ed0a22113f25e23b553b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f54cccdd60ed0a22113f25e23b553b1">&#9670;&nbsp;</a></span>edgeGroupRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::AugTriSolidTorus::edgeGroupRoles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>annulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation describing the role played by each top level edge group of the layered solid torus glued to the requested annulus of the core triangular solid torus. </p>
<p>See <a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">LayeredSolidTorus::topEdge()</a> for details regarding edge groups.</p>
<p>If the permutation returned is <code>p</code>, edge group <code>p[0]</code> will be glued to an axis edge, group <code>p[1]</code> will be glued to a major edge and group <code>p[2]</code> will be glued to a minor edge. <code>p[3]</code> will always be 3.</p>
<p>Even if the corresponding layered solid torus is a degenerate (2,1,1) mobius band (i.e., <a class="el" href="group__subcomplex.html#ga7a0bd603756efd481bf9bd828a4c0d19" title="Returns the layered solid torus attached to the requested annulus on the boundary of the core triangu...">augTorus()</a> returns <code>null</code>), the concept of edge groups is still meaningful and this routine will return correct results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>specifies which annulus to examine; this must be 0, 1 or 2. It is the layered solid torus glued to this annulus whose edge groups will be described. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation describing the roles of the corresponding top level edge groups. </dd></dl>

</div>
</div>
<a id="gae6878f15e256657c3e022422b1c265be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6878f15e256657c3e022422b1c265be">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__subcomplex.html#gaa9ec02399fc8c577957bc02912f5db87">SatBlockStarterSet::iterator</a> regina::SatBlockStarterSet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing past the end of the hard-coded list (i.e., just after the last item). </p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="group__subcomplex.html#gaab2edd99bee25ef747da8a1ba916bd7a" title="Returns an iterator pointing to the first block in the hard-coded list.">begin()</a> routine has been called at least once.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a past-the-end iterator. </dd></dl>

</div>
</div>
<a id="ga1c00920c51d6bda6c447107c43065b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c00920c51d6bda6c447107c43065b32">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::BlockedSFSTriple::end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested end region, as described in the class notes above. </p>
<p>The end regions are the two saturated regions with one boundary annulus each, which are both joined to the central region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>0 if the first end region should be returned (marked as end region 0 in the class notes), or 1 if the second end region should be returned (marked as end region 1 in the class notes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested end region. </dd></dl>

</div>
</div>
<a id="gadce9a454ef99df52f433e3535c178cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce9a454ef99df52f433e3535c178cae">&#9670;&nbsp;</a></span>equatorEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SnappedBall::equatorEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge that forms the equator of the boundary sphere of this ball. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding edge number in the tetrahedron. </dd></dl>

</div>
</div>
<a id="ga43c1dcd8b4e1181fe0481f35b1aff83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c1dcd8b4e1181fe0481f35b1aff83b">&#9670;&nbsp;</a></span>equatorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::PlugTriSolidTorus::equatorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which types of edges form the equator of the plug. </p>
<p>In the absence of layered chains these will either all be major edges or all be minor edges.</p>
<p>Layered chains complicate matters, but the roles that the major and minor edges play on the boundary annuli of the triangular solid torus can be carried up to the annuli at the top of each layered chain; the edges filling the corresponding major or minor roles will then form the equator of the plug.</p>
<dl class="section return"><dt>Returns</dt><dd>the types of edges that form the equator of the plug; this will be one of the equator type constants defined in this class. </dd></dl>

</div>
</div>
<a id="ga737839a4e297056cf8328c03a86b57b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga737839a4e297056cf8328c03a86b57b5">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatRegion::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">SatBlock::TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopIfIncomplete</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands this region as far as possible within the overall triangulation. </p>
<p>This routine will hunt for new saturated blocks, and will also hunt for new adjacencies between existing blocks.</p>
<p>The first argument to this routine is the tetrahedron list <em>avoidTets</em>. This is a list of tetrahedra that will not be considered when examining potential new blocks. This list will be modified by this routine; in particular, it will be expanded to include all tetrahedra for any new blocks that are found. Before calling this routine it should contain tetrahedra for blocks already in this region, as discussed in the preconditions below.</p>
<p>It may be that you are searching for a region that fills an entire triangulation component (i.e., every boundary annulus of the region in fact forms part of the boundary of the triangulation). In this case you may pass the optional argument <em>stopIfIncomplete</em> as <code>true</code>. This means that if this routine ever discovers an annulus that is not part of the triangulation boundary and that it cannot match with some adjacent block, it will exit immediately and return <code>false</code>. Note that the region structure will be incomplete and/or inconsistent if this happens; in this case the unfinished region should be destroyed completely and never used.</p>
<p>For internal purposes, it should be noted that any new blocks that are discovered will be added to the end of the internal block list (thus the indices of existing blocks will not change).</p>
<dl class="section warning"><dt>Warning</dt><dd>When joining blocks together, it is possible to create invalid edges (e.g., by joining a one-annulus untwisted boundary to a one-annulus twisted boundary). This routine does <em>not</em> check for such conditions. It is recommended that you run <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">Triangulation&lt;3&gt;::isValid()</a> before calling this routine.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If any blocks already belonging to this region have adjacencies listed in their <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> structures, then these adjacent blocks belong to this region also. This precondition is easily satisfied if you let the <a class="el" href="classregina_1_1SatRegion.html" title="A large saturated region in a Seifert fibred space formed by joining together saturated blocks.">SatRegion</a> constructor and <a class="el" href="group__subcomplex.html#ga737839a4e297056cf8328c03a86b57b5" title="Expands this region as far as possible within the overall triangulation.">expand()</a> do all of the adjacency handling, as described in the class notes. </dd>
<dd>
The list <em>avoidTets</em> includes all tetrahedra on the boundaries of any blocks already contained in this region.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The first argument <em>avoidTets</em> is not present. An empty list will be passed instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avoidTets</td><td>a list of tetrahedra that should not be considered for new blocks, as discussed above. Note that this list may be modified by this routine. </td></tr>
    <tr><td class="paramname">stopIfIncomplete</td><td><code>true</code> if you are filling an entire triangulation component with this region and you wish this routine to exit early if this is not possible, or <code>false</code> (the default) if you simply wish to expand this region as far as you can. See above for further discussion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the optional argument <em>stopIfIncomplete</em> was passed as <code>true</code> but expansion did not fill the entire triangulation component as described above, or <code>true</code> in all other cases. </dd></dl>

</div>
</div>
<a id="gaa48e1aabed68a1a39cd69a5c016533d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa48e1aabed68a1a39cd69a5c016533d9">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::Layering::extend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines whether one or more additional tetrahedra have been layered upon the current new boundary. </p>
<p>Specifically, this routine calls <a class="el" href="group__subcomplex.html#ga45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> as many times as possible. If <em>k</em> additional layerings are discovered as a result, the size of this structure will have grown by <em>k</em> and the new boundary will be changed to describe the remaining two faces of the <em>kth</em> layered tetrahedron.</p>
<p>It is guaranteed that, once this routine is finished, the new boundary will not have any additional tetrahedron layered upon it. That is, if <a class="el" href="group__subcomplex.html#ga45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> were called again then it would return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of additional layered tetrahedra that were discovered. </dd></dl>

</div>
</div>
<a id="gaf39b2d736d35ab0be374d191a68f1951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39b2d736d35ab0be374d191a68f1951">&#9670;&nbsp;</a></span>extendAbove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredChain::extendAbove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether this layered chain can be extended to include the tetrahedron above the top tetrahedron (and still remain a layered chain). </p>
<p>If so, this layered chain will be modified accordingly (note that its index will be increased by one and its top tetrahedron will change).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this layered chain was extended. </dd></dl>

</div>
</div>
<a id="ga5977fb7fe0cabde3a8712327b7434ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5977fb7fe0cabde3a8712327b7434ba0">&#9670;&nbsp;</a></span>extendBelow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredChain::extendBelow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether this layered chain can be extended to include the tetrahedron below the bottom tetrahedron (and still remain a layered chain). </p>
<p>If so, this layered chain will be modified accordingly (note that its index will be increased by one and its bottom tetrahedron will change).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this layered chain was extended. </dd></dl>

</div>
</div>
<a id="gabed0c53621cb17684707a65e59229771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed0c53621cb17684707a65e59229771">&#9670;&nbsp;</a></span>extendMaximal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredChain::extendMaximal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends this layered chain to a maximal length layered chain. </p>
<p>Both <a class="el" href="group__subcomplex.html#gaf39b2d736d35ab0be374d191a68f1951" title="Checks to see whether this layered chain can be extended to include the tetrahedron above the top tet...">extendAbove()</a> and <a class="el" href="group__subcomplex.html#ga5977fb7fe0cabde3a8712327b7434ba0" title="Checks to see whether this layered chain can be extended to include the tetrahedron below the bottom ...">extendBelow()</a> will be used until this layered chain can be extended no further.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this layered chain was extended. </dd></dl>

</div>
</div>
<a id="ga45a97df250ac597168260389eb2c6edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a97df250ac597168260389eb2c6edc">&#9670;&nbsp;</a></span>extendOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::extendOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines whether a single additional tetrahedron has been layered upon the current new boundary. </p>
<p>The new boundary triangles are assumed to form a torus as described in the class notes (this is not verified, and there are degenerate cases where this will likely be false). This defines three possible ways in which an additional tetrahedron may be layered (over the three boundary edges respectively).</p>
<p>If it is found that an additional tetrahedron does exist and has been joined to the new boundary in one of these three possible ways, this structure is extended to incorporate the additional tetrahedron. The size will grow by one, and the new boundary will become the remaining two faces of this additional tetrahedron.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a tetrahedron was found as described above and this structure was extended accordingly, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga211f6cc1476b89316c4f5670a67e2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211f6cc1476b89316c4f5670a67e2fa2">&#9670;&nbsp;</a></span>findStarterBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlockStarterSearcher::findStarterBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a search for every isomorphic embedding of every starter block from the global <a class="el" href="classregina_1_1SatBlockStarterSet.html" title="Represents a set of starter blocks that can be used for identifying triangulations of Seifert fibred ...">SatBlockStarterSet</a> within the given triangulation. </p>
<p>Each time an embedding is discovered, the pure virtual routine <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> will be called.</p>
<p>See the <a class="el" href="classregina_1_1SatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">SatBlockStarterSearcher</a> class notes for greater detail on what this search does and how it runs.</p>
<p>For subclasses that make use of the <em>usedTets</em> data member, it is worth noting that this routine empties the <em>usedTets</em> list on both entry and exit, as well as every time that <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> returns after each new embedding is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which to search for starter blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf27eeec34e19d156fad9d9e6ebc0032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27eeec34e19d156fad9d9e6ebc0032f">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::LayeredSolidTorus::flatten </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mobiusBandBdry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens this layered solid torus to a Mobius band. </p>
<p>A newly created modified triangulation is returned; the original triangulation is unchanged.</p>
<p>Note that there are three different ways in which this layered solid torus can be flattened, corresponding to the three different edges of the boundary torus that could become the boundary edge of the new Mobius band.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the triangulation containing this layered solid torus; this triangulation will not be changed. </td></tr>
    <tr><td class="paramname">mobiusBandBdry</td><td>the edge group on the boundary of this layered solid torus that will become the boundary of the new Mobius band (the remaining edge groups will become internal edges of the new Mobius band). This must be 0, 1 or 2. See <a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about edge groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation in which this layered solid torus has been flattened to a Mobius band. </dd></dl>

</div>
</div>
<a id="ga34a35647727585b3f7b7966cb0306205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a35647727585b3f7b7966cb0306205">&#9670;&nbsp;</a></span>formsLayeredSolidTorusBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a>* regina::LayeredSolidTorus::formsLayeredSolidTorusBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation. </p>
<p>The torus need not be the entire triangulation; the top level tetrahedron of the torus may be glued to something else (or to itself).</p>
<p>Note that the base tetrahedron of a layered solid torus is the tetrahedron furthest from the boundary of the torus, i.e. the tetrahedron glued to itself with a twist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine as a potential base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered solid torus, or <code>null</code> if the given tetrahedron is not the base of a layered solid torus. </dd></dl>

</div>
</div>
<a id="gab5e1fd9570fe5a2b7ed87c4a39dd73bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e1fd9570fe5a2b7ed87c4a39dd73bd">&#9670;&nbsp;</a></span>formsLayeredSolidTorusTop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a>* regina::LayeredSolidTorus::formsLayeredSolidTorusTop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms the top level tetrahedron of a layered solid torus, with the two given faces of this tetrahedron representing the boundary of the layered solid torus. </p>
<p>Note that the two given faces need not be boundary triangles in the overall triangulation. That is, the layered solid torus may be a subcomplex of some larger triangulation. For example, the two given faces may be joined to some other tetrahedra outside the layered solid torus or they may be joined to each other. In fact, they may even extend this smaller layered solid torus to a larger layered solid torus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine as a potential top level of a layered solid torus. </td></tr>
    <tr><td class="paramname">topFace1</td><td>the face number of the given tetrahedron that should represent the first boundary triangle of the layered solid torus. This should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">topFace2</td><td>the face number of the given tetrahedron that should represent the second boundary triangle of the layered solid torus. This should be between 0 and 3 inclusive, and should not be equal to <em>topFace1</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered solid torus, or <code>null</code> if the given tetrahedron with its two faces do not form the top level of a layered solid torus. </dd></dl>

</div>
</div>
<a id="gae80b056ef66285ed510a777cd6969ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae80b056ef66285ed510a777cd6969ee7">&#9670;&nbsp;</a></span>formsPillowTwoSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1PillowTwoSphere.html">PillowTwoSphere</a>* regina::PillowTwoSphere::formsPillowTwoSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the two given triangles together form a pillow 2-sphere. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given triangles are distinct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri1</td><td>the first triangle to examine. </td></tr>
    <tr><td class="paramname">tri2</td><td>the second triangle to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the pillow 2-sphere, or <code>null</code> if the given triangles do not form a pillow 2-sphere. </dd></dl>

</div>
</div>
<a id="gac5fef6a2032d2a78de6739e15c05c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5fef6a2032d2a78de6739e15c05c5e1">&#9670;&nbsp;</a></span>formsSnappedBall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a>* regina::SnappedBall::formsSnappedBall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms a snapped 3-ball within a triangulation. </p>
<p>The ball need not be the entire triangulation; the boundary triangles may be glued to something else (or to each other).</p>
<p>Note that the two boundary triangles of the snapped 3-ball need not be boundary triangles within the overall triangulation, i.e., they may be identified with each other or with triangles of other tetrahedra.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine as a potential 3-ball. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the snapped 3-ball, or <code>null</code> if the given tetrahedron is not a snapped 3-ball. </dd></dl>

</div>
</div>
<a id="ga46967e3d94d0bff13708e1677332c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46967e3d94d0bff13708e1677332c5c3">&#9670;&nbsp;</a></span>formsSnappedTwoSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a>* regina::SnappedTwoSphere::formsSnappedTwoSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *&#160;</td>
          <td class="paramname"><em>ball1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> *&#160;</td>
          <td class="paramname"><em>ball2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the two given snapped 3-balls together form a snapped 2-sphere. </p>
<p>If this is the case, the snapped 3-balls stored in the structure returned will be clones of the original 3-balls, not the original 3-balls themselves.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given snapped 3-balls use distinct tetrahedra.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ball1</td><td>the first snapped 3-ball to examine. </td></tr>
    <tr><td class="paramname">ball2</td><td>the second snapped 3-ball to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the snapped 2-sphere, or <code>null</code> if the given snapped 3-balls do not form a snapped 2-sphere. </dd></dl>

</div>
</div>
<a id="gae98381218f472fe7a31b3c26e56f7187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98381218f472fe7a31b3c26e56f7187">&#9670;&nbsp;</a></span>formsSnappedTwoSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SnappedTwoSphere.html">SnappedTwoSphere</a>* regina::SnappedTwoSphere::formsSnappedTwoSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the two given tetrahedra together form a snapped 2-sphere. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given tetrahedra are distinct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet1</td><td>the first tetrahedron to examine. </td></tr>
    <tr><td class="paramname">tet2</td><td>the second tetrahedron to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the snapped 2-sphere, or <code>null</code> if the given tetrahedra do not form a snapped 2-sphere. </dd></dl>

</div>
</div>
<a id="ga0f071e44a208be72fe4c9d5a2375e3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f071e44a208be72fe4c9d5a2375e3ec">&#9670;&nbsp;</a></span>formsSpiralSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SpiralSolidTorus.html">SpiralSolidTorus</a>* regina::SpiralSolidTorus::formsSpiralSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>useVertexRoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms part of a spiralled solid torus with its vertices playing the given roles in the solid torus. </p>
<p>Note that the boundary triangles of the spiralled solid torus need not be boundary triangles within the overall triangulation, i.e., they may be identified with each other or with triangles of other tetrahedra.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine. </td></tr>
    <tr><td class="paramname">useVertexRoles</td><td>a permutation describing the role each tetrahedron vertex must play in the solid torus; this must be in the same format as the permutation returned by <a class="el" href="group__subcomplex.html#gab5f4e19343a3c7ff83b2d401ba2bc575" title="Returns a permutation represeting the role that each vertex of the requested tetrahedron plays in the...">vertexRoles()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the solid torus with the given tetrahedron as tetrahedron 0, or <code>null</code> if the given tetrahedron is not part of a spiralled solid torus with the given vertex roles. </dd></dl>

</div>
</div>
<a id="gafcbf6dc2a01ca7ac4375f281201a8b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcbf6dc2a01ca7ac4375f281201a8b7e">&#9670;&nbsp;</a></span>formsTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TriSolidTorus.html">TriSolidTorus</a>* regina::TriSolidTorus::formsTriSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>useVertexRoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms part of a three-tetrahedron triangular solid torus with its vertices playing the given roles in the solid torus. </p>
<p>Note that the six boundary triangles of the triangular solid torus need not be boundary triangles within the overall triangulation, i.e., they may be identified with each other or with faces of other tetrahedra.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine. </td></tr>
    <tr><td class="paramname">useVertexRoles</td><td>a permutation describing the role each tetrahedron vertex must play in the solid torus; this must be in the same format as the permutation returned by <a class="el" href="group__subcomplex.html#ga7a73c2957fd960d42c0b493726f7f994" title="Returns a permutation represeting the role that each vertex of the requested tetrahedron plays in the...">vertexRoles()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the solid torus with the given tetrahedron as tetrahedron 0, or <code>null</code> if the given tetrahedron is not part of a triangular solid torus with the given vertex roles. </dd></dl>

</div>
</div>
<a id="ga3c2540d455af75c2d5d736267d4b78ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c2540d455af75c2d5d736267d4b78ff">&#9670;&nbsp;</a></span>halfTurnRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::halfTurnRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 180 degree rotated representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="group__subcomplex.html#gaeea9c67b200888b3aeb42251ee31c3cc" title="Rotates the representation of this annulus by 180 degrees.">rotateHalfTurn()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new 180 degree rotation of this annulus. </dd></dl>

</div>
</div>
<a id="ga70d78eef4a11ec11260bb000eaa5a056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70d78eef4a11ec11260bb000eaa5a056">&#9670;&nbsp;</a></span>hasAdjacentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::hasAdjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary annulus has an adjacent block listed, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga1254c105ca00c41987059ace85036d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1254c105ca00c41987059ace85036d46">&#9670;&nbsp;</a></span>hasLayeredChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AugTriSolidTorus::hasLayeredChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the core triangular solid torus has two of its boundary annuli linked by a layered chain as described in the general class notes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the layered chain described in the class notes is present. </dd></dl>

</div>
</div>
<a id="gacb5337de9a6540d096f7b91ae7353d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5337de9a6540d096f7b91ae7353d7f">&#9670;&nbsp;</a></span>hinge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * regina::LayeredLoop::hinge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested hinge edge of this layered loop. </p>
<p>See the general class notes for further details. If there is only one hinge but parameter <em>which</em> is 1, <code>null</code> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which hinge to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested hinge edge. </dd></dl>

</div>
</div>
<a id="gaca65a2083031bd2bc8cb2a2565004570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca65a2083031bd2bc8cb2a2565004570">&#9670;&nbsp;</a></span>homology() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::StandardTriangulation::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented in <a class="el" href="group__subcomplex.html#ga76d35ca33ad85aac7d50a449d53e9bdb">regina::TrivialTri</a>, <a class="el" href="group__subcomplex.html#ga6561d6eeb5f18705335ad19b10530942">regina::TriSolidTorus</a>, <a class="el" href="group__subcomplex.html#gaaa50b78ce48118418a74156102c148c0">regina::SpiralSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga43f94395d258660b3b027bad5868f7e6">regina::SnappedBall</a>, <a class="el" href="group__subcomplex.html#gabed042ff18db35d0d6c83b457dbb1ff0">regina::SnapPeaCensusTri</a>, <a class="el" href="group__subcomplex.html#gae4c426c8fc83e6eab4585e63bd9dcb39">regina::LayeredTorusBundle</a>, <a class="el" href="group__subcomplex.html#gaef96ee65b9fc3f337606d6eaaa96a869">regina::LayeredSolidTorus</a>, <a class="el" href="group__subcomplex.html#gae0181ec84dab4d3a390ace2ebe0639e2">regina::LayeredLoop</a>, <a class="el" href="group__subcomplex.html#ga72695e0f78b243ab581e5f1668bb7f75">regina::LayeredLensSpace</a>, <a class="el" href="group__subcomplex.html#ga085eee274563501755e876261eaae243">regina::LayeredChainPair</a>, <a class="el" href="group__subcomplex.html#ga60751ca7ff06b9ec2ceb3efc80c8d468">regina::LayeredChain</a>, and <a class="el" href="group__subcomplex.html#gac5bcee0e29af6eec7a506247a092ad8d">regina::L31Pillow</a>.</p>

</div>
</div>
<a id="gac5bcee0e29af6eec7a506247a092ad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bcee0e29af6eec7a506247a092ad8d">&#9670;&nbsp;</a></span>homology() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::L31Pillow::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga60751ca7ff06b9ec2ceb3efc80c8d468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60751ca7ff06b9ec2ceb3efc80c8d468">&#9670;&nbsp;</a></span>homology() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredChain::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga085eee274563501755e876261eaae243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085eee274563501755e876261eaae243">&#9670;&nbsp;</a></span>homology() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredChainPair::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga72695e0f78b243ab581e5f1668bb7f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72695e0f78b243ab581e5f1668bb7f75">&#9670;&nbsp;</a></span>homology() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredLensSpace::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gae0181ec84dab4d3a390ace2ebe0639e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0181ec84dab4d3a390ace2ebe0639e2">&#9670;&nbsp;</a></span>homology() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredLoop::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaef96ee65b9fc3f337606d6eaaa96a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef96ee65b9fc3f337606d6eaaa96a869">&#9670;&nbsp;</a></span>homology() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredSolidTorus::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gae4c426c8fc83e6eab4585e63bd9dcb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4c426c8fc83e6eab4585e63bd9dcb39">&#9670;&nbsp;</a></span>homology() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::LayeredTorusBundle::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gabed042ff18db35d0d6c83b457dbb1ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed042ff18db35d0d6c83b457dbb1ff0">&#9670;&nbsp;</a></span>homology() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SnapPeaCensusTri::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga43f94395d258660b3b027bad5868f7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f94395d258660b3b027bad5868f7e6">&#9670;&nbsp;</a></span>homology() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SnappedBall::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaaa50b78ce48118418a74156102c148c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa50b78ce48118418a74156102c148c0">&#9670;&nbsp;</a></span>homology() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SpiralSolidTorus::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga6561d6eeb5f18705335ad19b10530942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6561d6eeb5f18705335ad19b10530942">&#9670;&nbsp;</a></span>homology() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::TriSolidTorus::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga76d35ca33ad85aac7d50a449d53e9bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d35ca33ad85aac7d50a449d53e9bdb">&#9670;&nbsp;</a></span>homology() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::TrivialTri::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gacbd1c110caa1deb5e1ce0e58665bb573" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gacbd1c110caa1deb5e1ce0e58665bb573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbd1c110caa1deb5e1ce0e58665bb573">&#9670;&nbsp;</a></span>homologyH1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::StandardTriangulation::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this triangulation then this routine will return 0.</p>
<p>This routine does not work by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p>The details of which standard triangulations have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<p>This routine can also be accessed via the alias <a class="el" href="group__subcomplex.html#gaca65a2083031bd2bc8cb2a2565004570" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a> (a name that is less specific, but a little easier to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

</div>
</div>
<a id="gaa7c5947d121ebf8a25e0849bdf5a7f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c5947d121ebf8a25e0849bdf5a7f7e">&#9670;&nbsp;</a></span>horizontalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::horizontalReflection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a left-to-right reflected representation of this annulus. </p>
<p>This structure will not be changed. See <a class="el" href="group__subcomplex.html#ga53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new left-to-right reflection of this annulus. </dd></dl>

</div>
</div>
<a id="gaae35b903051842517e0c3be39eae2cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae35b903051842517e0c3be39eae2cee">&#9670;&nbsp;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this annulus representation under the given isomorphism between triangulations. </p>
<p>This annulus representation will not be changed. See <a class="el" href="group__subcomplex.html#gaadb34c281222b5a95a4d3a2bd4206fcf" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">transform()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the new annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca0ac74262853d183cb0bc125a83b2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0ac74262853d183cb0bc125a83b2c4">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredChain::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this layered chain. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="ga0653a0c75bc408a2e5cb9e9a44bb7225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0653a0c75bc408a2e5cb9e9a44bb7225">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SnapPeaCensusTri::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this triangulation within its particular section of the SnapPea census. </p>
<p>Note that indices for each section begin counting at zero.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of this triangulation within its section. </dd></dl>

</div>
</div>
<a id="ga52db0ca1eb1e56f93cf656dccb182db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52db0ca1eb1e56f93cf656dccb182db1">&#9670;&nbsp;</a></span>initialise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlockStarterSet::initialise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills this list with items. </p>
<p>The particular set of items to use will typically depend on the particular subclass of <a class="el" href="classregina_1_1ListOnCall.html" title="Offers a hard-coded list of expensive objects that should only be created if they are required.">ListOnCall</a> that is being defined.</p>
<p>This routine will be run the first time that <a class="el" href="group__subcomplex.html#gaab2edd99bee25ef747da8a1ba916bd7a" title="Returns an iterator pointing to the first block in the hard-coded list.">begin()</a> is called on each list, and will not be run again. </p>

<p>Implements <a class="el" href="group__utilities.html#gaf28a5e3992fdfe5b552848fc2a644b2e">regina::ListOnCall&lt; SatBlockStarter &gt;</a>.</p>

</div>
</div>
<a id="ga6e482d39394655f8ad0f2e35b9c67186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e482d39394655f8ad0f2e35b9c67186">&#9670;&nbsp;</a></span>insertBlock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatCube.html">SatCube</a>* regina::SatCube::insertBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new copy of a cube block into the given triangulation, and returns the corresponding block structure. </p>
<p>The given triangulation will not be emptied before the new tetrahedra are inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new block should be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structural details of the newly inserted block. </dd></dl>

</div>
</div>
<a id="ga40ae6234b5c89b74cb2937d7d31c2306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ae6234b5c89b74cb2937d7d31c2306">&#9670;&nbsp;</a></span>insertBlock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a>* regina::SatTriPrism::insertBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>major</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new copy of a triangular prism block into the given triangulation, and returns the corresponding block structure. </p>
<p>The given triangulation will not be emptied before the new tetrahedra are inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new block should be inserted. </td></tr>
    <tr><td class="paramname">major</td><td><code>true</code> if a block of major type should be inserted, or <code>false</code> if a block of minor type should be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structural details of the newly inserted block. </dd></dl>

</div>
</div>
<a id="ga92d402821b887395f10cc0812fd236c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d402821b887395f10cc0812fd236c7">&#9670;&nbsp;</a></span>insertBlock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a>* regina::SatReflectorStrip::insertBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new reflector strip into the given triangulation, and returns the corresponding block structure. </p>
<p>The given triangulation will not be emptied before the new tetrahedra are inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation into which the new block should be inserted. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the new reflector strip, i.e., the number of boundary annuli; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new reflector strip should be twisted (causing its ring of boundary annuli to be twisted also), or <code>false</code> if the new strip should not be twisted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structural details of the newly inserted block. </dd></dl>

</div>
</div>
<a id="gae2aea7f8ba81fb76dd3e4c9ed264dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2aea7f8ba81fb76dd3e4c9ed264dee5">&#9670;&nbsp;</a></span>interiorVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::L31Pillow::interiorVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichTet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the vertex number of the given tetrahedron corresponding to the degree three vertex in the interior of the triangular pillow. </p>
<p>See the general class notes for further details.</p>
<p>The specific tetrahedron to examine is determined by the argument <em>whichTet</em>; this will be the tetrahedron <code>tetrahedron(whichTet)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichTet</td><td>specifies which tetrahedron to examine; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex of tetrahedron <em>whichTet</em> corresponding to the vertex in the interior of the triangular pillow; this will be between 0 and 3 inclusive. </dd></dl>

</div>
</div>
<a id="ga30cebd232bb0c1b83011051a869e8406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30cebd232bb0c1b83011051a869e8406">&#9670;&nbsp;</a></span>internalEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SnappedBall::internalEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge internal to this snapped ball. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding edge number in the tetrahedron. </dd></dl>

</div>
</div>
<a id="gaf016c5430a4f92c7ed3699a43ee6fae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf016c5430a4f92c7ed3699a43ee6fae1">&#9670;&nbsp;</a></span>internalFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SnappedBall::internalFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedron faces internal to this snapped ball. </p>
<p>You are guaranteed that index 0 will return a smaller face number than index 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two internal faces to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face number in the tetrahedron. </dd></dl>

</div>
</div>
<a id="ga9d9b727fc646ae10eeb1cab0c1bf9f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9b727fc646ae10eeb1cab0c1bf9f1a">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredChain::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts this layered chain so the upper hinge becomes the lower and vice versa. </p>
<p>The top and bottom tetrahedra will remain the top and bottom tetrahedra respectively.</p>
<p>Note that this operation will cause the hinge edges to point in the opposite direction around the solid torus formed by this layered chain.</p>
<p>Note that only the representation of the chain is altered; the underlying triangulation is not changed. </p>

</div>
</div>
<a id="gab18b751a2ac184f75c42ee18d6cde745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18b751a2ac184f75c42ee18d6cde745">&#9670;&nbsp;</a></span>isAdjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isAdjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>refVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>refHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal reflections. </p>
<p>That is, this routine determines whether this and the given structure represent opposite sides of the same saturated annulus, where the fibres for both structures are consistent (though possibly reversed). See <a class="el" href="group__subcomplex.html#ga3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for details on what "opposite sides" means in this context, and see <a class="el" href="group__subcomplex.html#ga8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and <a class="el" href="group__subcomplex.html#ga53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a> for descriptions of the various types of reflection.</p>
<p>Information regarding reflections is returned via the two boolean pointers <em>refVert</em> and <em>refHoriz</em>. If the two annuli are identically opposite each other as described by <a class="el" href="group__subcomplex.html#ga3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a>, both booleans will be set to <code>false</code>. If the two annuli are identically opposite after one undergoes a vertical and/or horizontal reflection, then the booleans <em>refVert</em> and/or <em>refHoriz</em> will be set to <code>true</code> accordingly.</p>
<p>The critical difference between this routine and <a class="el" href="group__subcomplex.html#gab166da7e172160fef0a9f818823a2c4d" title="Determines whether this and the given annulus are joined in some form, even if the fibres on each ann...">isJoined()</a> is that this routine insists that the fibres on each annulus be consistent. This routine is thus suitable for examining joins between different sections of the same Seifert fibred space, for example.</p>
<dl class="section user"><dt>Python</dt><dd>This routine only takes a single argument (the annulus <em>other</em>). The return value is a tuple of three booleans: the usual return value, the value returned in <em>refVert</em>, and the value returned in <em>refHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
    <tr><td class="paramname">refVert</td><td>returns information on whether the annuli are adjacent modulo a vertical reflection. This is set to <code>true</code> if a vertical reflection is required and <code>false</code> if it is not. If no adjacency was found at all, this boolean is not touched. A null pointer may be passed, in which case this information will not be returned at all. </td></tr>
    <tr><td class="paramname">refHoriz</td><td>returns information on whether the annuli are adjacent modulo a horizontal reflection. This is set to <code>true</code> if a horizontal reflection is required and <code>false</code> if it is not. If no adjacency was found at all, this boolean is not touched. A null pointer may be passed, in which case this information will not be returned at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if some adjacency was found (either with or without reflections), or <code>false</code> if no adjacency was found at all. </dd></dl>

</div>
</div>
<a id="ga6ad5bd5c7d85cb3b617d5a8c3572d1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad5bd5c7d85cb3b617d5a8c3572d1a5">&#9670;&nbsp;</a></span>isAnnulusSelfIdentified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TriSolidTorus::isAnnulusSelfIdentified </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>roleMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the two triangles of the requested annulus are glued to each other. </p>
<p>If the two triangles are glued, parameter <em>roleMap</em> will be modified to return a permutation describing how the vertex roles are glued to each other. This will describe directly how axis edges, major edges and minor edges map to each other without having to worry about the specific assignment of tetrahedron vertex numbers. For a discussion of vertex roles, see <a class="el" href="group__subcomplex.html#ga7a73c2957fd960d42c0b493726f7f994" title="Returns a permutation represeting the role that each vertex of the requested tetrahedron plays in the...">vertexRoles()</a>.</p>
<p>Note that annulus <code>index</code> uses faces from tetrahedra <code>index+1</code> and <code>index+2</code>. The gluing permutation that maps vertices of tetrahedron <code>index+1</code> to vertices of tetrahedron <code>index+2</code> will be <code>vertexRoles(index+2) * roleMap * vertexRoles(index+1).inverse()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which annulus on the solid torus boundary to examine; this must be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">roleMap</td><td>a pointer to a permutation that, if this routine returns <code>true</code>, will be modified to describe the gluing of vertex roles. This parameter may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangles of the requested annulus are glued together. </dd></dl>

</div>
</div>
<a id="ga36d65869bc7a3bad2123ec14c724a357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d65869bc7a3bad2123ec14c724a357">&#9670;&nbsp;</a></span>isAugTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AugTriSolidTorus.html">AugTriSolidTorus</a>* regina::AugTriSolidTorus::isAugTriSolidTorus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is an augmented triangular solid torus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the augmented triangular solid torus, or <code>null</code> if the given component is not an augmented triangular solid torus. </dd></dl>

</div>
</div>
<a id="ga256141cc960c800628d726ec268ebfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256141cc960c800628d726ec268ebfd0">&#9670;&nbsp;</a></span>isBad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const List &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. It is a generic routine for working with arbitrary list types.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Forward iterators of type <code>List::const_iterator</code> that span the given list can be obtained by calling <code>list.begin()</code> and <code>list.end()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="gab1705b0b0d6a48822121a699d8e0ffb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1705b0b0d6a48822121a699d8e0ffb9">&#9670;&nbsp;</a></span>isBad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::SatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a id="ga24eeb48f535c22b24dc25699981e38d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24eeb48f535c22b24dc25699981e38d4">&#9670;&nbsp;</a></span>isBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>* regina::SatBlock::isBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block. </p>
<p>The annulus should be represented from the inside of the proposed saturated block.</p>
<p>Only certain types of saturated block are recognised by this routine. More exotic saturated blocks will not be identified, and this routine will return <code>null</code> in such cases.</p>
<p>The given list of tetrahedra will not be examined by this routine. That is, only saturated blocks that do not contain any of these tetrahedra will be considered. As a consequence, if the given annulus uses any of these tetrahedra then <code>null</code> will be returned.</p>
<p>If a block is found on the other hand, all of the tetrahedra within this block will be added to the given list.</p>
<p>In the event that a block is found, it is guaranteed that the given annulus will be listed as annulus number 0 in the block structure, without any horizontal or vertical reflection.</p>
<dl class="section user"><dt>Python</dt><dd>The second argument <em>avoidTets</em> is not present. An empty list will be passed instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga8d6fb4982be0f7854335dda6b9e75ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6fb4982be0f7854335dda6b9e75ce6">&#9670;&nbsp;</a></span>isBlockCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatCube.html">SatCube</a>* regina::SatCube::isBlockCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (cube). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga20c43d8cbb034623e886011cad85520c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20c43d8cbb034623e886011cad85520c">&#9670;&nbsp;</a></span>isBlockedSFS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1BlockedSFS.html">BlockedSFS</a>* regina::BlockedSFS::isBlockedSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a blocked Seifert fibred space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the blocked Seifert fibred space, or <code>null</code> if the given triangulation is not a blocked Seifert fibred space. </dd></dl>

</div>
</div>
<a id="ga1896c923afd5b415b7667fbb7b733ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1896c923afd5b415b7667fbb7b733ce2">&#9670;&nbsp;</a></span>isBlockedSFSLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1BlockedSFSLoop.html">BlockedSFSLoop</a>* regina::BlockedSFSLoop::isBlockedSFSLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a blocked Seifert fibred space with identified boundaries, as described by this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the blocked self-identified Seifert fibred space, or <code>null</code> if the given triangulation is not of this form. </dd></dl>

</div>
</div>
<a id="ga16f31f0afd954c6a3ec73dd9c421c7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f31f0afd954c6a3ec73dd9c421c7b5">&#9670;&nbsp;</a></span>isBlockedSFSPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1BlockedSFSPair.html">BlockedSFSPair</a>* regina::BlockedSFSPair::isBlockedSFSPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a blocked pair of Seifert fibred spaces, as described by this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the blocked pair, or <code>null</code> if the given triangulation is not of this form. </dd></dl>

</div>
</div>
<a id="ga0405ab30711d5dcf81cee91157ebce92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0405ab30711d5dcf81cee91157ebce92">&#9670;&nbsp;</a></span>isBlockedSFSTriple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1BlockedSFSTriple.html">BlockedSFSTriple</a>* regina::BlockedSFSTriple::isBlockedSFSTriple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a blocked sequence of three Seifert fibred spaces, as described in the class notes above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the blocked triple, or <code>null</code> if the given triangulation is not of this form. </dd></dl>

</div>
</div>
<a id="ga8acdf15bb66805a4252669d00c21b12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8acdf15bb66805a4252669d00c21b12e">&#9670;&nbsp;</a></span>isBlockLayering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a>* regina::SatLayering::isBlockLayering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (single layering). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga3607a9b334b63c9801dc21e48c4aa2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3607a9b334b63c9801dc21e48c4aa2a8">&#9670;&nbsp;</a></span>isBlockLST()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatLST.html">SatLST</a>* regina::SatLST::isBlockLST </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (layered solid torus). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga8f3293151da99685206c9f487e538415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f3293151da99685206c9f487e538415">&#9670;&nbsp;</a></span>isBlockMobius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a>* regina::SatMobius::isBlockMobius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (Mobius band). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga420ee40707aea3e946614ef3947d72b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420ee40707aea3e946614ef3947d72b9">&#9670;&nbsp;</a></span>isBlockReflectorStrip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a>* regina::SatReflectorStrip::isBlockReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (reflector strip). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="gadd63e3437f4ff479e36494fa15aedb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd63e3437f4ff479e36494fa15aedb0d">&#9670;&nbsp;</a></span>isBlockTriPrism()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a>* regina::SatTriPrism::isBlockTriPrism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (triangular prism). </p>
<p>This routine is a specific case of <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a id="ga267a2decfeb911ff176bb19aa19f2fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267a2decfeb911ff176bb19aa19f2fe0">&#9670;&nbsp;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SpiralSolidTorus::isCanonical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this spiralled solid torus is in canonical form. </p>
<p>Canonical form is described in detail in the description for <a class="el" href="group__subcomplex.html#ga8837a636d54f38151e0d793fd5e04f00" title="Converts this spiralled solid torus into its canonical representation.">makeCanonical()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which this solid torus lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this spiralled solid torus is in canonical form. </dd></dl>

</div>
</div>
<a id="gab166da7e172160fef0a9f818823a2c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab166da7e172160fef0a9f818823a2c4d">&#9670;&nbsp;</a></span>isJoined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isJoined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>matching</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given annulus are joined in some form, even if the fibres on each annulus are not consistent. </p>
<p>This routine treats each annulus as though its boundaries are identified to form a torus (though it does not actually test whether this is true). It then examines whether this and the given annulus represent opposite sides of the same torus. More specifically, it tests whether both annuli are formed from the same pair of triangles, and whether the mapping of 0/1/2 markings from one annulus to the other is the same for each triangle. Note that the triangles are allowed to be switched (i.e., the first triangle of one annulus may be the second triangle of the other).</p>
<p>The critical difference between this routine and <a class="el" href="group__subcomplex.html#gab18b751a2ac184f75c42ee18d6cde745" title="Determines whether this and the given annulus are adjacent, possibly modulo vertical or horizontal re...">isAdjacent()</a> is that this routine allows the fibres on each annulus to be inconsistent. This routine is thus suitable for examining joins between different Seifert fibred blocks in a graph manifold, for example.</p>
<p>If the two annuli are joined, the precise relationship between the curves on each annulus will be returned in the matrix <em>matching</em>. Specifically, let <em>x</em> and <em>y</em> be the oriented curves running from markings 0-1 and 0-2 respectively on the first triangle of this annulus. Likewise, let <em>x'</em> and <em>y'</em> run from markings 0-1 and 0-2 respectively on the first triangle of the annulus <em>other</em>. Then the joining between the two annuli can be expressed as follows:</p>
<pre>
    [x ]                [x']
    [  ]  =  matching * [  ].
    [y ]                [y']
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the annulus to compare with this. </td></tr>
    <tr><td class="paramname">matching</td><td>returns details on how the curves on each annulus are related. If the this and the given annulus are not joined, then this matrix is not touched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given annulus are found to be joined, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="ga046d6f000ee834ef3093443b91a954be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046d6f000ee834ef3093443b91a954be">&#9670;&nbsp;</a></span>isL31Pillow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1L31Pillow.html">L31Pillow</a>* regina::L31Pillow::isL31Pillow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is a triangular pillow L(3,1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the triangular pillow L(3,1), or <code>null</code> if the given component is not a triangular pillow L(3,1). </dd></dl>

</div>
</div>
<a id="gaccec6e8eca529ae81cda400e014823d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccec6e8eca529ae81cda400e014823d1">&#9670;&nbsp;</a></span>isLayeredChainPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredChainPair.html">LayeredChainPair</a>* regina::LayeredChainPair::isLayeredChainPair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is a layered chain pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered chain pair, or <code>null</code> if the given component is not a layered chain pair. </dd></dl>

</div>
</div>
<a id="ga10c0886d3844794432f2fe3305c6d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10c0886d3844794432f2fe3305c6d062">&#9670;&nbsp;</a></span>isLayeredLensSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredLensSpace.html">LayeredLensSpace</a>* regina::LayeredLensSpace::isLayeredLensSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is a layered lens space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered lens space, or <code>null</code> if the given component is not a layered lens space. </dd></dl>

</div>
</div>
<a id="ga02fd4f302e6956248be614064c37c182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02fd4f302e6956248be614064c37c182">&#9670;&nbsp;</a></span>isLayeredLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredLoop.html">LayeredLoop</a>* regina::LayeredLoop::isLayeredLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is a layered loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered loop, or <code>null</code> if the given component is not a layered loop. </dd></dl>

</div>
</div>
<a id="ga80c732226884181905286eba38ab4817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c732226884181905286eba38ab4817">&#9670;&nbsp;</a></span>isLayeredSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a>* regina::LayeredSolidTorus::isLayeredSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component forms a layered solid torus in its entirity. </p>
<p>Note that, unlike <a class="el" href="group__subcomplex.html#ga34a35647727585b3f7b7966cb0306205" title="Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation.">formsLayeredSolidTorusBase()</a>, this routine tests for a component that is a layered solid torus with no additional tetrahedra or gluings. That is, the two boundary triangles of the layered solid torus must in fact be boundary triangles of the component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered solid torus, or <code>null</code> if the given component is not a layered solid torus. </dd></dl>

</div>
</div>
<a id="ga8cca6c475d77e161fcd280d0a13da420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cca6c475d77e161fcd280d0a13da420">&#9670;&nbsp;</a></span>isLayeredTorusBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1LayeredTorusBundle.html">LayeredTorusBundle</a>* regina::LayeredTorusBundle::isLayeredTorusBundle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a layered surface bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the layered surface bundle, or <code>null</code> if the given triangulation is not a layered surface bundle. </dd></dl>

</div>
</div>
<a id="ga9c139ffaa27cd2ec950ec6df4f2a0dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c139ffaa27cd2ec950ec6df4f2a0dab">&#9670;&nbsp;</a></span>isMajor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatTriPrism::isMajor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this prism of major type or minor type? See the class notes for further details. </p>
<p>Note that this routine cannot be called major(), since on some compilers that name clashes with a macro for isolating major/minor bytes.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this prism is of major type, or <code>false</code> if it is of minor type. </dd></dl>

</div>
</div>
<a id="gaa67b119a4c528622846ffc50270cbfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa67b119a4c528622846ffc50270cbfea">&#9670;&nbsp;</a></span>isPluggedIBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::BlockedSFS::isPluggedIBundle </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this triangulation is a plugged thin I-bundle or a plugged thick I-bundle. </p>
<p>These structures are described in "Structures of small closed non-orientable
3-manifold triangulations", Benjamin A. Burton, J. Knot Theory Ramifications 16 (2007), 545&ndash;574.</p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>name</em> is not present. Instead, this routine returns a tuple of size two: the boolean usually returned from this function, and the string usually returned in the argument <em>name</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>used to return the name of the plugged thin/thick I-bundle, if the triangulation is of this form. If the triangulation is not of this form, this string is not touched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this triangulation is indeed a plugged thin I-bundle or a plugged thick I-bundle. </dd></dl>

</div>
</div>
<a id="ga813230a5189e44593250f80d4ba333c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813230a5189e44593250f80d4ba333c0">&#9670;&nbsp;</a></span>isPluggedTorusBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1PluggedTorusBundle.html">PluggedTorusBundle</a>* regina::PluggedTorusBundle::isPluggedTorusBundle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation is a saturated region joined to a thin I-bundle via optional layerings, as described in the class notes above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created object containing details of the structure that was found, or <code>null</code> if the given triangulation is not of the form described by this class. </dd></dl>

</div>
</div>
<a id="ga2324ae3d08a9c0e00e1b6f521b335dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2324ae3d08a9c0e00e1b6f521b335dc9">&#9670;&nbsp;</a></span>isPlugTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1PlugTriSolidTorus.html">PlugTriSolidTorus</a>* regina::PlugTriSolidTorus::isPlugTriSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is a plugged triangular solid torus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure containing details of the plugged triangular solid torus, or <code>null</code> if the given component is not a plugged triangular solid torus. </dd></dl>

</div>
</div>
<a id="ga51c5f53e8a166590e1cc6db486a7e075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c5f53e8a166590e1cc6db486a7e075">&#9670;&nbsp;</a></span>isSmallSnapPeaCensusTri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a>* regina::SnapPeaCensusTri::isSmallSnapPeaCensusTri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is one of the smallest SnapPea census triangulations. </p>
<p>This routine is able to recognise a small selection of triangulations from the beginning of the SnapPea census, by way of hard-coding their structures and properties. Most triangulations from the census however will not be recognised by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure representing the small SnapPea census triangulation, or <code>null</code> if the given component is not one of the few SnapPea census triangulations recognised by this routine. </dd></dl>

</div>
</div>
<a id="gaaad921715bbfd71029a4cbf9c76ba262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad921715bbfd71029a4cbf9c76ba262">&#9670;&nbsp;</a></span>isSnapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredLensSpace::isSnapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the layered solid torus that forms the basis for this lens space is snapped shut (folded closed without a twist). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the torus is snapped shut. </dd></dl>

</div>
</div>
<a id="ga1c589e3471255c2cf81a9da2ab6e214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c589e3471255c2cf81a9da2ab6e214a">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a>* regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given component represents one of the standard triangulations understood by Regina. </p>
<p>The list of recognised triangulations is expected to grow between releases.</p>
<p>If the standard triangulation returned has boundary triangles then the given component must have the same corresponding boundary triangles, i.e., the component cannot have any further identifications of these boundary triangles with each other.</p>
<p>Note that the triangulation-based routine <a class="el" href="group__subcomplex.html#ga08e665c2d5ba2cb29947962c2e176bfd" title="Determines whether the given triangulation represents one of the standard triangulations understood b...">isStandardTriangulation(Triangulation&lt;3&gt;*)</a> may recognise more triangulations than this routine, since passing an entire triangulation allows access to more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>the triangulation component under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the details of the standard triangulation if the given component is recognised, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga08e665c2d5ba2cb29947962c2e176bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e665c2d5ba2cb29947962c2e176bfd">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a>* regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given triangulation represents one of the standard triangulations understood by Regina. </p>
<p>The list of recognised triangulations is expected to grow between releases.</p>
<p>If the standard triangulation returned has boundary triangles then the given triangulation must have the same corresponding boundary triangles, i.e., the triangulation cannot have any further identifications of these boundary triangles with each other.</p>
<p>This routine may recognise more triangulations than the component-based <a class="el" href="group__subcomplex.html#ga1c589e3471255c2cf81a9da2ab6e214a" title="Determines whether the given component represents one of the standard triangulations understood by Re...">isStandardTriangulation(Component&lt;3&gt;*)</a>, since passing an entire triangulation allows access to more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the details of the standard triangualation if the given triangulation is recognised, or 0 otherwise. </dd></dl>

</div>
</div>
<a id="gaf190c12434f07e0f4807922ce4cd0b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf190c12434f07e0f4807922ce4cd0b37">&#9670;&nbsp;</a></span>isTrivialTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TrivialTri.html">TrivialTri</a>* regina::TrivialTri::isTrivialTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component is one of the trivial triangulations recognised by this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created structure representing the trivial triangulation, or <code>null</code> if the given component is not one of the triangulations recognised by this class. </dd></dl>

</div>
</div>
<a id="gafa3f7665028d10ea46d5319cbb1a74da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa3f7665028d10ea46d5319cbb1a74da">&#9670;&nbsp;</a></span>isTwisted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredLensSpace::isTwisted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the layered solid torus that forms the basis for this lens space is twisted shut (folded closed with a twist). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the torus is twisted shut. </dd></dl>

</div>
</div>
<a id="ga158132bf103660b079000084423e54c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga158132bf103660b079000084423e54c6">&#9670;&nbsp;</a></span>isTwisted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredLoop::isTwisted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this layered loop contains a twist. </p>
<p>See the general class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this layered loop contains a twist. </dd></dl>

</div>
</div>
<a id="gab92bb7286c0fb03b929257a7bc4888f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92bb7286c0fb03b929257a7bc4888f1">&#9670;&nbsp;</a></span>isTwoSidedTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::isTwoSidedTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this annulus has its boundaries identified to form an embedded two-sided torus within the surrounding triangulation. </p>
<p>It will be verified that:</p><ul>
<li>the two triangles of this annulus are joined along all three pairs of edges to form a torus;</li>
<li>the three edges of this torus remain distinct (i.e., different edges of the torus do not become identified within the larger triangulation);</li>
<li>this torus is two-sided within the surrounding triangulation.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this annulus forms an embedded two-sided torus as described above, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="gabc94fa314e6f5be566c2a83876a9f94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc94fa314e6f5be566c2a83876a9f94e">&#9670;&nbsp;</a></span>k()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TxIDiagonalCore::k </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the additional parameter <em>k</em> as described in the class notes. </p>
<dl class="section return"><dt>Returns</dt><dd>the additional parameter <em>k</em>. </dd></dl>

</div>
</div>
<a id="ga36031be7947e57d48376bc1728b9a0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36031be7947e57d48376bc1728b9a0b5">&#9670;&nbsp;</a></span>LayeredChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredChain::LayeredChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LayeredChain.html">LayeredChain</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new layered chain that is a clone of the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the layered chain to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5449fe384c23e2b570fa76000b25bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5449fe384c23e2b570fa76000b25bbe4">&#9670;&nbsp;</a></span>LayeredChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredChain::LayeredChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>vertexRoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new layered chain containing only the given tetrahedron. </p>
<p>This new layered chain will have index 1, but may be extended using <a class="el" href="group__subcomplex.html#gaf39b2d736d35ab0be374d191a68f1951" title="Checks to see whether this layered chain can be extended to include the tetrahedron above the top tet...">extendAbove()</a>, <a class="el" href="group__subcomplex.html#ga5977fb7fe0cabde3a8712327b7434ba0" title="Checks to see whether this layered chain can be extended to include the tetrahedron below the bottom ...">extendBelow()</a> or <a class="el" href="group__subcomplex.html#gabed0c53621cb17684707a65e59229771" title="Extends this layered chain to a maximal length layered chain.">extendMaximal()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron that will make up this layered chain. </td></tr>
    <tr><td class="paramname">vertexRoles</td><td>a permutation describing the role each tetrahedron vertex must play in the layered chain; this must be in the same format as the permutation returned by <a class="el" href="group__subcomplex.html#ga63c20b1c4b1ab485ba73af93e5f4fa09" title="Returns a permutation represeting the role that each vertex of the bottom tetrahedron plays in the la...">bottomVertexRoles()</a> and <a class="el" href="group__subcomplex.html#ga7604b4366f6cecd2df0bcf81d67852fe" title="Returns a permutation represeting the role that each vertex of the top tetrahedron plays in the layer...">topVertexRoles()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac7f0bc2712667f34a4b59f830dc2b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac7f0bc2712667f34a4b59f830dc2b60">&#9670;&nbsp;</a></span>Layering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Layering::Layering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bdry0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>roles0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bdry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>roles1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new trivial (zero-tetrahedron) layering upon the given boundary. </p>
<p>The boundary is described by two tetrahedra and two permutations as explained in the class notes. Note that the given tetrahedra need not be boundary triangles in the triangulation (and if search routines such as <a class="el" href="group__subcomplex.html#gaa48e1aabed68a1a39cd69a5c016533d9" title="Examines whether one or more additional tetrahedra have been layered upon the current new boundary.">extend()</a> are called then they almost certainly should not be).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdry0</td><td>the tetrahedron providing the first triangle of the boundary. </td></tr>
    <tr><td class="paramname">roles0</td><td>the permutation describing how this first triangle is formed from three vertices of tetrahedron <em>bdry0</em>, as described in the class notes. </td></tr>
    <tr><td class="paramname">bdry1</td><td>the tetrahedron providing the second triangle of the boundary. </td></tr>
    <tr><td class="paramname">roles1</td><td>the permutation describing how this second triangle is formed from three vertices of tetrahedron <em>bdry1</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga100043ce6619933fce5a17e15c2dfbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga100043ce6619933fce5a17e15c2dfbef">&#9670;&nbsp;</a></span>layeringReln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::LayeredTorusBundle::layeringReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing how the layering of tetrahedra relates curves on the two torus boundaries of the core <code>T x I</code>. </p>
<p>The <a class="el" href="classregina_1_1TxICore.html" title="Provides a triangulation of the product T x I (the product of the torus and the interval).">TxICore</a> class documentation describes generating <em>alpha</em> and <em>beta</em> curves on the two torus boundaries of the core <code>T x I</code> (which are referred to as the <em>upper</em> and <em>lower</em> boundaries). The two boundary tori are parallel in two directions: through the core, and through the layering. It is desirable to know the parallel relationship between the two sets of boundary curves in each direction.</p>
<p>The relationship through the core is already described by <a class="el" href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66" title="Returns a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary cur...">TxICore::parallelReln()</a>. This routine describes the relationship through the layering.</p>
<p>Let <em>a_u</em> and <em>b_u</em> be the <em>alpha</em> and <em>beta</em> curves on the upper boundary torus, and let <em>a_l</em> and <em>b_l</em> be the <em>alpha</em> and <em>beta</em> curves on the lower boundary torus. Suppose that the upper <em>alpha</em> is parallel to <em>w</em>.<em>a_l</em> + <em>x</em>.<em>b_l</em>, and that the upper <em>beta</em> is parallel to <em>y</em>.<em>a_l</em> + <em>z</em>.<em>b_l</em>. Then the matrix returned will be</p>
<pre>
    [ w  x ]
    [      ] .
    [ y  z ]
</pre><p>In other words,</p>
<pre>
    [ a_u ]                      [ a_l ]
    [     ]  =  <a class="el" href="group__subcomplex.html#ga100043ce6619933fce5a17e15c2dfbef" title="Returns a 2-by-2 matrix describing how the layering of tetrahedra relates curves on the two torus bou...">layeringReln()</a> * [     ] .
    [ b_u ]                      [ b_l ]
</pre><p>It can be observed that this matrix expresses the upper boundary curves in terms of the lower, whereas <a class="el" href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66" title="Returns a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary cur...">TxICore::parallelReln()</a> expresses the lower boundary curves in terms of the upper. This means that the monodromy describing the overall torus bundle over the circle can be calculated as </p><pre>
    M  =  <a class="el" href="group__subcomplex.html#ga100043ce6619933fce5a17e15c2dfbef" title="Returns a 2-by-2 matrix describing how the layering of tetrahedra relates curves on the two torus bou...">layeringReln()</a> * <a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">core()</a>.parallelReln()
</pre><p> or alternatively using the similar matrix </p><pre>
    M'  =  <a class="el" href="group__subcomplex.html#gad714490fe0e05e211c3e72b968f679c1" title="Returns the T x I triangulation at the core of this layered surface bundle.">core()</a>.parallelReln() * <a class="el" href="group__subcomplex.html#ga100043ce6619933fce5a17e15c2dfbef" title="Returns a 2-by-2 matrix describing how the layering of tetrahedra relates curves on the two torus bou...">layeringReln()</a> .
</pre><p>Note that in the degenerate case where there is no layering at all, this matrix is still perfectly well defined; in this case it describes a direct identification between the upper and lower boundary tori.</p>
<dl class="section return"><dt>Returns</dt><dd>the relationship through the layering between the upper and lower boundary curves of the core <code>T x I</code>. </dd></dl>

</div>
</div>
<a id="gad5f45c7012d837efbd29b227795a27e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f45c7012d837efbd29b227795a27e8">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredLoop::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of this layered loop. </p>
<p>See the general class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of this layered loop. </dd></dl>

</div>
</div>
<a id="gab930708bfe45d0c6b107477d3e90370b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab930708bfe45d0c6b107477d3e90370b">&#9670;&nbsp;</a></span>lst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> * regina::SatLST::lst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the layered solid torus that this block represents. </p>
<dl class="section return"><dt>Returns</dt><dd>details of the layered solid torus. </dd></dl>

</div>
</div>
<a id="ga8837a636d54f38151e0d793fd5e04f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8837a636d54f38151e0d793fd5e04f00">&#9670;&nbsp;</a></span>makeCanonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SpiralSolidTorus::makeCanonical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this spiralled solid torus into its canonical representation. </p>
<p>The canonical representation of a spiralled solid torus is unique in a given triangulation.</p>
<p>Tetrahedron 0 in the spiralled solid torus will be the tetrahedron with the lowest index in the triangulation, and under permutation <code>vertexRoles(0)</code> the image of 0 will be less than the image of 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which this solid torus lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the representation of this spiralled solid torus was actually changed. </dd></dl>

</div>
</div>
<a id="gac50ffb2c3d335dad75a45f1f8c4d9a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50ffb2c3d335dad75a45f1f8c4d9a4e">&#9670;&nbsp;</a></span>manifold() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a> * regina::StandardTriangulation::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented in <a class="el" href="group__subcomplex.html#ga9736cda87b31806f62187a9bbc2017fa">regina::TrivialTri</a>, <a class="el" href="group__subcomplex.html#gac3acbf6ce44a7908fe2c00e706c59ba0">regina::TriSolidTorus</a>, <a class="el" href="group__subcomplex.html#gab0f35ec11ed58654c673972ae683072c">regina::SpiralSolidTorus</a>, <a class="el" href="group__subcomplex.html#gaaefad8c7de255a9bf0854e00faf79c06">regina::SnappedBall</a>, <a class="el" href="group__subcomplex.html#ga29db744b46a69f7518e60b75d4d66f25">regina::SnapPeaCensusTri</a>, <a class="el" href="group__subcomplex.html#ga42a698d8b6a5e6d422d8c0762e532e29">regina::PlugTriSolidTorus</a>, <a class="el" href="group__subcomplex.html#gaddd42ca7b753e17f010cc763bf410521">regina::PluggedTorusBundle</a>, <a class="el" href="group__subcomplex.html#gaaeaf5e9116be3125f8bef1fa36b6c5d2">regina::LayeredTorusBundle</a>, <a class="el" href="group__subcomplex.html#gada5567379e82bc16c285e8e2d332a404">regina::LayeredSolidTorus</a>, <a class="el" href="group__subcomplex.html#gaadd1a02ce36d5400809d861c87a91558">regina::LayeredLoop</a>, <a class="el" href="group__subcomplex.html#gace21293e5bd3bc8eeffef8f53748b294">regina::LayeredLensSpace</a>, <a class="el" href="group__subcomplex.html#ga76605d4e5441075637634e6204f8e0a1">regina::LayeredChainPair</a>, <a class="el" href="group__subcomplex.html#gac7c63608de42c66a9b33385a30e911b8">regina::LayeredChain</a>, <a class="el" href="group__subcomplex.html#gaa3f6501798e8c61766612e83153eddb4">regina::L31Pillow</a>, <a class="el" href="group__subcomplex.html#ga1b816d801e761d91593aa46733f33b6d">regina::BlockedSFSTriple</a>, <a class="el" href="group__subcomplex.html#gac7cac0e968863ec7fff63d6475f1e8ae">regina::BlockedSFSPair</a>, <a class="el" href="group__subcomplex.html#gab3b581576665e5909a2fbb75f8c9611c">regina::BlockedSFSLoop</a>, <a class="el" href="group__subcomplex.html#ga9e8a8201cecd98cc61c4f4023a3df03b">regina::BlockedSFS</a>, and <a class="el" href="group__subcomplex.html#gadeb28c773dc5aad2dd02cd7267372c7b">regina::AugTriSolidTorus</a>.</p>

</div>
</div>
<a id="gadeb28c773dc5aad2dd02cd7267372c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb28c773dc5aad2dd02cd7267372c7b">&#9670;&nbsp;</a></span>manifold() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::AugTriSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga9e8a8201cecd98cc61c4f4023a3df03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8a8201cecd98cc61c4f4023a3df03b">&#9670;&nbsp;</a></span>manifold() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::BlockedSFS::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gab3b581576665e5909a2fbb75f8c9611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b581576665e5909a2fbb75f8c9611c">&#9670;&nbsp;</a></span>manifold() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::BlockedSFSLoop::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gac7cac0e968863ec7fff63d6475f1e8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7cac0e968863ec7fff63d6475f1e8ae">&#9670;&nbsp;</a></span>manifold() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::BlockedSFSPair::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga1b816d801e761d91593aa46733f33b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b816d801e761d91593aa46733f33b6d">&#9670;&nbsp;</a></span>manifold() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::BlockedSFSTriple::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaa3f6501798e8c61766612e83153eddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f6501798e8c61766612e83153eddb4">&#9670;&nbsp;</a></span>manifold() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::L31Pillow::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gac7c63608de42c66a9b33385a30e911b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c63608de42c66a9b33385a30e911b8">&#9670;&nbsp;</a></span>manifold() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredChain::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga76605d4e5441075637634e6204f8e0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76605d4e5441075637634e6204f8e0a1">&#9670;&nbsp;</a></span>manifold() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredChainPair::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gace21293e5bd3bc8eeffef8f53748b294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace21293e5bd3bc8eeffef8f53748b294">&#9670;&nbsp;</a></span>manifold() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredLensSpace::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaadd1a02ce36d5400809d861c87a91558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd1a02ce36d5400809d861c87a91558">&#9670;&nbsp;</a></span>manifold() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredLoop::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gada5567379e82bc16c285e8e2d332a404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5567379e82bc16c285e8e2d332a404">&#9670;&nbsp;</a></span>manifold() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaaeaf5e9116be3125f8bef1fa36b6c5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeaf5e9116be3125f8bef1fa36b6c5d2">&#9670;&nbsp;</a></span>manifold() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::LayeredTorusBundle::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaddd42ca7b753e17f010cc763bf410521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddd42ca7b753e17f010cc763bf410521">&#9670;&nbsp;</a></span>manifold() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::PluggedTorusBundle::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga42a698d8b6a5e6d422d8c0762e532e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a698d8b6a5e6d422d8c0762e532e29">&#9670;&nbsp;</a></span>manifold() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::PlugTriSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga29db744b46a69f7518e60b75d4d66f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29db744b46a69f7518e60b75d4d66f25">&#9670;&nbsp;</a></span>manifold() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::SnapPeaCensusTri::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaaefad8c7de255a9bf0854e00faf79c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaefad8c7de255a9bf0854e00faf79c06">&#9670;&nbsp;</a></span>manifold() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::SnappedBall::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gab0f35ec11ed58654c673972ae683072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f35ec11ed58654c673972ae683072c">&#9670;&nbsp;</a></span>manifold() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::SpiralSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gac3acbf6ce44a7908fe2c00e706c59ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3acbf6ce44a7908fe2c00e706c59ba0">&#9670;&nbsp;</a></span>manifold() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::TriSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga9736cda87b31806f62187a9bbc2017fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9736cda87b31806f62187a9bbc2017fa">&#9670;&nbsp;</a></span>manifold() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Manifold.html">Manifold</a>* regina::TrivialTri::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p>If the 3-manifold cannot be recognised then this routine will return 0.</p>
<p>The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns 0.</p>
<p>It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<p>The 3-manifold will be newly allocated and must be destroyed by the caller of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gac50ffb2c3d335dad75a45f1f8c4d9a4e">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gacbe01df349467b1d0752c80361c6e77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe01df349467b1d0752c80361c6e77c">&#9670;&nbsp;</a></span>matchesTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::matchesTop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>upperBdry0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>upperRoles0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>upperBdry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>upperRoles1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>upperReln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the new torus boundary of this structure is identified with the given torus boundary. </p>
<p>In other words, this routine determines whether the new torus boundary of this structure and the given torus boundary represent opposite sides of the same two triangles.</p>
<p>The two boundaries must be identified according to some homeomorphism of the torus. Note that there are 12 different ways in which this can be done (two choices for which tetrahedron face joins with which, and then six possible rotations and reflections).</p>
<p>As with the other routines in this class, this routine does not verify that either boundary in fact forms a torus. Instead, it uses this assumption to define the rules of what identifications are allowable.</p>
<p>If there is a match, the given matrix <em>upperReln</em> will be modified to describe how the edges of the given boundary relate to the edges of the old boundary torus. Note that this relationship depends on how the intermediate tetrahedra are layered (and in fact the purpose of a layering is often to produce such a non-trivial relationship).</p>
<p>Specifically, let <em>t0</em> and <em>p0</em> be the first tetrahedron and permutation of the old boundary (as returned by oldBoundaryTet(0) and oldBoundaryRoles(0)), and let <em>x</em> and <em>y</em> be the directed edges <em>p0</em>[0]-<em>p0</em>[1] and <em>p0</em>[0]-<em>p0</em>[2] of tetrahedron <em>t0</em> respectively (these are the leftmost and uppermost edges of the diagram below). Likewise, let <em>u</em> and <em>q</em> be the first tetrahedron and permutation of the given boundary (as passed by parameters <em>upperBdry0</em> and <em>upperRoles0</em>), and let <em>a</em> and <em>b</em> be the directed edges <em>q</em>[0]-<em>q</em>[1] and <em>q</em>[0]-<em>q</em>[2] of tetrahedron <em>u</em> respectively.</p>
<pre>
    *---&gt;&gt;--*
    |0  2 / |
    |    / 1|
    v   /   v
    |1 /    |
    | / 2  0|
    *---&gt;&gt;--*
</pre><p>Assuming both boundaries are tori, edges <em>x</em> and <em>y</em> are generators of the original torus boundary and edges <em>a</em> and <em>b</em> are generators of the given torus boundary. Using additive notation, the matrix <em>upperReln</em> is modified so that</p>
<pre>
    [a]                 [x]
    [ ]  =  upperReln * [ ] .
    [b]                 [y]
</pre><p>In other words, the modified <em>upperReln</em> matrix expresses the generator curves of the given boundary in terms of the generator curves of the old boundary.</p>
<p>If no match is found, the matrix <em>upperReln</em> is not touched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperBdry0</td><td>the tetrahedron providing the first triangle of the given boundary. </td></tr>
    <tr><td class="paramname">upperRoles0</td><td>the permutation describing how this first triangle is formed from three vertices of tetrahedron upperBdry0, as described in the class notes. </td></tr>
    <tr><td class="paramname">upperBdry1</td><td>the tetrahedron providing the second triangle of the given boundary. </td></tr>
    <tr><td class="paramname">upperRoles1</td><td>the permutation describing how this second triangle is formed from three vertices of tetrahedron upperBdry1. </td></tr>
    <tr><td class="paramname">upperReln</td><td>the matrix that is changed to reflect the relationship between the old boundary of this structure and the given boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary is found to matche the new boundary of this structure, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga700ac73cf8df31fafb66394a8a6468d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga700ac73cf8df31fafb66394a8a6468d9">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::BlockedSFSLoop::matchingReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two torus boundaries of the saturated region are joined. </p>
<p>Note that if a layering is placed between the two boundary tori, then any changes to the boundary relationships caused by the layering are included in this matrix.</p>
<p>See the class notes above for precise information on how this matrix is presented.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix describing how the boundaries of the region are joined. </dd></dl>

</div>
</div>
<a id="ga2f426a237c0308b53471c651d8102b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f426a237c0308b53471c651d8102b40">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::BlockedSFSPair::matchingReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two saturated region boundaries are joined. </p>
<p>Note that if a layering is placed between the two region boundaries, then any changes to the boundary relationships caused by the layering are included in this matrix.</p>
<p>See the class notes above for precise information on how this matrix is presented.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix describing how the region boundaries are joined. </dd></dl>

</div>
</div>
<a id="ga88ddf03fb89d727059cf9105f7022300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88ddf03fb89d727059cf9105f7022300">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::PluggedTorusBundle::matchingReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the two torus boundaries of the saturated region are joined by the thin I-bundle and layerings. </p>
<p>See the class notes above for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching relation between the two region boundaries. </dd></dl>

</div>
</div>
<a id="ga09cb3062e81744d647f61d33e105ca3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cb3062e81744d647f61d33e105ca3f">&#9670;&nbsp;</a></span>matchingReln() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::BlockedSFSTriple::matchingReln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the matrix describing how the given end region is joined to the central region. </p>
<p>Note that if a layering is placed between the two respective region boundaries, then any changes to the boundary relationships caused by the layering are included in this matrix.</p>
<p>See the class notes above for precise information on how each matrix is presented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>0 if the matrix returned should describe how the central region is joined to the first end region (marked end region 0 in the class notes), or 1 if the matrix returned should describe how the central region is joined to the second end region (marked end region 1 in the class notes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix describing how the requested region boundaries are joined. </dd></dl>

</div>
</div>
<a id="gaee8efd019dec98bc14e74e6290ce7d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8efd019dec98bc14e74e6290ce7d5f">&#9670;&nbsp;</a></span>meetsBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatAnnulus::meetsBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines how many triangles of this annulus lie on the boundary of the triangulation. </p>
<p>Note that this routine can also be used as a boolean function to determine whether any triangles of the annulus lie on the triangulation boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of triangles of this annulus that lie on the boundary of the triangulation; this will be 0, 1 or 2. </dd></dl>

</div>
</div>
<a id="ga1e3b241365315391145ebe5fb7f7ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e3b241365315391145ebe5fb7f7ad3c">&#9670;&nbsp;</a></span>meridinalCuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredSolidTorus::meridinalCuts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times the meridinal disc of the torus cuts the top level tetrahedron edges in the given group. </p>
<p>See <a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the given edge group; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times the meridinal disc cuts the edges in the given group. </dd></dl>

</div>
</div>
<a id="gab9d2e5fc3f15883cb14082366e55a570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9d2e5fc3f15883cb14082366e55a570">&#9670;&nbsp;</a></span>mobiusBoundaryGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredLensSpace::mobiusBoundaryGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which edge of the layered solid torus is glued to the boundary of the mobius strip (i.e., the weight 2 edge of the degenerate (2,1,1) layered solid torus). </p>
<p>The return value will be one of the three top level tetrahedron edge groups in the layered solid torus; see <a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">LayeredSolidTorus::topEdge()</a> for further details about edge groups.</p>
<dl class="section return"><dt>Returns</dt><dd>the top level edge group of the layered solid torus to which the mobius strip boundary is glued. </dd></dl>

</div>
</div>
<a id="ga62f318c415f2ec73916cc6c3aa669d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62f318c415f2ec73916cc6c3aa669d8a">&#9670;&nbsp;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation. </dd></dl>

</div>
</div>
<a id="ga11e0abc543b918e79d0d8a733e921c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e0abc543b918e79d0d8a733e921c96">&#9670;&nbsp;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TxICore::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation of <code>T x I</code> as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation. </dd></dl>

</div>
</div>
<a id="gab6315fa72abebfdd6c03f4ed5ea68bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6315fa72abebfdd6c03f4ed5ea68bab">&#9670;&nbsp;</a></span>nAnnuli()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::nAnnuli </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a id="gac4d707028b14c22101af674b7c599dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d707028b14c22101af674b7c599dd9">&#9670;&nbsp;</a></span>newBoundaryRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::Layering::newBoundaryRoles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutations that describe the new boundary triangles. </p>
<p>These refer to the final boundary after layerings have been performed.</p>
<p>See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which permutation to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested permutation describing the new boundary. </dd></dl>

</div>
</div>
<a id="gafe0fcd20ed86c84df7a654cd9cfce074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0fcd20ed86c84df7a654cd9cfce074">&#9670;&nbsp;</a></span>newBoundaryTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::Layering::newBoundaryTet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedra that provide the new boundary triangles. </p>
<p>These belong to the final boundary after layerings have been performed.</p>
<p>See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which tetrahedron to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron of the new boundary. </dd></dl>

</div>
</div>
<a id="ga3b5dfbf2105ead4220eee5c49e08ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5dfbf2105ead4220eee5c49e08ff1b">&#9670;&nbsp;</a></span>nextBoundaryAnnulus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::nextBoundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&amp;&#160;</td>
          <td class="paramname"><em>nextBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nextAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refHoriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>followPrev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region. </p>
<p>Suppose that all saturated blocks are merged together according to adjacent boundary annuli, forming larger saturated structures. The remaining annuli that do not have adjacent blocks will group together to form several large boundary rings. Note that each boundary ring might involve annuli from several different blocks, and might or might not have a twist (thus forming a large Klein bottle instead of a large torus).</p>
<p>This routine is used to trace around such a boundary ring. It is assumed that annulus <em>thisAnnulus</em> of this block forms part of a boundary ring (i.e., it has no adjacent block). This routine will then return the next/previous annulus around from this in the large boundary ring. Here "next" means in the direction following from the second triangle of this annulus, and "previous" means in the direction following from the first triangle; the boolean argument <em>followPrev</em> controls which we will be used. This next/previous annulus might belong to another block, or it might even be this original annulus again.</p>
<p>The next/previous annulus itself is not returned, but rather a reference as to how it appears within its enclosing saturated block. Specifically, a block and corresponding annulus number will be returned in the arguments <em>nextBlock</em> and <em>nextAnnulus</em> respectively.</p>
<p>It is possible that the next/previous annulus as it appears within the returned block is oriented differently from how it appears within this large boundary ring. For this reason, two booleans are returned also. The argument <em>refVert</em> will describe whether the annulus is reflected vertically as it appears within the large boundary ring (i.e., the first and second triangles remain the same but the fibre direction is reversed). Similarly, the argument <em>refHoriz</em> will describe whether the annulus is reflected horizontally as it appears within the large boundary ring (i.e., first and second triangles are switched but the fibre direction is unchanged).</p>
<p>It is possible that both a horizontal and vertical reflection take place. Note that any kind of reflection will also affect the locations of the 0/1/2 markings as described in the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes.</p>
<p>Finally, note that if the large boundary ring is twisted (i.e., it forms a Klein bottle), then following the entire boundary ring around using this routine will bring you back to the starting annulus but with the <em>refVert</em> flag set.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Annulus <em>thisAnnulus</em> of this block has no block adjacent to it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to trace around an entire boundary ring, you will need to adjust the argument <em>followPrev</em> according to whether or not the current annulus is reflected horizontally (since, under a horizontal reflection, "next" becomes "previous" and vice versa).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine only takes two arguments (<em>thisAnnulus</em> and <em>followPrev</em>). The return value is a tuple of four values: the block returned in <em>nextBlock</em>, the integer returned in <em>nextAnnulus</em>, the boolean returned in <em>refVert</em>, and the boolean returned in <em>refHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisAnnulus</td><td>describes which original boundary annulus of this block to examine; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">nextBlock</td><td>a reference used to return the block containing the next boundary annulus around from <em>thisAnnulus</em>. </td></tr>
    <tr><td class="paramname">nextAnnulus</td><td>a reference used to return the specific annulus number within <em>nextBlock</em> of the next annulus around; this will be between 0 and <em>nextBlock-&gt;<a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1</em> inclusive, and the corresponding annulus will have no block adjacent to it. </td></tr>
    <tr><td class="paramname">refVert</td><td>a reference used to return <code>true</code> if the next annulus around is vertically reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">refHoriz</td><td>a reference used to return <code>true</code> if the next annulus around is horizontally reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">followPrev</td><td><code>true</code> if we should find the previous boundary annulus, or <code>false</code> if we should find the next boundary annulus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5d32449ef8e48dcf87e24c10bef03f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d32449ef8e48dcf87e24c10bef03f2">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<p>The name <a class="el" href="group__subcomplex.html#gae5d32449ef8e48dcf87e24c10bef03f2" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> may seem strang for what is essentially a nullity test; in fact this routine is offered as a degenerate case of other variants of <a class="el" href="group__subcomplex.html#gae5d32449ef8e48dcf87e24c10bef03f2" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> that take more tetrahedra as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab4dd0f929b39e314a96e2c99c699ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4dd0f929b39e314a96e2c99c699ce85">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga45574f81ee799875b38ad24e3c87e777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45574f81ee799875b38ad24e3c87e777">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em> or <em>other2</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gacd16a7f145941c3270d2eb37b015e968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd16a7f145941c3270d2eb37b015e968">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em> or <em>other3</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga3b8d8b87118dd4442251a5a040612b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b8d8b87118dd4442251a5a040612b41">&#9670;&nbsp;</a></span>notUnique() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>other4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other4</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em>, <em>other3</em> or <em>other4</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gada2e43b86fa0d683fdfd5c4b03a023ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2e43b86fa0d683fdfd5c4b03a023ec">&#9670;&nbsp;</a></span>numberOfBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SatRegion::numberOfBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated blocks that come together to form this saturated region. </p>

</div>
</div>
<a id="ga0eab8ca2776c0047b5f25c2aad047ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eab8ca2776c0047b5f25c2aad047ad1">&#9670;&nbsp;</a></span>numberOfBoundaryAnnuli()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SatRegion::numberOfBoundaryAnnuli </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of saturated annuli that together form the boundary components of this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a id="ga5df4641fc7b186beed57c6d94a31675a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df4641fc7b186beed57c6d94a31675a">&#9670;&nbsp;</a></span>oldBoundaryRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::Layering::oldBoundaryRoles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutations that describe the old boundary triangles. </p>
<p>These refer to the original boundary before any layerings take place.</p>
<p>See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which permutation to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested permutation describing the old boundary. </dd></dl>

</div>
</div>
<a id="gad27c6b14e099411beda83a195c068ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad27c6b14e099411beda83a195c068ebc">&#9670;&nbsp;</a></span>oldBoundaryTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::Layering::oldBoundaryTet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedra that provide the old boundary triangles. </p>
<p>These belong to the original boundary before any layerings take place.</p>
<p>See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which tetrahedron to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron of the old boundary. </dd></dl>

</div>
</div>
<a id="ga3f9a3e17d58f8a53930d74b2511f64fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f9a3e17d58f8a53930d74b2511f64fd">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe the same annulus with the same representation. </p>
<p>This requires both structures to have identical <em>tet</em>[] and <em>roles</em>[] arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the structures do not describe the same annulus with the same representation, or <code>false</code> if they do. </dd></dl>

</div>
</div>
<a id="ga62bfa152b7cf206ed5b3f0b83d767294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62bfa152b7cf206ed5b3f0b83d767294">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlockSpec::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure contain different information. </p>
<p>In particular, they are considered different if their <em>block</em> pointers are different (even if they point to different blocks with the same contents).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and <em>other</em> contain different information. </dd></dl>

</div>
</div>
<a id="ga94cbf3a6227144003d05e64410a24f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94cbf3a6227144003d05e64410a24f9a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaCensusTri::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure represent different triangulations from the SnapPea census. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the structure with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given structure represent different SnapPea census triangulations. </dd></dl>

</div>
</div>
<a id="ga076736b6fe8a23d801e9bd5179aaf205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076736b6fe8a23d801e9bd5179aaf205">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a consistent ordering of saturated blocks. </p>
<p>This ordering is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the saturated block with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this block comes before the given block according to the ordering of saturated blocks, or <code>false</code> if either the blocks are identical or this block comes after the given block. </dd></dl>

</div>
</div>
<a id="ga593529f0a73e5d27cb720676f9432a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga593529f0a73e5d27cb720676f9432a14">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp; regina::SatAnnulus::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this equal to a clone of the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the structure to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this structure. </dd></dl>

</div>
</div>
<a id="ga1944cb6dd1237ba9eeb41e348e24e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1944cb6dd1237ba9eeb41e348e24e904">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a>&amp; regina::SatBlockSpec::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given structure. </p>

</div>
</div>
<a id="ga422274dc01b3829898fc5bd9912c887e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga422274dc01b3829898fc5bd9912c887e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatAnnulus::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this and the given structure describe the same annulus with the same representation. </p>
<p>This requires both structures to have identical <em>tet</em>[] and <em>roles</em>[] arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the structures describe the same annulus with the same representation, or <code>false</code> if they do not. </dd></dl>

</div>
</div>
<a id="ga4e603f6a52be2e34ca2f62a2336bdbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e603f6a52be2e34ca2f62a2336bdbda">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlockSpec::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure contain identical information. </p>
<p>In particular, their <em>block</em> pointers must be identical (not pointing to different blocks with the same contents).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and <em>other</em> contain identical information. </dd></dl>

</div>
</div>
<a id="ga2ba8c9b131485a0771c6027d12ffac66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba8c9b131485a0771c6027d12ffac66">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SnapPeaCensusTri::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapPeaCensusTri.html">SnapPeaCensusTri</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure represent the same triangulation from the SnapPea census. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the structure with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given structure represent the same SnapPea census triangulation. </dd></dl>

</div>
</div>
<a id="gabe1a05d4855418a5e4de2261f93ae9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe1a05d4855418a5e4de2261f93ae9ec">&#9670;&nbsp;</a></span>otherSide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::otherSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of the same annulus from the other side. </p>
<p>This structure will not be changed. See <a class="el" href="group__subcomplex.html#ga3314169287c13371d490bfe8f156c2e8" title="Converts this into a representation of the same annulus from the other side.">switchSides()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus from the other side. </dd></dl>

</div>
</div>
<a id="ga4c3ca5778e03c7d378bcc271fcc2e78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3ca5778e03c7d378bcc271fcc2e78e">&#9670;&nbsp;</a></span>overHorizontal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatLayering::overHorizontal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this describe a layering over the horizontal edge of the boundary annulus, or a layering over the diagonal edge? </p>
<p>See the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes for definitions of horizontal and diagonal in this context. </p>

</div>
</div>
<a id="ga1bcc7a4e0c35b841f20cc0bd43f008aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bcc7a4e0c35b841f20cc0bd43f008aa">&#9670;&nbsp;</a></span>p()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredLensSpace::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first parameter <em>p</em> of this lens space L(p,q). </p>
<dl class="section return"><dt>Returns</dt><dd>the first parameter <em>p</em>. </dd></dl>

</div>
</div>
<a id="gae3daec5c7c16c43b461d123cdf37fd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3daec5c7c16c43b461d123cdf37fd66">&#9670;&nbsp;</a></span>parallelReln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::TxICore::parallelReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary curves. </p>
<p>Let <em>a_u</em> and <em>b_u</em> be the upper <em>alpha</em> and <em>beta</em> boundary curves. Suppose that the lower <em>alpha</em> is parallel to <em>w</em>.<em>a_u</em> + <em>x</em>.<em>b_u</em>, and that the lower <em>beta</em> is parallel to <em>y</em>.<em>a_u</em> + <em>z</em>.<em>b_u</em>. Then the matrix returned will be</p>
<pre>
    [ w  x ]
    [      ] .
    [ y  z ]
</pre><p>In other words, if <em>a_l</em> and <em>b_l</em> are the lower <em>alpha</em> and <em>beta</em> curves respectively, we have</p>
<pre>
    [ a_l ]                      [ a_u ]
    [     ]  =  <a class="el" href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66" title="Returns a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary cur...">parallelReln()</a> * [     ] .
    [ b_l ]                      [ b_u ]
</pre><dl class="section return"><dt>Returns</dt><dd>the relationship between the upper and lower boundary curves. </dd></dl>

</div>
</div>
<a id="ga90c2aa660f6fcd2cecceef46521e7560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c2aa660f6fcd2cecceef46521e7560">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::SatMobius::position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes how the Mobius band is attached to the boundary annulus. </p>
<p>The class notes discuss the weight two edge of the Mobius band (or equivalently the boundary edge of the Mobius band). The return value of this routine indicates which edge of the boundary annulus this weight two edge is joined to.</p>
<p>In the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes, the three edges of the annulus are denoted vertical, horizontal and boundary, and the vertices of each triangle are given markings 0, 1 and 2.</p>
<p>The return value of this routine takes the value 0, 1 or 2 as follows:</p><ul>
<li>0 means that the weight two edge is joined to the diagonal edge of the annulus (markings 1 and 2);</li>
<li>1 means that the weight two edge is joined to the horizontal edge of the annulus (markings 0 and 2);</li>
<li>2 means that the weight two edge is joined to the vertical edge of the annulus (markings 0 and 1).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the value 0, 1 or 2 as described above. </dd></dl>

</div>
</div>
<a id="ga7cfb30b05a416384a2d076ed26ea335b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cfb30b05a416384a2d076ed26ea335b">&#9670;&nbsp;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredLensSpace::q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second parameter <em>q</em> of this lens space L(p,q). </p>
<dl class="section return"><dt>Returns</dt><dd>the second parameter <em>q</em>. </dd></dl>

</div>
</div>
<a id="ga53d10195c977f38a583700303629ebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53d10195c977f38a583700303629ebc8">&#9670;&nbsp;</a></span>reflectHorizontal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectHorizontal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left-to-right reflection of this annulus representation. </p>
<p>The vertical direction of the fibres will remain unchanged, but the first and second triangles will be switched (and the 0..2 markings changed to compensate). </p>

</div>
</div>
<a id="ga8cb14f03e956c6a208d02226a4a684c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb14f03e956c6a208d02226a4a684c2">&#9670;&nbsp;</a></span>reflectVertical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::reflectVertical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the direction of the vertical fibres in this annulus representation. </p>
<p>The first and second triangles (as described in the class notes) will remain unchanged, but the markings 0 and 1 on each triangle will be switched. </p>

</div>
</div>
<a id="ga4de7f534b82eadd85b8ce9e775a35d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de7f534b82eadd85b8ce9e775a35d8c">&#9670;&nbsp;</a></span>region() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::BlockedSFS::region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the single saturated region that fills this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the single saturated region. </dd></dl>

</div>
</div>
<a id="ga8ca70a6716fa34ba23c83667d1b5bafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ca70a6716fa34ba23c83667d1b5bafe">&#9670;&nbsp;</a></span>region() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::BlockedSFSLoop::region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the saturated region from which this triangulation is formed. </p>
<p>See the class notes above for further information.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated region. </dd></dl>

</div>
</div>
<a id="ga21d2b41297a9db787e7863c76c32628d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d2b41297a9db787e7863c76c32628d">&#9670;&nbsp;</a></span>region() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::PluggedTorusBundle::region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated region that forms part of this triangulation. </p>
<p>The region refers directly to tetrahedra within this triangulation (as opposed to the thin I-bundle, which refers to a separate external triangulation).</p>
<dl class="section return"><dt>Returns</dt><dd>the saturated region. </dd></dl>

</div>
</div>
<a id="ga13a17c8ef49b0ddef5dccd37d954f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13a17c8ef49b0ddef5dccd37d954f65e">&#9670;&nbsp;</a></span>region() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SatRegion.html">SatRegion</a> &amp; regina::BlockedSFSPair::region </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of one of the two bounded saturated regions that form this triangulation. </p>
<p>See the class notes above for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>0 if the first region should be returned, or 1 if the second region should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested saturated region. </dd></dl>

</div>
</div>
<a id="ga42388f03d605c4700f94a68c1003a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42388f03d605c4700f94a68c1003a104">&#9670;&nbsp;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredChain::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses this layered chain so the top tetrahedron becomes the bottom and vice versa. </p>
<p>The upper and lower hinges will remain the upper and lower hinges respectively.</p>
<p>Note that this operation will cause the hinge edges to point in the opposite direction around the solid torus formed by this layered chain.</p>
<p>Note that only the representation of the chain is altered; the underlying triangulation is not changed. </p>

</div>
</div>
<a id="ga0025e7cff79ec36c33d6236a3dd3f699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0025e7cff79ec36c33d6236a3dd3f699">&#9670;&nbsp;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpiralSolidTorus::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses this spiralled solid torus. </p>
<p>Tetrahedra 0, 1, 2, ..., <a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227" title="Returns the number of tetrahedra in this spiralled solid torus.">size()</a>-1 will become tetrahedra <a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227" title="Returns the number of tetrahedra in this spiralled solid torus.">size()</a>-1, ..., 2, 1, 0 respectively. Note that this operation will change the vertex roles as well.</p>
<p>The underlying triangulation is not changed; all that changes is how this spiralled solid torus is represented. </p>

</div>
</div>
<a id="gaa1fc56873ff14590241f70e4387adffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1fc56873ff14590241f70e4387adffa">&#9670;&nbsp;</a></span>roles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::SatLST::roles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes how the layered solid torus is attached to the boundary annulus. </p>
<p>The <a class="el" href="classregina_1_1LayeredSolidTorus.html" title="Represents a layered solid torus in a triangulation.">LayeredSolidTorus</a> class notes describe top-level edge groups 0, 1 and 2 for a layered solid torus. On the other hand, the <a class="el" href="structregina_1_1SatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">SatAnnulus</a> class notes define vertical, horizontal and diagonal edges on the boundary annulus.</p>
<p>Suppose that the permutation returned by this routine is <em>r</em>. This indicates that:</p><ul>
<li>edge group <em>r</em>[0] is attached to the vertical annulus edges;</li>
<li>edge group <em>r</em>[1] is attached to the horizontal annulus edges;</li>
<li>edge group <em>r</em>[2] is attached to the diagonal annulus edges.</li>
</ul>
<p>The image <em>r</em>[3] will always be 3.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of how the layered solid torus is attached to the boundary annulus. </dd></dl>

</div>
</div>
<a id="gaeea9c67b200888b3aeb42251ee31c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeea9c67b200888b3aeb42251ee31c3cc">&#9670;&nbsp;</a></span>rotateHalfTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::rotateHalfTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates the representation of this annulus by 180 degrees. </p>
<p>This has the effect of switching the first and second triangles and also reversing the direction of the vertical fibres.</p>
<p>Calling this routine is equivalent to calling <a class="el" href="group__subcomplex.html#ga8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> and then <a class="el" href="group__subcomplex.html#ga53d10195c977f38a583700303629ebc8" title="Performs a left-to-right reflection of this annulus representation.">reflectHorizontal()</a>. </p>

</div>
</div>
<a id="ga3a81c2692c140b8ed46d060fcc62fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a81c2692c140b8ed46d060fcc62fffa">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised structure. </p>
<p>Both tetrahedra will be set to null pointers. </p>

</div>
</div>
<a id="gaf020064341a684f10ed73f7d0720ee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf020064341a684f10ed73f7d0720ee6e">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf90ba5f29977e590d5cd897ce07ec61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90ba5f29977e590d5cd897ce07ec61c">&#9670;&nbsp;</a></span>SatAnnulus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatAnnulus::SatAnnulus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure initialised to the given values. </p>
<p>See the class notes for what the various tetrahedra and permutations mean.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>the tetrahedron to assign to <em>tet</em>[0]. </td></tr>
    <tr><td class="paramname">r0</td><td>the permutation to assign to <em>roles</em>[0]. </td></tr>
    <tr><td class="paramname">t1</td><td>the tetrahedron to assign to <em>tet</em>[1]. </td></tr>
    <tr><td class="paramname">r1</td><td>the permutation to assign to <em>roles</em>[1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f5e2d7590e6821abcb395a4788a7f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f5e2d7590e6821abcb395a4788a7f66">&#9670;&nbsp;</a></span>SatBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::SatBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new clone of the given block. </p>
<p>Note that the new <em>adjBlock_</em> array will contain pointers to the same adjacent blocks as the original. That is, adjacent blocks will not be cloned also; instead pointers to adjacent blocks will simply be copied across.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the saturated block to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb3e6b4ec2c84ec3e3af1b90f2bb797a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb3e6b4ec2c84ec3e3af1b90f2bb797a">&#9670;&nbsp;</a></span>SatBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::SatBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nAnnuli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twistedBoundary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a block with the given number of annuli on the boundary. </p>
<p>All arrays will be constructed but their contents will remain uninitialised, with the exception that the <em>adjBlock</em> array will be filled with null pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAnnuli</td><td>the number of annuli on the boundary of this block; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twistedBoundary</td><td><code>true</code> if the ring of boundary annuli is twisted to form a long Mobius band, or <code>false</code> (the default) if it is not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1595d36f7a05e067e20d2f4013af2d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1595d36f7a05e067e20d2f4013af2d7d">&#9670;&nbsp;</a></span>SatBlockSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockSpec::SatBlockSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure that is completely uninitialised. </p>

</div>
</div>
<a id="ga2b46832a3c372b4568d1844e40fa0449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b46832a3c372b4568d1844e40fa0449">&#9670;&nbsp;</a></span>SatBlockSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockSpec::SatBlockSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SatBlockSpec.html">SatBlockSpec</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure that is a clone of the given structure. </p>

</div>
</div>
<a id="ga2b20151cc890847526af91ee8f0b0a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b20151cc890847526af91ee8f0b0a1d">&#9670;&nbsp;</a></span>SatBlockSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockSpec::SatBlockSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>useBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRefVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRefHoriz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new structure that is initialised to the given set of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useBlock</td><td>details of the saturated block structure. </td></tr>
    <tr><td class="paramname">useRefVert</td><td><code>true</code> if the block is reflected vertically within the larger region, or <code>false</code> otherwise. </td></tr>
    <tr><td class="paramname">useRefHoriz</td><td><code>true</code> if the block is reflected horizontally within the larger region, or <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d06980180f54d84eec4500301063f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d06980180f54d84eec4500301063f8b">&#9670;&nbsp;</a></span>SatBlockStarterSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockStarterSearcher::SatBlockStarterSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, for use by subclasses. </p>

</div>
</div>
<a id="ga2a02dbeb316e2c64816ed381d0f9714f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a02dbeb316e2c64816ed381d0f9714f">&#9670;&nbsp;</a></span>SatCube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatCube::SatCube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an uninitialised block. </p>
<p>The boundary annuli must be initialised before this block can be used. </p>

</div>
</div>
<a id="gac4fda8e4ab7cb99ae6fcb0622f2fa2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4fda8e4ab7cb99ae6fcb0622f2fa2a8">&#9670;&nbsp;</a></span>SatCube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatCube::SatCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatCube.html">SatCube</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ae52a083ecd4d15166786f2e4892aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ae52a083ecd4d15166786f2e4892aad">&#9670;&nbsp;</a></span>SatLayering() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatLayering::SatLayering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overHorizontal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a partially initialised block. </p>
<p>The boundary annuli will remain uninitialised, and must be initialised before this block can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overHorizontal</td><td><code>true</code> if this block describes a layering over the horizontal edge of the boundary annulus, or <code>false</code> if it describes a layering over the diagonal edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5a4b982a78589a71112bbfd3d7fa9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a4b982a78589a71112bbfd3d7fa9e7">&#9670;&nbsp;</a></span>SatLayering() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatLayering::SatLayering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatLayering.html">SatLayering</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc6c6f88585b9a1fded80949dc5170ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc6c6f88585b9a1fded80949dc5170ff">&#9670;&nbsp;</a></span>SatLST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatLST::SatLST </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatLST.html">SatLST</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1dd62a0d376212810d909a31fe6215c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd62a0d376212810d909a31fe6215c1">&#9670;&nbsp;</a></span>SatMobius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatMobius::SatMobius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatMobius.html">SatMobius</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d17a2ced5d69e3cf56847a80f0d9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d17a2ced5d69e3cf56847a80f0d9dd">&#9670;&nbsp;</a></span>SatReflectorStrip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatReflectorStrip::SatReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatReflectorStrip.html">SatReflectorStrip</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefbd29f8ddad38991a3f2209a1ba3974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefbd29f8ddad38991a3f2209a1ba3974">&#9670;&nbsp;</a></span>SatReflectorStrip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatReflectorStrip::SatReflectorStrip </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a partially initialised block of the given length. </p>
<p>The boundary annuli will remain uninitialised, and must be initialised before this block can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the new reflector strip, i.e., the number of boundary annuli; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twisted</td><td><code>true</code> if the strip should be twisted (giving a twisted ring of boundary annuli), or <code>false</code> if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5307cfd3f28b9a737c9bc56587f3882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5307cfd3f28b9a737c9bc56587f3882">&#9670;&nbsp;</a></span>SatRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatRegion::SatRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>starter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new region containing just the given block. </p>
<p>All boundary annuli of the given block will become boundary annuli of this region. It is guaranteed that this block will be stored in the region without any kind of reflection (see <a class="el" href="structregina_1_1SatBlockSpec.html" title="Describes how a single saturated block forms a part of a larger saturated region.">SatBlockSpec</a> for details).</p>
<p>Typically a region is initialised using this constructor, and then grown using the <a class="el" href="group__subcomplex.html#ga737839a4e297056cf8328c03a86b57b5" title="Expands this region as far as possible within the overall triangulation.">expand()</a> routine. For help in finding an initial starter block, see the <a class="el" href="classregina_1_1SatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">SatBlockStarterSearcher</a> class.</p>
<p>This region will claim ownership of the given block, and upon destruction it will destroy this block also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given block has no adjacencies listed. That is, for every boundary annulus of the given block, <a class="el" href="group__subcomplex.html#ga70d78eef4a11ec11260bb000eaa5a056" title="Returns whether there is another saturated block listed as being adjacent to the given boundary annul...">SatBlock::hasAdjacentBlock()</a> returns <code>false</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starter</td><td>the single block that this region will describe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3a180fa33809948d8269c3b19fbef12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a180fa33809948d8269c3b19fbef12">&#9670;&nbsp;</a></span>SatTriPrism() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatTriPrism::SatTriPrism </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>major</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a partially initialised block. </p>
<p>The boundary annuli will remain uninitialised, and must be initialised before this block can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">major</td><td><code>true</code> if this block is of major type, or <code>false</code> if it is of minor type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacab2cd63212fd6becd41c3cfa250b619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacab2cd63212fd6becd41c3cfa250b619">&#9670;&nbsp;</a></span>SatTriPrism() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatTriPrism::SatTriPrism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SatTriPrism.html">SatTriPrism</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17cbcc61d020779e77970ed6399ec925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17cbcc61d020779e77970ed6399ec925">&#9670;&nbsp;</a></span>section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::SnapPeaCensusTri::section </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the section of the SnapPea census to which this triangulation belongs. </p>
<p>This will be one of the section constants defined in this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the section of the SnapPea census. </dd></dl>

</div>
</div>
<a id="ga43412c3c8b26ef6dee3ed83bfeb5f004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43412c3c8b26ef6dee3ed83bfeb5f004">&#9670;&nbsp;</a></span>setAdjacent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::setAdjacent </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>adjBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>adjAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjReflected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjBackwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists the given saturated block as being adjacent to the given boundary annulus of this block. </p>
<p>Both block structures (this and the given block) will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block has the new adjacency; this must be between 0 and <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjBlock</td><td>the other saturated block that is adjacent to this. </td></tr>
    <tr><td class="paramname">adjAnnulus</td><td>indicates which boundary annulus of the adjacent block meets the given boundary annulus of this block; this must be between 0 and adjBlock-&gt;<a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjReflected</td><td>indicates whether the new adjacency is reflected (see the class notes for details). </td></tr>
    <tr><td class="paramname">adjBackwards</td><td>indicates whether the new adjacency is backwards (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19bebe108f5548a9a54906ff125eea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19bebe108f5548a9a54906ff125eea76">&#9670;&nbsp;</a></span>size() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::LayeredSolidTorus::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this layered solid torus. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="gac4217f6e46d0713d1af3b26ba6970c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4217f6e46d0713d1af3b26ba6970c14">&#9670;&nbsp;</a></span>size() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::Layering::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of individual tetrahedra that have been layered onto the original boundary, according to the data stored in this structure. </p>
<p>This begins at zero when the class constructor is called, and it increases if the routines <a class="el" href="group__subcomplex.html#gaa48e1aabed68a1a39cd69a5c016533d9" title="Examines whether one or more additional tetrahedra have been layered upon the current new boundary.">extend()</a> or <a class="el" href="group__subcomplex.html#ga45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> find that additional layerings have taken place.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of layered tetrahedra. </dd></dl>

</div>
</div>
<a id="gac31ed2050238c4e835689fff87956227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31ed2050238c4e835689fff87956227">&#9670;&nbsp;</a></span>size() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SpiralSolidTorus::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in this spiralled solid torus. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="gac0d7205d82b28024ea4d48564a3fbc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d7205d82b28024ea4d48564a3fbc4a">&#9670;&nbsp;</a></span>size() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::TxIDiagonalCore::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra in this <code>T x I</code> triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the total number of tetrahedra. </dd></dl>

</div>
</div>
<a id="ga031db144e9f041c06efb12d9b0029c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031db144e9f041c06efb12d9b0029c68">&#9670;&nbsp;</a></span>snappedBall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SnappedBall.html">SnappedBall</a> * regina::SnappedTwoSphere::snappedBall </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two snapped 3-balls whose equators are joined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two 3-balls to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding snapped 3-ball. </dd></dl>

</div>
</div>
<a id="gaa2f26731dc597e075130299d5d520ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2f26731dc597e075130299d5d520ce1">&#9670;&nbsp;</a></span>StandardTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StandardTriangulation::StandardTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This is needed for subclasses to implicitly call from their own constructors. </p>

</div>
</div>
<a id="ga0384e9bcbb4e02ad62708cdafbf4bf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0384e9bcbb4e02ad62708cdafbf4bf9a">&#9670;&nbsp;</a></span>StandardTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StandardTriangulation::StandardTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do-nothing copy constructor. </p>
<p>This is needed for subclasses to implicitly call from their own default copy constructors. </p>

</div>
</div>
<a id="ga3314169287c13371d490bfe8f156c2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3314169287c13371d490bfe8f156c2e8">&#9670;&nbsp;</a></span>switchSides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::switchSides </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a representation of the same annulus from the other side. </p>
<p>The first and second triangles and their 0..2 markings (as described in the class notes) remain unchanged. However, the two tetrahedra that are used to describe the annulus will be replaced by their counterparts on the other side of the annulus (i.e., the two new tetrahedra that meet the two original tetrahedra along the annulus itself).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Neither triangle of this annulus is a boundary triangle of the triangulation. </dd></dl>

</div>
</div>
<a id="ga1065793a1b9ed62f334863727145159b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1065793a1b9ed62f334863727145159b">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::SnappedBall::tetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the tetrahedron that forms this snapped ball. </p>
<dl class="section return"><dt>Returns</dt><dd>the tetrahedron. </dd></dl>

</div>
</div>
<a id="ga6309e86d2d4d03d34cc5d750bd1fc393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6309e86d2d4d03d34cc5d750bd1fc393">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::TriSolidTorus::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this solid torus. </p>
<p>See the general class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron in the solid torus to return; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="gaa8c00c92de980b307b8c862b4a7c17ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8c00c92de980b307b8c862b4a7c17ce">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::L31Pillow::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichTet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two tetrahedra involved in this structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichTet</td><td>specifies which tetrahedron to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="gabc085c61267bac6e531bee325f44031e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc085c61267bac6e531bee325f44031e">&#9670;&nbsp;</a></span>tetrahedron() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::SpiralSolidTorus::tetrahedron </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested tetrahedron in this spiralled solid torus. </p>
<p>Tetrahedra are numbered from 0 to <a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227" title="Returns the number of tetrahedra in this spiralled solid torus.">size()</a>-1 inclusive, with tetrahedron <em>i</em>+1 being placed above tetrahedron <em>i</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron to return; this must be between 0 and <a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227" title="Returns the number of tetrahedra in this spiralled solid torus.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="gad060bab2f08b1e5881d25b2291d8e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad060bab2f08b1e5881d25b2291d8e09c">&#9670;&nbsp;</a></span>TeXName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation in TeX format. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation in TeX format. </dd></dl>

</div>
</div>
<a id="ga21a0bfc69007e1d3aa8c9e63cdff5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a0bfc69007e1d3aa8c9e63cdff5fe1">&#9670;&nbsp;</a></span>TeXName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TxICore::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of this specific triangulation of <code>T x I</code> in TeX format. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation in TeX format. </dd></dl>

</div>
</div>
<a id="gaacb73be0df49c8de341997dcc3f77306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacb73be0df49c8de341997dcc3f77306">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredChain::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top tetrahedron of this layered chain. </p>
<dl class="section return"><dt>Returns</dt><dd>the top tetrahedron. </dd></dl>

</div>
</div>
<a id="ga0b8910645cf2e930df846536098d9a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8910645cf2e930df846536098d9a34">&#9670;&nbsp;</a></span>topEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested edge of the top level tetrahedron belonging to the given group. </p>
<p>The layering reduces five of the top level tetrahedron edges to three boundary edges of the solid torus; this divides the five initial edges into groups of size two, two and one.</p>
<p>Group 0 represents the boundary edge that the meridinal disc cuts fewest times. Group 2 represents the boundary edge that the meridinal disc cuts most times. Group 1 is in the middle.</p>
<p>Note that <code>topEdgeGroup(topEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code> that actually correspond to an edge.</p>
<p>Edges <code>topEdge(group, 0)</code> will all belong to face <code>topFace(0)</code>. Edges <code>topEdge(group, 1)</code> (if they exist) will all belong to face <code>topFace(1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group that the requested edge should belong to; this must be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">index</td><td>the index within the given group of the requested edge; this must be 0 or 1. Note that one of the groups only contains one tetrahedron edge, in which case this edge will be stored at index 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge number in the top level tetrahedron of the requested edge (between 0 and 5 inclusive), or -1 if there is no such edge (only possible if the given group was the group of size one and the given index was 1). </dd></dl>

</div>
</div>
<a id="ga52ba8a45362bc1ef93195913c4cc6b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ba8a45362bc1ef93195913c4cc6b9e">&#9670;&nbsp;</a></span>topEdgeGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topEdgeGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the group that the given edge of the top level tetrahedron belongs to. </p>
<p>See <a class="el" href="group__subcomplex.html#ga0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about groups.</p>
<p>Note that <code>topEdgeGroup(topEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code> that actually correspond to an edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the edge number in the top level tetrahedron of the given edge; this must be between 0 and 5 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group to which the given edge belongs (0, 1 or 2), or -1 if this edge does not belong to any group (only possible if this is the unique edge in the top tetrahedron not on the torus boundary). </dd></dl>

</div>
</div>
<a id="gafba992cb747e96fe1da6ec884daffa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba992cb747e96fe1da6ec884daffa4d">&#9670;&nbsp;</a></span>topFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two faces of the top level tetrahedron that form the boundary of this layered solid torus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two faces to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face number in the top level tetrahedron; this will be between 0 and 3 inclusive. </dd></dl>

</div>
</div>
<a id="ga5c8b86fc53f94266fc2420df6aeb7361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c8b86fc53f94266fc2420df6aeb7361">&#9670;&nbsp;</a></span>topLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredSolidTorus::topLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top level tetrahedron in this layered solid torus. </p>
<p>This is the tetrahedron that would be on the boundary of the torus if the torus were the entire manifold.</p>
<dl class="section return"><dt>Returns</dt><dd>the top level tetrahedron. </dd></dl>

</div>
</div>
<a id="ga7604b4366f6cecd2df0bcf81d67852fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7604b4366f6cecd2df0bcf81d67852fe">&#9670;&nbsp;</a></span>topVertexRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::LayeredChain::topVertexRoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the top tetrahedron plays in the layered chain. </p>
<p>The permutation returned (call this <code>p</code>) maps 0, 1, 2 and 3 to the four vertices of the top tetrahedron so that the edge from <code>p[0]</code> to <code>p[1]</code> is the top hinge, the edge from <code>p[2]</code> to <code>p[3]</code> is the bottom hinge, faces <code>p[1]</code> and <code>p[2]</code> are the bottom faces and faces <code>p[0]</code> and <code>p[3]</code> are the (boundary) top faces.</p>
<p>See the general class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a permutation representing the roles of the vertices of the top tetrahedron. </dd></dl>

</div>
</div>
<a id="ga5106950b750dde99e7894722b1fd20fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5106950b750dde99e7894722b1fd20fd">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp; regina::LayeredLensSpace::torus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the layered solid torus to which the mobius strip is glued. </p>
<dl class="section return"><dt>Returns</dt><dd>the layered solid torus. </dd></dl>

</div>
</div>
<a id="gada7446d154dc67c10d6b04eef8ea7aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7446d154dc67c10d6b04eef8ea7aef">&#9670;&nbsp;</a></span>torusAnnulus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::AugTriSolidTorus::torusAnnulus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the single boundary annulus of the core triangular solid torus to which a layered solid torus is attached. </p>
<p>This routine is only meaningful if the other two annuli are linked by a layered chain.</p>
<p>The integer returned will be 0, 1 or 2; see the <a class="el" href="classregina_1_1TriSolidTorus.html" title="Represents a three-tetrahedron triangular solid torus in a triangulation.">TriSolidTorus</a> class notes for how the boundary annuli are numbered.</p>
<dl class="section return"><dt>Returns</dt><dd>the single annulus to which the layered solid torus is attached, or -1 if there is no layered chain (and thus all three annuli have layered solid tori attached). </dd></dl>

</div>
</div>
<a id="gacf5a80dbeae803934a49a7be23241a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf5a80dbeae803934a49a7be23241a55">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredSolidTorus::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the details of this layered solid torus according to the given isomorphism between triangulations. </p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this layered solid torus must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called this structure will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This layered solid torus currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently referenced by this layered solid torus. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be referenced by the updated layered solid torus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadb34c281222b5a95a4d3a2bd4206fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadb34c281222b5a95a4d3a2bd4206fcf">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatAnnulus::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts this annulus representation according to the given isomorphism between triangulations. </p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this annulus must refer to tetrahedra in <em>originalTri</em>. This routine will adjust this annulus according to the given isomorphism, so that it refers to the corresponding tetrahedra in <em>newTri</em> (with the <em>roles</em> permutations also updated accordingly).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This annulus refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this annulus representation. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated annulus representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4d565eec762b612fbf72b3f41e26dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d565eec762b612fbf72b3f41e26dce">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the structure of this block according to the given isomorphism between triangulations. </p>
<p>Any triangulation-specific information will be transformed accordingly (for instance, the routine <a class="el" href="group__subcomplex.html#gaadb34c281222b5a95a4d3a2bd4206fcf" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">SatAnnulus::transform()</a> will be called for each boundary annulus).</p>
<p>Information regarding adjacent blocks will <em>not</em> be changed. Only structural information for this particular block will be updated.</p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this block must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called the block will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This block currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any subclasses of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> that store additional triangulation-specific information will need to override this routine. When doing so, be sure to call <a class="el" href="group__subcomplex.html#gaa4d565eec762b612fbf72b3f41e26dce" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">SatBlock::transform()</a> so that the generic changes defined here will still take place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this saturated block. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated block structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__subcomplex.html#gada8a6cf454d624c3457b9e57c8595e6d">regina::SatLST</a>.</p>

</div>
</div>
<a id="gada8a6cf454d624c3457b9e57c8595e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada8a6cf454d624c3457b9e57c8595e6d">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatLST::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the structure of this block according to the given isomorphism between triangulations. </p>
<p>Any triangulation-specific information will be transformed accordingly (for instance, the routine <a class="el" href="group__subcomplex.html#gaadb34c281222b5a95a4d3a2bd4206fcf" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">SatAnnulus::transform()</a> will be called for each boundary annulus).</p>
<p>Information regarding adjacent blocks will <em>not</em> be changed. Only structural information for this particular block will be updated.</p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this block must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called the block will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This block currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any subclasses of <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> that store additional triangulation-specific information will need to override this routine. When doing so, be sure to call <a class="el" href="group__subcomplex.html#gaa4d565eec762b612fbf72b3f41e26dce" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">SatBlock::transform()</a> so that the generic changes defined here will still take place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this saturated block. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated block structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#gaa4d565eec762b612fbf72b3f41e26dce">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gaff35702b155b794c798c001d7011b27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff35702b155b794c798c001d7011b27d">&#9670;&nbsp;</a></span>triangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; * regina::PillowTwoSphere::triangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the two triangles whose boundaries are joined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two triangles to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding triangle. </dd></dl>

</div>
</div>
<a id="gafd8de3b8afb69ec0e133509f0c888dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8de3b8afb69ec0e133509f0c888dd9">&#9670;&nbsp;</a></span>triangleMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::PillowTwoSphere::triangleMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation describing how the boundaries of the two triangles are joined. </p>
<p>The permutation will map vertices (0,1,2) of <code>triangle(0)</code> to vertices (0,1,2) of <code>triangle(1)</code>. The map will represent how the vertices of the triangles are identified by the three edge gluings.</p>
<dl class="section return"><dt>Returns</dt><dd>a permutation describing how the triangle boundaries are joined. </dd></dl>

</div>
</div>
<a id="gaf162c1569d051d46056867a4125bf522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf162c1569d051d46056867a4125bf522">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; regina::SatBlockStarter::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the triangulation of the saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the block triangulation. </dd></dl>

</div>
</div>
<a id="gad1893440bbd41f62a28f1c49f7d3bfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1893440bbd41f62a28f1c49f7d3bfae">&#9670;&nbsp;</a></span>twistedBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a long Mobius strip? </p>
<p>Recall from the class notes that the twist occurs between boundary annuli <a class="el" href="group__subcomplex.html#gab6315fa72abebfdd6c03f4ed5ea68bab" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 and 0.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the ring of boundary annuli is twisted, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="gaf574a77b04122f2e651b9bd8aeeac3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf574a77b04122f2e651b9bd8aeeac3d8">&#9670;&nbsp;</a></span>TxICore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TxICore::TxICore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that performs no initialisation. </p>

</div>
</div>
<a id="gaf7c62f61f1241df737f5e9cc2c317341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7c62f61f1241df737f5e9cc2c317341">&#9670;&nbsp;</a></span>TxIDiagonalCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TxIDiagonalCore::TxIDiagonalCore </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>T x I</code> triangulation with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the number of tetrahedra in this triangulation. This must be at least 6. </td></tr>
    <tr><td class="paramname">newK</td><td>the additional parameter <em>k</em> as described in the class notes. This must be between 1 and (<em>newSize</em> - 5) inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga198aea2fa58aa22b469b68151c4df3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga198aea2fa58aa22b469b68151c4df3f5">&#9670;&nbsp;</a></span>TxIParallelCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TxIParallelCore::TxIParallelCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of this <code>T x I</code> triangulation. </p>

</div>
</div>
<a id="ga1bef4097fcca559268c5b629015ff2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bef4097fcca559268c5b629015ff2ee">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TrivialTri::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific trivial triangulation being represented. </p>
<dl class="section return"><dt>Returns</dt><dd>the specific triangulation. This will be one of the triangulation constants defined in this class. </dd></dl>

</div>
</div>
<a id="ga3b34926e074563265cddbf5c1a4c05c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b34926e074563265cddbf5c1a4c05c0">&#9670;&nbsp;</a></span>useStarterBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::SatBlockStarterSearcher::useStarterBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a> *&#160;</td>
          <td class="paramname"><em>starter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by subclasses to process each starter block embedding that is found. </p>
<p>Suppose that the main search routine <a class="el" href="group__subcomplex.html#ga211f6cc1476b89316c4f5670a67e2fa2" title="Runs a search for every isomorphic embedding of every starter block from the global SatBlockStarterSe...">findStarterBlocks()</a> has been called with some triangulation <em>t</em>. Each time it locates an isomorphic embedding of a starter block within <em>t</em>, it will call <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a>. Subclasses of <a class="el" href="classregina_1_1SatBlockStarterSearcher.html" title="A helper class for locating and using starter blocks within a triangulation.">SatBlockStarterSearcher</a> should therefore override <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> to process each embedding in whatever way is appropriate for the problem at hand.</p>
<p>The block passed in the argument <em>starter</em> is a newly created structure describing the starter block as it appears within the triangulation <em>t</em>. Thus different embeddings of the same starter block within <em>t</em> will pass different <em>starter</em> arguments to this routine. It is the responsibility of <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> to either destroy the new block <em>starter</em> or pass ownership of it elsewhere.</p>
<p>When this routine is called, the data member <em>usedTets</em> will contain a list of all tetrahedra from the triangulation <em>t</em> that appear within the relevant starter block embedding. The reimplementation of <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> may modify this list as it pleases, since the main search routine will empty the list anyway when <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> returns. One possible use for the <em>usedTets</em> data member is for passing to <a class="el" href="group__subcomplex.html#ga24eeb48f535c22b24dc25699981e38d4" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">SatBlock::isBlock()</a> or <a class="el" href="group__subcomplex.html#ga737839a4e297056cf8328c03a86b57b5" title="Expands this region as far as possible within the overall triangulation.">SatRegion::expand()</a> as the list of tetrahedra to avoid in further searches.</p>
<p>This routine must return a boolean; this allows subclasses to immediately terminate the main search once they have found whatever it is they were looking for. A return value of <code>true</code> signifies that the search should continue as normal, whereas a return value of <code>false</code> signifies that the search should end immediately (specifically, that <a class="el" href="group__subcomplex.html#ga211f6cc1476b89316c4f5670a67e2fa2" title="Runs a search for every isomorphic embedding of every starter block from the global SatBlockStarterSe...">findStarterBlocks()</a> should clean up and return before all remaining embeddings of all starter blocks have been found).</p>
<dl class="section warning"><dt>Warning</dt><dd>Subclasses must remember to either destroy or claim ownership of the newly created block <em>starter</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starter</td><td>a newly created structure describing the starter block as it appears within the larger triangulation currently under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the search for embeddings of starter blocks should continue, or <code>false</code> if the search should stop immediately. </dd></dl>

</div>
</div>
<a id="ga7a73c2957fd960d42c0b493726f7f994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a73c2957fd960d42c0b493726f7f994">&#9670;&nbsp;</a></span>vertexRoles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::TriSolidTorus::vertexRoles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus. </p>
<p>The permutation returned (call this <code>p</code>) maps 0, 1, 2 and 3 to the four vertices of tetrahedron <em>index</em> so that the edge from <code>p[0]</code> to <code>p[3]</code> is an oriented axis edge, and the path from vertices <code>p[0]</code> to <code>p[1]</code> to <code>p[2]</code> to <code>p[3]</code> follows the three oriented major edges. In particular, the major edge for annulus <em>index</em> will run from vertices <code>p[1]</code> to <code>p[2]</code>. Edges <code>p[0]</code> to <code>p[2]</code> and <code>p[1]</code> to <code>p[3]</code> will both be oriented minor edges.</p>
<p>Note that annulus <code>index+1</code> uses face <code>p[1]</code> of the requested tetrahedron and annulus <code>index+2</code> uses face <code>p[2]</code> of the requested tetrahedron. Both annuli use the axis edge <code>p[0]</code> to <code>p[3]</code>, and each annulus uses one other major edge and one other minor edge so that (according to homology) the axis edge equals the major edge plus the minor edge.</p>
<p>See the general class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron in the solid torus to examine; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation representing the roles of the vertices of the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="gab5f4e19343a3c7ff83b2d401ba2bc575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f4e19343a3c7ff83b2d401ba2bc575">&#9670;&nbsp;</a></span>vertexRoles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::SpiralSolidTorus::vertexRoles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation represeting the role that each vertex of the requested tetrahedron plays in the solid torus. </p>
<p>The permutation returned (call this <code>p</code>) maps 0, 1, 2 and 3 to the four vertices of tetrahedron <em>index</em> so that vertices <code>p[0]</code>, <code>p[1]</code>, <code>p[2]</code> and <code>p[3]</code> correspond to vertices A, B, C and D respectively as described in the general class notes.</p>
<p>In particular, the directed edge from vertex <code>p[0]</code> to <code>p[3]</code> is an axis edge, directed edges <code>p[0]</code> to <code>p[2]</code> and <code>p[1]</code> to <code>p[3]</code> are minor edges and the directed path from vertices <code>p[0]</code> to <code>p[1]</code> to <code>p[2]</code> to <code>p[3]</code> follows the three major edges.</p>
<p>See the general class notes for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which tetrahedron in the solid torus to examine; this must be between 0 and <a class="el" href="group__subcomplex.html#gac31ed2050238c4e835689fff87956227" title="Returns the number of tetrahedra in this spiralled solid torus.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation representing the roles of the vertices of the requested tetrahedron. </dd></dl>

</div>
</div>
<a id="gac1cc54b9dfdf84f901beacaab63b9f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cc54b9dfdf84f901beacaab63b9f39">&#9670;&nbsp;</a></span>verticalReflection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a> regina::SatAnnulus::verticalReflection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a representation of this annulus in which the vertical direction of the fibres has been reversed. </p>
<p>This structure will not be changed. See <a class="el" href="group__subcomplex.html#ga8cb14f03e956c6a208d02226a4a684c2" title="Reverses the direction of the vertical fibres in this annulus representation.">reflectVertical()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a new representation of this annulus in which fibres have been reversed. </dd></dl>

</div>
</div>
<a id="gab81d8335c3999dfea5665b9d2b21134f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab81d8335c3999dfea5665b9d2b21134f">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga265e7b7e42b84115fc9a99bfa6322120">regina::SatLayering</a>, <a class="el" href="group__subcomplex.html#gaacf1d38319376efdada01acf757fa342">regina::SatReflectorStrip</a>, <a class="el" href="group__subcomplex.html#ga3a75bc834917cbc4dea03ab41f055f37">regina::SatCube</a>, <a class="el" href="group__subcomplex.html#ga723ccdc7de49209c5bf7b3a4977c17e3">regina::SatTriPrism</a>, <a class="el" href="group__subcomplex.html#gaa84879d9a184d6561ab0d8d786642910">regina::SatLST</a>, and <a class="el" href="group__subcomplex.html#ga8430b475c80a072f8a18788492f9171c">regina::SatMobius</a>.</p>

</div>
</div>
<a id="ga8430b475c80a072f8a18788492f9171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8430b475c80a072f8a18788492f9171c">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatMobius::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gaa84879d9a184d6561ab0d8d786642910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84879d9a184d6561ab0d8d786642910">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatLST::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga723ccdc7de49209c5bf7b3a4977c17e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723ccdc7de49209c5bf7b3a4977c17e3">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatTriPrism::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga3a75bc834917cbc4dea03ab41f055f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a75bc834917cbc4dea03ab41f055f37">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatCube::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gaacf1d38319376efdada01acf757fa342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf1d38319376efdada01acf757fa342">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatReflectorStrip::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga265e7b7e42b84115fc9a99bfa6322120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265e7b7e42b84115fc9a99bfa6322120">&#9670;&nbsp;</a></span>writeAbbr() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatLayering::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gaa09d512dd41181f4bb0394281d7623fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09d512dd41181f4bb0394281d7623fa">&#9670;&nbsp;</a></span>writeBlockAbbrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeBlockAbbrs </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an abbreviated list of blocks within this region to the given output stream. </p>
<p>Blocks will be written using their abbreviated names, and these names will be separated by commas. See <a class="el" href="group__subcomplex.html#gab81d8335c3999dfea5665b9d2b21134f" title="Writes an abbreviated name or symbol for this block to the given output stream.">SatBlock::writeAbbr()</a> for further details.</p>
<p>The blocks within this region will be sorted before their abbreviated names are output. The particular method of sorting is an arbitrary aesthetic decision on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0913963357b5660ea996226a70ce91a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0913963357b5660ea996226a70ce91a0">&#9670;&nbsp;</a></span>writeDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeDetail </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes details of the composition of this region to the given output stream. </p>
<p>The output will consist of several lines. The first line will contain the title string (passed as a separate argument to this routine), followed by a colon. Following this will be a number of lines describing the individual blocks that make up this region and the various adjacencies between them.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">title</td><td>the name of this region, to be written on the first line of output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4dd4f6240a77f6148c66b16dc94922da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd4f6240a77f6148c66b16dc94922da">&#9670;&nbsp;</a></span>writeName() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::StandardTriangulation::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#gafe1b90a2eb4bc4680081fd927f265078">regina::TrivialTri</a>, <a class="el" href="group__subcomplex.html#ga45703ff36060192b4d248e30d9eb20cb">regina::TriSolidTorus</a>, <a class="el" href="group__subcomplex.html#gab3ebbeb5ae8293c3e6ccfb13902d4dd7">regina::SpiralSolidTorus</a>, <a class="el" href="group__subcomplex.html#gab1acb9738f55ad2fac5f297af4774906">regina::SnappedBall</a>, <a class="el" href="group__subcomplex.html#ga00867f9d2da120606eabc5107478e2ee">regina::SnapPeaCensusTri</a>, <a class="el" href="group__subcomplex.html#ga6294c946a4a3bc67f788875b161a69cf">regina::PlugTriSolidTorus</a>, <a class="el" href="group__subcomplex.html#gac6f73d0f600679abb6ad8bcd8c847609">regina::PluggedTorusBundle</a>, <a class="el" href="group__subcomplex.html#ga7030c630c47f79f355fff640be314a4c">regina::LayeredTorusBundle</a>, <a class="el" href="group__subcomplex.html#ga77d03cc2acaae8ef46a0c64d311b0e04">regina::LayeredSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga1be965e2c0456e2d5c88f09dd897baf9">regina::LayeredLoop</a>, <a class="el" href="group__subcomplex.html#ga31b991706522516fdc20d939bbb38acc">regina::LayeredLensSpace</a>, <a class="el" href="group__subcomplex.html#gace8b36a4a2e18d04270e9daed8e30b2e">regina::LayeredChainPair</a>, <a class="el" href="group__subcomplex.html#ga146ca193c489eed78b7b26ffeb830576">regina::LayeredChain</a>, <a class="el" href="group__subcomplex.html#ga5fc8652135bc2920f809dd59bba7ffc6">regina::L31Pillow</a>, <a class="el" href="group__subcomplex.html#gaaf5bc7667dbbe53c399f1cf9eeef3080">regina::BlockedSFSTriple</a>, <a class="el" href="group__subcomplex.html#gaecafe5270c65cf39f36ae25b75d2269e">regina::BlockedSFSPair</a>, <a class="el" href="group__subcomplex.html#gae94a79bcee7ed6a6ba814b1051ed33d9">regina::BlockedSFSLoop</a>, <a class="el" href="group__subcomplex.html#gaf02dd77d605d672d2fede888dd198834">regina::BlockedSFS</a>, and <a class="el" href="group__subcomplex.html#ga775f6ef15a3dd8b66fcc72870e0dc2ab">regina::AugTriSolidTorus</a>.</p>

</div>
</div>
<a id="ga22d4aaa8783b92d1634170799e703926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22d4aaa8783b92d1634170799e703926">&#9670;&nbsp;</a></span>writeName() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::TxICore::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> to the given output stream. </p>
<p>The name will be written as a human-readable string.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga8019ca7edb50fbe10f92372be137b277">regina::TxIParallelCore</a>, and <a class="el" href="group__subcomplex.html#ga71d926daf31520d463bb9722e24d64e7">regina::TxIDiagonalCore</a>.</p>

</div>
</div>
<a id="ga775f6ef15a3dd8b66fcc72870e0dc2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga775f6ef15a3dd8b66fcc72870e0dc2ab">&#9670;&nbsp;</a></span>writeName() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::AugTriSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaf02dd77d605d672d2fede888dd198834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02dd77d605d672d2fede888dd198834">&#9670;&nbsp;</a></span>writeName() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFS::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gae94a79bcee7ed6a6ba814b1051ed33d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94a79bcee7ed6a6ba814b1051ed33d9">&#9670;&nbsp;</a></span>writeName() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSLoop::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaecafe5270c65cf39f36ae25b75d2269e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecafe5270c65cf39f36ae25b75d2269e">&#9670;&nbsp;</a></span>writeName() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSPair::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaaf5bc7667dbbe53c399f1cf9eeef3080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5bc7667dbbe53c399f1cf9eeef3080">&#9670;&nbsp;</a></span>writeName() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSTriple::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga5fc8652135bc2920f809dd59bba7ffc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc8652135bc2920f809dd59bba7ffc6">&#9670;&nbsp;</a></span>writeName() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::L31Pillow::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga146ca193c489eed78b7b26ffeb830576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146ca193c489eed78b7b26ffeb830576">&#9670;&nbsp;</a></span>writeName() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredChain::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gace8b36a4a2e18d04270e9daed8e30b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace8b36a4a2e18d04270e9daed8e30b2e">&#9670;&nbsp;</a></span>writeName() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredChainPair::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga31b991706522516fdc20d939bbb38acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b991706522516fdc20d939bbb38acc">&#9670;&nbsp;</a></span>writeName() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::LayeredLensSpace::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga1be965e2c0456e2d5c88f09dd897baf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be965e2c0456e2d5c88f09dd897baf9">&#9670;&nbsp;</a></span>writeName() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredLoop::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga77d03cc2acaae8ef46a0c64d311b0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d03cc2acaae8ef46a0c64d311b0e04">&#9670;&nbsp;</a></span>writeName() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga7030c630c47f79f355fff640be314a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7030c630c47f79f355fff640be314a4c">&#9670;&nbsp;</a></span>writeName() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredTorusBundle::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gac6f73d0f600679abb6ad8bcd8c847609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f73d0f600679abb6ad8bcd8c847609">&#9670;&nbsp;</a></span>writeName() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::PluggedTorusBundle::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga6294c946a4a3bc67f788875b161a69cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6294c946a4a3bc67f788875b161a69cf">&#9670;&nbsp;</a></span>writeName() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::PlugTriSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga00867f9d2da120606eabc5107478e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00867f9d2da120606eabc5107478e2ee">&#9670;&nbsp;</a></span>writeName() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SnapPeaCensusTri::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gab1acb9738f55ad2fac5f297af4774906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1acb9738f55ad2fac5f297af4774906">&#9670;&nbsp;</a></span>writeName() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SnappedBall::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gab3ebbeb5ae8293c3e6ccfb13902d4dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ebbeb5ae8293c3e6ccfb13902d4dd7">&#9670;&nbsp;</a></span>writeName() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SpiralSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga45703ff36060192b4d248e30d9eb20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45703ff36060192b4d248e30d9eb20cb">&#9670;&nbsp;</a></span>writeName() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TriSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gafe1b90a2eb4bc4680081fd927f265078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1b90a2eb4bc4680081fd927f265078">&#9670;&nbsp;</a></span>writeName() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::TrivialTri::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga71d926daf31520d463bb9722e24d64e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d926daf31520d463bb9722e24d64e7">&#9670;&nbsp;</a></span>writeName() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TxIDiagonalCore::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> to the given output stream. </p>
<p>The name will be written as a human-readable string.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga22d4aaa8783b92d1634170799e703926">regina::TxICore</a>.</p>

</div>
</div>
<a id="ga8019ca7edb50fbe10f92372be137b277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8019ca7edb50fbe10f92372be137b277">&#9670;&nbsp;</a></span>writeName() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TxIParallelCore::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> to the given output stream. </p>
<p>The name will be written as a human-readable string.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga22d4aaa8783b92d1634170799e703926">regina::TxICore</a>.</p>

</div>
</div>
<a id="ga7acaa9c2c1a8abaf4b0f6639fe413037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7acaa9c2c1a8abaf4b0f6639fe413037">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::StandardTriangulation::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga2c6b86dba9f72df48e1c55cb265e9de9">regina::TrivialTri</a>, <a class="el" href="group__subcomplex.html#gaf42be4348d68170c65a146398cc246eb">regina::TriSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga5fb7aedbf38fd0e8a5fadf13256acc87">regina::SpiralSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga855f2eed086762360c249660ad634109">regina::SnappedBall</a>, <a class="el" href="group__subcomplex.html#ga85df37685a1d128fb6fda90f3a77360b">regina::SnapPeaCensusTri</a>, <a class="el" href="group__subcomplex.html#ga2f6e754b606f22e7274b16c2b2e168cc">regina::PlugTriSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga81b5f03cbfa4337fddcfbc43bd002204">regina::PluggedTorusBundle</a>, <a class="el" href="group__subcomplex.html#ga50d5a208bec81a4a28c68e24424f7b41">regina::LayeredTorusBundle</a>, <a class="el" href="group__subcomplex.html#ga7b26b8de06723564d00d023362df52a0">regina::LayeredSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga38a24af535d51502874624ed86aefb4f">regina::LayeredLoop</a>, <a class="el" href="group__subcomplex.html#ga3009d8827ebbcec49fcafb89c3ea06ca">regina::LayeredLensSpace</a>, <a class="el" href="group__subcomplex.html#ga47dabc2ccc16d5da29f3efc549354e86">regina::LayeredChainPair</a>, <a class="el" href="group__subcomplex.html#ga475bb023d836a974f69721e3646d6018">regina::LayeredChain</a>, <a class="el" href="group__subcomplex.html#ga36eb0e668f12d2f02420c7fd647f8478">regina::L31Pillow</a>, <a class="el" href="group__subcomplex.html#gaa29abbf245780e0394b9495c4472faf5">regina::BlockedSFSTriple</a>, <a class="el" href="group__subcomplex.html#ga42bd0a8dc34b89a0ac20f96d0616f657">regina::BlockedSFSPair</a>, <a class="el" href="group__subcomplex.html#gabb9751385499fdd8e89ca8d02b0095e9">regina::BlockedSFSLoop</a>, <a class="el" href="group__subcomplex.html#gacb433562e1873d79049ec7b57848d55e">regina::BlockedSFS</a>, and <a class="el" href="group__subcomplex.html#gafeb5555a5884d986589593215b531be5">regina::AugTriSolidTorus</a>.</p>

</div>
</div>
<a id="ga7f870c1e82a584830858fb1ebb13e62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f870c1e82a584830858fb1ebb13e62c">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; regina::TxICore::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#ga4355651bc847facab8d3781a3b6b6740">regina::TxIParallelCore</a>, and <a class="el" href="group__subcomplex.html#gad2d04cae182aa78d8ea98dcac2ee0591">regina::TxIDiagonalCore</a>.</p>

</div>
</div>
<a id="gafeb5555a5884d986589593215b531be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb5555a5884d986589593215b531be5">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::AugTriSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gacb433562e1873d79049ec7b57848d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb433562e1873d79049ec7b57848d55e">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFS::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gabb9751385499fdd8e89ca8d02b0095e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb9751385499fdd8e89ca8d02b0095e9">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSLoop::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga42bd0a8dc34b89a0ac20f96d0616f657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42bd0a8dc34b89a0ac20f96d0616f657">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSPair::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaa29abbf245780e0394b9495c4472faf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa29abbf245780e0394b9495c4472faf5">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::BlockedSFSTriple::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga36eb0e668f12d2f02420c7fd647f8478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36eb0e668f12d2f02420c7fd647f8478">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::L31Pillow::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga475bb023d836a974f69721e3646d6018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga475bb023d836a974f69721e3646d6018">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredChain::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga47dabc2ccc16d5da29f3efc549354e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47dabc2ccc16d5da29f3efc549354e86">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredChainPair::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga3009d8827ebbcec49fcafb89c3ea06ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3009d8827ebbcec49fcafb89c3ea06ca">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::LayeredLensSpace::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga38a24af535d51502874624ed86aefb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38a24af535d51502874624ed86aefb4f">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredLoop::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga7b26b8de06723564d00d023362df52a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b26b8de06723564d00d023362df52a0">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga50d5a208bec81a4a28c68e24424f7b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50d5a208bec81a4a28c68e24424f7b41">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredTorusBundle::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga81b5f03cbfa4337fddcfbc43bd002204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b5f03cbfa4337fddcfbc43bd002204">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::PluggedTorusBundle::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga2f6e754b606f22e7274b16c2b2e168cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6e754b606f22e7274b16c2b2e168cc">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::PlugTriSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga85df37685a1d128fb6fda90f3a77360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85df37685a1d128fb6fda90f3a77360b">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::SnapPeaCensusTri::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga855f2eed086762360c249660ad634109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga855f2eed086762360c249660ad634109">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SnappedBall::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga5fb7aedbf38fd0e8a5fadf13256acc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb7aedbf38fd0e8a5fadf13256acc87">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SpiralSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaf42be4348d68170c65a146398cc246eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf42be4348d68170c65a146398cc246eb">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TriSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga2c6b86dba9f72df48e1c55cb265e9de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c6b86dba9f72df48e1c55cb265e9de9">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::TrivialTri::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7acaa9c2c1a8abaf4b0f6639fe413037">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gad2d04cae182aa78d8ea98dcac2ee0591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d04cae182aa78d8ea98dcac2ee0591">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TxIDiagonalCore::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7f870c1e82a584830858fb1ebb13e62c">regina::TxICore</a>.</p>

</div>
</div>
<a id="ga4355651bc847facab8d3781a3b6b6740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4355651bc847facab8d3781a3b6b6740">&#9670;&nbsp;</a></span>writeTeXName() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::TxIParallelCore::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this specific triangulation of <code>T x I</code> in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be written.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga7f870c1e82a584830858fb1ebb13e62c">regina::TxICore</a>.</p>

</div>
</div>
<a id="ga130a8ba7b087b1a560891f9f075d443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130a8ba7b087b1a560891f9f075d443c">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatBlock::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1SatBlock.html" title="Represents a saturated block in a Seifert fibred space.">SatBlock</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ad76b1305eb7d9115e0aac71432b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad76b1305eb7d9115e0aac71432b983">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a933ec0aad81b4560f574f4f2e15813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a933ec0aad81b4560f574f4f2e15813">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::StandardTriangulation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__subcomplex.html#ga78fec3514968e13c7ff4b8f900be4c0b">regina::TrivialTri</a>, <a class="el" href="group__subcomplex.html#ga0460017e67a7ddfc3a9af80b3a5a9df2">regina::TriSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga77c0b0517a7e5d1dc6b2c3f9c7ff2818">regina::SpiralSolidTorus</a>, <a class="el" href="group__subcomplex.html#gadb63dc3d3295836b75aaa1303f013921">regina::SnappedBall</a>, <a class="el" href="group__subcomplex.html#ga62026c61dc76949cc5ce03dea53f70b0">regina::PlugTriSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga4278557170643a37470486a03599153d">regina::PluggedTorusBundle</a>, <a class="el" href="group__subcomplex.html#ga08de39903d5532b0957df84fbcae493e">regina::LayeredTorusBundle</a>, <a class="el" href="group__subcomplex.html#gaa8ef1bccde86445eb106d3bd1d866599">regina::LayeredSolidTorus</a>, <a class="el" href="group__subcomplex.html#ga566d5c530d931e15893ca17018b2f216">regina::LayeredLoop</a>, <a class="el" href="group__subcomplex.html#gadc54288677ea5caef65896ad25f4e95b">regina::LayeredLensSpace</a>, <a class="el" href="group__subcomplex.html#gacd44940e8690d4efa5fead8c5b8de349">regina::LayeredChainPair</a>, <a class="el" href="group__subcomplex.html#gadc747857e0e15305fd7e7f59754cd4d8">regina::LayeredChain</a>, <a class="el" href="group__subcomplex.html#ga0e886cf39d12c090959c64ab4787a883">regina::L31Pillow</a>, <a class="el" href="group__subcomplex.html#ga1204d734453ff396ed67e8d4932638c7">regina::BlockedSFSTriple</a>, <a class="el" href="group__subcomplex.html#gaf44d8e2931379c7b16b1df400205363e">regina::BlockedSFSPair</a>, <a class="el" href="group__subcomplex.html#ga2ed6371374a10a805c612b5f82eef296">regina::BlockedSFSLoop</a>, <a class="el" href="group__subcomplex.html#gaaf88cb11f0dc3fa4717cfe0970b0671b">regina::BlockedSFS</a>, and <a class="el" href="group__subcomplex.html#ga62bf0dddd611fb1ac1b0d05f79f50f51">regina::AugTriSolidTorus</a>.</p>

</div>
</div>
<a id="gaa73ec7df4dd1aad29cdffc5ecbf4eca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73ec7df4dd1aad29cdffc5ecbf4eca1">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TxICore::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62bf0dddd611fb1ac1b0d05f79f50f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62bf0dddd611fb1ac1b0d05f79f50f51">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AugTriSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga775f6ef15a3dd8b66fcc72870e0dc2ab" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaaf88cb11f0dc3fa4717cfe0970b0671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf88cb11f0dc3fa4717cfe0970b0671b">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BlockedSFS::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gaf02dd77d605d672d2fede888dd198834" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga2ed6371374a10a805c612b5f82eef296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed6371374a10a805c612b5f82eef296">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BlockedSFSLoop::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gae94a79bcee7ed6a6ba814b1051ed33d9" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaf44d8e2931379c7b16b1df400205363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44d8e2931379c7b16b1df400205363e">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BlockedSFSPair::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gaecafe5270c65cf39f36ae25b75d2269e" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga1204d734453ff396ed67e8d4932638c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1204d734453ff396ed67e8d4932638c7">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BlockedSFSTriple::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gaaf5bc7667dbbe53c399f1cf9eeef3080" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga0e886cf39d12c090959c64ab4787a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e886cf39d12c090959c64ab4787a883">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::L31Pillow::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga5fc8652135bc2920f809dd59bba7ffc6" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gadc747857e0e15305fd7e7f59754cd4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc747857e0e15305fd7e7f59754cd4d8">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredChain::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga146ca193c489eed78b7b26ffeb830576" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gacd44940e8690d4efa5fead8c5b8de349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd44940e8690d4efa5fead8c5b8de349">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredChainPair::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gace8b36a4a2e18d04270e9daed8e30b2e" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gadc54288677ea5caef65896ad25f4e95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc54288677ea5caef65896ad25f4e95b">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredLensSpace::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga31b991706522516fdc20d939bbb38acc" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga566d5c530d931e15893ca17018b2f216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566d5c530d931e15893ca17018b2f216">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredLoop::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga1be965e2c0456e2d5c88f09dd897baf9" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaa8ef1bccde86445eb106d3bd1d866599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8ef1bccde86445eb106d3bd1d866599">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga77d03cc2acaae8ef46a0c64d311b0e04" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga08de39903d5532b0957df84fbcae493e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08de39903d5532b0957df84fbcae493e">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredTorusBundle::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga7030c630c47f79f355fff640be314a4c" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga4278557170643a37470486a03599153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4278557170643a37470486a03599153d">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PluggedTorusBundle::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gac6f73d0f600679abb6ad8bcd8c847609" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga62026c61dc76949cc5ce03dea53f70b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62026c61dc76949cc5ce03dea53f70b0">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PlugTriSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga6294c946a4a3bc67f788875b161a69cf" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gadb63dc3d3295836b75aaa1303f013921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb63dc3d3295836b75aaa1303f013921">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnappedBall::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gab1acb9738f55ad2fac5f297af4774906" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga77c0b0517a7e5d1dc6b2c3f9c7ff2818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c0b0517a7e5d1dc6b2c3f9c7ff2818">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SpiralSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gab3ebbeb5ae8293c3e6ccfb13902d4dd7" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga0460017e67a7ddfc3a9af80b3a5a9df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0460017e67a7ddfc3a9af80b3a5a9df2">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TriSolidTorus::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga45703ff36060192b4d248e30d9eb20cb" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="ga78fec3514968e13c7ff4b8f900be4c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78fec3514968e13c7ff4b8f900be4c0b">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TrivialTri::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#gafe1b90a2eb4bc4680081fd927f265078" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__subcomplex.html#ga1a933ec0aad81b4560f574f4f2e15813">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="gaba11bed9dd6975d36eb65aa3cf3022fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba11bed9dd6975d36eb65aa3cf3022fa">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PillowTwoSphere::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga556a1ced4a7a188ecc761e6f12f068cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556a1ced4a7a188ecc761e6f12f068cf">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatRegion::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e231086b93a4e355f4ead409dfbbe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e231086b93a4e355f4ead409dfbbe05">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SnappedTwoSphere::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11da317c33469df8b5518cecb60b2109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11da317c33469df8b5518cecb60b2109">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::StandardTriangulation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="group__subcomplex.html#ga4dd4f6240a77f6148c66b16dc94922da" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53538bb8ef322ca252e9b9c99119defb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53538bb8ef322ca252e9b9c99119defb">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TxICore::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27450164476537cc702924e8f039947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27450164476537cc702924e8f039947f">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatBlock::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__subcomplex.html#gadbd63b216e4e5eb3c9a609f5e8dc8855">regina::SatLayering</a>, <a class="el" href="group__subcomplex.html#ga30ae58723734d89763e3cd684b89e352">regina::SatReflectorStrip</a>, <a class="el" href="group__subcomplex.html#ga25aceb80b2d715df1fda912b17e3f9ad">regina::SatCube</a>, <a class="el" href="group__subcomplex.html#gac988f9304e4a52b69df5ffc232ec34a1">regina::SatTriPrism</a>, <a class="el" href="group__subcomplex.html#ga4573ce98a10aee74114308c0676a0d32">regina::SatLST</a>, and <a class="el" href="group__subcomplex.html#gab09aa0f965390a7234762f90a5f0d633">regina::SatMobius</a>.</p>

</div>
</div>
<a id="gab09aa0f965390a7234762f90a5f0d633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09aa0f965390a7234762f90a5f0d633">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatMobius::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga4573ce98a10aee74114308c0676a0d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4573ce98a10aee74114308c0676a0d32">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SatLST::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gac988f9304e4a52b69df5ffc232ec34a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac988f9304e4a52b69df5ffc232ec34a1">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatTriPrism::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga25aceb80b2d715df1fda912b17e3f9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25aceb80b2d715df1fda912b17e3f9ad">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatCube::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga30ae58723734d89763e3cd684b89e352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ae58723734d89763e3cd684b89e352">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatReflectorStrip::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="gadbd63b216e4e5eb3c9a609f5e8dc8855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd63b216e4e5eb3c9a609f5e8dc8855">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SatLayering::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__subcomplex.html#ga27450164476537cc702924e8f039947f">regina::SatBlock</a>.</p>

</div>
</div>
<a id="ga29844946ea9d17f3e52920501708641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29844946ea9d17f3e52920501708641f">&#9670;&nbsp;</a></span>~AugTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::AugTriSolidTorus::~AugTriSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this augmented solid torus; note that the corresponding triangular and layered solid tori will also be destroyed. </p>

</div>
</div>
<a id="ga911e5655dafe570fcee17d589ae84584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga911e5655dafe570fcee17d589ae84584">&#9670;&nbsp;</a></span>~BlockedSFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::BlockedSFS::~BlockedSFS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its constituent components. </p>

</div>
</div>
<a id="ga04350ba48303730ce71487a4a08c5320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04350ba48303730ce71487a4a08c5320">&#9670;&nbsp;</a></span>~BlockedSFSLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::BlockedSFSLoop::~BlockedSFSLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its constituent components. </p>

</div>
</div>
<a id="ga71d106ce2902b57c3bd52639322d005b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d106ce2902b57c3bd52639322d005b">&#9670;&nbsp;</a></span>~BlockedSFSPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::BlockedSFSPair::~BlockedSFSPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its constituent components. </p>

</div>
</div>
<a id="ga257511835ac6ed0ff98e4ddf34a22b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257511835ac6ed0ff98e4ddf34a22b9e">&#9670;&nbsp;</a></span>~BlockedSFSTriple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::BlockedSFSTriple::~BlockedSFSTriple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its constituent components. </p>

</div>
</div>
<a id="gac67160931a1cc60efdccbc4134694a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac67160931a1cc60efdccbc4134694a46">&#9670;&nbsp;</a></span>~L31Pillow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::L31Pillow::~L31Pillow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this structure. </p>

</div>
</div>
<a id="gab2c5f5c6057993baac2a5d54c745bfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c5f5c6057993baac2a5d54c745bfcb">&#9670;&nbsp;</a></span>~LayeredChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredChain::~LayeredChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this layered chain. </p>

</div>
</div>
<a id="ga628b9acf04b84e7a07e99cc2884f4ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628b9acf04b84e7a07e99cc2884f4ec5">&#9670;&nbsp;</a></span>~LayeredChainPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredChainPair::~LayeredChainPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this layered chain pair. </p>

</div>
</div>
<a id="ga89826ae497eab85ee80cf649bd4cfd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89826ae497eab85ee80cf649bd4cfd36">&#9670;&nbsp;</a></span>~LayeredLensSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredLensSpace::~LayeredLensSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this lens space; note that the corresponding layered solid torus will also be destroyed. </p>

</div>
</div>
<a id="ga53c59674afef403d5c3bc034d299a2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c59674afef403d5c3bc034d299a2cc">&#9670;&nbsp;</a></span>~LayeredLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredLoop::~LayeredLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this layered loop. </p>

</div>
</div>
<a id="gac9534d53ae665aeb124ee7a6d18a4897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9534d53ae665aeb124ee7a6d18a4897">&#9670;&nbsp;</a></span>~LayeredTorusBundle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::LayeredTorusBundle::~LayeredTorusBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this layered torus bundle and all of its internal components. </p>

</div>
</div>
<a id="ga3cb14a78f6e6b457e58202fb87f0a17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb14a78f6e6b457e58202fb87f0a17e">&#9670;&nbsp;</a></span>~PluggedTorusBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::PluggedTorusBundle::~PluggedTorusBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its constituent components. </p>
<p>As an exception, the thin I-bundle is not destroyed, since it is assumed that this is referenced from elsewhere. </p>

</div>
</div>
<a id="ga370899baafd7e4781742ba91af04d472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370899baafd7e4781742ba91af04d472">&#9670;&nbsp;</a></span>~PlugTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::PlugTriSolidTorus::~PlugTriSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this plugged solid torus; note that the corresponding triangular solid torus and layered chains will also be destroyed. </p>

</div>
</div>
<a id="ga1626a88050fce82a844bb7258b20c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1626a88050fce82a844bb7258b20c3e3">&#9670;&nbsp;</a></span>~SatBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlock::~SatBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all internal arrays. </p>
<p>Note that any adjacent blocks that are referenced by the <em>adjBlock</em> array will <em>not</em> be destroyed. </p>

</div>
</div>
<a id="ga96e7a6b43fc0465af1ddaca4d02d8ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e7a6b43fc0465af1ddaca4d02d8ab9">&#9670;&nbsp;</a></span>~SatBlockStarter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockStarter::~SatBlockStarter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys both the internal triangulation and block structure. </p>

</div>
</div>
<a id="ga652694021bc1c0507f24fd7d2450e7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652694021bc1c0507f24fd7d2450e7c9">&#9670;&nbsp;</a></span>~SatBlockStarterSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatBlockStarterSearcher::~SatBlockStarterSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object and its internal structures. </p>

</div>
</div>
<a id="ga049df8deb0c85fc99539209e07494b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049df8deb0c85fc99539209e07494b7a">&#9670;&nbsp;</a></span>~SatLST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatLST::~SatLST </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and its internal components. </p>

</div>
</div>
<a id="gab38c590b25c141dd36cc47b64db6588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38c590b25c141dd36cc47b64db6588c">&#9670;&nbsp;</a></span>~SatRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SatRegion::~SatRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this structure and all of its internal data, including the individual blocks that make up this region. </p>

</div>
</div>
<a id="ga562cdb2d0d0fedcafd311649a8188366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562cdb2d0d0fedcafd311649a8188366">&#9670;&nbsp;</a></span>~SnappedTwoSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SnappedTwoSphere::~SnappedTwoSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this snapped 2-sphere; note that the corresponding snapped 3-balls will also be destroyed. </p>

</div>
</div>
<a id="gae8408a546f06acc1d53b4710fe4c9062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8408a546f06acc1d53b4710fe4c9062">&#9670;&nbsp;</a></span>~SpiralSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SpiralSolidTorus::~SpiralSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this spiralled solid torus. </p>

</div>
</div>
<a id="gae151285bffbeaa55a7fc0ed1db4e0ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae151285bffbeaa55a7fc0ed1db4e0ff8">&#9670;&nbsp;</a></span>~StandardTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::StandardTriangulation::~StandardTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A destructor that does nothing. </p>

</div>
</div>
<a id="ga70b53a3215c260f91b3f0b8c51688f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70b53a3215c260f91b3f0b8c51688f02">&#9670;&nbsp;</a></span>~TriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TriSolidTorus::~TriSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this solid torus. </p>

</div>
</div>
<a id="ga9850d79cfe4c9848a42087d5e0f2e707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9850d79cfe4c9848a42087d5e0f2e707">&#9670;&nbsp;</a></span>~TxICore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TxICore::~TxICore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga8cbbe922c434c19fc44f84efe43beb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cbbe922c434c19fc44f84efe43beb89">&#9670;&nbsp;</a></span>adjAnnulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned* regina::SatBlock::adjAnnulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block. </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="gaafcda28943ad300bcfd713f8bb4f59a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcda28943ad300bcfd713f8bb4f59a8">&#9670;&nbsp;</a></span>adjBackwards_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjBackwards_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is backwards (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="ga6fb04cbf5461053c069fe67c54584c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb04cbf5461053c069fe67c54584c04">&#9670;&nbsp;</a></span>adjBlock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>** regina::SatBlock::adjBlock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known. </p>

</div>
</div>
<a id="ga88f9015c09cdd1987f7c3d1af08bf777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f9015c09cdd1987f7c3d1af08bf777">&#9670;&nbsp;</a></span>adjReflected_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::SatBlock::adjReflected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is reflected (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a id="ga66a97514c4f3ee1dea5a0331e1161417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a97514c4f3ee1dea5a0331e1161417">&#9670;&nbsp;</a></span>annulus_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SatAnnulus.html">SatAnnulus</a>* regina::SatBlock::annulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Details of each boundary annulus, as seen from the inside of this saturated block. </p>

</div>
</div>
<a id="ga59b687c152c73ab8b8adc240a23cf4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59b687c152c73ab8b8adc240a23cf4f2">&#9670;&nbsp;</a></span>BALL_3_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::BALL_3_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the one-tetrahedron three-vertex triangulation of the ball. </p>
<p>This is a single tetrahedron with two faces as boundary and the other two faces folded together. </p>

</div>
</div>
<a id="ga5b125d48f87efab2d32aa80052ac1fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b125d48f87efab2d32aa80052ac1fef">&#9670;&nbsp;</a></span>BALL_4_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::BALL_4_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the one-tetrahedron four-vertex triangulation of the ball. </p>
<p>This is a single tetrahedron with all four faces as boundary. </p>

</div>
</div>
<a id="gaba82836fafd0b2d378bca3f6c15e7e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba82836fafd0b2d378bca3f6c15e7e81">&#9670;&nbsp;</a></span>bdryReln_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> regina::TxICore::bdryReln_[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expresses the <em>alpha</em> and <em>beta</em> curves for each torus boundary in terms of specific tetrahedron edges and vertices. </p>
<p>The elements <em>bdryReln_</em>[0] and <em>bdryReln_</em>[1] refer to the upper and lower boundaries respectively, and each of these matrices must have determinant +1 or -1. See <a class="el" href="group__subcomplex.html#ga946dfcbcf575fc6bdadfcd62cb3fdccb" title="Returns a 2-by-2 matrix describing the alpha and beta curves on a torus boundary in terms of specific...">bdryReln()</a> for further details. </p>

</div>
</div>
<a id="ga81976d1f21f260327f4597cff60ac386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81976d1f21f260327f4597cff60ac386">&#9670;&nbsp;</a></span>bdryRoles_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::TxICore::bdryRoles_[2][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which tetrahedron vertices play which roles in the upper and lower boundary triangles. </p>
<p>See <a class="el" href="group__subcomplex.html#gaf88a3493c1bccb2599849f69f9f2ad9d" title="Describes which tetrahedron vertices play which roles in the upper and lower boundary triangles.">bdryRoles()</a> for details. </p>

</div>
</div>
<a id="ga4fe7fec4109bf0087d816d05dae09ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe7fec4109bf0087d816d05dae09ca7">&#9670;&nbsp;</a></span>bdryTet_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::TxICore::bdryTet_[2][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The tetrahedra that provide the upper and lower boundary triangles. </p>
<p>See <a class="el" href="group__subcomplex.html#ga20ce48c06e18758687bb6ab9e45dda28" title="Determines which tetrahedron provides the requested boundary triangle.">bdryTet()</a> for details. </p>

</div>
</div>
<a id="ga7e16981731ba029e6f8f35979bbfd940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e16981731ba029e6f8f35979bbfd940">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SatBlock.html">SatBlock</a>* regina::SatBlockSpec::block</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Details of the saturated block structure. </p>

</div>
</div>
<a id="ga41597d71000c96063637a84f1f6c3604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41597d71000c96063637a84f1f6c3604">&#9670;&nbsp;</a></span>CHAIN_AXIS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::AugTriSolidTorus::CHAIN_AXIS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that this augmented triangular solid torus contains a layered chain attached as described by <a class="el" href="group__subcomplex.html#ga3126bafc3f63fb842e54a0bf9aa814dd" title="Determines whether the two given annuli are linked in a particular fashion by a layered chain.">TriSolidTorus::areAnnuliLinkedAxis()</a>. </p>

</div>
</div>
<a id="gae8a8a06e97b050a573b90a0bfe3297bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8a8a06e97b050a573b90a0bfe3297bf">&#9670;&nbsp;</a></span>CHAIN_MAJOR <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::AugTriSolidTorus::CHAIN_MAJOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that this augmented triangular solid torus contains a layered chain attached as described by <a class="el" href="group__subcomplex.html#ga646e2a25cdee5230abff81fe108b54ed" title="Determines whether the two given annuli are linked in a particular fashion by a layered chain.">TriSolidTorus::areAnnuliLinkedMajor()</a>. </p>

</div>
</div>
<a id="gad0ae24f77c013e50bf815baf85de650a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0ae24f77c013e50bf815baf85de650a">&#9670;&nbsp;</a></span>CHAIN_MAJOR <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::PlugTriSolidTorus::CHAIN_MAJOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates an annulus on the triangular solid torus boundary with an attached layered chain layered over the major edge of the annulus. </p>

</div>
</div>
<a id="ga04e748de2c6f928a14e4a338d068884c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e748de2c6f928a14e4a338d068884c">&#9670;&nbsp;</a></span>CHAIN_MINOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::PlugTriSolidTorus::CHAIN_MINOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates an annulus on the triangular solid torus boundary with an attached layered chain layered over the minor edge of the annulus. </p>

</div>
</div>
<a id="ga8f4588843946303e81dcf3389053551a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f4588843946303e81dcf3389053551a">&#9670;&nbsp;</a></span>CHAIN_NONE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::AugTriSolidTorus::CHAIN_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that this augmented triangular solid torus contains no layered chain. </p>

</div>
</div>
<a id="gadafc2cafca8f5176e96f515a03f2673a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadafc2cafca8f5176e96f515a03f2673a">&#9670;&nbsp;</a></span>CHAIN_NONE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::PlugTriSolidTorus::CHAIN_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates an annulus on the triangular solid torus boundary with no attached layered chain. </p>

</div>
</div>
<a id="ga6481f02fef54047d443ad6b2e03caf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6481f02fef54047d443ad6b2e03caf32">&#9670;&nbsp;</a></span>core_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt; regina::TxICore::core_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A full copy of the <code>T x I</code> triangulation that is described. </p>

</div>
</div>
<a id="ga3581a2811f95bc535e9222537d59bb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3581a2811f95bc535e9222537d59bb9c">&#9670;&nbsp;</a></span>EQUATOR_MAJOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::PlugTriSolidTorus::EQUATOR_MAJOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that, if no layered chains were present, the equator of the plug would consist of major edges of the core triangular solid torus. </p>

</div>
</div>
<a id="ga0f37b28522211bad751741c1c5ceb01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f37b28522211bad751741c1c5ceb01e">&#9670;&nbsp;</a></span>EQUATOR_MINOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::PlugTriSolidTorus::EQUATOR_MINOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that, if no layered chains were present, the equator of the plug would consist of minor edges of the core triangular solid torus. </p>

</div>
</div>
<a id="gac7951dbfdbe4e28bd2f4843068ecc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7951dbfdbe4e28bd2f4843068ecc03c">&#9670;&nbsp;</a></span>N2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::N2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the two-tetrahedron triangulation N(2) of the twisted 2-sphere bundle over the circle. </p>

</div>
</div>
<a id="ga4eda6b8d1897102416697ad2c3dcf382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eda6b8d1897102416697ad2c3dcf382">&#9670;&nbsp;</a></span>N3_1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::N3_1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the three-tetrahedron triangulation N(3,1) of the projective plane bundle over the circle. </p>
<p>This particular triangulation has no Mobius band triangles. </p>

</div>
</div>
<a id="ga93fc47119509108a4e501e61a849917d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fc47119509108a4e501e61a849917d">&#9670;&nbsp;</a></span>N3_2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::N3_2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the three-tetrahedron triangulation N(3,2) of the projective plane bundle over the circle. </p>
<p>This particular triangulation has two Mobius band triangles. </p>

</div>
</div>
<a id="gaca51e567fe4ca52128747f0ea2c6cf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca51e567fe4ca52128747f0ea2c6cf4c">&#9670;&nbsp;</a></span>nAnnuli_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::SatBlock::nAnnuli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary annuli. </p>

</div>
</div>
<a id="ga0354d7f37aa48d265bdc514787dcf781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0354d7f37aa48d265bdc514787dcf781">&#9670;&nbsp;</a></span>parallelReln_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> regina::TxICore::parallelReln_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expresses the lower <em>alpha</em> and <em>beta</em> curves in terms of the upper <em>alpha</em> and <em>beta</em> curves. </p>
<p>See <a class="el" href="group__subcomplex.html#gae3daec5c7c16c43b461d123cdf37fd66" title="Returns a 2-by-2 matrix describing the parallel relationship between the upper and lower boundary cur...">parallelReln()</a> for details. </p>

</div>
</div>
<a id="ga4c8a8aa4ea84450e7ee5d00a1f00c201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c8a8aa4ea84450e7ee5d00a1f00c201">&#9670;&nbsp;</a></span>refHoriz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlockSpec::refHoriz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the block is reflected horizontally within the larger region. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="gacf57ea9d6d91f042edc88fa87f25362e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf57ea9d6d91f042edc88fa87f25362e">&#9670;&nbsp;</a></span>refVert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlockSpec::refVert</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the block is reflected vertically within the larger region. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="ga561aae549a9dc09de541ea0b76dfcc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga561aae549a9dc09de541ea0b76dfcc7a">&#9670;&nbsp;</a></span>roles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::SatAnnulus::roles[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes how the first and second triangles match up with individual tetrahedron vertices. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="ga4d7e98565057fa204a67b74f6a5b7eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7e98565057fa204a67b74f6a5b7eac">&#9670;&nbsp;</a></span>SEC_5</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusTri::SEC_5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of triangulations formed from five or fewer tetrahedra (both orientable and non-orientable). </p>
<p>There are 415 triangulations in this section. </p>

</div>
</div>
<a id="ga8c6a591789471ebf9ea0783f88dbc9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c6a591789471ebf9ea0783f88dbc9ff">&#9670;&nbsp;</a></span>SEC_6_NOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusTri::SEC_6_NOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of non-orientable triangulations formed from six tetrahedra. </p>
<p>There are 259 triangulations in this section. </p>

</div>
</div>
<a id="ga51c625971e3eee4d78ea43e94464ab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c625971e3eee4d78ea43e94464ab3f">&#9670;&nbsp;</a></span>SEC_6_OR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusTri::SEC_6_OR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of orientable triangulations formed from six tetrahedra. </p>
<p>There are 962 triangulations in this section. </p>

</div>
</div>
<a id="ga4b03ab09b3cf522bb398cd545b653e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b03ab09b3cf522bb398cd545b653e32">&#9670;&nbsp;</a></span>SEC_7_NOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusTri::SEC_7_NOR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of non-orientable triangulations formed from seven tetrahedra. </p>
<p>There are 887 triangulations in this section. </p>

</div>
</div>
<a id="ga33c7ea5e086fa20f70d69bec9ce9642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33c7ea5e086fa20f70d69bec9ce9642a">&#9670;&nbsp;</a></span>SEC_7_OR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::SnapPeaCensusTri::SEC_7_OR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the collection of orientable triangulations formed from seven tetrahedra. </p>
<p>There are 3552 triangulations in this section. </p>

</div>
</div>
<a id="ga93bae69ab4116d0b4ca42d56a8eda10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93bae69ab4116d0b4ca42d56a8eda10a">&#9670;&nbsp;</a></span>SPHERE_4_VERTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::TrivialTri::SPHERE_4_VERTEX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the two-tetrahedron four-vertex triangulation of the 3-sphere. </p>

</div>
</div>
<a id="ga4e63bfd1ccfca9404d9af26e0f5bcfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e63bfd1ccfca9404d9af26e0f5bcfb3">&#9670;&nbsp;</a></span>tet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;* regina::SatAnnulus::tet[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes which tetrahedra provide the first and second triangles. </p>
<p>See the class notes for details. </p>

</div>
</div>
<a id="gab46bf466819a76108db37eb218c4a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab46bf466819a76108db37eb218c4a458">&#9670;&nbsp;</a></span>twistedBoundary_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SatBlock::twistedBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a Mobius band? </p>

</div>
</div>
<a id="ga510583f2a4753522bcc088fe980440af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga510583f2a4753522bcc088fe980440af">&#9670;&nbsp;</a></span>usedTets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__subcomplex.html#ga3f4ac64f5f274a2dd743ce10ce533303">SatBlock::TetList</a> regina::SatBlockStarterSearcher::usedTets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of which tetrahedra have used by the current embedding of the current starter block. </p>
<p>See <a class="el" href="group__subcomplex.html#ga3b34926e074563265cddbf5c1a4c05c0" title="Used by subclasses to process each starter block embedding that is found.">useStarterBlock()</a> for further details. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
