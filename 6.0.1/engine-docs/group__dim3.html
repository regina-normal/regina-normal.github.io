<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: 3-Manifold Triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">3-Manifold Triangulations</div>  </div>
</div><!--header-->
<div class="contents">

<p>Details for implementing triangulations of 3-manifolds.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoundaryComponent_3_013_01_4.html">regina::BoundaryComponent&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component of the boundary of a 3-manifold triangulation.  <a href="classregina_1_1BoundaryComponent_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Component_3_013_01_4.html">regina::Component&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a connected component of a 3-manifold triangulation.  <a href="classregina_1_1Component_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html">regina::Face&lt; 3, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a tetrahedron within a 3-manifold triangulation.  <a href="classregina_1_1Face_3_013_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_012_01_4.html">regina::Face&lt; 3, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a triangle in the skeleton of a 3-manifold triangulation.  <a href="classregina_1_1Face_3_013_00_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_013_01_4.html">regina::Triangulation&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3-dimensional triangulation, typically of a 3-manifold.  <a href="classregina_1_1Triangulation_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html">regina::Face&lt; 3, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vertex in the skeleton of a 3-manifold triangulation.  <a href="classregina_1_1Face_3_013_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga40b86bb6bd77635ae7474c169cee2916"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga40b86bb6bd77635ae7474c169cee2916">regina::NBoundaryComponent</a></td></tr>
<tr class="memdesc:ga40b86bb6bd77635ae7474c169cee2916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#ga40b86bb6bd77635ae7474c169cee2916">More...</a><br /></td></tr>
<tr class="separator:ga40b86bb6bd77635ae7474c169cee2916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b188ec182ddb0b3972db58baa815b6b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3b188ec182ddb0b3972db58baa815b6b">regina::NComponent</a></td></tr>
<tr class="memdesc:ga3b188ec182ddb0b3972db58baa815b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#ga3b188ec182ddb0b3972db58baa815b6b">More...</a><br /></td></tr>
<tr class="separator:ga3b188ec182ddb0b3972db58baa815b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4515e68a1557dda62baabe15c060ed9c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4515e68a1557dda62baabe15c060ed9c">regina::NTetrahedron</a></td></tr>
<tr class="memdesc:ga4515e68a1557dda62baabe15c060ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#ga4515e68a1557dda62baabe15c060ed9c">More...</a><br /></td></tr>
<tr class="separator:ga4515e68a1557dda62baabe15c060ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe4c3553ac238df7a0a0d3bacd754b6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; 3, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gacbe4c3553ac238df7a0a0d3bacd754b6">regina::NTriangleEmbedding</a></td></tr>
<tr class="memdesc:gacbe4c3553ac238df7a0a0d3bacd754b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#gacbe4c3553ac238df7a0a0d3bacd754b6">More...</a><br /></td></tr>
<tr class="separator:gacbe4c3553ac238df7a0a0d3bacd754b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc42b6c6fab71011ed72206a70849ff4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gadc42b6c6fab71011ed72206a70849ff4">regina::NTriangle</a></td></tr>
<tr class="memdesc:gadc42b6c6fab71011ed72206a70849ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#gadc42b6c6fab71011ed72206a70849ff4">More...</a><br /></td></tr>
<tr class="separator:gadc42b6c6fab71011ed72206a70849ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ed43a36b0cc25726e9438260710681"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga38ed43a36b0cc25726e9438260710681">regina::Triangulation&lt; 3 &gt;::TetrahedronIterator</a></td></tr>
<tr class="memdesc:ga38ed43a36b0cc25726e9438260710681"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for SimplexIterator, used to iterate through tetrahedra.  <a href="group__dim3.html#ga38ed43a36b0cc25726e9438260710681">More...</a><br /></td></tr>
<tr class="separator:ga38ed43a36b0cc25726e9438260710681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b908f31770d4d6579cd5e6033e8e04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 3, 2 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gac7b908f31770d4d6579cd5e6033e8e04">regina::Triangulation&lt; 3 &gt;::TriangleIterator</a></td></tr>
<tr class="memdesc:gac7b908f31770d4d6579cd5e6033e8e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through triangles.  <a href="group__dim3.html#gac7b908f31770d4d6579cd5e6033e8e04">More...</a><br /></td></tr>
<tr class="separator:gac7b908f31770d4d6579cd5e6033e8e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644596a866ce7bc0d777415663fd7a8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 3, 1 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga644596a866ce7bc0d777415663fd7a8f">regina::Triangulation&lt; 3 &gt;::EdgeIterator</a></td></tr>
<tr class="memdesc:ga644596a866ce7bc0d777415663fd7a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through edges.  <a href="group__dim3.html#ga644596a866ce7bc0d777415663fd7a8f">More...</a><br /></td></tr>
<tr class="separator:ga644596a866ce7bc0d777415663fd7a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167d59f6b80199dd25614a1a93f1c636"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 3, 0 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga167d59f6b80199dd25614a1a93f1c636">regina::Triangulation&lt; 3 &gt;::VertexIterator</a></td></tr>
<tr class="memdesc:ga167d59f6b80199dd25614a1a93f1c636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through vertices.  <a href="group__dim3.html#ga167d59f6b80199dd25614a1a93f1c636">More...</a><br /></td></tr>
<tr class="separator:ga167d59f6b80199dd25614a1a93f1c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3efba468e41908d82bf24996745397fb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; unsigned long, bool &gt;, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3efba468e41908d82bf24996745397fb">regina::Triangulation&lt; 3 &gt;::TuraevViroSet</a></td></tr>
<tr class="memdesc:ga3efba468e41908d82bf24996745397fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from (<em>r</em>, <em>parity</em>) pairs to Turaev-Viro invariants, as described by <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a>.  <a href="group__dim3.html#ga3efba468e41908d82bf24996745397fb">More...</a><br /></td></tr>
<tr class="separator:ga3efba468e41908d82bf24996745397fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2d67a282de290d5e033d14f3dce9f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4c2d67a282de290d5e033d14f3dce9f3">regina::NTriangulation</a></td></tr>
<tr class="memdesc:ga4c2d67a282de290d5e033d14f3dce9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#ga4c2d67a282de290d5e033d14f3dce9f3">More...</a><br /></td></tr>
<tr class="separator:ga4c2d67a282de290d5e033d14f3dce9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec69256bc1b8d097dfceddbfc7ba7fb0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaec69256bc1b8d097dfceddbfc7ba7fb0">regina::NEdgeEmbedding</a></td></tr>
<tr class="memdesc:gaec69256bc1b8d097dfceddbfc7ba7fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#gaec69256bc1b8d097dfceddbfc7ba7fb0">More...</a><br /></td></tr>
<tr class="separator:gaec69256bc1b8d097dfceddbfc7ba7fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed636d94ab36840468359b75ef77fcb3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaed636d94ab36840468359b75ef77fcb3">regina::NEdge</a></td></tr>
<tr class="memdesc:gaed636d94ab36840468359b75ef77fcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#gaed636d94ab36840468359b75ef77fcb3">More...</a><br /></td></tr>
<tr class="separator:gaed636d94ab36840468359b75ef77fcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793f31b50b818ee88993c83b57a07f8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; 3, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga793f31b50b818ee88993c83b57a07f8f">regina::NVertexEmbedding</a></td></tr>
<tr class="memdesc:ga793f31b50b818ee88993c83b57a07f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#ga793f31b50b818ee88993c83b57a07f8f">More...</a><br /></td></tr>
<tr class="separator:ga793f31b50b818ee88993c83b57a07f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab74e629471cd39954cfd0ead65c265"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gadab74e629471cd39954cfd0ead65c265">regina::NVertex</a></td></tr>
<tr class="memdesc:gadab74e629471cd39954cfd0ead65c265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__dim3.html#gadab74e629471cd39954cfd0ead65c265">More...</a><br /></td></tr>
<tr class="separator:gadab74e629471cd39954cfd0ead65c265"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaca65058d771fc756610f20b7eb45061"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaaca65058d771fc756610f20b7eb45061">regina::Face&lt; 3, 2 &gt;::Type</a> { <br />
&#160;&#160;<a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061a7a0e23ebad3d1672fc6c576a59676804">regina::Face&lt; 3, 2 &gt;::UNKNOWN_TYPE</a> = 0
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061ada796135a96c29bde25a2a044ba3c15a">regina::Face&lt; 3, 2 &gt;::TRIANGLE</a> = 1
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061a2b9bc8cabccceb365ce973569f1278f3">regina::Face&lt; 3, 2 &gt;::SCARF</a> = 2
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061a01ac79fd508080388bc28429326c0fd1">regina::Face&lt; 3, 2 &gt;::PARACHUTE</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061a4be9fb00f7b51b7362ac8de850b26a7f">regina::Face&lt; 3, 2 &gt;::CONE</a> = 4
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061aa31a608dcfddd14ab3880668e2fe0a35">regina::Face&lt; 3, 2 &gt;::MOBIUS</a> = 5
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061a16bb6ddb23de36209a94fcebf67910f0">regina::Face&lt; 3, 2 &gt;::HORN</a> = 6
, <a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061ae506dc8a3c413c8716b66091b518c183">regina::Face&lt; 3, 2 &gt;::DUNCEHAT</a> = 7
, <br />
&#160;&#160;<a class="el" href="group__dim3.html#ggaaca65058d771fc756610f20b7eb45061addf287abeb174ff57223a7cadfd76279">regina::Face&lt; 3, 2 &gt;::L31</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:gaaca65058d771fc756610f20b7eb45061"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>type</em> of a triangle, which indicates how the vertices and edges of the triangle are identified together.  <a href="group__dim3.html#gaaca65058d771fc756610f20b7eb45061">More...</a><br /></td></tr>
<tr class="separator:gaaca65058d771fc756610f20b7eb45061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a34beeab677315bd4b5e0091ea1645c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3a34beeab677315bd4b5e0091ea1645c">regina::Face&lt; 3, 0 &gt;::LinkType</a> { <br />
&#160;&#160;<a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645ca2bf5faa23b062281a1a2320d1337bc05">regina::Face&lt; 3, 0 &gt;::SPHERE</a> = 1
, <a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645ca8672c0ae2f51ee6e3f9af4941bfb76d2">regina::Face&lt; 3, 0 &gt;::DISC</a> = 2
, <a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645ca82cce2a6053a92d04efaa1135d425220">regina::Face&lt; 3, 0 &gt;::TORUS</a> = 3
, <a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645caccb5da4a6cddf14df333422dd5c24aec">regina::Face&lt; 3, 0 &gt;::KLEIN_BOTTLE</a> = 4
, <br />
&#160;&#160;<a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645caf19fa3672680ee945e836b6fbae0ef17">regina::Face&lt; 3, 0 &gt;::NON_STANDARD_CUSP</a> = 5
, <a class="el" href="group__dim3.html#gga3a34beeab677315bd4b5e0091ea1645ca1971e44e60c0052a04c8f02e20e0e2a3">regina::Face&lt; 3, 0 &gt;::INVALID</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:ga3a34beeab677315bd4b5e0091ea1645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categorises the possible links of a vertex into a small number of common types.  <a href="group__dim3.html#ga3a34beeab677315bd4b5e0091ea1645c">More...</a><br /></td></tr>
<tr class="separator:ga3a34beeab677315bd4b5e0091ea1645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b2c840bbe581f5fe58a4cb8e57e3702"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1b2c840bbe581f5fe58a4cb8e57e3702">regina::BoundaryComponent&lt; 3 &gt;::eulerChar</a> () const</td></tr>
<tr class="memdesc:ga1b2c840bbe581f5fe58a4cb8e57e3702"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this boundary component.  <a href="group__dim3.html#ga1b2c840bbe581f5fe58a4cb8e57e3702">More...</a><br /></td></tr>
<tr class="separator:ga1b2c840bbe581f5fe58a4cb8e57e3702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8fe30054307cdec4b14e06b545b5a2"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga1f8fe30054307cdec4b14e06b545b5a2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1f8fe30054307cdec4b14e06b545b5a2">regina::Component&lt; 3 &gt;::countFaces</a> () const</td></tr>
<tr class="memdesc:ga1f8fe30054307cdec4b14e06b545b5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this component.  <a href="group__dim3.html#ga1f8fe30054307cdec4b14e06b545b5a2">More...</a><br /></td></tr>
<tr class="separator:ga1f8fe30054307cdec4b14e06b545b5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a890230af4297f0a2f805804bcee58"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga60a890230af4297f0a2f805804bcee58"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, subdim &gt; * &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga60a890230af4297f0a2f805804bcee58">regina::Component&lt; 3 &gt;::faces</a> () const</td></tr>
<tr class="memdesc:ga60a890230af4297f0a2f805804bcee58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the list of all <em>subdim</em>-faces in this component.  <a href="group__dim3.html#ga60a890230af4297f0a2f805804bcee58">More...</a><br /></td></tr>
<tr class="separator:ga60a890230af4297f0a2f805804bcee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119c71aa7d6bd0f9317806d05cf138fe"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga119c71aa7d6bd0f9317806d05cf138fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; 3, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga119c71aa7d6bd0f9317806d05cf138fe">regina::Component&lt; 3 &gt;::face</a> (size_t <a class="el" href="group__detail.html#ga2e104f0a39be4e2167aa83588608102b">index</a>) const</td></tr>
<tr class="memdesc:ga119c71aa7d6bd0f9317806d05cf138fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face in this component.  <a href="group__dim3.html#ga119c71aa7d6bd0f9317806d05cf138fe">More...</a><br /></td></tr>
<tr class="separator:ga119c71aa7d6bd0f9317806d05cf138fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cf63fc33430bf03ef2bfb08900b6b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae2cf63fc33430bf03ef2bfb08900b6b4">regina::Component&lt; 3 &gt;::isIdeal</a> () const</td></tr>
<tr class="memdesc:gae2cf63fc33430bf03ef2bfb08900b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this component is ideal.  <a href="group__dim3.html#gae2cf63fc33430bf03ef2bfb08900b6b4">More...</a><br /></td></tr>
<tr class="separator:gae2cf63fc33430bf03ef2bfb08900b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef53f62c988b090ce5f9e398f9066d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gabef53f62c988b090ce5f9e398f9066d3">regina::Component&lt; 3 &gt;::isClosed</a> () const</td></tr>
<tr class="memdesc:gabef53f62c988b090ce5f9e398f9066d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this component is closed.  <a href="group__dim3.html#gabef53f62c988b090ce5f9e398f9066d3">More...</a><br /></td></tr>
<tr class="separator:gabef53f62c988b090ce5f9e398f9066d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674b8434d6c9baf99d39748d5b76cd2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga674b8434d6c9baf99d39748d5b76cd2a">regina::Face&lt; 3, 3 &gt;::adjacentTetrahedron</a> (int <a class="el" href="group__detail.html#ga727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:ga674b8434d6c9baf99d39748d5b76cd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#gad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a>.  <a href="group__dim3.html#ga674b8434d6c9baf99d39748d5b76cd2a">More...</a><br /></td></tr>
<tr class="separator:ga674b8434d6c9baf99d39748d5b76cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccf140ce8a41c983d22111160ec2d8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga0ccf140ce8a41c983d22111160ec2d8b">regina::Face&lt; 3, 3 &gt;::adjacentFace</a> (int <a class="el" href="group__detail.html#ga727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:ga0ccf140ce8a41c983d22111160ec2d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#ga09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a>.  <a href="group__dim3.html#ga0ccf140ce8a41c983d22111160ec2d8b">More...</a><br /></td></tr>
<tr class="separator:ga0ccf140ce8a41c983d22111160ec2d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76885f1024082f3d43fc80b84d4ea08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dim3.html#gaaca65058d771fc756610f20b7eb45061">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f">regina::Face&lt; 3, 2 &gt;::type</a> ()</td></tr>
<tr class="memdesc:ga76885f1024082f3d43fc80b84d4ea08f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a description of the triangle type.  <a href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f">More...</a><br /></td></tr>
<tr class="separator:ga76885f1024082f3d43fc80b84d4ea08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga327e1fe59736942aecf5acf451822679"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga327e1fe59736942aecf5acf451822679">regina::Face&lt; 3, 2 &gt;::subtype</a> ()</td></tr>
<tr class="memdesc:ga327e1fe59736942aecf5acf451822679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the triangle vertex or triangle edge that plays a special role for the triangle type of this triangle.  <a href="group__dim3.html#ga327e1fe59736942aecf5acf451822679">More...</a><br /></td></tr>
<tr class="separator:ga327e1fe59736942aecf5acf451822679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e831408180b6c804d8fb3b1842d3b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga46e831408180b6c804d8fb3b1842d3b5">regina::Face&lt; 3, 2 &gt;::isMobiusBand</a> ()</td></tr>
<tr class="memdesc:ga46e831408180b6c804d8fb3b1842d3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangle is wrapped up to form a Mobius band.  <a href="group__dim3.html#ga46e831408180b6c804d8fb3b1842d3b5">More...</a><br /></td></tr>
<tr class="separator:ga46e831408180b6c804d8fb3b1842d3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1508686718374e81f50b5d3ca694f83a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1508686718374e81f50b5d3ca694f83a">regina::Face&lt; 3, 2 &gt;::isCone</a> ()</td></tr>
<tr class="memdesc:ga1508686718374e81f50b5d3ca694f83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangle is wrapped up to form a cone.  <a href="group__dim3.html#ga1508686718374e81f50b5d3ca694f83a">More...</a><br /></td></tr>
<tr class="separator:ga1508686718374e81f50b5d3ca694f83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab375e6c4829ff149955889353050935c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gab375e6c4829ff149955889353050935c">regina::Face&lt; 3, 0 &gt;::~Face</a> ()</td></tr>
<tr class="memdesc:gab375e6c4829ff149955889353050935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="group__dim3.html#gab375e6c4829ff149955889353050935c">More...</a><br /></td></tr>
<tr class="separator:gab375e6c4829ff149955889353050935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62065e3c545bc03eead5ea324218fb6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dim3.html#ga3a34beeab677315bd4b5e0091ea1645c">LinkType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga62065e3c545bc03eead5ea324218fb6d">regina::Face&lt; 3, 0 &gt;::link</a> () const</td></tr>
<tr class="memdesc:ga62065e3c545bc03eead5ea324218fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a broad categorisation of the link of the vertex.  <a href="group__dim3.html#ga62065e3c545bc03eead5ea324218fb6d">More...</a><br /></td></tr>
<tr class="separator:ga62065e3c545bc03eead5ea324218fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab249ca6c2debe19f475562cf16607fc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9">regina::Face&lt; 3, 0 &gt;::buildLink</a> () const</td></tr>
<tr class="memdesc:gab249ca6c2debe19f475562cf16607fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex.  <a href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9">More...</a><br /></td></tr>
<tr class="separator:gab249ca6c2debe19f475562cf16607fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45022906dce3d868e59a845cffe5763d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga45022906dce3d868e59a845cffe5763d">regina::Face&lt; 3, 0 &gt;::buildLinkDetail</a> (bool labels=true, <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; **inclusion=0) const</td></tr>
<tr class="memdesc:ga45022906dce3d868e59a845cffe5763d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex.  <a href="group__dim3.html#ga45022906dce3d868e59a845cffe5763d">More...</a><br /></td></tr>
<tr class="separator:ga45022906dce3d868e59a845cffe5763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e01e4f5bbef0e84445d22ca6893c213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga7e01e4f5bbef0e84445d22ca6893c213">regina::Face&lt; 3, 0 &gt;::isLinkClosed</a> () const</td></tr>
<tr class="memdesc:ga7e01e4f5bbef0e84445d22ca6893c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the link of this vertex is closed.  <a href="group__dim3.html#ga7e01e4f5bbef0e84445d22ca6893c213">More...</a><br /></td></tr>
<tr class="separator:ga7e01e4f5bbef0e84445d22ca6893c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01930771735b8e8e038961938a19a994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga01930771735b8e8e038961938a19a994">regina::Face&lt; 3, 0 &gt;::isIdeal</a> () const</td></tr>
<tr class="memdesc:ga01930771735b8e8e038961938a19a994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vertex is an ideal vertex.  <a href="group__dim3.html#ga01930771735b8e8e038961938a19a994">More...</a><br /></td></tr>
<tr class="separator:ga01930771735b8e8e038961938a19a994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeed70df6add0c2808c22244f7e1dbbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gafeed70df6add0c2808c22244f7e1dbbd">regina::Face&lt; 3, 0 &gt;::isStandard</a> () const</td></tr>
<tr class="memdesc:gafeed70df6add0c2808c22244f7e1dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vertex is standard.  <a href="group__dim3.html#gafeed70df6add0c2808c22244f7e1dbbd">More...</a><br /></td></tr>
<tr class="separator:gafeed70df6add0c2808c22244f7e1dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262af8b8587ab08281ed6f80aca226fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga262af8b8587ab08281ed6f80aca226fb">regina::Face&lt; 3, 0 &gt;::linkEulerChar</a> () const</td></tr>
<tr class="memdesc:ga262af8b8587ab08281ed6f80aca226fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the vertex link.  <a href="group__dim3.html#ga262af8b8587ab08281ed6f80aca226fb">More...</a><br /></td></tr>
<tr class="separator:ga262af8b8587ab08281ed6f80aca226fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df7d8a6ae50bff8311eb873daccb9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga9df7d8a6ae50bff8311eb873daccb9e9">regina::Face&lt; 3, 0 &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga9df7d8a6ae50bff8311eb873daccb9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__dim3.html#ga9df7d8a6ae50bff8311eb873daccb9e9">More...</a><br /></td></tr>
<tr class="separator:ga9df7d8a6ae50bff8311eb873daccb9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BoundaryComponent&lt; 3 &gt;::Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top"><a id="ga830f8fd15be1fd552a1b44d4801d89e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BoundaryComponent&lt; 3 &gt;::detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Component&lt; 3 &gt;::Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top"><a id="ga830f8fd15be1fd552a1b44d4801d89e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Component&lt; 3 &gt;::detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 3 &gt;::Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga830f8fd15be1fd552a1b44d4801d89e8">regina::Face&lt; 3, 3 &gt;::detail::TriangulationBase&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow access to private members.  <a href="group__dim3.html#ga830f8fd15be1fd552a1b44d4801d89e8">More...</a><br /></td></tr>
<tr class="separator:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 2 &gt;::Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top"><a id="ga830f8fd15be1fd552a1b44d4801d89e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 2 &gt;::detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="ga1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 0 &gt;::Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top"><a id="ga830f8fd15be1fd552a1b44d4801d89e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 0 &gt;::detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Importing Triangulations</h2></td></tr>
<tr class="memitem:ga00affdf386be4547770822446bfb4285"><td class="memItemLeft" align="right" valign="top"><a id="ga00affdf386be4547770822446bfb4285"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 3, 3 &gt;</b></td></tr>
<tr class="separator:ga00affdf386be4547770822446bfb4285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631fec6382438e511841c19b8eae1973"><td class="memItemLeft" align="right" valign="top"><a id="ga631fec6382438e511841c19b8eae1973"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga631fec6382438e511841c19b8eae1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49eb60f011061eea6a1aab1c05c7119"><td class="memItemLeft" align="right" valign="top"><a id="gaf49eb60f011061eea6a1aab1c05c7119"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:gaf49eb60f011061eea6a1aab1c05c7119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819518abe6ced894ff133ef4fcfeb4c6"><td class="memItemLeft" align="right" valign="top"><a id="ga819518abe6ced894ff133ef4fcfeb4c6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTriangulationReader&lt; 3 &gt;</b></td></tr>
<tr class="separator:ga819518abe6ced894ff133ef4fcfeb4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b12eaa406b30275e692975f0cef0b4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8b12eaa406b30275e692975f0cef0b4b">regina::Triangulation&lt; 3 &gt;::enterTextTriangulation</a> (std::istream &amp;in, std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga8b12eaa406b30275e692975f0cef0b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to interactively enter a triangulation in plain text.  <a href="group__dim3.html#ga8b12eaa406b30275e692975f0cef0b4b">More...</a><br /></td></tr>
<tr class="separator:ga8b12eaa406b30275e692975f0cef0b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d2946f00ee2558b45ca08ed770490e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e">regina::Triangulation&lt; 3 &gt;::rehydrate</a> (const std::string &amp;dehydration)</td></tr>
<tr class="memdesc:gae2d2946f00ee2558b45ca08ed770490e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehydrates the given alphabetical string into a new triangulation.  <a href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e">More...</a><br /></td></tr>
<tr class="separator:gae2d2946f00ee2558b45ca08ed770490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1fb509efaa90335f0fd0863443b7db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db">regina::Triangulation&lt; 3 &gt;::fromSnapPea</a> (const std::string &amp;snapPeaData)</td></tr>
<tr class="memdesc:ga1b1fb509efaa90335f0fd0863443b7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file.  <a href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db">More...</a><br /></td></tr>
<tr class="separator:ga1b1fb509efaa90335f0fd0863443b7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b917f3f668afb87237c6f8f2b453273"><td class="memItemLeft" align="right" valign="top"><a id="ga1b917f3f668afb87237c6f8f2b453273"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Triangulation&lt; 3 &gt;::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga1b917f3f668afb87237c6f8f2b453273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d64120795e92d1a7c18b0427180080a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga9d64120795e92d1a7c18b0427180080a">regina::Triangulation&lt; 3 &gt;::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga9d64120795e92d1a7c18b0427180080a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__dim3.html#ga9d64120795e92d1a7c18b0427180080a">More...</a><br /></td></tr>
<tr class="separator:ga9d64120795e92d1a7c18b0427180080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3951498021127cad3b20bb1e1c415809"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3951498021127cad3b20bb1e1c415809">regina::Triangulation&lt; 3 &gt;::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga3951498021127cad3b20bb1e1c415809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__dim3.html#ga3951498021127cad3b20bb1e1c415809">More...</a><br /></td></tr>
<tr class="separator:ga3951498021127cad3b20bb1e1c415809"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:ga0a5532d43f65d9ba0354bd8bd8c4931d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga0a5532d43f65d9ba0354bd8bd8c4931d">regina::Triangulation&lt; 3 &gt;::Triangulation</a> ()</td></tr>
<tr class="memdesc:ga0a5532d43f65d9ba0354bd8bd8c4931d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__dim3.html#ga0a5532d43f65d9ba0354bd8bd8c4931d">More...</a><br /></td></tr>
<tr class="separator:ga0a5532d43f65d9ba0354bd8bd8c4931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0089671524095fac72abd688bbf91c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga6f0089671524095fac72abd688bbf91c">regina::Triangulation&lt; 3 &gt;::Triangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;copy)</td></tr>
<tr class="memdesc:ga6f0089671524095fac72abd688bbf91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation.  <a href="group__dim3.html#ga6f0089671524095fac72abd688bbf91c">More...</a><br /></td></tr>
<tr class="separator:ga6f0089671524095fac72abd688bbf91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050b0e057071f9e9e2561b315b7b001b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga050b0e057071f9e9e2561b315b7b001b">regina::Triangulation&lt; 3 &gt;::Triangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:ga050b0e057071f9e9e2561b315b7b001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also.  <a href="group__dim3.html#ga050b0e057071f9e9e2561b315b7b001b">More...</a><br /></td></tr>
<tr class="separator:ga050b0e057071f9e9e2561b315b7b001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da371e375c0591bcc939a4e21923d62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8da371e375c0591bcc939a4e21923d62">regina::Triangulation&lt; 3 &gt;::Triangulation</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:ga8da371e375c0591bcc939a4e21923d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a triangulation.  <a href="group__dim3.html#ga8da371e375c0591bcc939a4e21923d62">More...</a><br /></td></tr>
<tr class="separator:ga8da371e375c0591bcc939a4e21923d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca1afde1e9403a01f01e7da09ba012e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3ca1afde1e9403a01f01e7da09ba012e">regina::Triangulation&lt; 3 &gt;::Triangulation</a> (snappy.Manifold m)</td></tr>
<tr class="memdesc:ga3ca1afde1e9403a01f01e7da09ba012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only constructor that copies the given SnapPy manifold.  <a href="group__dim3.html#ga3ca1afde1e9403a01f01e7da09ba012e">More...</a><br /></td></tr>
<tr class="separator:ga3ca1afde1e9403a01f01e7da09ba012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd134f0130375e5ac15e90c0cab6c57c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gabd134f0130375e5ac15e90c0cab6c57c">regina::Triangulation&lt; 3 &gt;::Triangulation</a> (snappy.Triangulation t)</td></tr>
<tr class="memdesc:gabd134f0130375e5ac15e90c0cab6c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python-only constructor that copies the given SnapPy triangulation.  <a href="group__dim3.html#gabd134f0130375e5ac15e90c0cab6c57c">More...</a><br /></td></tr>
<tr class="separator:gabd134f0130375e5ac15e90c0cab6c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e699e5ba8923b37ae89eb5994f6b902"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4e699e5ba8923b37ae89eb5994f6b902">regina::Triangulation&lt; 3 &gt;::~Triangulation</a> ()</td></tr>
<tr class="memdesc:ga4e699e5ba8923b37ae89eb5994f6b902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <a href="group__dim3.html#ga4e699e5ba8923b37ae89eb5994f6b902">More...</a><br /></td></tr>
<tr class="separator:ga4e699e5ba8923b37ae89eb5994f6b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Administration</h2></td></tr>
<tr class="memitem:gaf5d26032c0c2af5a7c9f931df93edaed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaf5d26032c0c2af5a7c9f931df93edaed">regina::Triangulation&lt; 3 &gt;::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf5d26032c0c2af5a7c9f931df93edaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__dim3.html#gaf5d26032c0c2af5a7c9f931df93edaed">More...</a><br /></td></tr>
<tr class="separator:gaf5d26032c0c2af5a7c9f931df93edaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3c9276224681ca932912e989485266"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga0e3c9276224681ca932912e989485266">regina::Triangulation&lt; 3 &gt;::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0e3c9276224681ca932912e989485266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__dim3.html#ga0e3c9276224681ca932912e989485266">More...</a><br /></td></tr>
<tr class="separator:ga0e3c9276224681ca932912e989485266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937b00d0472570d29436cacecbaf701a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga937b00d0472570d29436cacecbaf701a">regina::Triangulation&lt; 3 &gt;::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga937b00d0472570d29436cacecbaf701a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__dim3.html#ga937b00d0472570d29436cacecbaf701a">More...</a><br /></td></tr>
<tr class="separator:ga937b00d0472570d29436cacecbaf701a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tetrahedra</h2></td></tr>
<tr class="memitem:ga8ed61991de885c0e4b393690f91b0930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8ed61991de885c0e4b393690f91b0930">regina::Triangulation&lt; 3 &gt;::newTetrahedron</a> ()</td></tr>
<tr class="memdesc:ga8ed61991de885c0e4b393690f91b0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="group__dim3.html#ga8ed61991de885c0e4b393690f91b0930">More...</a><br /></td></tr>
<tr class="separator:ga8ed61991de885c0e4b393690f91b0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d942a89497e2bce4ee716db55dfd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad6d942a89497e2bce4ee716db55dfd92">regina::Triangulation&lt; 3 &gt;::newTetrahedron</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:gad6d942a89497e2bce4ee716db55dfd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="group__dim3.html#gad6d942a89497e2bce4ee716db55dfd92">More...</a><br /></td></tr>
<tr class="separator:gad6d942a89497e2bce4ee716db55dfd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d12119aa7e43ba418129a62edd57f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga7d12119aa7e43ba418129a62edd57f92">regina::Triangulation&lt; 3 &gt;::removeTetrahedron</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:ga7d12119aa7e43ba418129a62edd57f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#ga7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>.  <a href="group__dim3.html#ga7d12119aa7e43ba418129a62edd57f92">More...</a><br /></td></tr>
<tr class="separator:ga7d12119aa7e43ba418129a62edd57f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085896e8328394d9cb399529e97d6b7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga085896e8328394d9cb399529e97d6b7a">regina::Triangulation&lt; 3 &gt;::removeTetrahedronAt</a> (size_t index)</td></tr>
<tr class="memdesc:ga085896e8328394d9cb399529e97d6b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#gac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>.  <a href="group__dim3.html#ga085896e8328394d9cb399529e97d6b7a">More...</a><br /></td></tr>
<tr class="separator:ga085896e8328394d9cb399529e97d6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d5db4562cc8b5cc400c32cc84baf052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga5d5db4562cc8b5cc400c32cc84baf052">regina::Triangulation&lt; 3 &gt;::removeAllTetrahedra</a> ()</td></tr>
<tr class="memdesc:ga5d5db4562cc8b5cc400c32cc84baf052"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="group__detail.html#ga3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>.  <a href="group__dim3.html#ga5d5db4562cc8b5cc400c32cc84baf052">More...</a><br /></td></tr>
<tr class="separator:ga5d5db4562cc8b5cc400c32cc84baf052"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Skeletal Queries</h2></td></tr>
<tr class="memitem:ga46851fcdaca6a86afe44b9fd185d0c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga46851fcdaca6a86afe44b9fd185d0c1b">regina::Triangulation&lt; 3 &gt;::hasTwoSphereBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:ga46851fcdaca6a86afe44b9fd185d0c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation contains any two-sphere boundary components.  <a href="group__dim3.html#ga46851fcdaca6a86afe44b9fd185d0c1b">More...</a><br /></td></tr>
<tr class="separator:ga46851fcdaca6a86afe44b9fd185d0c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcccbe5dab59415beab467a51fdab22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaafcccbe5dab59415beab467a51fdab22">regina::Triangulation&lt; 3 &gt;::hasNegativeIdealBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:gaafcccbe5dab59415beab467a51fdab22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation contains any ideal boundary components with negative Euler characteristic.  <a href="group__dim3.html#gaafcccbe5dab59415beab467a51fdab22">More...</a><br /></td></tr>
<tr class="separator:gaafcccbe5dab59415beab467a51fdab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic Properties</h2></td></tr>
<tr class="memitem:gaea8890fe2a84e4c147c43c2ae3c2386f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaea8890fe2a84e4c147c43c2ae3c2386f">regina::Triangulation&lt; 3 &gt;::eulerCharManifold</a> () const</td></tr>
<tr class="memdesc:gaea8890fe2a84e4c147c43c2ae3c2386f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the corresponding compact 3-manifold.  <a href="group__dim3.html#gaea8890fe2a84e4c147c43c2ae3c2386f">More...</a><br /></td></tr>
<tr class="separator:gaea8890fe2a84e4c147c43c2ae3c2386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef22e54275916f8b81b8fd74ab8a439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga6ef22e54275916f8b81b8fd74ab8a439">regina::Triangulation&lt; 3 &gt;::isIdeal</a> () const</td></tr>
<tr class="memdesc:ga6ef22e54275916f8b81b8fd74ab8a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is ideal.  <a href="group__dim3.html#ga6ef22e54275916f8b81b8fd74ab8a439">More...</a><br /></td></tr>
<tr class="separator:ga6ef22e54275916f8b81b8fd74ab8a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97688a6770fe85d320b05edd355abbc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga97688a6770fe85d320b05edd355abbc2">regina::Triangulation&lt; 3 &gt;::isStandard</a> () const</td></tr>
<tr class="memdesc:ga97688a6770fe85d320b05edd355abbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is standard.  <a href="group__dim3.html#ga97688a6770fe85d320b05edd355abbc2">More...</a><br /></td></tr>
<tr class="separator:ga97688a6770fe85d320b05edd355abbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07002c044286b6ba00d747d3fa49d52a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga07002c044286b6ba00d747d3fa49d52a">regina::Triangulation&lt; 3 &gt;::isClosed</a> () const</td></tr>
<tr class="memdesc:ga07002c044286b6ba00d747d3fa49d52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is closed.  <a href="group__dim3.html#ga07002c044286b6ba00d747d3fa49d52a">More...</a><br /></td></tr>
<tr class="separator:ga07002c044286b6ba00d747d3fa49d52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579be62f99849f22c5a23cceb3f2bf41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga579be62f99849f22c5a23cceb3f2bf41">regina::Triangulation&lt; 3 &gt;::isOrdered</a> () const</td></tr>
<tr class="memdesc:ga579be62f99849f22c5a23cceb3f2bf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is ordered; that is, if tetrahedron vertices are labelled so that all gluing permutations are order-preserving on the tetrahedron faces.  <a href="group__dim3.html#ga579be62f99849f22c5a23cceb3f2bf41">More...</a><br /></td></tr>
<tr class="separator:ga579be62f99849f22c5a23cceb3f2bf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Algebraic Properties</h2></td></tr>
<tr class="memitem:ga2c04ae11156b884a110348c037e7e4cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga2c04ae11156b884a110348c037e7e4cf">regina::Triangulation&lt; 3 &gt;::homologyRel</a> () const</td></tr>
<tr class="memdesc:ga2c04ae11156b884a110348c037e7e4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relative first homology group with respect to the boundary for this triangulation.  <a href="group__dim3.html#ga2c04ae11156b884a110348c037e7e4cf">More...</a><br /></td></tr>
<tr class="separator:ga2c04ae11156b884a110348c037e7e4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd544278d4054d8b11144af3c13e756"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gafdd544278d4054d8b11144af3c13e756">regina::Triangulation&lt; 3 &gt;::homologyBdry</a> () const</td></tr>
<tr class="memdesc:gafdd544278d4054d8b11144af3c13e756"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of the boundary for this triangulation.  <a href="group__dim3.html#gafdd544278d4054d8b11144af3c13e756">More...</a><br /></td></tr>
<tr class="separator:gafdd544278d4054d8b11144af3c13e756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7367b565a914ccf4ecd5bbc9e7e65b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga0c7367b565a914ccf4ecd5bbc9e7e65b">regina::Triangulation&lt; 3 &gt;::homologyH2</a> () const</td></tr>
<tr class="memdesc:ga0c7367b565a914ccf4ecd5bbc9e7e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group for this triangulation.  <a href="group__dim3.html#ga0c7367b565a914ccf4ecd5bbc9e7e65b">More...</a><br /></td></tr>
<tr class="separator:ga0c7367b565a914ccf4ecd5bbc9e7e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c0948923311085b2d5c0bb61a6ab95"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga86c0948923311085b2d5c0bb61a6ab95">regina::Triangulation&lt; 3 &gt;::homologyH2Z2</a> () const</td></tr>
<tr class="memdesc:ga86c0948923311085b2d5c0bb61a6ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group with coefficients in Z_2 for this triangulation.  <a href="group__dim3.html#ga86c0948923311085b2d5c0bb61a6ab95">More...</a><br /></td></tr>
<tr class="separator:ga86c0948923311085b2d5c0bb61a6ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c7fc5f723ce2c68158d7319dda0cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4">regina::Triangulation&lt; 3 &gt;::turaevViro</a> (unsigned long r, bool parity=true, <a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr) const</td></tr>
<tr class="memdesc:gad3c7fc5f723ce2c68158d7319dda0cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.  <a href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4">More...</a><br /></td></tr>
<tr class="separator:gad3c7fc5f723ce2c68158d7319dda0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d6e40d1a39ee48966c7a95f00092da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da">regina::Triangulation&lt; 3 &gt;::turaevViroApprox</a> (unsigned long r, unsigned long whichRoot=1, <a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a> alg=<a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a>) const</td></tr>
<tr class="memdesc:ga45d6e40d1a39ee48966c7a95f00092da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floating-point approximation.  <a href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da">More...</a><br /></td></tr>
<tr class="separator:ga45d6e40d1a39ee48966c7a95f00092da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad43a33c581d838c8d558da03acc290c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__dim3.html#ga3efba468e41908d82bf24996745397fb">TuraevViroSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad43a33c581d838c8d558da03acc290c7">regina::Triangulation&lt; 3 &gt;::allCalculatedTuraevViro</a> () const</td></tr>
<tr class="memdesc:gad43a33c581d838c8d558da03acc290c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifold.  <a href="group__dim3.html#gad43a33c581d838c8d558da03acc290c7">More...</a><br /></td></tr>
<tr class="separator:gad43a33c581d838c8d558da03acc290c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8531170c02fc4d184ed5ce64b0a8181f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8531170c02fc4d184ed5ce64b0a8181f">regina::Triangulation&lt; 3 &gt;::longitude</a> ()</td></tr>
<tr class="memdesc:ga8531170c02fc4d184ed5ce64b0a8181f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edge, and returns this edge.  <a href="group__dim3.html#ga8531170c02fc4d184ed5ce64b0a8181f">More...</a><br /></td></tr>
<tr class="separator:ga8531170c02fc4d184ed5ce64b0a8181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7f8558f06077f8cbe716a8691717d6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga2b7f8558f06077f8cbe716a8691717d6">regina::Triangulation&lt; 3 &gt;::meridianLongitude</a> ()</td></tr>
<tr class="memdesc:ga2b7f8558f06077f8cbe716a8691717d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a single boundary edge, and returns these two edges.  <a href="group__dim3.html#ga2b7f8558f06077f8cbe716a8691717d6">More...</a><br /></td></tr>
<tr class="separator:ga2b7f8558f06077f8cbe716a8691717d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Normal Surfaces and Angle Structures</h2></td></tr>
<tr class="memitem:ga570440313fe0bfe6b6a56afd00c3b0b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga570440313fe0bfe6b6a56afd00c3b0b6">regina::Triangulation&lt; 3 &gt;::isZeroEfficient</a> ()</td></tr>
<tr class="memdesc:ga570440313fe0bfe6b6a56afd00c3b0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is 0-efficient.  <a href="group__dim3.html#ga570440313fe0bfe6b6a56afd00c3b0b6">More...</a><br /></td></tr>
<tr class="separator:ga570440313fe0bfe6b6a56afd00c3b0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18754e52a8c76dcadb6f885bb7c551bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga18754e52a8c76dcadb6f885bb7c551bc">regina::Triangulation&lt; 3 &gt;::knowsZeroEfficient</a> () const</td></tr>
<tr class="memdesc:ga18754e52a8c76dcadb6f885bb7c551bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known whether or not this triangulation is 0-efficient? See <a class="el" href="group__dim3.html#ga570440313fe0bfe6b6a56afd00c3b0b6" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> for further details.  <a href="group__dim3.html#ga18754e52a8c76dcadb6f885bb7c551bc">More...</a><br /></td></tr>
<tr class="separator:ga18754e52a8c76dcadb6f885bb7c551bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d92d88a4a00fee457751e054e0ae4f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7">regina::Triangulation&lt; 3 &gt;::hasSplittingSurface</a> () const</td></tr>
<tr class="memdesc:ga5d92d88a4a00fee457751e054e0ae4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation has a normal splitting surface.  <a href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7">More...</a><br /></td></tr>
<tr class="separator:ga5d92d88a4a00fee457751e054e0ae4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c145120697c1050b74e917dd341dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga96c145120697c1050b74e917dd341dd3">regina::Triangulation&lt; 3 &gt;::knowsSplittingSurface</a> () const</td></tr>
<tr class="memdesc:ga96c145120697c1050b74e917dd341dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known whether or not this triangulation has a splitting surface? See <a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7" title="Determines whether this triangulation has a normal splitting surface.">hasSplittingSurface()</a> for further details.  <a href="group__dim3.html#ga96c145120697c1050b74e917dd341dd3">More...</a><br /></td></tr>
<tr class="separator:ga96c145120697c1050b74e917dd341dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083a8ddcda2a432be55fa74fff30f5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga083a8ddcda2a432be55fa74fff30f5c7">regina::Triangulation&lt; 3 &gt;::hasNonTrivialSphereOrDisc</a> ()</td></tr>
<tr class="memdesc:ga083a8ddcda2a432be55fa74fff30f5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a non-vertex-linking normal sphere or disc within this triangulation.  <a href="group__dim3.html#ga083a8ddcda2a432be55fa74fff30f5c7">More...</a><br /></td></tr>
<tr class="separator:ga083a8ddcda2a432be55fa74fff30f5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50916d43443f754d92082f80235ecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa50916d43443f754d92082f80235ecf7">regina::Triangulation&lt; 3 &gt;::hasOctagonalAlmostNormalSphere</a> ()</td></tr>
<tr class="memdesc:gaa50916d43443f754d92082f80235ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an octagonal almost normal 2-sphere within this triangulation.  <a href="group__dim3.html#gaa50916d43443f754d92082f80235ecf7">More...</a><br /></td></tr>
<tr class="separator:gaa50916d43443f754d92082f80235ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6025d379dd0ec53d9ee8427f6ed1a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7">regina::Triangulation&lt; 3 &gt;::findStrictAngleStructure</a> () const</td></tr>
<tr class="memdesc:ga8d6025d379dd0ec53d9ee8427f6ed1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a strict angle structure on this triangulation.  <a href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7">More...</a><br /></td></tr>
<tr class="separator:ga8d6025d379dd0ec53d9ee8427f6ed1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9d01479e8abe3e6759f13b66babb9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c">regina::Triangulation&lt; 3 &gt;::hasStrictAngleStructure</a> () const</td></tr>
<tr class="memdesc:gacf9d01479e8abe3e6759f13b66babb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation supports a strict angle structure.  <a href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c">More...</a><br /></td></tr>
<tr class="separator:gacf9d01479e8abe3e6759f13b66babb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac439e27b0888b60b2d256e9ad8eaaa15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gac439e27b0888b60b2d256e9ad8eaaa15">regina::Triangulation&lt; 3 &gt;::knowsStrictAngleStructure</a> () const</td></tr>
<tr class="memdesc:gac439e27b0888b60b2d256e9ad8eaaa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this triangulation supports a strict angle structure? See <a class="el" href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> for further details.  <a href="group__dim3.html#gac439e27b0888b60b2d256e9ad8eaaa15">More...</a><br /></td></tr>
<tr class="separator:gac439e27b0888b60b2d256e9ad8eaaa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Skeletal Transformations</h2></td></tr>
<tr class="memitem:ga1243c7aeb18c339068d8fe308af037dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1243c7aeb18c339068d8fe308af037dc">regina::Triangulation&lt; 3 &gt;::maximalForestInBoundary</a> (std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; &amp;edgeSet, std::set&lt; <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * &gt; &amp;vertexSet) const</td></tr>
<tr class="memdesc:ga1243c7aeb18c339068d8fe308af037dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a maximal forest in the 1-skeleton of the triangulation boundary.  <a href="group__dim3.html#ga1243c7aeb18c339068d8fe308af037dc">More...</a><br /></td></tr>
<tr class="separator:ga1243c7aeb18c339068d8fe308af037dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34c4cb9c0978c75c3062d6dcc018afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad34c4cb9c0978c75c3062d6dcc018afa">regina::Triangulation&lt; 3 &gt;::maximalForestInSkeleton</a> (std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; &amp;edgeSet, bool canJoinBoundaries=true) const</td></tr>
<tr class="memdesc:gad34c4cb9c0978c75c3062d6dcc018afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a maximal forest in the triangulation's 1-skeleton.  <a href="group__dim3.html#gad34c4cb9c0978c75c3062d6dcc018afa">More...</a><br /></td></tr>
<tr class="separator:gad34c4cb9c0978c75c3062d6dcc018afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63140ff3ab1dd53acd661a6c8cde47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e">regina::Triangulation&lt; 3 &gt;::intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:gad63140ff3ab1dd53acd661a6c8cde47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the triangulation using fast and greedy heuristics.  <a href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e">More...</a><br /></td></tr>
<tr class="separator:gad63140ff3ab1dd53acd661a6c8cde47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc067391ecf8f6269e624ee9d658761"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga0bc067391ecf8f6269e624ee9d658761">regina::Triangulation&lt; 3 &gt;::simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:ga0bc067391ecf8f6269e624ee9d658761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of tetrahedra.  <a href="group__dim3.html#ga0bc067391ecf8f6269e624ee9d658761">More...</a><br /></td></tr>
<tr class="separator:ga0bc067391ecf8f6269e624ee9d658761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ba73293308b8bfba1947ba4716457b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b">regina::Triangulation&lt; 3 &gt;::simplifyExhaustive</a> (int height=1, unsigned nThreads=1, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:gaf4ba73293308b8bfba1947ba4716457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.  <a href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b">More...</a><br /></td></tr>
<tr class="separator:gaf4ba73293308b8bfba1947ba4716457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b703a9bd9717144c800a710870d1e12"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:ga5b703a9bd9717144c800a710870d1e12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga5b703a9bd9717144c800a710870d1e12">regina::Triangulation&lt; 3 &gt;::retriangulate</a> (int height, unsigned nThreads, <a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *tracker, Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ga5b703a9bd9717144c800a710870d1e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores all triangulations that can be reached from this via Pachner moves, without exceeding a given number of additional tetrahedra.  <a href="group__dim3.html#ga5b703a9bd9717144c800a710870d1e12">More...</a><br /></td></tr>
<tr class="separator:ga5b703a9bd9717144c800a710870d1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e659747844d582d50162a471fd81ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae3e659747844d582d50162a471fd81ab">regina::Triangulation&lt; 3 &gt;::minimiseBoundary</a> ()</td></tr>
<tr class="memdesc:gae3e659747844d582d50162a471fd81ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this.  <a href="group__dim3.html#gae3e659747844d582d50162a471fd81ab">More...</a><br /></td></tr>
<tr class="separator:gae3e659747844d582d50162a471fd81ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9160ade86ae2ac23ac91a97d25aa79de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga9160ade86ae2ac23ac91a97d25aa79de">regina::Triangulation&lt; 3 &gt;::minimizeBoundary</a> ()</td></tr>
<tr class="memdesc:ga9160ade86ae2ac23ac91a97d25aa79de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for <a class="el" href="group__dim3.html#gae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a>.  <a href="group__dim3.html#ga9160ade86ae2ac23ac91a97d25aa79de">More...</a><br /></td></tr>
<tr class="separator:ga9160ade86ae2ac23ac91a97d25aa79de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a3cf330dd5f6900cff75d237242ef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga61a3cf330dd5f6900cff75d237242ef7">regina::Triangulation&lt; 3 &gt;::fourOneMove</a> (<a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *v, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga61a3cf330dd5f6900cff75d237242ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated function that checks the eligibility of and/or performs a 4-1 Pachner move upon the given vertex.  <a href="group__dim3.html#ga61a3cf330dd5f6900cff75d237242ef7">More...</a><br /></td></tr>
<tr class="separator:ga61a3cf330dd5f6900cff75d237242ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4dabe68d39bf8044b568565f1e9b8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4f4dabe68d39bf8044b568565f1e9b8e">regina::Triangulation&lt; 3 &gt;::threeTwoMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga4f4dabe68d39bf8044b568565f1e9b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated function that checks the eligibility of and/or performs a 3-2 move about the given edge.  <a href="group__dim3.html#ga4f4dabe68d39bf8044b568565f1e9b8e">More...</a><br /></td></tr>
<tr class="separator:ga4f4dabe68d39bf8044b568565f1e9b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fe0ada1310d50f4eee52f684bbcd5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaf5fe0ada1310d50f4eee52f684bbcd5a">regina::Triangulation&lt; 3 &gt;::twoThreeMove</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaf5fe0ada1310d50f4eee52f684bbcd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated function that checks the eligibility of and/or performs a 2-3 move about the given triangle.  <a href="group__dim3.html#gaf5fe0ada1310d50f4eee52f684bbcd5a">More...</a><br /></td></tr>
<tr class="separator:gaf5fe0ada1310d50f4eee52f684bbcd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e014a14f3ab909fb0774190725c1898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4e014a14f3ab909fb0774190725c1898">regina::Triangulation&lt; 3 &gt;::oneFourMove</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga4e014a14f3ab909fb0774190725c1898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated function that checks the eligibility of and/or performs a 1-4 Pachner move upon the given tetrahedron.  <a href="group__dim3.html#ga4e014a14f3ab909fb0774190725c1898">More...</a><br /></td></tr>
<tr class="separator:ga4e014a14f3ab909fb0774190725c1898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cf09bfb6bc4e6f82db1466b3765b97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaf0cf09bfb6bc4e6f82db1466b3765b97">regina::Triangulation&lt; 3 &gt;::fourFourMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, int newAxis, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaf0cf09bfb6bc4e6f82db1466b3765b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 4-4 move about the given edge.  <a href="group__dim3.html#gaf0cf09bfb6bc4e6f82db1466b3765b97">More...</a><br /></td></tr>
<tr class="separator:gaf0cf09bfb6bc4e6f82db1466b3765b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac177c5e1e70fb0d0a24324108ce64ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gac177c5e1e70fb0d0a24324108ce64ead">regina::Triangulation&lt; 3 &gt;::twoZeroMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gac177c5e1e70fb0d0a24324108ce64ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2.  <a href="group__dim3.html#gac177c5e1e70fb0d0a24324108ce64ead">More...</a><br /></td></tr>
<tr class="separator:gac177c5e1e70fb0d0a24324108ce64ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa1cd8d7fd0334ad909beafcd75974c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gacaa1cd8d7fd0334ad909beafcd75974c">regina::Triangulation&lt; 3 &gt;::twoZeroMove</a> (<a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *v, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gacaa1cd8d7fd0334ad909beafcd75974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given vertex of degree 2.  <a href="group__dim3.html#gacaa1cd8d7fd0334ad909beafcd75974c">More...</a><br /></td></tr>
<tr class="separator:gacaa1cd8d7fd0334ad909beafcd75974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f35dda23ea3274dbf35c3196508df26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4f35dda23ea3274dbf35c3196508df26">regina::Triangulation&lt; 3 &gt;::twoOneMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, int edgeEnd, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga4f35dda23ea3274dbf35c3196508df26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-1 move about the given edge.  <a href="group__dim3.html#ga4f35dda23ea3274dbf35c3196508df26">More...</a><br /></td></tr>
<tr class="separator:ga4f35dda23ea3274dbf35c3196508df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1f76566647492c74f380c466edcbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4e1f76566647492c74f380c466edcbe5">regina::Triangulation&lt; 3 &gt;::openBook</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga4e1f76566647492c74f380c466edcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a book opening move about the given triangle.  <a href="group__dim3.html#ga4e1f76566647492c74f380c466edcbe5">More...</a><br /></td></tr>
<tr class="separator:ga4e1f76566647492c74f380c466edcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83effbc43af294638b92d39246ebb26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa83effbc43af294638b92d39246ebb26">regina::Triangulation&lt; 3 &gt;::closeBook</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaa83effbc43af294638b92d39246ebb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a book closing move about the given boundary edge.  <a href="group__dim3.html#gaa83effbc43af294638b92d39246ebb26">More...</a><br /></td></tr>
<tr class="separator:gaa83effbc43af294638b92d39246ebb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b16dc8a8d13d3b01f1cee099988fd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga37b16dc8a8d13d3b01f1cee099988fd3">regina::Triangulation&lt; 3 &gt;::shellBoundary</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga37b16dc8a8d13d3b01f1cee099988fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron.  <a href="group__dim3.html#ga37b16dc8a8d13d3b01f1cee099988fd3">More...</a><br /></td></tr>
<tr class="separator:ga37b16dc8a8d13d3b01f1cee099988fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15b75f55bf6eaead57e6864fd7db58d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d">regina::Triangulation&lt; 3 &gt;::collapseEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:gaa15b75f55bf6eaead57e6864fd7db58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.  <a href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d">More...</a><br /></td></tr>
<tr class="separator:gaa15b75f55bf6eaead57e6864fd7db58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9a8527f05610a08f7f7a3d5042d152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gafd9a8527f05610a08f7f7a3d5042d152">regina::Triangulation&lt; 3 &gt;::reorderTetrahedraBFS</a> (bool reverse=false)</td></tr>
<tr class="memdesc:gafd9a8527f05610a08f7f7a3d5042d152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the tetrahedra of this triangulation using a breadth-first search, so that small-numbered tetrahedra are adjacent to other small-numbered tetrahedra.  <a href="group__dim3.html#gafd9a8527f05610a08f7f7a3d5042d152">More...</a><br /></td></tr>
<tr class="separator:gafd9a8527f05610a08f7f7a3d5042d152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1c5856b28d23276d52d5c4c7705b5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8b1c5856b28d23276d52d5c4c7705b5d">regina::Triangulation&lt; 3 &gt;::order</a> (bool forceOriented=false)</td></tr>
<tr class="memdesc:ga8b1c5856b28d23276d52d5c4c7705b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels tetrahedron vertices in this triangulation to give an ordered triangulation, if possible.  <a href="group__dim3.html#ga8b1c5856b28d23276d52d5c4c7705b5d">More...</a><br /></td></tr>
<tr class="separator:ga8b1c5856b28d23276d52d5c4c7705b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Decompositions</h2></td></tr>
<tr class="memitem:ga24d584e4a9005f75a12c80fb249c92c5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga24d584e4a9005f75a12c80fb249c92c5">regina::Triangulation&lt; 3 &gt;::connectedSumDecomposition</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *primeParent=nullptr, bool setLabels=true)</td></tr>
<tr class="memdesc:ga24d584e4a9005f75a12c80fb249c92c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this triangulation into its connected sum decomposition.  <a href="group__dim3.html#ga24d584e4a9005f75a12c80fb249c92c5">More...</a><br /></td></tr>
<tr class="separator:ga24d584e4a9005f75a12c80fb249c92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca834327979c983148c9bd166c39a77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77">regina::Triangulation&lt; 3 &gt;::isThreeSphere</a> () const</td></tr>
<tr class="memdesc:ga1ca834327979c983148c9bd166c39a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of a 3-sphere.  <a href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77">More...</a><br /></td></tr>
<tr class="separator:ga1ca834327979c983148c9bd166c39a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga265402601c5756fec4ea837197aeac89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga265402601c5756fec4ea837197aeac89">regina::Triangulation&lt; 3 &gt;::knowsThreeSphere</a> () const</td></tr>
<tr class="memdesc:ga265402601c5756fec4ea837197aeac89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere? See <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> for further details.  <a href="group__dim3.html#ga265402601c5756fec4ea837197aeac89">More...</a><br /></td></tr>
<tr class="separator:ga265402601c5756fec4ea837197aeac89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bccc3c75b25276fa66c4fc1b337cc0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c">regina::Triangulation&lt; 3 &gt;::isBall</a> () const</td></tr>
<tr class="memdesc:ga4bccc3c75b25276fa66c4fc1b337cc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of a 3-dimensional ball.  <a href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c">More...</a><br /></td></tr>
<tr class="separator:ga4bccc3c75b25276fa66c4fc1b337cc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ece1722460a2265a4926a7d517af2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa1ece1722460a2265a4926a7d517af2e">regina::Triangulation&lt; 3 &gt;::knowsBall</a> () const</td></tr>
<tr class="memdesc:gaa1ece1722460a2265a4926a7d517af2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimensional ball? See <a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> for further details.  <a href="group__dim3.html#gaa1ece1722460a2265a4926a7d517af2e">More...</a><br /></td></tr>
<tr class="separator:gaa1ece1722460a2265a4926a7d517af2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bc0ba8cbb3ecef1fbbe71c05b9d067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga91bc0ba8cbb3ecef1fbbe71c05b9d067">regina::Triangulation&lt; 3 &gt;::makeZeroEfficient</a> ()</td></tr>
<tr class="memdesc:ga91bc0ba8cbb3ecef1fbbe71c05b9d067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a 0-efficient triangulation of the same underlying 3-manifold.  <a href="group__dim3.html#ga91bc0ba8cbb3ecef1fbbe71c05b9d067">More...</a><br /></td></tr>
<tr class="separator:ga91bc0ba8cbb3ecef1fbbe71c05b9d067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6887425d2144a4f3a485c59ec9b74c3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e">regina::Triangulation&lt; 3 &gt;::isSolidTorus</a> () const</td></tr>
<tr class="memdesc:ga6887425d2144a4f3a485c59ec9b74c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a triangulation of the solid torus; that is, the unknot complement.  <a href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e">More...</a><br /></td></tr>
<tr class="separator:ga6887425d2144a4f3a485c59ec9b74c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281f3fc9351e4c757fec0053252d1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga281f3fc9351e4c757fec0053252d1dd4">regina::Triangulation&lt; 3 &gt;::knowsSolidTorus</a> () const</td></tr>
<tr class="memdesc:ga281f3fc9351e4c757fec0053252d1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus (that is, the unknot complement)? See <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> for further details.  <a href="group__dim3.html#ga281f3fc9351e4c757fec0053252d1dd4">More...</a><br /></td></tr>
<tr class="separator:ga281f3fc9351e4c757fec0053252d1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0326a12e5c235b90e78ccd3f51e5863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863">regina::Triangulation&lt; 3 &gt;::isTxI</a> () const</td></tr>
<tr class="memdesc:gae0326a12e5c235b90e78ccd3f51e5863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the underlying 3-manifold is the product of a torus with an interval.  <a href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863">More...</a><br /></td></tr>
<tr class="separator:gae0326a12e5c235b90e78ccd3f51e5863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga53ffd0e9e8e5b2e9c8521c58871ec56b">regina::Triangulation&lt; 3 &gt;::knowsTxI</a> () const</td></tr>
<tr class="memdesc:ga53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not this is a triangulation of a the product of a torus with an interval? See <a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> for further details.  <a href="group__dim3.html#ga53ffd0e9e8e5b2e9c8521c58871ec56b">More...</a><br /></td></tr>
<tr class="separator:ga53ffd0e9e8e5b2e9c8521c58871ec56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7785d4bb75a5366cc4d9bae5bf5536ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga7785d4bb75a5366cc4d9bae5bf5536ae">regina::Triangulation&lt; 3 &gt;::isIrreducible</a> () const</td></tr>
<tr class="memdesc:ga7785d4bb75a5366cc4d9bae5bf5536ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the underlying 3-manifold (which must be closed) is irreducible.  <a href="group__dim3.html#ga7785d4bb75a5366cc4d9bae5bf5536ae">More...</a><br /></td></tr>
<tr class="separator:ga7785d4bb75a5366cc4d9bae5bf5536ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96238fc751a6350e17ce5727a183ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa96238fc751a6350e17ce5727a183ba1">regina::Triangulation&lt; 3 &gt;::knowsIrreducible</a> () const</td></tr>
<tr class="memdesc:gaa96238fc751a6350e17ce5727a183ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold is irreducible? See <a class="el" href="group__dim3.html#ga7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> for further details.  <a href="group__dim3.html#gaa96238fc751a6350e17ce5727a183ba1">More...</a><br /></td></tr>
<tr class="separator:gaa96238fc751a6350e17ce5727a183ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6b6645fdc68b91645acda38cedb2a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8">regina::Triangulation&lt; 3 &gt;::hasCompressingDisc</a> () const</td></tr>
<tr class="memdesc:ga3f6b6645fdc68b91645acda38cedb2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a compressing disc within the underlying 3-manifold.  <a href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8">More...</a><br /></td></tr>
<tr class="separator:ga3f6b6645fdc68b91645acda38cedb2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga70b6cb41cbea1bab5fbe1692ecd8a2d7">regina::Triangulation&lt; 3 &gt;::knowsCompressingDisc</a> () const</td></tr>
<tr class="memdesc:ga70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold contains a compressing disc? See <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> for further details.  <a href="group__dim3.html#ga70b6cb41cbea1bab5fbe1692ecd8a2d7">More...</a><br /></td></tr>
<tr class="separator:ga70b6cb41cbea1bab5fbe1692ecd8a2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dd70d1448cb32ce52da8e8ae78f6d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga14dd70d1448cb32ce52da8e8ae78f6d8">regina::Triangulation&lt; 3 &gt;::isHaken</a> () const</td></tr>
<tr class="memdesc:ga14dd70d1448cb32ce52da8e8ae78f6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.  <a href="group__dim3.html#ga14dd70d1448cb32ce52da8e8ae78f6d8">More...</a><br /></td></tr>
<tr class="separator:ga14dd70d1448cb32ce52da8e8ae78f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gadaeafdd4bd2b7a28d3bcfcb31521a5a3">regina::Triangulation&lt; 3 &gt;::knowsHaken</a> () const</td></tr>
<tr class="memdesc:gadaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it already known (or trivial to determine) whether or not the underlying 3-manifold is Haken? See <a class="el" href="group__dim3.html#ga14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> for further details.  <a href="group__dim3.html#gadaeafdd4bd2b7a28d3bcfcb31521a5a3">More...</a><br /></td></tr>
<tr class="separator:gadaeafdd4bd2b7a28d3bcfcb31521a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d8cba1fae2b39de379ff6c8df4d61c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga31d8cba1fae2b39de379ff6c8df4d61c">regina::Triangulation&lt; 3 &gt;::hasSimpleCompressingDisc</a> () const</td></tr>
<tr class="memdesc:ga31d8cba1fae2b39de379ff6c8df4d61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a "simple" compressing disc inside this triangulation.  <a href="group__dim3.html#ga31d8cba1fae2b39de379ff6c8df4d61c">More...</a><br /></td></tr>
<tr class="separator:ga31d8cba1fae2b39de379ff6c8df4d61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab345829b2c1486eb39f319ed90720c97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gab345829b2c1486eb39f319ed90720c97">regina::Triangulation&lt; 3 &gt;::niceTreeDecomposition</a> () const</td></tr>
<tr class="memdesc:gab345829b2c1486eb39f319ed90720c97"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the face pairing graph of this triangulation.  <a href="group__dim3.html#gab345829b2c1486eb39f319ed90720c97">More...</a><br /></td></tr>
<tr class="separator:gab345829b2c1486eb39f319ed90720c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subdivisions, Extensions and Covers</h2></td></tr>
<tr class="memitem:gac025b93b99f5b674fd448e6374c81142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gac025b93b99f5b674fd448e6374c81142">regina::Triangulation&lt; 3 &gt;::idealToFinite</a> ()</td></tr>
<tr class="memdesc:gac025b93b99f5b674fd448e6374c81142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ideal triangulation into a finite triangulation.  <a href="group__dim3.html#gac025b93b99f5b674fd448e6374c81142">More...</a><br /></td></tr>
<tr class="separator:gac025b93b99f5b674fd448e6374c81142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24fe1e3bae956fbf8954fb54adc19e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4">regina::Triangulation&lt; 3 &gt;::pinchEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e)</td></tr>
<tr class="memdesc:gad24fe1e3bae956fbf8954fb54adc19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pinches an internal edge to a point.  <a href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4">More...</a><br /></td></tr>
<tr class="separator:gad24fe1e3bae956fbf8954fb54adc19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65db6a4aa82283c7b68b9c2525ff7c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga65db6a4aa82283c7b68b9c2525ff7c69">regina::Triangulation&lt; 3 &gt;::drillEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e, bool simplify=true)</td></tr>
<tr class="memdesc:ga65db6a4aa82283c7b68b9c2525ff7c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that drills out a regular neighbourhood of the given edge of the triangulation.  <a href="group__dim3.html#ga65db6a4aa82283c7b68b9c2525ff7c69">More...</a><br /></td></tr>
<tr class="separator:ga65db6a4aa82283c7b68b9c2525ff7c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae171f874204819014b8a5ea77b1ca2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae171f874204819014b8a5ea77b1ca2aa">regina::Triangulation&lt; 3 &gt;::puncture</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet=nullptr)</td></tr>
<tr class="memdesc:gae171f874204819014b8a5ea77b1ca2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punctures this manifold by removing a 3-ball from the interior of the given tetrahedron.  <a href="group__dim3.html#gae171f874204819014b8a5ea77b1ca2aa">More...</a><br /></td></tr>
<tr class="separator:gae171f874204819014b8a5ea77b1ca2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Triangulations</h2></td></tr>
<tr class="memitem:gad484a6c5eb82073a251b4a056777a475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gad484a6c5eb82073a251b4a056777a475">regina::Triangulation&lt; 3 &gt;::layerOn</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *edge)</td></tr>
<tr class="memdesc:gad484a6c5eb82073a251b4a056777a475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a layering upon the given boundary edge of the triangulation.  <a href="group__dim3.html#gad484a6c5eb82073a251b4a056777a475">More...</a><br /></td></tr>
<tr class="separator:gad484a6c5eb82073a251b4a056777a475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bd90a983d00116514d0dd5bbefe3a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae0bd90a983d00116514d0dd5bbefe3a2">regina::Triangulation&lt; 3 &gt;::fillTorus</a> (unsigned long cuts0, unsigned long cuts1, unsigned long cuts2, <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; 3 &gt; *bc=nullptr)</td></tr>
<tr class="memdesc:gae0bd90a983d00116514d0dd5bbefe3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.  <a href="group__dim3.html#gae0bd90a983d00116514d0dd5bbefe3a2">More...</a><br /></td></tr>
<tr class="separator:gae0bd90a983d00116514d0dd5bbefe3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6f440e7d977462241c1b4f16a169e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga6b6f440e7d977462241c1b4f16a169e3">regina::Triangulation&lt; 3 &gt;::fillTorus</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e0, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e1, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *e2, unsigned long cuts0, unsigned long cuts1, unsigned long cuts2)</td></tr>
<tr class="memdesc:ga6b6f440e7d977462241c1b4f16a169e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.  <a href="group__dim3.html#ga6b6f440e7d977462241c1b4f16a169e3">More...</a><br /></td></tr>
<tr class="separator:ga6b6f440e7d977462241c1b4f16a169e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99ca37ffcd95d0c2435e5155a19c2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae99ca37ffcd95d0c2435e5155a19c2ad">regina::Triangulation&lt; 3 &gt;::insertLayeredSolidTorus</a> (unsigned long cuts0, unsigned long cuts1)</td></tr>
<tr class="memdesc:gae99ca37ffcd95d0c2435e5155a19c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new layered solid torus into the triangulation.  <a href="group__dim3.html#gae99ca37ffcd95d0c2435e5155a19c2ad">More...</a><br /></td></tr>
<tr class="separator:gae99ca37ffcd95d0c2435e5155a19c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcec413ba8a0ff9560e20ab4ed7b7649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gabcec413ba8a0ff9560e20ab4ed7b7649">regina::Triangulation&lt; 3 &gt;::insertLayeredLensSpace</a> (unsigned long p, unsigned long q)</td></tr>
<tr class="memdesc:gabcec413ba8a0ff9560e20ab4ed7b7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new layered lens space L(p,q) into the triangulation.  <a href="group__dim3.html#gabcec413ba8a0ff9560e20ab4ed7b7649">More...</a><br /></td></tr>
<tr class="separator:gabcec413ba8a0ff9560e20ab4ed7b7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d30803ee064e8e5310331b4eff1a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga81d30803ee064e8e5310331b4eff1a9d">regina::Triangulation&lt; 3 &gt;::insertLayeredLoop</a> (unsigned long length, bool twisted)</td></tr>
<tr class="memdesc:ga81d30803ee064e8e5310331b4eff1a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a layered loop of the given length into this triangulation.  <a href="group__dim3.html#ga81d30803ee064e8e5310331b4eff1a9d">More...</a><br /></td></tr>
<tr class="separator:ga81d30803ee064e8e5310331b4eff1a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365a97340d03271ae3eae9870f5b6a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga365a97340d03271ae3eae9870f5b6a87">regina::Triangulation&lt; 3 &gt;::insertAugTriSolidTorus</a> (long a1, long b1, long a2, long b2, long a3, long b3)</td></tr>
<tr class="memdesc:ga365a97340d03271ae3eae9870f5b6a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an augmented triangular solid torus with the given parameters into this triangulation.  <a href="group__dim3.html#ga365a97340d03271ae3eae9870f5b6a87">More...</a><br /></td></tr>
<tr class="separator:ga365a97340d03271ae3eae9870f5b6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535ca040456b25b738f9bb44c9f76ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga535ca040456b25b738f9bb44c9f76ee3">regina::Triangulation&lt; 3 &gt;::insertSFSOverSphere</a> (long a1=1, long b1=0, long a2=1, long b2=0, long a3=1, long b3=0)</td></tr>
<tr class="memdesc:ga535ca040456b25b738f9bb44c9f76ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an orientable Seifert fibred space with at most three exceptional fibres over the 2-sphere into this triangulation.  <a href="group__dim3.html#ga535ca040456b25b738f9bb44c9f76ee3">More...</a><br /></td></tr>
<tr class="separator:ga535ca040456b25b738f9bb44c9f76ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0671a3ebe7d61fe1fc9ba26862bfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gacf0671a3ebe7d61fe1fc9ba26862bfce">regina::Triangulation&lt; 3 &gt;::connectedSumWith</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> &amp;other)</td></tr>
<tr class="memdesc:gacf0671a3ebe7d61fe1fc9ba26862bfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the connected sum of this triangulation with the given triangulation.  <a href="group__dim3.html#gacf0671a3ebe7d61fe1fc9ba26862bfce">More...</a><br /></td></tr>
<tr class="separator:gacf0671a3ebe7d61fe1fc9ba26862bfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ebb16f99797ca3f97e044a57d95c2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga59ebb16f99797ca3f97e044a57d95c2f">regina::Triangulation&lt; 3 &gt;::insertRehydration</a> (const std::string &amp;dehydration)</td></tr>
<tr class="memdesc:ga59ebb16f99797ca3f97e044a57d95c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the rehydration of the given string into this triangulation.  <a href="group__dim3.html#ga59ebb16f99797ca3f97e044a57d95c2f">More...</a><br /></td></tr>
<tr class="separator:ga59ebb16f99797ca3f97e044a57d95c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exporting Triangulations</h2></td></tr>
<tr class="memitem:ga8b1081ff442801c2d33038c11031ee2b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b">regina::Triangulation&lt; 3 &gt;::dehydrate</a> () const</td></tr>
<tr class="memdesc:ga8b1081ff442801c2d33038c11031ee2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dehydrates this triangulation into an alphabetical string.  <a href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b">More...</a><br /></td></tr>
<tr class="separator:ga8b1081ff442801c2d33038c11031ee2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9140993b6d06937e8126bbdd6b15fe4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gac9140993b6d06937e8126bbdd6b15fe4">regina::Triangulation&lt; 3 &gt;::snapPea</a> () const</td></tr>
<tr class="memdesc:gac9140993b6d06937e8126bbdd6b15fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string containing the full contents of a SnapPea data file that describes this triangulation.  <a href="group__dim3.html#gac9140993b6d06937e8126bbdd6b15fe4">More...</a><br /></td></tr>
<tr class="separator:gac9140993b6d06937e8126bbdd6b15fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd0d487462ab790649791803fe4b265"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga8dd0d487462ab790649791803fe4b265">regina::Triangulation&lt; 3 &gt;::snapPea</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga8dd0d487462ab790649791803fe4b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the full contents of a SnapPea data file describing this triangulation to the given output stream.  <a href="group__dim3.html#ga8dd0d487462ab790649791803fe4b265">More...</a><br /></td></tr>
<tr class="separator:ga8dd0d487462ab790649791803fe4b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdea1498a9373b31883820b01b02e9d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gabfdea1498a9373b31883820b01b02e9d">regina::Triangulation&lt; 3 &gt;::saveSnapPea</a> (const char *filename) const</td></tr>
<tr class="memdesc:gabfdea1498a9373b31883820b01b02e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this triangulation to the given file using SnapPea's native file format.  <a href="group__dim3.html#gabfdea1498a9373b31883820b01b02e9d">More...</a><br /></td></tr>
<tr class="separator:gabfdea1498a9373b31883820b01b02e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaeff844c71c39d0ae40b4d1c4aa3b0efc">regina::Triangulation&lt; 3 &gt;::recogniser</a> () const</td></tr>
<tr class="memdesc:gaeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string that expresses this triangulation in Matveev's 3-manifold recogniser format.  <a href="group__dim3.html#gaeff844c71c39d0ae40b4d1c4aa3b0efc">More...</a><br /></td></tr>
<tr class="separator:gaeff844c71c39d0ae40b4d1c4aa3b0efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403a36d9a4748032f5abb7e16c24621d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga403a36d9a4748032f5abb7e16c24621d">regina::Triangulation&lt; 3 &gt;::recognizer</a> () const</td></tr>
<tr class="memdesc:ga403a36d9a4748032f5abb7e16c24621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for <a class="el" href="group__dim3.html#gaeff844c71c39d0ae40b4d1c4aa3b0efc" title="Returns a string that expresses this triangulation in Matveev&#39;s 3-manifold recogniser format.">recogniser()</a>.  <a href="group__dim3.html#ga403a36d9a4748032f5abb7e16c24621d">More...</a><br /></td></tr>
<tr class="separator:ga403a36d9a4748032f5abb7e16c24621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f721425309c5b113d24d0e06abfb08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#ga61f721425309c5b113d24d0e06abfb08">regina::Triangulation&lt; 3 &gt;::recogniser</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga61f721425309c5b113d24d0e06abfb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream.  <a href="group__dim3.html#ga61f721425309c5b113d24d0e06abfb08">More...</a><br /></td></tr>
<tr class="separator:ga61f721425309c5b113d24d0e06abfb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9565c761baf1d0fcf41f1e08baf1733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaf9565c761baf1d0fcf41f1e08baf1733">regina::Triangulation&lt; 3 &gt;::recognizer</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf9565c761baf1d0fcf41f1e08baf1733"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for recognizer(std::ostream&amp;).  <a href="group__dim3.html#gaf9565c761baf1d0fcf41f1e08baf1733">More...</a><br /></td></tr>
<tr class="separator:gaf9565c761baf1d0fcf41f1e08baf1733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c68d0faa4438c15960509298e100ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gaa0c68d0faa4438c15960509298e100ec">regina::Triangulation&lt; 3 &gt;::saveRecogniser</a> (const char *filename) const</td></tr>
<tr class="memdesc:gaa0c68d0faa4438c15960509298e100ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this triangulation to the given file in Matveev's 3-manifold recogniser format.  <a href="group__dim3.html#gaa0c68d0faa4438c15960509298e100ec">More...</a><br /></td></tr>
<tr class="separator:gaa0c68d0faa4438c15960509298e100ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae579243386ad33795b0759dd5fb35fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dim3.html#gae579243386ad33795b0759dd5fb35fab">regina::Triangulation&lt; 3 &gt;::saveRecognizer</a> (const char *filename) const</td></tr>
<tr class="memdesc:gae579243386ad33795b0759dd5fb35fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for <a class="el" href="group__dim3.html#gaa0c68d0faa4438c15960509298e100ec" title="Writes this triangulation to the given file in Matveev&#39;s 3-manifold recogniser format.">saveRecogniser()</a>.  <a href="group__dim3.html#gae579243386ad33795b0759dd5fb35fab">More...</a><br /></td></tr>
<tr class="separator:gae579243386ad33795b0759dd5fb35fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Details for implementing triangulations of 3-manifolds. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga644596a866ce7bc0d777415663fd7a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644596a866ce7bc0d777415663fd7a8f">&#9670;&nbsp;</a></span>EdgeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;3, 1&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga644596a866ce7bc0d777415663fd7a8f">EdgeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through edges. </p>

</div>
</div>
<a id="ga40b86bb6bd77635ae7474c169cee2916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b86bb6bd77635ae7474c169cee2916">&#9670;&nbsp;</a></span>NBoundaryComponent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;3&gt; <a class="el" href="group__dim3.html#ga40b86bb6bd77635ae7474c169cee2916">regina::NBoundaryComponent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000187">Deprecated:</a></b></dt><dd>Instead of the old typedef NBoundaryComponent, you should use the real class name <a class="el" href="classregina_1_1BoundaryComponent_3_013_01_4.html" title="A component of the boundary of a 3-manifold triangulation.">BoundaryComponent&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga3b188ec182ddb0b3972db58baa815b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b188ec182ddb0b3972db58baa815b6b">&#9670;&nbsp;</a></span>NComponent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Component.html">Component</a>&lt;3&gt; <a class="el" href="group__dim3.html#ga3b188ec182ddb0b3972db58baa815b6b">regina::NComponent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000188">Deprecated:</a></b></dt><dd>Instead of the old typedef NComponent, you should use the real class name <a class="el" href="classregina_1_1Component_3_013_01_4.html" title="Represents a connected component of a 3-manifold triangulation.">Component&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="gaed636d94ab36840468359b75ef77fcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed636d94ab36840468359b75ef77fcb3">&#9670;&nbsp;</a></span>NEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt;3, 1&gt; <a class="el" href="group__dim3.html#gaed636d94ab36840468359b75ef77fcb3">regina::NEdge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000194">Deprecated:</a></b></dt><dd>Instead of the old typedef NEdge, you should use either the new alias Edge&lt;3&gt;, or the full class name Face&lt;3, 1&gt;. </dd></dl>

</div>
</div>
<a id="gaec69256bc1b8d097dfceddbfc7ba7fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec69256bc1b8d097dfceddbfc7ba7fb0">&#9670;&nbsp;</a></span>NEdgeEmbedding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;3, 1&gt; <a class="el" href="group__dim3.html#gaec69256bc1b8d097dfceddbfc7ba7fb0">regina::NEdgeEmbedding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000193">Deprecated:</a></b></dt><dd>Instead of the old typedef NEdgeEmbedding, you should use either the new alias EdgeEmbedding&lt;3&gt;, or the full class name FaceEmbedding&lt;3, 1&gt;. </dd></dl>

</div>
</div>
<a id="ga4515e68a1557dda62baabe15c060ed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4515e68a1557dda62baabe15c060ed9c">&#9670;&nbsp;</a></span>NTetrahedron</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;3&gt; <a class="el" href="group__dim3.html#ga4515e68a1557dda62baabe15c060ed9c">regina::NTetrahedron</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000189">Deprecated:</a></b></dt><dd>Instead of the old typedef NTetrahedron, you should use the new alias Simplex&lt;3&gt; (or, if you prefer, the full class name <a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html" title="Represents a tetrahedron within a 3-manifold triangulation.">Face&lt;3, 3&gt;</a>). </dd></dl>

</div>
</div>
<a id="gadc42b6c6fab71011ed72206a70849ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc42b6c6fab71011ed72206a70849ff4">&#9670;&nbsp;</a></span>NTriangle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt;3, 2&gt; <a class="el" href="group__dim3.html#gadc42b6c6fab71011ed72206a70849ff4">regina::NTriangle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000191">Deprecated:</a></b></dt><dd>Instead of the old typedef NTriangle, you should use either the new alias Triangle&lt;3&gt;, or the full class name <a class="el" href="classregina_1_1Face_3_013_00_012_01_4.html" title="Represents a triangle in the skeleton of a 3-manifold triangulation.">Face&lt;3, 2&gt;</a>. </dd></dl>

</div>
</div>
<a id="gacbe4c3553ac238df7a0a0d3bacd754b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe4c3553ac238df7a0a0d3bacd754b6">&#9670;&nbsp;</a></span>NTriangleEmbedding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;3, 2&gt; <a class="el" href="group__dim3.html#gacbe4c3553ac238df7a0a0d3bacd754b6">regina::NTriangleEmbedding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000190">Deprecated:</a></b></dt><dd>Instead of the old typedef NTriangleEmbedding, you should use either the new alias TriangleEmbedding&lt;3&gt;, or the full class name FaceEmbedding&lt;3, 2&gt;. </dd></dl>

</div>
</div>
<a id="ga4c2d67a282de290d5e033d14f3dce9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c2d67a282de290d5e033d14f3dce9f3">&#9670;&nbsp;</a></span>NTriangulation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt; <a class="el" href="group__dim3.html#ga4c2d67a282de290d5e033d14f3dce9f3">regina::NTriangulation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000192">Deprecated:</a></b></dt><dd>Instead of the old typedef NTriangulation, you should use the templated class name <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="gadab74e629471cd39954cfd0ead65c265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab74e629471cd39954cfd0ead65c265">&#9670;&nbsp;</a></span>NVertex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Face.html">Face</a>&lt;3, 0&gt; <a class="el" href="group__dim3.html#gadab74e629471cd39954cfd0ead65c265">regina::NVertex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000201">Deprecated:</a></b></dt><dd>Instead of the old typedef NVertex, you should use either the new alias Vertex&lt;3&gt;, or the full class name <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html" title="Represents a vertex in the skeleton of a 3-manifold triangulation.">Face&lt;3, 0&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga793f31b50b818ee88993c83b57a07f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga793f31b50b818ee88993c83b57a07f8f">&#9670;&nbsp;</a></span>NVertexEmbedding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt;3, 0&gt; <a class="el" href="group__dim3.html#ga793f31b50b818ee88993c83b57a07f8f">regina::NVertexEmbedding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000200">Deprecated:</a></b></dt><dd>Instead of the old typedef NVertexEmbedding, you should use either the new alias VertexEmbedding&lt;3&gt;, or the full class name FaceEmbedding&lt;3, 0&gt;. </dd></dl>

</div>
</div>
<a id="ga38ed43a36b0cc25726e9438260710681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ed43a36b0cc25726e9438260710681">&#9670;&nbsp;</a></span>TetrahedronIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga38ed43a36b0cc25726e9438260710681">TetrahedronIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dimension-specific alias for SimplexIterator, used to iterate through tetrahedra. </p>

</div>
</div>
<a id="gac7b908f31770d4d6579cd5e6033e8e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7b908f31770d4d6579cd5e6033e8e04">&#9670;&nbsp;</a></span>TriangleIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;3, 2&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#gac7b908f31770d4d6579cd5e6033e8e04">TriangleIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through triangles. </p>

</div>
</div>
<a id="ga3efba468e41908d82bf24996745397fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3efba468e41908d82bf24996745397fb">&#9670;&nbsp;</a></span>TuraevViroSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;unsigned long, bool&gt;, <a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a>&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga3efba468e41908d82bf24996745397fb">TuraevViroSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from (<em>r</em>, <em>parity</em>) pairs to Turaev-Viro invariants, as described by <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a>. </p>

</div>
</div>
<a id="ga167d59f6b80199dd25614a1a93f1c636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167d59f6b80199dd25614a1a93f1c636">&#9670;&nbsp;</a></span>VertexIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;3, 0&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga167d59f6b80199dd25614a1a93f1c636">VertexIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through vertices. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3a34beeab677315bd4b5e0091ea1645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a34beeab677315bd4b5e0091ea1645c">&#9670;&nbsp;</a></span>LinkType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::<a class="el" href="group__dim3.html#ga3a34beeab677315bd4b5e0091ea1645c">LinkType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Categorises the possible links of a vertex into a small number of common types. </p>
<p>Here a vertex link is considered only up to its topology (not the combinatorics of its triangulation).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#ga62065e3c545bc03eead5ea324218fb6d" title="Returns a broad categorisation of the link of the vertex.">link</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645ca2bf5faa23b062281a1a2320d1337bc05"></a>SPHERE&#160;</td><td class="fielddoc"><p>Specifies a vertex link that is a sphere. </p>
<p>In other words, the vertex is internal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645ca8672c0ae2f51ee6e3f9af4941bfb76d2"></a>DISC&#160;</td><td class="fielddoc"><p>Specifies a vertex link that is a disc. </p>
<p>In other words, the vertex lies on a real boundary component. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645ca82cce2a6053a92d04efaa1135d425220"></a>TORUS&#160;</td><td class="fielddoc"><p>Specifies a vertex link that is a torus. </p>
<p>In other words, this is an ideal vertex representing a torus cusp. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645caccb5da4a6cddf14df333422dd5c24aec"></a>KLEIN_BOTTLE&#160;</td><td class="fielddoc"><p>Specifies a vertex link that is a Klein bottle. </p>
<p>In other words, this is an ideal vertex representing a Klein bottle cusp. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645caf19fa3672680ee945e836b6fbae0ef17"></a>NON_STANDARD_CUSP&#160;</td><td class="fielddoc"><p>Specifies a vertex link that is closed and is not a sphere, torus or Klein bottle. </p>
<p>In other words, this is an ideal vertex but not one of the standard ideal vertex types. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3a34beeab677315bd4b5e0091ea1645ca1971e44e60c0052a04c8f02e20e0e2a3"></a>INVALID&#160;</td><td class="fielddoc"><p>Specifies a vertex link that has boundary and is not a disc. </p>
<p>In other words, this vertex makes the triangulation invalid. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaaca65058d771fc756610f20b7eb45061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca65058d771fc756610f20b7eb45061">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 2 &gt;::<a class="el" href="group__dim3.html#gaaca65058d771fc756610f20b7eb45061">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <em>type</em> of a triangle, which indicates how the vertices and edges of the triangle are identified together. </p>
<p>Here the vertices of a triangle are considered unlabelled (so a relabelling will not change the triangle type).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f" title="Returns a description of the triangle type.">type</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061a7a0e23ebad3d1672fc6c576a59676804"></a>UNKNOWN_TYPE&#160;</td><td class="fielddoc"><p>Indicates that the triangle type has not yet been determined. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061ada796135a96c29bde25a2a044ba3c15a"></a>TRIANGLE&#160;</td><td class="fielddoc"><p>Specifies a triangle with no identified vertices or edges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061a2b9bc8cabccceb365ce973569f1278f3"></a>SCARF&#160;</td><td class="fielddoc"><p>Specifies a triangle with two identified vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061a01ac79fd508080388bc28429326c0fd1"></a>PARACHUTE&#160;</td><td class="fielddoc"><p>Specifies a triangle with three identified vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061a4be9fb00f7b51b7362ac8de850b26a7f"></a>CONE&#160;</td><td class="fielddoc"><p>Specifies a triangle with two edges identified to form a cone. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061aa31a608dcfddd14ab3880668e2fe0a35"></a>MOBIUS&#160;</td><td class="fielddoc"><p>Specifies a triangle with two edges identified to form a mobius band. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061a16bb6ddb23de36209a94fcebf67910f0"></a>HORN&#160;</td><td class="fielddoc"><p>Specifies a triangle with two edges identified to form a cone with all three vertices identified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061ae506dc8a3c413c8716b66091b518c183"></a>DUNCEHAT&#160;</td><td class="fielddoc"><p>Specifies a triangle with all three edges identified, some via orientable and some via non-orientable gluings. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaca65058d771fc756610f20b7eb45061addf287abeb174ff57223a7cadfd76279"></a>L31&#160;</td><td class="fielddoc"><p>Specifies a triangle with all three edges identified using non-orientable gluings. </p>
<p>Note that this forms a spine for the Lens space L(3,1). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0ccf140ce8a41c983d22111160ec2d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ccf140ce8a41c983d22111160ec2d8b">&#9670;&nbsp;</a></span>adjacentFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 3 &gt;::adjacentFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#ga09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a>. </p>
<p>See <a class="el" href="group__detail.html#ga09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a> for further information. </p>

</div>
</div>
<a id="ga674b8434d6c9baf99d39748d5b76cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674b8434d6c9baf99d39748d5b76cd2a">&#9670;&nbsp;</a></span>adjacentTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 3 &gt;::adjacentTetrahedron </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#gad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a>. </p>
<p>See <a class="el" href="group__detail.html#gad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a> for further information. </p>

</div>
</div>
<a id="gad43a33c581d838c8d558da03acc290c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad43a33c581d838c8d558da03acc290c7">&#9670;&nbsp;</a></span>allCalculatedTuraevViro()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga3efba468e41908d82bf24996745397fb">TuraevViroSet</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::allCalculatedTuraevViro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifold. </p>
<p>This cache is updated every time <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> is called, and is emptied whenever the triangulation is modified.</p>
<p>Turaev-Viro invariants are identified by an (<em>r</em>, <em>parity</em>) pair as described in the <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> documentation. The cache is just a set that maps (<em>r</em>, <em>parity</em>) pairs to the corresponding invariant values.</p>
<p>For even values of <em>r</em>, the parity is ignored when calling <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> (since the even and odd versions of the invariant contain essentially the same information). Therefore, in this cache, all even values of <em>r</em> will have the corresponding parities set to <code>false</code>.</p>
<dl class="section note"><dt>Note</dt><dd>All invariants in this cache are now computed using exact arithmetic, as elements of a cyclotomic field. This is a change from Regina 4.96 and earlier, which computed floating-point approximations instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the cache of all Turaev-Viro invariants that have already been calculated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro</a> </dd></dl>

</div>
</div>
<a id="gab249ca6c2debe19f475562cf16607fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab249ca6c2debe19f475562cf16607fc9">&#9670;&nbsp;</a></span>buildLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 2 &gt; * <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::buildLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex. </p>
<p>This routine is fast (it uses a pre-computed triangulation if possible). The downside is that the triangulation is read-only, and does not contain any information on how the triangles in the link correspond to tetrahedra in the original triangulation (though this is easily deduced; see below). If you want a writable triangulation, or one with this extra information, then call <a class="el" href="group__dim3.html#ga45022906dce3d868e59a845cffe5763d" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLinkDetail()</a> instead.</p>
<p>The triangulation of the vertex link is built as follows. Let <em>i</em> lie between 0 and <a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b" title="Returns the degree of this face.">degree()</a>-1 inclusive, let <em>tet</em> represent <code>embedding(i).tetrahedron()</code>, and let <em>v</em> represent <code>embedding(i).vertex()</code>. Then <code><a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> is the triangle in the vertex link that "slices off" vertex <em>v</em> from tetrahedron <em>tet</em>. In other words, <code><a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> in the vertex link is parallel to triangle <code>tet-&gt;triangle(v)</code> in the surrounding 3-manifold triangulation.</p>
<p>The vertices of each triangle in the vertex link are numbered as follows. Following the discussion above, suppose that <code><a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>-&gt;triangle(i)</code> sits within <code>tet</code> and is parallel to <code>tet-&gt;triangle(v)</code>. Then vertices 0,1,2 of the triangle in the link will be parallel to vertices 0,1,2 of the corresponding Triangle&lt;3&gt;. The permutation <code>tet-&gt;triangleMapping(v)</code> will map vertices 0,1,2 of the triangle in the link to the corresponding vertices of <code>tet</code> (those opposite <code>v</code>), and will map 3 to <code>v</code> itself.</p>
<p>This Vertex&lt;3&gt; object will retain ownership of the triangulation that is returned. If you wish to edit the triangulation, you should make a new clone and edit the clone instead.</p>
<dl class="section user"><dt>Python</dt><dd>Since Python does not distinguish between const and non-const, this routine will make a deep copy of the vertex link. You are free to modify the triangulation that is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the read-only triangulated link of the vertex. </dd></dl>

</div>
</div>
<a id="ga45022906dce3d868e59a845cffe5763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45022906dce3d868e59a845cffe5763d">&#9670;&nbsp;</a></span>buildLinkDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;2&gt;* <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::buildLinkDetail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; **&#160;</td>
          <td class="paramname"><em>inclusion</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a full 2-manifold triangulation describing the link of this vertex. </p>
<p>This routine is heavyweight (it computes a new triangulation each time). The benefit is that the triangulation is writeable, and optionally contain detailed information on how the triangles in the link correspond to tetrahedra in the original triangulation. If you do not need this extra information, consider using the faster <a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a> instead.</p>
<p>See the <a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a> documentation for an explanation of exactly how the triangulation will be constructed.</p>
<p>If <em>labels</em> is passed as <code>true</code>, each triangle of the new vertex link will be given a text description of the form <code>t&#160;(v)</code>, where <code>t</code> is the index of the tetrahedron the triangle is from, and <code>v</code> is the vertex of that tetrahedron that this triangle links.</p>
<p>If <em>inclusion</em> is non-null (i.e., it points to some <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> pointer <em>p</em>), then it will be modified to point to a new <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> that describes in detail how the individual triangles of the link sit within tetrahedra of the original triangulation. Specifically, after this routine is called, <code>p-&gt;tetImage(i)</code> will indicate which tetrahedron <em>tet</em> of the 3-manifold triangulation contains the <em>i</em>th triangle of the link. Moreover, <code>p-&gt;facePerm(i)</code> will indicate exactly where the <em>i</em>th triangle sits within <em>tet:</em> it will send 3 to the vertex of <em>t</em> that the triangle links, and it will send 0,1,2 to the vertices of <em>tet</em> that are parallel to vertices 0,1,2 of this triangle.</p>
<p>The triangulation that is returned, as well as the isomorphism if one was requested, will be newly allocated. The caller of this routine is responsible for destroying these objects.</p>
<p>Strictly speaking, this is an abuse of the <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism&lt;3&gt;</a> class (the domain is a triangulation of the wrong dimension, and the map is not 1-to-1 into the range tetrahedra). We use it anyway, but you should not attempt to call any high-level routines (such as <a class="el" href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">Isomorphism&lt;3&gt;::apply</a>).</p>
<dl class="section user"><dt>Python</dt><dd>The second (isomorphism) argument is not present. Instead this routine returns a pair (triangulation, isomorphism). As a side-effect, the isomorphism will always be constructed (i.e., it is not optional).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since Python does not distinguish between const and non-const, this routine will make a deep copy of the vertex link. You are free to modify the triangulation that is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation of the link of this vertex. </dd></dl>

</div>
</div>
<a id="gaa83effbc43af294638b92d39246ebb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83effbc43af294638b92d39246ebb26">&#9670;&nbsp;</a></span>closeBook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::closeBook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a book closing move about the given boundary edge. </p>
<p>This involves taking a boundary edge of the triangulation and folding together the two boundary triangles on either side. This move is the inverse of the <a class="el" href="group__dim3.html#ga4e1f76566647492c74f380c466edcbe5" title="Checks the eligibility of and/or performs a book opening move about the given triangle.">openBook()</a> move, and is used to simplify the boundary of the triangulation. This move can be done if:</p>
<ul>
<li>the edge <em>e</em> is a boundary edge;</li>
<li>the two vertices opposite <em>e</em> in the boundary triangles that contain <em>e</em> are valid and distinct;</li>
<li>the boundary component containing <em>e</em> contains more than two triangles.</li>
</ul>
<p>There are in fact several other distinctness conditions on the nearby edges and triangles, but they follow automatically from the conditions above.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaa15b75f55bf6eaead57e6864fd7db58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa15b75f55bf6eaead57e6864fd7db58d">&#9670;&nbsp;</a></span>collapseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::collapseEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices. </p>
<p>This operation (when it is allowed) does not change the topology of the manifold, decreases the number of vertices by one, and also decreases the number of tetrahedra.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>If you are trying to reduce the number of vertices without changing the topology, and if <em>e</em> is an edge connecting an internal vertex with some different vertex, then either <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> or <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> may be more appropriate for your situation.</p>
<ul>
<li>The advantage of <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> is that it decreases the number of tetrahedra, whereas <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> increases this number (but only by two).</li>
<li>The disadvantages of <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> are that it cannot always be performed, and its validity tests are expensive; <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> on the other hand can always be used for edges <em>e</em> of the type described above.</li>
</ul>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<p>The eligibility requirements for this move are somewhat involved, and are discussed in detail in the <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> source code for those who are interested.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to collapse. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the given edge may be collapsed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga24d584e4a9005f75a12c80fb249c92c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d584e4a9005f75a12c80fb249c92c5">&#9670;&nbsp;</a></span>connectedSumDecomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::connectedSumDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>primeParent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setLabels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits this triangulation into its connected sum decomposition. </p>
<p>The individual prime 3-manifold triangulations that make up this decomposition will be inserted as children of the given parent packet. The original triangulation will be left unchanged.</p>
<p>For non-orientable triangulations, this routine is only guaranteed to succeed if the original manifold contains no embedded two-sided projective planes. If the manifold <em>does</em> contain embedded two-sided projective planes, then this routine might still succeed but it might fail; however, such a failure will always be detected, and in such a case this routine will return -1 instead (without building any prime summands at all).</p>
<p>Note that this routine is currently only available for closed triangulations; see the list of preconditions for full details.</p>
<p>If the given parent packet is 0, the new prime summand triangulations will be inserted as children of this triangulation.</p>
<p>This routine can optionally assign unique (and sensible) packet labels to each of the new prime summand triangulations. Note however that uniqueness testing may be slow, so this assignment of labels should be disabled if the summand triangulations are only temporary objects used as part of a larger routine.</p>
<p>If this is a triangulation of a 3-sphere then no prime summand triangulations will be created at all, and this routine will return 0.</p>
<p>The underlying algorithm appears in "A new approach to crushing
3-manifold triangulations", Discrete and Computational Geometry 52:1 (2014), pp. 116-139. This algorithm is based on the Jaco-Rubinstein 0-efficiency algorithm, and works in both orientable and non-orientable settings.</p>
<dl class="section warning"><dt>Warning</dt><dd>Users are strongly advised to check the return value if embedded two-sided projective planes are a possibility, since in such a case this routine might fail (as explained above). Note however that this routine might still succeed, and so success is not a proof that no embedded two-sided projective planes exist.</dd>
<dd>
The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations. For 3-sphere testing, see the routine <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> which uses faster methods where possible.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primeParent</td><td>the packet beneath which the new prime summand triangulations will be inserted, or 0 if they should be inserted directly beneath this triangulation. </td></tr>
    <tr><td class="paramname">setLabels</td><td><code>true</code> if the new prime summand triangulations should be assigned unique packet labels, or <code>false</code> if they should be left without labels at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prime summands created, 0 if this triangulation is a 3-sphere, or -1 if this routine failed because this is a non-orientable triangulation with embedded two-sided projective planes. </dd></dl>

</div>
</div>
<a id="gacf0671a3ebe7d61fe1fc9ba26862bfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf0671a3ebe7d61fe1fc9ba26862bfce">&#9670;&nbsp;</a></span>connectedSumWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::connectedSumWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the connected sum of this triangulation with the given triangulation. </p>
<p>This triangulation will be altered directly.</p>
<p>If this and the given triangulation are both oriented, then the result will be oriented also, and the connected sum will respect these orientations.</p>
<p>If one or both triangulations contains multiple connected components, this routine will connect the components containing tetrahedron 0 of each triangulation, and will copy any additional components across with no modification.</p>
<p>If either triangulation is empty, then the result will simply be a clone of the other triangulation.</p>
<p>This and/or the given triangulation may be bounded or ideal, or even invalid; in all cases the connected sum will be formed correctly. Note, however, that the result might possibly contain internal vertices (even if the original triangulations do not).</p>
<p>It is allowed to pass this triangulation as <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to sum with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f8fe30054307cdec4b14e06b545b5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8fe30054307cdec4b14e06b545b5a2">&#9670;&nbsp;</a></span>countFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Component.html">regina::Component</a>&lt; 3 &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this component. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and 2 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ga8b1081ff442801c2d33038c11031ee2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1081ff442801c2d33038c11031ee2b">&#9670;&nbsp;</a></span>dehydrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::dehydrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dehydrates this triangulation into an alphabetical string. </p>
<p>A <em>dehydration string</em> is a compact text representation of a triangulation, introduced by Callahan, Hildebrand and Weeks for their cusped hyperbolic census (see below). The dehydration string of an <em>n</em>-tetrahedron triangulation consists of approximately (but not precisely) 5<em>n</em>/2 lower-case letters.</p>
<p>Dehydration strings come with some restrictions:</p><ul>
<li>They rely on the triangulation being "canonical" in some combinatorial sense. This is not enforced here; instead a combinatorial isomorphism is applied to make the triangulation canonical, and this isomorphic triangulation is dehydrated instead. Note that the original triangulation is not changed.</li>
<li>They require the triangulation to be connected.</li>
<li>They require the triangulation to have no boundary triangles (though ideal triangulations are fine).</li>
<li>They can only support triangulations with at most 25 tetrahedra.</li>
</ul>
<p>The routine <a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e" title="Rehydrates the given alphabetical string into a new triangulation.">rehydrate()</a> can be used to recover a triangulation from a dehydration string. Note that the triangulation recovered <b>might not be identical</b> to the original, but it is guaranteed to be an isomorphic copy.</p>
<p>For a full description of the dehydrated triangulation format, see <em>A <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> of Cusped Hyperbolic 3-Manifolds</em>, Callahan, Hildebrand and Weeks, Mathematics of Computation 68/225, 1999.</p>
<dl class="section return"><dt>Returns</dt><dd>a dehydrated representation of this triangulation (or an isomorphic variant of this triangulation), or the empty string if dehydration is not possible because the triangulation is disconnected, has boundary triangles or contains too many tetrahedra.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e" title="Rehydrates the given alphabetical string into a new triangulation.">rehydrate</a> </dd>
<dd>
<a class="el" href="group__dim3.html#ga59ebb16f99797ca3f97e044a57d95c2f" title="Inserts the rehydration of the given string into this triangulation.">insertRehydration</a> </dd></dl>

</div>
</div>
<a id="ga937b00d0472570d29436cacecbaf701a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga937b00d0472570d29436cacecbaf701a">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__snappea.html#ga69a2d5c64038c031ca6626b4fbc80175">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga65db6a4aa82283c7b68b9c2525ff7c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65db6a4aa82283c7b68b9c2525ff7c69">&#9670;&nbsp;</a></span>drillEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::drillEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that drills out a regular neighbourhood of the given edge of the triangulation. </p>
<p>The drilling is done by (i) performing two barycentric subdivisions, (ii) removing all tetrahedra that touch the original edge, and then (iii) simplifying the resulting triangulation (unless the optional argument <em>simplify</em> is <code>false</code>).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000199">Deprecated:</a></b></dt><dd>This routine is very slow, largely thanks to the simplification needed after the second barycentric subdivision multiplies the number of tetrahedra by 576. For those cases where <a class="el" href="group__dim3.html#ga65db6a4aa82283c7b68b9c2525ff7c69" title="Deprecated routine that drills out a regular neighbourhood of the given edge of the triangulation.">drillEdge()</a> does something interesting, you can typically achieve the same topological effect by calling <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> (followed by <a class="el" href="group__dim3.html#gac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> if you need real boundary).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to drill out. </td></tr>
    <tr><td class="paramname">simplify</td><td><code>true</code> if the triangulation should be simplified, as described above. This is highly recommended, due to the second barycentric subdivision. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b12eaa406b30275e692975f0cef0b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b12eaa406b30275e692975f0cef0b4b">&#9670;&nbsp;</a></span>enterTextTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::enterTextTriangulation </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the user to interactively enter a triangulation in plain text. </p>
<p>Prompts will be sent to the given output stream and information will be read from the given input stream.</p>
<dl class="section user"><dt>Python</dt><dd>This routine is a member of class Engine. It takes no parameters; <em>in</em> and <em>out</em> are always assumed to be standard input and standard output respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which text will be read. </td></tr>
    <tr><td class="paramname">out</td><td>the output stream to which prompts will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the triangulation entered in by the user. </dd></dl>

</div>
</div>
<a id="ga1b2c840bbe581f5fe58a4cb8e57e3702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b2c840bbe581f5fe58a4cb8e57e3702">&#9670;&nbsp;</a></span>eulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1BoundaryComponent.html">regina::BoundaryComponent</a>&lt; 3 &gt;::eulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this boundary component. </p>
<p>If this boundary component is ideal, the Euler characteristic of the link of the corresponding ideal vertex is returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This boundary component does not contain any invalid vertices (i.e., vertices that belongs to one or more boundary triangles but also have positive genus links). For such boundary components, <a class="el" href="group__dim3.html#ga1b2c840bbe581f5fe58a4cb8e57e3702" title="Returns the Euler characteristic of this boundary component.">eulerChar()</a> does still return a well-defined result, but this result is not topologically meaningful.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic. </dd></dl>

</div>
</div>
<a id="gaea8890fe2a84e4c147c43c2ae3c2386f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8890fe2a84e4c147c43c2ae3c2386f">&#9670;&nbsp;</a></span>eulerCharManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::eulerCharManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the corresponding compact 3-manifold. </p>
<p>Instead of simply calculating <em>V-E+F-T</em>, this routine also:</p>
<ul>
<li>treats ideal vertices as surface boundary components (i.e., effectively truncates them);</li>
<li>truncates invalid boundary vertices (i.e., boundary vertices whose links are not discs);</li>
<li>truncates the projective plane cusps at the midpoints of invalid edges (edges identified with themselves in reverse).</li>
</ul>
<p>For ideal triangulations, this routine therefore computes the proper Euler characteristic of the manifold (unlike <a class="el" href="group__detail.html#ga8063bd8d3c1ff8d896ae0a24db2203d5" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a>, which does not).</p>
<p>For triangulations whose vertex links are all spheres or discs, this routine and <a class="el" href="group__detail.html#ga8063bd8d3c1ff8d896ae0a24db2203d5" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a> give identical results.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the corresponding compact manifold. </dd></dl>

</div>
</div>
<a id="ga119c71aa7d6bd0f9317806d05cf138fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga119c71aa7d6bd0f9317806d05cf138fe">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;3, subdim&gt;* <a class="el" href="classregina_1_1Component.html">regina::Component</a>&lt; 3 &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face in this component. </p>
<p>Note that the index of a face in the component need not be the index of the same face in the overall triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and 2 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__dim3.html#ga1f8fe30054307cdec4b14e06b545b5a2" title="Returns the number of subdim-faces in this component.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ga60a890230af4297f0a2f805804bcee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60a890230af4297f0a2f805804bcee58">&#9670;&nbsp;</a></span>faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;3, subdim&gt;*&gt;&amp; <a class="el" href="classregina_1_1Component.html">regina::Component</a>&lt; 3 &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the list of all <em>subdim</em>-faces in this component. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and 2 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ga6b6f440e7d977462241c1b4f16a169e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b6f440e7d977462241c1b4f16a169e3">&#9670;&nbsp;</a></span>fillTorus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fillTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a two-triangle torus boundary component by attaching a solid torus along a given curve. </p>
<p>The three edges of the boundary component should be passed as the arguments <em>e0</em>, <em>e1</em> and <em>e2</em>. The boundary component will then be filled with a solid torus whose meridional curve cuts these three edges <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> times respectively.</p>
<p>For the filling to be performed successfully, the three given edges must belong to the same boundary component, and this boundary component must be a two-triangle torus. Moreover, the integers <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> must be coprime, and two of them must add to give the third. If any of these conditions are not met, then this routine will do nothing and return <code>false</code>.</p>
<p>The triangulation will be simplified before returning.</p>
<p>There are two versions of <a class="el" href="group__dim3.html#gae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a>; the other takes a boundary component, and sets <em>e0</em>, <em>e1</em> and <em>e2</em> to its three edges according to Regina's own edge numbering. This version of <a class="el" href="group__dim3.html#gae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a> should be used when you know how the filling curve cuts each boundary edge but you do not know how these edges are indexed in the corresponding boundary component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e0</td><td>one of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">e1</td><td>the second of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">e2</td><td>the second of the three edges of the boundary component to fill. </td></tr>
    <tr><td class="paramname">cuts0</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e0</em>. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e1</em>. </td></tr>
    <tr><td class="paramname">cuts2</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <em>e2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the boundary component was filled successfully, or <code>false</code> if one of the required conditions as described above is not satisfied. </dd></dl>

</div>
</div>
<a id="gae0bd90a983d00116514d0dd5bbefe3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0bd90a983d00116514d0dd5bbefe3a2">&#9670;&nbsp;</a></span>fillTorus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fillTorus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a two-triangle torus boundary component by attaching a solid torus along a given curve. </p>
<p>The boundary component to be filled should be passed as the argument <em>bc</em>; if the triangulation has exactly one boundary component then you may omit <em>bc</em> (i.e., pass <code>null</code>), and the (unique) boundary component will be inferred.</p>
<p>If the boundary component cannot be inferred, and/or if the selected boundary component is not a two-triangle torus, then this routine will do nothing and return <code>false</code>.</p>
<p>Otherwise the given boundary component will be filled with a solid torus whose meridional curve cuts the edges <code>bc-&gt;edge(0)</code>, <code>bc-&gt;edge(1)</code> and <code>bc-&gt;edge(2)</code> a total of <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> times respectively.</p>
<p>For the filling to be performed successfully, the integers <em>cuts0</em>, <em>cuts1</em> and <em>cuts2</em> must be coprime, and two of them must add to give the third. Otherwise, as above, this routine will do nothing and return <code>false</code>.</p>
<p>The triangulation will be simplified before returning.</p>
<p>There are two versions of <a class="el" href="group__dim3.html#gae0bd90a983d00116514d0dd5bbefe3a2" title="Fills a two-triangle torus boundary component by attaching a solid torus along a given curve.">fillTorus()</a>; the other takes three explicit edges instead of a boundary component. You should use the other version if you know how the filling curve cuts each boundary edge but you do not know how these edges are indexed in the boundary component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cuts0</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(0)</code>. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(1)</code>. </td></tr>
    <tr><td class="paramname">cuts2</td><td>the number of times that the meridional curve of the new solid torus should cut the edge <code>bc-&gt;edge(2)</code>. </td></tr>
    <tr><td class="paramname">bc</td><td>the boundary component to fill. If the triangulation has precisely one boundary component then this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the boundary component was filled successfully, or <code>false</code> if one of the required conditions as described above is not satisfied. </dd></dl>

</div>
</div>
<a id="ga8d6025d379dd0ec53d9ee8427f6ed1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6025d379dd0ec53d9ee8427f6ed1a7">&#9670;&nbsp;</a></span>findStrictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a>* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::findStrictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a strict angle structure on this triangulation. </p>
<p>Recall that a <em>strict</em> angle structure is one in which every angle is strictly between 0 and &pi;. If a strict angle structure does exist, then this routine is guaranteed to find one.</p>
<p>The underlying algorithm runs a single linear program (it does <em>not</em> enumerate all vertex angle structures). This means that it is likely to be fast even for large triangulations.</p>
<p>If you are only interested in <em>whether</em> a strict angle structure exists (i.e., you are not interested in the specific angles themselves), then you may call <a class="el" href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> instead.</p>
<p>The angle structure returned (if any) is cached internally alongside this triangulation. This means that, as long as the triangulation does not change, subsequent calls to <a class="el" href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7" title="Searches for a strict angle structure on this triangulation.">findStrictAngleStructure()</a> will return identical pointers and will be essentially instantaneous.</p>
<p>If the triangulation changes however, then the cached angle structure will be deleted. This means that you should not store the returned pointer for later use; instead you should just call <a class="el" href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7" title="Searches for a strict angle structure on this triangulation.">findStrictAngleStructure()</a> again.</p>
<dl class="section return"><dt>Returns</dt><dd>a strict angle structure on this triangulation, or 0 if none exists. </dd></dl>

</div>
</div>
<a id="gaf0cf09bfb6bc4e6f82db1466b3765b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cf09bfb6bc4e6f82db1466b3765b97">&#9670;&nbsp;</a></span>fourFourMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fourFourMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 4-4 move about the given edge. </p>
<p>This involves replacing the four tetrahedra joined at that edge with four tetrahedra joined along a different edge. Consider the octahedron made up of the four original tetrahedra; this has three internal axes. The initial four tetrahedra meet along the given edge which forms one of these axes; the new tetrahedra will meet along a different axis. This move can be done iff (i) the edge is valid and non-boundary, and (ii) the four tetrahedra are distinct.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>If this triangulation is currently oriented, then this 4-4 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">newAxis</td><td>Specifies which axis of the octahedron the new tetrahedra should meet along; this should be 0 or 1. Consider the four original tetrahedra in the order described by Edge&lt;3&gt;::embedding(0,...,3); call these tetrahedra 0, 1, 2 and<ol type="1">
<li>If <em>newAxis</em> is 0, the new axis will separate tetrahedra 0 and 1 from 2 and 3. If <em>newAxis</em> is 1, the new axis will separate tetrahedra 1 and 2 from 3 and 0. </li>
</ol>
</td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga61a3cf330dd5f6900cff75d237242ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a3cf330dd5f6900cff75d237242ef7">&#9670;&nbsp;</a></span>fourOneMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fourOneMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated function that checks the eligibility of and/or performs a 4-1 Pachner move upon the given vertex. </p>
<p>This is an alias for pachner(Vertex&lt;3&gt;*, bool, bool); see that routine for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given vertex is a vertex of this triangulation.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000196">Deprecated:</a></b></dt><dd>You should use the identical routine <a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">pachner()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vertex about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga1b1fb509efaa90335f0fd0863443b7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1fb509efaa90335f0fd0863443b7db">&#9670;&nbsp;</a></span>fromSnapPea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::fromSnapPea </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>snapPeaData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file. </p>
<p>All other SnapPea-specific information (such as peripheral curves) will be ignored, since Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class does not track such information itself.</p>
<p>If you wish to preserve all SnapPea-specific information from the data file, you should work with the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> class instead (which uses the SnapPea kernel directly, and can therefore store anything that SnapPea can).</p>
<p>If you wish to read a triangulation from a SnapPea <em>file</em>, you should likewise call the <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> constructor, giving the filename as argument. This will read all SnapPea-specific information (as described above), and also avoids constructing an enormous intermediate string.</p>
<p>The triangulation that is returned will be newly created. If the SnapPea data is not in the correct format, this routine will return 0 instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is "lossy", in that drops SnapPea-specific information (as described above). Unless you specifically need an <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (not an <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>) or you need to avoid calling routines from the SnapPea kernel, it is highly recommended that you create a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> from the given file contents instead. See the string-based <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> constructor for how to do this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snapPeaData</td><td>a string containing the full contents of a SnapPea data file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new triangulation extracted from the given data, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga3f6b6645fdc68b91645acda38cedb2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f6b6645fdc68b91645acda38cedb2a8">&#9670;&nbsp;</a></span>hasCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a compressing disc within the underlying 3-manifold. </p>
<p>Let <em>M</em> be the underlying 3-manifold and let <em>B</em> be its boundary. By a <em>compressing disc</em>, we mean a disc <em>D</em> properly embedded in <em>M</em>, where the boundary of <em>D</em> lies in <em>B</em> but does not bound a disc in <em>B</em>.</p>
<p>This routine will first call the heuristic routine <a class="el" href="group__dim3.html#ga31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">hasSimpleCompressingDisc()</a> in the hope of obtaining a fast answer. If this fails, it will do one of two things:</p>
<ul>
<li>If the triangulation is orientable and 1-vertex, it will use the linear programming and crushing machinery outlined in "Computing closed essential surfaces in knot complements", Burton, Coward and Tillmann, SCG '13, p405-414, 2013. This is often extremely fast, even for triangulations with many tetrahedra.</li>
<li>If the triangulation is non-orientable or has multiple vertices then it will run a full enumeration of vertex normal surfaces, as described in "Algorithms for the
  complete decomposition of a closed 3-manifold", Jaco and Tollefson, Illinois J. Math. 39 (1995), 358-406. As the number of tetrahedra grows, this can become extremely slow.</li>
</ul>
<p>This routine will work on a copy of this triangulation, not the original. In particular, the copy will be simplified, which means that there is no harm in calling this routine on an unsimplified triangulation.</p>
<p>If this triangulation has no boundary components, this routine will simply return <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal. </dd>
<dd>
The underlying 3-manifold is irreducible.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine can be infeasibly slow for large triangulations (particularly those that are non-orientable or have multiple vertices), since it may need to perform a full enumeration of vertex normal surfaces, and since it might perform "large" operations on these surfaces such as cutting along them. See <a class="el" href="group__dim3.html#ga31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">hasSimpleCompressingDisc()</a> for a "heuristic shortcut" that is faster but might not give a definitive answer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying 3-manifold contains a compressing disc, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="gaafcccbe5dab59415beab467a51fdab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcccbe5dab59415beab467a51fdab22">&#9670;&nbsp;</a></span>hasNegativeIdealBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasNegativeIdealBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation contains any ideal boundary components with negative Euler characteristic. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is at least one such boundary component. </dd></dl>

</div>
</div>
<a id="ga083a8ddcda2a432be55fa74fff30f5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083a8ddcda2a432be55fa74fff30f5c7">&#9670;&nbsp;</a></span>hasNonTrivialSphereOrDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasNonTrivialSphereOrDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a non-vertex-linking normal sphere or disc within this triangulation. </p>
<p>If such a surface exists within this triangulation, this routine is guaranteed to find one.</p>
<p>Note that the surface returned (if any) depends upon this triangulation, and so the surface must be destroyed before this triangulation is destroyed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may, in some scenarios, temporarily modify the packet tree by creating and then destroying a normal surface list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated non-vertex-linking normal sphere or disc, or 0 if none exists. </dd></dl>

</div>
</div>
<a id="gaa50916d43443f754d92082f80235ecf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50916d43443f754d92082f80235ecf7">&#9670;&nbsp;</a></span>hasOctagonalAlmostNormalSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasOctagonalAlmostNormalSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for an octagonal almost normal 2-sphere within this triangulation. </p>
<p>If such a surface exists, this routine is guaranteed to find one.</p>
<p>Note that the surface returned (if any) depends upon this triangulation, and so the surface must be destroyed before this triangulation is destroyed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable, connected, and 0-efficient. These preconditions are almost certainly more restrictive than they need to be, but we stay safe for now.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may, in some scenarios, temporarily modify the packet tree by creating and then destroying a normal surface list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated non-vertex-linking normal sphere or disc, or 0 if none exists. </dd></dl>

</div>
</div>
<a id="ga31d8cba1fae2b39de379ff6c8df4d61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d8cba1fae2b39de379ff6c8df4d61c">&#9670;&nbsp;</a></span>hasSimpleCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasSimpleCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a "simple" compressing disc inside this triangulation. </p>
<p>Let <em>M</em> be the underlying 3-manifold and let <em>B</em> be its boundary. By a <em>compressing disc</em>, we mean a disc <em>D</em> properly embedded in <em>M</em>, where the boundary of <em>D</em> lies in <em>B</em> but does not bound a disc in <em>B</em>.</p>
<p>By a <em>simple</em> compressing disc, we mean a compressing disc that has a very simple combinatorial structure (here "simple" is subject to change; see the warning below). Examples include the compressing disc inside a 1-tetrahedron solid torus, or a compressing disc formed from a single internal triangle surrounded by three boundary edges.</p>
<p>The purpose of this routine is to avoid working with normal surfaces within a large triangulation where possible. This routine is relatively fast, and if it returns <code>true</code> then this 3-manifold definitely contains a compressing disc. If this routine returns <code>false</code> then there might or might not be a compressing disc; the user will need to perform a full normal surface enumeration using <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> to be sure.</p>
<p>This routine will work on a copy of this triangulation, not the original. In particular, the copy will be simplified, which means that there is no harm in calling this routine on an unsimplified triangulation.</p>
<p>If this triangulation has no boundary components, this routine will simply return <code>false</code>.</p>
<p>For further information on this test, see "The Weber-Seifert
dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<dl class="section warning"><dt>Warning</dt><dd>The definition of "simple" is subject to change in future releases of Regina. That is, this routine may be expanded over time to identify more types of compressing discs (thus making it more useful as a "heuristic shortcut").</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a simple compressing disc was found, or <code>false</code> if not. Note that even with a return value of <code>false</code>, there might still be a compressing disc (just not one with a simple combinatorial structure). </dd></dl>

</div>
</div>
<a id="ga5d92d88a4a00fee457751e054e0ae4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d92d88a4a00fee457751e054e0ae4f7">&#9670;&nbsp;</a></span>hasSplittingSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasSplittingSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this triangulation has a normal splitting surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga330f08b68053b89d2545c0027bbc3405" title="Determines whether or not this surface is a splitting surface.">NormalSurface::isSplitting()</a> for details regarding normal splitting surfaces.</p>
<p>In the special case where this is the empty triangulation, this routine returns <code>false</code>.</p>
<p>As of Regina 6.0, this routine is now fast (small polynomial time), and works even for triangulations with more than one connected component. Thanks to Robert Haraway.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation has a normal splitting surface. </dd></dl>

</div>
</div>
<a id="gacf9d01479e8abe3e6759f13b66babb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9d01479e8abe3e6759f13b66babb9c">&#9670;&nbsp;</a></span>hasStrictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasStrictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation supports a strict angle structure. </p>
<p>Recall that a <em>strict</em> angle structure is one in which every angle is strictly between 0 and &pi;.</p>
<p>This routine is equivalent to calling <a class="el" href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7" title="Searches for a strict angle structure on this triangulation.">findStrictAngleStructure()</a> and testing whether the return value is non-null.</p>
<p>The underlying algorithm runs a single linear program (it does <em>not</em> enumerate all vertex angle structures). This means that it is likely to be fast even for large triangulations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a strict angle structure exists on this triangulation, or 0 if not. </dd></dl>

</div>
</div>
<a id="ga46851fcdaca6a86afe44b9fd185d0c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46851fcdaca6a86afe44b9fd185d0c1b">&#9670;&nbsp;</a></span>hasTwoSphereBoundaryComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::hasTwoSphereBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation contains any two-sphere boundary components. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is at least one two-sphere boundary component. </dd></dl>

</div>
</div>
<a id="gafdd544278d4054d8b11144af3c13e756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd544278d4054d8b11144af3c13e756">&#9670;&nbsp;</a></span>homologyBdry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyBdry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of the boundary for this triangulation. </p>
<p>Note that ideal vertices are considered part of the boundary.</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__dim3.html#gafdd544278d4054d8b11144af3c13e756" title="Returns the first homology group of the boundary for this triangulation.">homologyBdry()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<p>This routine is fairly fast, since it deduces the homology of each boundary component through knowing what kind of surface it is.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of the boundary. </dd></dl>

</div>
</div>
<a id="ga0c7367b565a914ccf4ecd5bbc9e7e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7367b565a914ccf4ecd5bbc9e7e65b">&#9670;&nbsp;</a></span>homologyH2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyH2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group for this triangulation. </p>
<p>If this triangulation contains any ideal vertices, the homology group will be calculated as if each such vertex had been truncated. The algorithm used calculates various first homology groups and uses homology and cohomology theorems to deduce the second homology group.</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__dim3.html#ga0c7367b565a914ccf4ecd5bbc9e7e65b" title="Returns the second homology group for this triangulation.">homologyH2()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the second homology group. </dd></dl>

</div>
</div>
<a id="ga86c0948923311085b2d5c0bb61a6ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c0948923311085b2d5c0bb61a6ab95">&#9670;&nbsp;</a></span>homologyH2Z2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyH2Z2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group with coefficients in Z_2 for this triangulation. </p>
<p>If this triangulation contains any ideal vertices, the homology group will be calculated as if each such vertex had been truncated. The algorithm used calculates the relative first homology group with respect to the boundary and uses homology and cohomology theorems to deduce the second homology group.</p>
<p>This group will simply be the direct sum of several copies of Z_2, so the number of Z_2 terms is returned.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of Z_2 terms in the second homology group with coefficients in Z_2. </dd></dl>

</div>
</div>
<a id="ga2c04ae11156b884a110348c037e7e4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c04ae11156b884a110348c037e7e4cf">&#9670;&nbsp;</a></span>homologyRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::homologyRel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relative first homology group with respect to the boundary for this triangulation. </p>
<p>Note that ideal vertices are considered part of the boundary.</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__dim3.html#ga2c04ae11156b884a110348c037e7e4cf" title="Returns the relative first homology group with respect to the boundary for this triangulation.">homologyRel()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the relative first homology group with respect to the boundary. </dd></dl>

</div>
</div>
<a id="gac025b93b99f5b674fd448e6374c81142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac025b93b99f5b674fd448e6374c81142">&#9670;&nbsp;</a></span>idealToFinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::idealToFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ideal triangulation into a finite triangulation. </p>
<p>All ideal or invalid vertices are truncated and thus converted into real boundary components made from unglued faces of tetrahedra.</p>
<p>Note that this operation is a loose converse of <a class="el" href="group__detail.html#gadc25a58b48e39f3c7f8621b84432d294" title="Converts each real boundary component into a cusp (i.e., an ideal vertex).">finiteToIdeal()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this routine subdivides all tetrahedra as if <em>all</em> vertices (not just some) were ideal. This may lead to more tetrahedra than are necessary.</dd>
<dd>
Currently, the presence of an invalid edge will force the triangulation to be subdivided regardless of the value of parameter <em>forceDivision</em>. The final triangulation will still have the projective plane cusp caused by the invalid edge.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000053">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Have this routine only use as many tetrahedra as are necessary, leaving finite vertices alone.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was changed. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>David Letscher </dd></dl>

</div>
</div>
<a id="ga365a97340d03271ae3eae9870f5b6a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga365a97340d03271ae3eae9870f5b6a87">&#9670;&nbsp;</a></span>insertAugTriSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertAugTriSolidTorus </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an augmented triangular solid torus with the given parameters into this triangulation. </p>
<p>Almost all augmented triangular solid tori represent Seifert fibred spaces with three or fewer exceptional fibres. Augmented triangular solid tori are described in more detail in the <a class="el" href="classregina_1_1AugTriSolidTorus.html" title="Represents an augmented triangular solid torus component of a triangulation.">AugTriSolidTorus</a> class notes.</p>
<p>The resulting Seifert fibred space will be SFS((<em>a1</em>,<em>b1</em>) (<em>a2</em>,<em>b2</em>) (<em>a3</em>,<em>b3</em>) (1,1)), where the parameters <em>a1</em>, ..., <em>b3</em> are passed as arguments to this routine. The three layered solid tori that are attached to the central triangular solid torus will be LST(|<em>a1</em>|, |<em>b1</em>|, |-<em>a1</em>-<em>b1</em>|), ..., LST(|<em>a3</em>|, |<em>b3</em>|, |-<em>a3</em>-<em>b3</em>|).</p>
<p>The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>gcd(<em>a1</em>, <em>b1</em>) = 1. </dd>
<dd>
gcd(<em>a2</em>, <em>b2</em>) = 1. </dd>
<dd>
gcd(<em>a3</em>, <em>b3</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>a parameter describing the first layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
    <tr><td class="paramname">b1</td><td>a parameter describing the first layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
    <tr><td class="paramname">a2</td><td>a parameter describing the second layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
    <tr><td class="paramname">b2</td><td>a parameter describing the second layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
    <tr><td class="paramname">a3</td><td>a parameter describing the third layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
    <tr><td class="paramname">b3</td><td>a parameter describing the third layered solid torus in the augmented triangular solid torus; this may be either positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabcec413ba8a0ff9560e20ab4ed7b7649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcec413ba8a0ff9560e20ab4ed7b7649">&#9670;&nbsp;</a></span>insertLayeredLensSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertLayeredLensSpace </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new layered lens space L(p,q) into the triangulation. </p>
<p>The lens space will be created by gluing together two layered solid tori in a way that uses the fewest possible tetrahedra.</p>
<p>The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>p</em> &gt; <em>q</em> &gt;= 0 unless (<em>p</em>,<em>q</em>) = (0,1); </dd>
<dd>
gcd(<em>p</em>, <em>q</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a parameter of the desired lens space. </td></tr>
    <tr><td class="paramname">q</td><td>a parameter of the desired lens space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1LayeredLensSpace.html" title="Represents a layered lens space component of a triangulation.">LayeredLensSpace</a> </dd></dl>

</div>
</div>
<a id="ga81d30803ee064e8e5310331b4eff1a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d30803ee064e8e5310331b4eff1a9d">&#9670;&nbsp;</a></span>insertLayeredLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertLayeredLoop </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a layered loop of the given length into this triangulation. </p>
<p>Layered loops are described in more detail in the <a class="el" href="classregina_1_1LayeredLoop.html" title="Represents a layered loop component of a triangulation.">LayeredLoop</a> class notes.</p>
<p>The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the new layered loop; this must be strictly positive. </td></tr>
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new layered loop should be twisted, or <code>false</code> if it should be untwisted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1LayeredLoop.html" title="Represents a layered loop component of a triangulation.">LayeredLoop</a> </dd></dl>

</div>
</div>
<a id="gae99ca37ffcd95d0c2435e5155a19c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99ca37ffcd95d0c2435e5155a19c2ad">&#9670;&nbsp;</a></span>insertLayeredSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertLayeredSolidTorus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cuts1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new layered solid torus into the triangulation. </p>
<p>The meridinal disc of the layered solid torus will intersect the three edges of the boundary torus in <em>cuts0</em>, <em>cuts1</em> and (<em>cuts0</em> + <em>cuts1</em>) points respectively.</p>
<p>The boundary torus will always consist of faces 012 and 013 of the tetrahedron containing this boundary torus (this tetrahedron will be returned). In face 012, edges 12, 02 and 01 will meet the meridinal disc <em>cuts0</em>, <em>cuts1</em> and (<em>cuts0</em> + <em>cuts1</em>) times respectively. The only exceptions are if these three intersection numbers are (1,1,2) or (0,1,1), in which case edges 12, 02 and 01 will meet the meridinal disc (1, 2 and 1) or (1, 1 and 0) times respectively.</p>
<p>The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>cuts0</em> &lt;= <em>cuts1</em>; </dd>
<dd>
gcd(<em>cuts0</em>, <em>cuts1</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cuts0</td><td>the smallest of the three desired intersection numbers. </td></tr>
    <tr><td class="paramname">cuts1</td><td>the second smallest of the three desired intersection numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tetrahedron containing the boundary torus.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1LayeredSolidTorus.html" title="Represents a layered solid torus in a triangulation.">LayeredSolidTorus</a> </dd></dl>

</div>
</div>
<a id="ga59ebb16f99797ca3f97e044a57d95c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59ebb16f99797ca3f97e044a57d95c2f">&#9670;&nbsp;</a></span>insertRehydration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertRehydration </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dehydration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the rehydration of the given string into this triangulation. </p>
<p>If you simply wish to convert a dehydration string into a new triangulation, use the static routine <a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e" title="Rehydrates the given alphabetical string into a new triangulation.">rehydrate()</a> instead. See <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> for more information on dehydration strings.</p>
<p>This routine will first rehydrate the given string into a proper triangulation. The tetrahedra from the rehydrated triangulation will then be inserted into this triangulation in the same order in which they appear in the rehydrated triangulation, and the numbering of their vertices (0-3) will not change.</p>
<p>The routine <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> can be used to extract a dehydration string from an existing triangulation. Dehydration followed by rehydration might not produce a triangulation identical to the original, but it is guaranteed to produce an isomorphic copy. See <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> for the reasons behind this.</p>
<p>For a full description of the dehydrated triangulation format, see <em>A <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> of Cusped Hyperbolic 3-Manifolds</em>, Callahan, Hildebrand and Weeks, Mathematics of Computation 68/225, 1999.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dehydration</td><td>a dehydrated representation of the triangulation to insert. Case is irrelevant; all letters will be treated as if they were lower case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the insertion was successful, or <code>false</code> if the given string could not be rehydrated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate</a> </dd>
<dd>
<a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e" title="Rehydrates the given alphabetical string into a new triangulation.">rehydrate</a> </dd></dl>

</div>
</div>
<a id="ga535ca040456b25b738f9bb44c9f76ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535ca040456b25b738f9bb44c9f76ee3">&#9670;&nbsp;</a></span>insertSFSOverSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::insertSFSOverSphere </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a1</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a2</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a3</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b3</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an orientable Seifert fibred space with at most three exceptional fibres over the 2-sphere into this triangulation. </p>
<p>The inserted Seifert fibred space will be SFS((<em>a1</em>,<em>b1</em>) (<em>a2</em>,<em>b2</em>) (<em>a3</em>,<em>b3</em>) (1,1)), where the parameters <em>a1</em>, ..., <em>b3</em> are passed as arguments to this routine.</p>
<p>The three pairs of parameters (<em>a</em>,<em>b</em>) do not need to be normalised, i.e., the parameters can be positive or negative and <em>b</em> may lie outside the range [0..<em>a</em>). There is no separate twisting parameter; each additional twist can be incorporated into the existing parameters by replacing some pair (<em>a</em>,<em>b</em>) with the pair (<em>a</em>,<em>a</em>+<em>b</em>). For Seifert fibred spaces with less than three exceptional fibres, some or all of the parameter pairs may be (1,<em>k</em>) or even (1,0).</p>
<p>The new tetrahedra will be inserted at the end of the list of tetrahedra in the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None of <em>a1</em>, <em>a2</em> or <em>a3</em> are 0. </dd>
<dd>
gcd(<em>a1</em>, <em>b1</em>) = 1. </dd>
<dd>
gcd(<em>a2</em>, <em>b2</em>) = 1. </dd>
<dd>
gcd(<em>a3</em>, <em>b3</em>) = 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>a parameter describing the first exceptional fibre. </td></tr>
    <tr><td class="paramname">b1</td><td>a parameter describing the first exceptional fibre. </td></tr>
    <tr><td class="paramname">a2</td><td>a parameter describing the second exceptional fibre. </td></tr>
    <tr><td class="paramname">b2</td><td>a parameter describing the second exceptional fibre. </td></tr>
    <tr><td class="paramname">a3</td><td>a parameter describing the third exceptional fibre. </td></tr>
    <tr><td class="paramname">b3</td><td>a parameter describing the third exceptional fibre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad63140ff3ab1dd53acd661a6c8cde47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63140ff3ab1dd53acd661a6c8cde47e">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the triangulation using fast and greedy heuristics. </p>
<p>This routine will attempt to reduce both the number of tetrahedra and the number of boundary triangles (with the number of tetrahedra as its priority).</p>
<p>Currently this routine uses <a class="el" href="group__dim3.html#ga0bc067391ecf8f6269e624ee9d658761" title="Uses all known simplification moves to reduce the triangulation monotonically to some local minimum n...">simplifyToLocalMinimum()</a> in combination with random 4-4 moves, book opening moves and book closing moves.</p>
<p>Although <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> works very well most of the time, it can occasionally get stuck; in such cases you may wish to try the more powerful but (much) slower <a class="el" href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> instead.</p>
<p>If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Running this routine multiple times upon the same triangulation may return different results, since the implementation makes random decisions. More broadly, the implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd><em>Optimise:</em> Include random 2-3 moves to get out of wells.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was successfully simplified. Otherwise this triangulation will not be changed. </dd></dl>

</div>
</div>
<a id="ga9d64120795e92d1a7c18b0427180080a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d64120795e92d1a7c18b0427180080a">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__snappea.html#gaac5b4c8b62c4c1467bac25d2797629f7">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga4bccc3c75b25276fa66c4fc1b337cc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bccc3c75b25276fa66c4fc1b337cc0c">&#9670;&nbsp;</a></span>isBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of a 3-dimensional ball. </p>
<p>This routine is based on <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a>, which in turn combines Rubinstein's 3-sphere recognition algorithm with Jaco and Rubinstein's 0-efficiency prime decomposition algorithm.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="group__dim3.html#gaa1ece1722460a2265a4926a7d517af2e" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimension...">knowsBall()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a triangulation of a 3-dimensional ball. </dd></dl>

</div>
</div>
<a id="gabef53f62c988b090ce5f9e398f9066d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef53f62c988b090ce5f9e398f9066d3">&#9670;&nbsp;</a></span>isClosed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Component.html">regina::Component</a>&lt; 3 &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this component is closed. </p>
<p>This is the case if and only if it has no boundary. Note that ideal components are not closed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this component is closed. </dd></dl>

</div>
</div>
<a id="ga07002c044286b6ba00d747d3fa49d52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07002c044286b6ba00d747d3fa49d52a">&#9670;&nbsp;</a></span>isClosed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is closed. </p>
<p>This is the case if and only if it has no boundary. Note that ideal triangulations are not closed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is closed. </dd></dl>

</div>
</div>
<a id="ga1508686718374e81f50b5d3ca694f83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1508686718374e81f50b5d3ca694f83a">&#9670;&nbsp;</a></span>isCone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 2 &gt;::isCone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangle is wrapped up to form a cone. </p>
<p>Note that several different triangle types (as returned by <a class="el" href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f" title="Returns a description of the triangle type.">type()</a>) can produce this result. Note also that a triangle can be both a Mobius band <em>and</em> a cone.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangle is a cone. </dd></dl>

</div>
</div>
<a id="ga14dd70d1448cb32ce52da8e8ae78f6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14dd70d1448cb32ce52da8e8ae78f6d8">&#9670;&nbsp;</a></span>isHaken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isHaken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken. </p>
<p>In other words, this routine determines whether the underlying 3-manifold contains an embedded closed two-sided incompressible surface.</p>
<p>Currently Hakenness testing is available only for irreducible manifolds. This routine will first test whether the manifold is irreducible and, if it is not, will return <code>false</code> immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine could be very slow for larger triangulations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the underlying 3-manifold is irreducible and Haken. </dd></dl>

</div>
</div>
<a id="gae2cf63fc33430bf03ef2bfb08900b6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cf63fc33430bf03ef2bfb08900b6b4">&#9670;&nbsp;</a></span>isIdeal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Component.html">regina::Component</a>&lt; 3 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this component is ideal. </p>
<p>This is the case if and only if it contains an ideal vertex as described by Vertex&lt;3&gt;::isIdeal().</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this component is ideal. </dd></dl>

</div>
</div>
<a id="ga6ef22e54275916f8b81b8fd74ab8a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ef22e54275916f8b81b8fd74ab8a439">&#9670;&nbsp;</a></span>isIdeal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is ideal. </p>
<p>This is the case if and only if one of the vertex links is closed and not a 2-sphere. Note that the triangulation is not required to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is ideal. </dd></dl>

</div>
</div>
<a id="ga01930771735b8e8e038961938a19a994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01930771735b8e8e038961938a19a994">&#9670;&nbsp;</a></span>isIdeal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vertex is an ideal vertex. </p>
<p>This requires the vertex link to be closed and not a 2-sphere.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is an ideal vertex. </dd></dl>

</div>
</div>
<a id="ga7785d4bb75a5366cc4d9bae5bf5536ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7785d4bb75a5366cc4d9bae5bf5536ae">&#9670;&nbsp;</a></span>isIrreducible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isIrreducible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the underlying 3-manifold (which must be closed) is irreducible. </p>
<p>In other words, this routine determines whether every embedded sphere in the underlying 3-manifold bounds a ball.</p>
<p>If the underlying 3-manifold is orientable, this routine will use fast crushing and branch-and-bound methods. If the underlying 3-manifold is non-orientable, it will use a (much slower) full enumeration of vertex normal surfaces.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and might be slow for larger triangulations.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the underlying 3-manifold is irreducible. </dd></dl>

</div>
</div>
<a id="ga7e01e4f5bbef0e84445d22ca6893c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e01e4f5bbef0e84445d22ca6893c213">&#9670;&nbsp;</a></span>isLinkClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isLinkClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the link of this vertex is closed. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link of this vertex is closed. </dd></dl>

</div>
</div>
<a id="ga46e831408180b6c804d8fb3b1842d3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46e831408180b6c804d8fb3b1842d3b5">&#9670;&nbsp;</a></span>isMobiusBand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 2 &gt;::isMobiusBand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangle is wrapped up to form a Mobius band. </p>
<p>Note that several different triangle types (as returned by <a class="el" href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f" title="Returns a description of the triangle type.">type()</a>) can produce this result. Note also that a triangle can be both a Mobius band <em>and</em> a cone.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangle is a Mobius band. </dd></dl>

</div>
</div>
<a id="ga579be62f99849f22c5a23cceb3f2bf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579be62f99849f22c5a23cceb3f2bf41">&#9670;&nbsp;</a></span>isOrdered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is ordered; that is, if tetrahedron vertices are labelled so that all gluing permutations are order-preserving on the tetrahedron faces. </p>
<p>Equivalently, this tests whether the edges of the triangulation can all be oriented such that they induce a consistent ordering on the vertices of each tetrahedron.</p>
<p>Triangulations are not ordered by default, and indeed some cannot be ordered at all. The routine <a class="el" href="group__dim3.html#ga8b1c5856b28d23276d52d5c4c7705b5d" title="Relabels tetrahedron vertices in this triangulation to give an ordered triangulation,...">order()</a> will attempt to relabel tetrahedron vertices to give an ordered triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all gluing permutations are order preserving on the tetrahedron faces.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="ga6887425d2144a4f3a485c59ec9b74c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6887425d2144a4f3a485c59ec9b74c3e">&#9670;&nbsp;</a></span>isSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of the solid torus; that is, the unknot complement. </p>
<p>This routine can be used on a triangulation with real boundary triangles, or on an ideal triangulation (in which case all ideal vertices will be assumed to be truncated).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so might be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="group__dim3.html#ga281f3fc9351e4c757fec0053252d1dd4" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus...">knowsSolidTorus()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is either a real (compact) or ideal (non-compact) triangulation of the solid torus. </dd></dl>

</div>
</div>
<a id="ga97688a6770fe85d320b05edd355abbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97688a6770fe85d320b05edd355abbc2">&#9670;&nbsp;</a></span>isStandard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is standard. </p>
<p>This is the case if and only if every vertex is standard. See Vertex&lt;3&gt;::isStandard() for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is standard. </dd></dl>

</div>
</div>
<a id="gafeed70df6add0c2808c22244f7e1dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeed70df6add0c2808c22244f7e1dbbd">&#9670;&nbsp;</a></span>isStandard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::isStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vertex is standard. </p>
<p>This requires the vertex link to be a sphere, disc, torus or Klein bottle.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this vertex is standard. </dd></dl>

</div>
</div>
<a id="ga1ca834327979c983148c9bd166c39a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca834327979c983148c9bd166c39a77">&#9670;&nbsp;</a></span>isThreeSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isThreeSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is a triangulation of a 3-sphere. </p>
<p>This routine relies upon a combination of Rubinstein's 3-sphere recognition algorithm and Jaco and Rubinstein's 0-efficiency prime decomposition algorithm.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations (although faster tests are used where possible). The routine <a class="el" href="group__dim3.html#ga265402601c5756fec4ea837197aeac89" title="Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere?...">knowsThreeSphere()</a> can be called to see if this property is already known or if it happens to be very fast to calculate for this triangulation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a 3-sphere triangulation. </dd></dl>

</div>
</div>
<a id="gae0326a12e5c235b90e78ccd3f51e5863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0326a12e5c235b90e78ccd3f51e5863">&#9670;&nbsp;</a></span>isTxI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isTxI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the underlying 3-manifold is the product of a torus with an interval. </p>
<p>This routine can be used on a triangulation with real boundary triangles, or ideal boundary components, or a mix of both. If there are any ideal vertices, they will be treated as though they were truncated.</p>
<p>The underlying algorithm is due to Robert C. Haraway, III; see <a href="https://journals.carleton.ca/jocg/index.php/jocg/article/view/433">https://journals.carleton.ca/jocg/index.php/jocg/article/view/433</a> for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This algorithm ultimately relies on <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a>, which might run slowly for large triangulations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a triangulation (either real, ideal or a combination) of the product of the torus with an interval. </dd></dl>

</div>
</div>
<a id="ga570440313fe0bfe6b6a56afd00c3b0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga570440313fe0bfe6b6a56afd00c3b0b6">&#9670;&nbsp;</a></span>isZeroEfficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::isZeroEfficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is 0-efficient. </p>
<p>A triangulation is 0-efficient if its only normal spheres and discs are vertex linking, and if it has no 2-sphere boundary components.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is 0-efficient. </dd></dl>

</div>
</div>
<a id="gaa1ece1722460a2265a4926a7d517af2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ece1722460a2265a4926a7d517af2e">&#9670;&nbsp;</a></span>knowsBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-dimensional ball? See <a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> will be very fast (simply returning the precalculated value).</p>
<p>If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> and this routine will return <code>true</code>.</p>
<p>Otherwise a call to <a class="el" href="group__dim3.html#ga4bccc3c75b25276fa66c4fc1b337cc0c" title="Determines whether this is a triangulation of a 3-dimensional ball.">isBall()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a ball; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga70b6cb41cbea1bab5fbe1692ecd8a2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70b6cb41cbea1bab5fbe1692ecd8a2d7">&#9670;&nbsp;</a></span>knowsCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsCompressingDisc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold contains a compressing disc? See <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> will be very fast (simply returning the precalculated value).</p>
<p>If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> and this routine will return <code>true</code>.</p>
<p>Otherwise a call to <a class="el" href="group__dim3.html#ga3f6b6645fdc68b91645acda38cedb2a8" title="Searches for a compressing disc within the underlying 3-manifold.">hasCompressingDisc()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold has a compressing disc; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid and is not ideal. </dd>
<dd>
The underlying 3-manifold is irreducible.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="gadaeafdd4bd2b7a28d3bcfcb31521a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaeafdd4bd2b7a28d3bcfcb31521a5a3">&#9670;&nbsp;</a></span>knowsHaken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsHaken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold is Haken? See <a class="el" href="group__dim3.html#ga14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga14dd70d1448cb32ce52da8e8ae78f6d8" title="Determines whether the underlying 3-manifold (which must be closed and orientable) is Haken.">isHaken()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold is Haken; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="gaa96238fc751a6350e17ce5727a183ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96238fc751a6350e17ce5727a183ba1">&#9670;&nbsp;</a></span>knowsIrreducible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsIrreducible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not the underlying 3-manifold is irreducible? See <a class="el" href="group__dim3.html#ga7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga7785d4bb75a5366cc4d9bae5bf5536ae" title="Determines whether the underlying 3-manifold (which must be closed) is irreducible.">isIrreducible()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the underlying 3-manifold is irreducible; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga281f3fc9351e4c757fec0053252d1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga281f3fc9351e4c757fec0053252d1dd4">&#9670;&nbsp;</a></span>knowsSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsSolidTorus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a solid torus (that is, the unknot complement)? See <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> will be very fast (simply returning the precalculated value).</p>
<p>If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> and this routine will return <code>true</code>.</p>
<p>Otherwise a call to <a class="el" href="group__dim3.html#ga6887425d2144a4f3a485c59ec9b74c3e" title="Determines whether this is a triangulation of the solid torus; that is, the unknot complement.">isSolidTorus()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a solid torus; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga96c145120697c1050b74e917dd341dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96c145120697c1050b74e917dd341dd3">&#9670;&nbsp;</a></span>knowsSplittingSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsSplittingSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known whether or not this triangulation has a splitting surface? See <a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7" title="Determines whether this triangulation has a normal splitting surface.">hasSplittingSurface()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7" title="Determines whether this triangulation has a normal splitting surface.">hasSplittingSurface()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation has a splitting surface; it merely tells you whether the answer has already been computed.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000195">Deprecated:</a></b></dt><dd>Since <a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7" title="Determines whether this triangulation has a normal splitting surface.">hasSplittingSurface()</a> now uses a fast (small polynomial time) algorithm, there is no need to pre-query whether the property is already known. Just call <a class="el" href="group__dim3.html#ga5d92d88a4a00fee457751e054e0ae4f7" title="Determines whether this triangulation has a normal splitting surface.">hasSplittingSurface()</a> directly.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="gac439e27b0888b60b2d256e9ad8eaaa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac439e27b0888b60b2d256e9ad8eaaa15">&#9670;&nbsp;</a></span>knowsStrictAngleStructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsStrictAngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this triangulation supports a strict angle structure? See <a class="el" href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga8d6025d379dd0ec53d9ee8427f6ed1a7" title="Searches for a strict angle structure on this triangulation.">findStrictAngleStructure()</a> and <a class="el" href="group__dim3.html#gacf9d01479e8abe3e6759f13b66babb9c" title="Determines whether this triangulation supports a strict angle structure.">hasStrictAngleStructure()</a> will be very fast (simply returning the precalculated solution).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> the triangulation supports a strict angle structure; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga265402601c5756fec4ea837197aeac89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265402601c5756fec4ea837197aeac89">&#9670;&nbsp;</a></span>knowsThreeSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsThreeSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a 3-sphere? See <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> will be very fast (simply returning the precalculated value).</p>
<p>If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> and this routine will return <code>true</code>.</p>
<p>Otherwise a call to <a class="el" href="group__dim3.html#ga1ca834327979c983148c9bd166c39a77" title="Determines whether this is a triangulation of a 3-sphere.">isThreeSphere()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms a 3-sphere; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga53ffd0e9e8e5b2e9c8521c58871ec56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ffd0e9e8e5b2e9c8521c58871ec56b">&#9670;&nbsp;</a></span>knowsTxI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsTxI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it already known (or trivial to determine) whether or not this is a triangulation of a the product of a torus with an interval? See <a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> for further details. </p>
<p>If this property is indeed already known, future calls to <a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> will be very fast (simply returning the precalculated value).</p>
<p>If this property is not already known, this routine will nevertheless run some very fast preliminary tests to see if the answer is obviously no. If so, it will store <code>false</code> as the precalculated value for <a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> and this routine will return <code>true</code>.</p>
<p>Otherwise a call to <a class="el" href="group__dim3.html#gae0326a12e5c235b90e78ccd3f51e5863" title="Determines whether or not the underlying 3-manifold is the product of a torus with an interval.">isTxI()</a> may potentially require more significant work, and so this routine will return <code>false</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation forms the product of the torus with an interval; it merely tells you whether the answer has already been computed (or is very easily computed).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known or trivial to calculate. </dd></dl>

</div>
</div>
<a id="ga18754e52a8c76dcadb6f885bb7c551bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18754e52a8c76dcadb6f885bb7c551bc">&#9670;&nbsp;</a></span>knowsZeroEfficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::knowsZeroEfficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is it already known whether or not this triangulation is 0-efficient? See <a class="el" href="group__dim3.html#ga570440313fe0bfe6b6a56afd00c3b0b6" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> for further details. </p>
<p>If this property is already known, future calls to <a class="el" href="group__dim3.html#ga570440313fe0bfe6b6a56afd00c3b0b6" title="Determines if this triangulation is 0-efficient.">isZeroEfficient()</a> will be very fast (simply returning the precalculated value).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not actually tell you <em>whether</em> this triangulation is 0-efficient; it merely tells you whether the answer has already been computed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this property is already known. </dd></dl>

</div>
</div>
<a id="gad484a6c5eb82073a251b4a056777a475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad484a6c5eb82073a251b4a056777a475">&#9670;&nbsp;</a></span>layerOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::layerOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a layering upon the given boundary edge of the triangulation. </p>
<p>See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for further details on what a layering entails.</p>
<p>The new tetrahedron will be returned, and the new boundary edge that it creates will be edge 5 (i.e., the edge joining vertices 2 and 3) of this tetrahedron.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge is a boundary edge of this triangulation, and the two boundary triangles on either side of it are distinct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the boundary edge upon which to layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new tetrahedron provided by the layering. </dd></dl>

</div>
</div>
<a id="ga62065e3c545bc03eead5ea324218fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62065e3c545bc03eead5ea324218fb6d">&#9670;&nbsp;</a></span>link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt;::<a class="el" href="group__dim3.html#ga3a34beeab677315bd4b5e0091ea1645c">LinkType</a> <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a broad categorisation of the link of the vertex. </p>
<p>This considers topological information only, not the combinatorics of how the link is triangulated.</p>
<p>This routine does not require a full triangulation of the vertex link, and so can be much faster than analysing the result of <a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a broad categorisation of the vertex link. </dd></dl>

</div>
</div>
<a id="ga262af8b8587ab08281ed6f80aca226fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga262af8b8587ab08281ed6f80aca226fb">&#9670;&nbsp;</a></span>linkEulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::linkEulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the vertex link. </p>
<p>This routine does not require a full triangulation of the vertex link, and so can be much faster than calling <a class="el" href="group__dim3.html#gab249ca6c2debe19f475562cf16607fc9" title="Returns a full 2-manifold triangulation describing the link of this vertex.">buildLink()</a>.eulerChar().</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the vertex link. </dd></dl>

</div>
</div>
<a id="ga8531170c02fc4d184ed5ce64b0a8181f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8531170c02fc4d184ed5ce64b0a8181f">&#9670;&nbsp;</a></span>longitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::longitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edge, and returns this edge. </p>
<p>Assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine:</p>
<ul>
<li>identifies the algebraic longitude of the knot complement; that is, identifies the non-trivial simple closed curve on the boundary whose homology in the 3-manifold is trivial;</li>
<li>layers additional tetrahedra on the boundary if necessary so that this curve is represented by a single boundary edge;</li>
<li>returns that (possibly new) boundary edge.</li>
</ul>
<p>Whilst this routine returns less information than <a class="el" href="group__dim3.html#ga2b7f8558f06077f8cbe716a8691717d6" title="Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a si...">meridianLongitude()</a>, it (1) runs much faster since it is based on fast algebraic calculations, and (2) guarantees to terminate. In contrast, <a class="el" href="group__dim3.html#ga2b7f8558f06077f8cbe716a8691717d6" title="Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a si...">meridianLongitude()</a> must repeatedly try to test for 3-spheres, and (as a result of only using fast 3-sphere recognition heuristics) does not guarantee to terminate.</p>
<p>At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<p>If the algebraic longitude is already represented by a single boundary edge, then it is guaranteed that this routine will <em>not</em> modify the triangulation, and will simply return this boundary edge.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may modify the triangluation, as explained above, which will have the side-effect of invalidating any existing Vertex, Edge or Triangle references.</dd>
<dd>
If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="group__dim3.html#gac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the boundary edge representing the algebraic longitude of the knot (after this triangulation has been modified if necessary), or <code>null</code> if an error (such as an integer overflow) occurred during the computation. </dd></dl>

</div>
</div>
<a id="ga91bc0ba8cbb3ecef1fbbe71c05b9d067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91bc0ba8cbb3ecef1fbbe71c05b9d067">&#9670;&nbsp;</a></span>makeZeroEfficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::makeZeroEfficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a 0-efficient triangulation of the same underlying 3-manifold. </p>
<p>A triangulation is 0-efficient if its only normal spheres and discs are vertex linking, and if it has no 2-sphere boundary components.</p>
<p>Note that this routine is currently only available for closed orientable triangulations; see the list of preconditions for details. The 0-efficiency algorithm of Jaco and Rubinstein is used.</p>
<p>If the underlying 3-manifold is prime, it can always be made 0-efficient (with the exception of the special cases RP3 and S2xS1 as noted below). In this case the original triangulation will be modified directly and 0 will be returned.</p>
<p>If the underyling 3-manifold is RP3 or S2xS1, it cannot be made 0-efficient; in this case the original triangulation will be reduced to a two-tetrahedron minimal triangulation and 0 will again be returned.</p>
<p>If the underlying 3-manifold is not prime, it cannot be made 0-efficient. In this case the original triangulation will remain unchanged and a new connected sum decomposition will be returned. This will be presented as a newly allocated container packet with one child triangulation for each prime summand.</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithms used in this routine rely on normal surface theory and so can be very slow for larger triangulations.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed, orientable and connected.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000052">Todo:</a></b></dt><dd>Preserve computed properties of the underlying manifold.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the underlying 3-manifold is prime (in which case the original triangulation was modified directly), or a newly allocated connected sum decomposition if the underlying 3-manifold is composite (in which case the original triangulation was not changed). </dd></dl>

</div>
</div>
<a id="ga1243c7aeb18c339068d8fe308af037dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1243c7aeb18c339068d8fe308af037dc">&#9670;&nbsp;</a></span>maximalForestInBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::maximalForestInBoundary </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a maximal forest in the 1-skeleton of the triangulation boundary. </p>
<p>Both given sets will be emptied and the edges and vertices of the maximal forest will be placed into them. A vertex that forms its own boundary component (such as an ideal vertex) will still be placed in <code>vertexSet</code>.</p>
<p>Note that the edge and vertex pointers returned will become invalid once the triangulation has changed.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeSet</td><td>the set to be emptied and into which the edges of the maximal forest will be placed. </td></tr>
    <tr><td class="paramname">vertexSet</td><td>the set to be emptied and into which the vertices of the maximal forest will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad34c4cb9c0978c75c3062d6dcc018afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34c4cb9c0978c75c3062d6dcc018afa">&#9670;&nbsp;</a></span>maximalForestInSkeleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::maximalForestInSkeleton </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>canJoinBoundaries</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a maximal forest in the triangulation's 1-skeleton. </p>
<p>The given set will be emptied and will have the edges of the maximal forest placed into it. It can be specified whether or not different boundary components may be joined by the maximal forest.</p>
<p>An edge leading to an ideal vertex is still a candidate for inclusion in the maximal forest. For the purposes of this algorithm, any ideal vertex will be treated as any other vertex (and will still be considered part of its own boundary component).</p>
<p>Note that the edge pointers returned will become invalid once the triangulation has changed.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeSet</td><td>the set to be emptied and into which the edges of the maximal forest will be placed. </td></tr>
    <tr><td class="paramname">canJoinBoundaries</td><td><code>true</code> if and only if different boundary components are allowed to be joined by the maximal forest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b7f8558f06077f8cbe716a8691717d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b7f8558f06077f8cbe716a8691717d6">&#9670;&nbsp;</a></span>meridianLongitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*, <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*&gt; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::meridianLongitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies a triangulated knot complement so that the meridian and algebraic longitude each follow a single boundary edge, and returns these two edges. </p>
<p>Assuming that this triangulation represents the complement of a knot in the 3-sphere, this routine:</p>
<ul>
<li>identifies the meridian of the knot complement, and also the algebraic longitude (i.e., the non-trivial simple closed curve on the boundary whose homology in the 3-manifold is trivial);</li>
<li>layers additional tetrahedra on the boundary if necessary so that each of these curves is represented by a single boundary edge;</li>
<li>returns these two (possibly new) boundary edges.</li>
</ul>
<p>This routine uses fast heuristics to locate the meridian; as a result, <b>it does not guarantee to terminate</b> (but if you find a case where it does not, please let the Regina developers know!). If it does return then it guarantees that the result is correct.</p>
<p>Whilst this routine returns more information than <a class="el" href="group__dim3.html#ga8531170c02fc4d184ed5ce64b0a8181f" title="Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edg...">longitude()</a>, note that <a class="el" href="group__dim3.html#ga8531170c02fc4d184ed5ce64b0a8181f" title="Modifies a triangulated knot complement so that the algebraic longitude follows a single boundary edg...">longitude()</a> (1) runs much faster since it is based on fast algebraic calculations, and (2) guarantees to terminate.</p>
<p>At present this routine is fairly restrictive in what triangulations it can work with: it requires the triangulation to be one-vertex and have real (not ideal) boundary. These restrictions may be eased in future versions of Regina.</p>
<p>If the meridian and algebraic longitude are already both represented by single boundary edges, then it is guaranteed that this routine will <em>not</em> modify the triangulation, and will simply return these two boundary edges.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold is known to be the complement of a knot in the 3-sphere. </dd>
<dd>
This triangulation has precisely one vertex, and its (unique) boundary component is formed from two triangles.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine may modify the triangluation, as explained above, which will have the side-effect of invalidating any existing Vertex, Edge or Triangle references.</dd>
<dd>
If you have an <em>ideal</em> triangulation of a knot complement, you <em>must</em> first run <a class="el" href="group__dim3.html#gac025b93b99f5b674fd448e6374c81142" title="Converts an ideal triangulation into a finite triangulation.">idealToFinite()</a> and then simplify the resulting triangulation to have two boundary triangles.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair (<em>m</em>, <em>l</em>), where <em>m</em> is the boundary edge representing the meridian and <em>l</em> is the boundary edge representing the algebraic longitude of the knot complement (after this triangulation has been modified if necessary). If an error (such as an integer overflow) occurs during the computation, then this routine will return (<code>null</code>, <code>null</code>). </dd></dl>

</div>
</div>
<a id="gae3e659747844d582d50162a471fd81ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e659747844d582d50162a471fd81ab">&#9670;&nbsp;</a></span>minimiseBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimiseBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this. </p>
<p>This routine is for use with algorithms that require minimal boundaries (e.g., torus boundaries must contain exactly two triangles). As noted above, it may in fact increase the total number of tetrahedra in the triangulation (though the implementation does make efforts not to do this).</p>
<p>Once this routine is finished, every boundary component will have exactly one vertex, except for sphere and projective plane boundaries which will have exactly two triangles (but three and two vertices respectively).</p>
<p>The changes that this routine performs can always be expressed using only close book moves and/or layerings. In particular, this routine never creates new vertices, and it never creates a non-vertex-linking normal disc or sphere if there was not one before.</p>
<p>Although this routine only modifies real boundary components, it is fine if the triangulation also contains ideal boundary components (and these simply will be left alone).</p>
<p>If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if every boundary component was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="ga9160ade86ae2ac23ac91a97d25aa79de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9160ade86ae2ac23ac91a97d25aa79de">&#9670;&nbsp;</a></span>minimizeBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::minimizeBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for <a class="el" href="group__dim3.html#gae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a>. </p>
<p>This ensures that the boundary contains the smallest possible number of triangles, potentially adding tetrahedra to do this.</p>
<p>See <a class="el" href="group__dim3.html#gae3e659747844d582d50162a471fd81ab" title="Ensures that the boundary contains the smallest possible number of triangles, potentially adding tetr...">minimiseBoundary()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if every boundary component was already minimal to begin with. </dd></dl>

</div>
</div>
<a id="ga8ed61991de885c0e4b393690f91b0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed61991de885c0e4b393690f91b0930">&#9670;&nbsp;</a></span>newTetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p>See <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a id="gad6d942a89497e2bce4ee716db55dfd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d942a89497e2bce4ee716db55dfd92">&#9670;&nbsp;</a></span>newTetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::newTetrahedron </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p>See <a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a id="gab345829b2c1486eb39f319ed90720c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab345829b2c1486eb39f319ed90720c97">&#9670;&nbsp;</a></span>niceTreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::niceTreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a nice tree decomposition of the face pairing graph of this triangulation. </p>
<p>This can (for example) be used in implementing algorithms that are fixed-parameter tractable in the treewidth of the face pairing graph.</p>
<p>See <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a> for further details on tree decompositions, and see <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what it means to be a <em>nice</em> tree decomposition.</p>
<p>This routine is fast: it will use a greedy algorithm to find a tree decomposition with (hopefully) small width, but with no guarantees that the width of this tree decomposition is the smallest possible.</p>
<p>The tree decomposition will be cached, so that if this routine is called a second time (and the underlying triangulation has not been changed) then the same tree decomposition will be returned immediately.</p>
<dl class="section return"><dt>Returns</dt><dd>a nice tree decomposition of the face pairing graph of this triangulation. </dd></dl>

</div>
</div>
<a id="ga4e014a14f3ab909fb0774190725c1898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e014a14f3ab909fb0774190725c1898">&#9670;&nbsp;</a></span>oneFourMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::oneFourMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated function that checks the eligibility of and/or performs a 1-4 Pachner move upon the given tetrahedron. </p>
<p>This differs from pachner(Simplex&lt;3&gt;*, bool, bool) in the labelling of the new tetrahedra:</p>
<ul>
<li><a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">pachner()</a> will create the new vertex as <code><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a>.back()-&gt;vertex(0)</code>, for consistency with Pachner moves on faces of other dimensions;</li>
<li><a class="el" href="group__dim3.html#ga4e014a14f3ab909fb0774190725c1898" title="Deprecated function that checks the eligibility of and/or performs a 1-4 Pachner move upon the given ...">oneFourMove()</a> will create the new vertex as <code><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a>.back()-&gt;vertex(3)</code>, for consistency with earlier versions of Regina.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given tetrahedron is a tetrahedron of this triangulation.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000198">Deprecated:</a></b></dt><dd>You should use the new routine <a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">pachner()</a> instead (though note that this changes the labelling of the new tetrahedra).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td>this argument is ignored, since this move is always legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> always. </dd></dl>

</div>
</div>
<a id="ga4e1f76566647492c74f380c466edcbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1f76566647492c74f380c466edcbe5">&#9670;&nbsp;</a></span>openBook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::openBook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a book opening move about the given triangle. </p>
<p>This involves taking a triangle meeting the boundary along two edges, and ungluing it to create two new boundary triangles (thus exposing the tetrahedra it initially joined). This move is the inverse of the <a class="el" href="group__dim3.html#gaa83effbc43af294638b92d39246ebb26" title="Checks the eligibility of and/or performs a book closing move about the given boundary edge.">closeBook()</a> move, and is used to open the way for new <a class="el" href="group__dim3.html#ga37b16dc8a8d13d3b01f1cee099988fd3" title="Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron.">shellBoundary()</a> moves.</p>
<p>This move can be done if:</p>
<ul>
<li>the triangle meets the boundary in precisely two edges (and thus also joins two tetrahedra);</li>
<li>the vertex between these two edges is a standard boundary vertex (its link is a disc);</li>
<li>the remaining edge of the triangle (which is internal to the triangulation) is valid.</li>
</ul>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given triangle is a triangle of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga8b1c5856b28d23276d52d5c4c7705b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1c5856b28d23276d52d5c4c7705b5d">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::order </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOriented</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels tetrahedron vertices in this triangulation to give an ordered triangulation, if possible. </p>
<p>To be an ordered triangulation, all face gluings (when restricted to the tetrahedron face) must be order preserving. In other words, it must be possible to orient all edges of the triangulation in such a fashion that they are consistent with the ordering of the vertices in each tetrahedron.</p>
<p>If it is possible to order this triangulation, the vertices of each tetrahedron will be relabelled accordingly and this routine will return <code>true</code>. Otherwise, this routine will return <code>false</code> and the triangulation will not be changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may be slow, since it backtracks through all possible edge orientations until a consistent one has been found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forceOriented</td><td><code>true</code> if the triangulation must be both ordered and <em>oriented</em>, in which case this routine will return <code>false</code> if the triangulation cannot be oriented and ordered at the same time. See <a class="el" href="group__detail.html#ga2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation has been successfully ordered as described above, or <code>false</code> if not.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="gad24fe1e3bae956fbf8954fb54adc19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad24fe1e3bae956fbf8954fb54adc19e4">&#9670;&nbsp;</a></span>pinchEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::pinchEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pinches an internal edge to a point. </p>
<p>Topologically, this collapses the edge to a point with no further side-effects, and it increases the number of tetrahedra by two.</p>
<p>This operation can be performed on <em>any</em> internal edge, without further constraints. Two particularly useful settings are:</p>
<ul>
<li>If the edge joins an internal vertex with some different vertex (which may be internal, boundary, ideal or invalid), then this move does not change the topology of the manifold at all, and it reduces the total number of vertices by one. In this sense, it acts as an alternative to <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a>, and unlike <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> it can <em>always</em> be performed.</li>
<li>If the edge runs from an internal vertex back to itself, then this move effectively drills out the edge, leaving an ideal torus or Klein bottle boundary component.</li>
</ul>
<p>We do not allow <em>e</em> to lie entirely on the triangulation boundary, because the implementation actually collapses an internal curve <em>parallel</em> to <em>e</em>, not the edge <em>e</em> itself (and so if <em>e</em> is a boundary edge then the topological effect would not be as intended). We do allow <em>e</em> to be an internal edge with both endpoints on the boundary, but note that in this case the resulting topological operation would render the triangulation invalid.</p>
<p>If you are trying to reduce the number of vertices without changing the topology, and if <em>e</em> is an edge connecting an internal vertex with some different vertex, then either <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> or <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> may be more appropriate for your situation.</p>
<ul>
<li>The advantage of <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> is that it decreases the number of tetrahedra, whereas <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> increases this number (but only by two).</li>
<li>The disadvantages of <a class="el" href="group__dim3.html#gaa15b75f55bf6eaead57e6864fd7db58d" title="Checks the eligibility of and/or performs a collapse of an edge between two distinct vertices.">collapseEdge()</a> are that it cannot always be performed, and its validity tests are expensive; <a class="el" href="group__dim3.html#gad24fe1e3bae956fbf8954fb54adc19e4" title="Pinches an internal edge to a point.">pinchEdge()</a> on the other hand can always be used for edges <em>e</em> of the type described above.</li>
</ul>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge is an internal edge of this triangulation (that is, <em>e</em> does not lie entirely within the boundary).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to collapse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae171f874204819014b8a5ea77b1ca2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae171f874204819014b8a5ea77b1ca2aa">&#9670;&nbsp;</a></span>puncture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::puncture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Punctures this manifold by removing a 3-ball from the interior of the given tetrahedron. </p>
<p>If no tetrahedron is specified (i.e., the tetrahedron pointer is <code>null</code>), then the puncture will be taken from the interior of tetrahedron 0.</p>
<p>The puncture will not meet the boundary of the tetrahedron, so nothing will go wrong if the tetrahedron has boundary facets and/or ideal vertices. A side-effect of this, however, is that the resulting triangulation will contain additional vertices, and will almost certainly be far from minimal. It is highly recommended that you run <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> if you do not need to preserve the combinatorial structure of the new triangulation.</p>
<p>The puncturing is done by subdividing the original tetrahedron. The new tetrahedra will have orientations consistent with the original tetrahedra, so if the triangulation was originally oriented then it will also be oriented after this routine has been called. See <a class="el" href="group__detail.html#gab712e58bba1242110e49b2fac979e98f" title="Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplic...">isOriented()</a> for further details on oriented triangulations.</p>
<p>The new sphere boundary will be formed from two triangles; specifically, face 0 of the last and second-last tetrahedra of the triangulation. These two triangles will be joined so that vertex 1 of each tetrahedron coincides, and vertices 2,3 of one map to vertices 3,2 of the other.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is non-empty, and if <code>tet</code> is non-null then it is in fact a tetrahedron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron inside which the puncture will be taken. This may be <code>null</code> (the default), in which case the first tetrahedron will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeff844c71c39d0ae40b4d1c4aa3b0efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff844c71c39d0ae40b4d1c4aa3b0efc">&#9670;&nbsp;</a></span>recogniser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recogniser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string that expresses this triangulation in Matveev's 3-manifold recogniser format. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the 3-manifold recogniser data. </dd></dl>

</div>
</div>
<a id="ga61f721425309c5b113d24d0e06abfb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f721425309c5b113d24d0e06abfb08">&#9670;&nbsp;</a></span>recogniser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recogniser </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the recogniser data file will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga403a36d9a4748032f5abb7e16c24621d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga403a36d9a4748032f5abb7e16c24621d">&#9670;&nbsp;</a></span>recognizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recognizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A synonym for <a class="el" href="group__dim3.html#gaeff844c71c39d0ae40b4d1c4aa3b0efc" title="Returns a string that expresses this triangulation in Matveev&#39;s 3-manifold recogniser format.">recogniser()</a>. </p>
<p>This returns a string that expresses this triangulation in Matveev's 3-manifold recogniser format.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the 3-manifold recogniser data. </dd></dl>

</div>
</div>
<a id="gaf9565c761baf1d0fcf41f1e08baf1733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9565c761baf1d0fcf41f1e08baf1733">&#9670;&nbsp;</a></span>recognizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::recognizer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for recognizer(std::ostream&amp;). </p>
<p>This writes a string expressing this triangulation in Matveev's 3-manifold recogniser format to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the recogniser data file will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2d2946f00ee2558b45ca08ed770490e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2d2946f00ee2558b45ca08ed770490e">&#9670;&nbsp;</a></span>rehydrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::rehydrate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dehydration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehydrates the given alphabetical string into a new triangulation. </p>
<p>See <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> for more information on dehydration strings.</p>
<p>This routine will rehydrate the given string into a new triangulation, and return this new triangulation.</p>
<p>The converse routine <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> can be used to extract a dehydration string from an existing triangulation. Dehydration followed by rehydration might not produce a triangulation identical to the original, but it is guaranteed to produce an isomorphic copy. See <a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate()</a> for the reasons behind this.</p>
<p>For a full description of the dehydrated triangulation format, see <em>A <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> of Cusped Hyperbolic 3-Manifolds</em>, Callahan, Hildebrand and Weeks, Mathematics of Computation 68/225, 1999.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dehydration</td><td>a dehydrated representation of the triangulation to construct. Case is irrelevant; all letters will be treated as if they were lower case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated triangulation if the rehydration was successful, or null if the given string could not be rehydrated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#ga8b1081ff442801c2d33038c11031ee2b" title="Dehydrates this triangulation into an alphabetical string.">dehydrate</a> </dd>
<dd>
<a class="el" href="group__dim3.html#ga59ebb16f99797ca3f97e044a57d95c2f" title="Inserts the rehydration of the given string into this triangulation.">insertRehydration</a> </dd></dl>

</div>
</div>
<a id="ga5d5db4562cc8b5cc400c32cc84baf052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d5db4562cc8b5cc400c32cc84baf052">&#9670;&nbsp;</a></span>removeAllTetrahedra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeAllTetrahedra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#ga3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>. </p>
<p>See <a class="el" href="group__detail.html#ga3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a> for further information. </p>

</div>
</div>
<a id="ga7d12119aa7e43ba418129a62edd57f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d12119aa7e43ba418129a62edd57f92">&#9670;&nbsp;</a></span>removeTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeTetrahedron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#ga7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>. </p>
<p>See <a class="el" href="group__detail.html#ga7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> for further information. </p>

</div>
</div>
<a id="ga085896e8328394d9cb399529e97d6b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085896e8328394d9cb399529e97d6b7a">&#9670;&nbsp;</a></span>removeTetrahedronAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::removeTetrahedronAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="group__detail.html#gac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>. </p>
<p>See <a class="el" href="group__detail.html#gac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a> for further information. </p>

</div>
</div>
<a id="gafd9a8527f05610a08f7f7a3d5042d152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9a8527f05610a08f7f7a3d5042d152">&#9670;&nbsp;</a></span>reorderTetrahedraBFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::reorderTetrahedraBFS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the tetrahedra of this triangulation using a breadth-first search, so that small-numbered tetrahedra are adjacent to other small-numbered tetrahedra. </p>
<p>Specifically, the reordering will operate as follows. Tetrahedron 0 will remain tetrahedron 0. Its immediate neighbours will be numbered 1, 2, 3 and 4 (though if these neighbours are not distinct then of course fewer labels will be required). Their immediate neighbours will in turn be numbered 5, 6, and so on, ultimately following a breadth-first search throughout the entire triangulation.</p>
<p>If the optional argument <em>reverse</em> is <code>true</code>, then tetrahedron numbers will be assigned in reverse order. That is, tetrahedron 0 will become tetrahedron <em>n-1</em>, its neighbours will become tetrahedra <em>n-2</em> down to <em>n-5</em>, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td><code>true</code> if the new tetrahedron numbers should be assigned in reverse order, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b703a9bd9717144c800a710870d1e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b703a9bd9717144c800a710870d1e12">&#9670;&nbsp;</a></span>retriangulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::retriangulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explores all triangulations that can be reached from this via Pachner moves, without exceeding a given number of additional tetrahedra. </p>
<p>Specifically, this routine will iterate through all triangulations that can be reached from this triangulation via 2-3 and 3-2 Pachner moves, without ever exceeding <em>height</em> additional tetrahedra beyond the original number.</p>
<p>For every such triangulation (including this starting triangulation), this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li><em>action</em> must take at least one argument. The first argument will be of type <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>&amp;, and will reference the triangulation that has been found. If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return a boolean. If <em>action</em> ever returns <code>true</code>, then this indicates that processing should stop immediately (i.e., no more triangulations will be processed).</li>
<li><em>action</em> may, if it chooses, make changes to this triangulation (i.e., the original triangulation upon which <a class="el" href="group__dim3.html#ga5b703a9bd9717144c800a710870d1e12" title="Explores all triangulations that can be reached from this via Pachner moves, without exceeding a give...">retriangulate()</a> was called). This will not affect the search: all triangulations that this routine visits will be obtained via Pachner moves from the original form of this triangulation, before any subsequent changes (if any) were made.</li>
<li><em>action</em> may, if it chooses, make changes to the triangulation that is passed in its argument (though it must not delete it). This will likewise not affect the search, since the triangulation that is passed to <em>action</em> will be destroyed immediately after <em>action</em> is called.</li>
<li><em>action</em> will only be called once for each triangulation (including this starting triangulation). In other words, no triangulation will be revisited a second time in a single call to <a class="el" href="group__dim3.html#ga5b703a9bd9717144c800a710870d1e12" title="Explores all triangulations that can be reached from this via Pachner moves, without exceeding a give...">retriangulate()</a>.</li>
</ul>
<p>This routine can be very slow and very memory-intensive, since the number of triangulations it visits may be superexponential in the number of tetrahedra, and it records every triangulation that it visits (so as to avoid revisiting the same triangulation again). It is highly recommended that you begin with <em>height</em> = 1, and if necessary try increasing <em>height</em> one at a time until this routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional tetrahedra. This means that the routine will <em>never terminate</em>, unless <em>action</em> returns <code>true</code> for some triangulation that is passed to it.</p>
<p>If a progress tracker is passed, then the exploration of triangulations will take place in a new thread and this routine will return immediately.</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either <em>action</em> returned <code>true</code>, or the search was exhausted). All calls to <em>action</em> will be protected by a mutex (i.e., different threads will never be calling <em>action</em> at the same time).</p>
<p>If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="section warning"><dt>Warning</dt><dd>By default, the arguments <em>args</em> will be copied (or moved) when they are passed to <em>action</em>. If you need to pass some argument(s) by reference, you must wrap them in std::ref or std::cref.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is connected.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> tetrahedra to allow beyond the number of tetrahedra originally present in the triangulation, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call upon each triangulation that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial triangulation argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if some call to <em>action</em> returned <code>true</code> (thereby terminating the search early), or <code>false</code> if the search ran to completion. </dd></dl>

</div>
</div>
<a id="gaa0c68d0faa4438c15960509298e100ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c68d0faa4438c15960509298e100ec">&#9670;&nbsp;</a></span>saveRecogniser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::saveRecogniser </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this triangulation to the given file in Matveev's 3-manifold recogniser format. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the Recogniser file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="gae579243386ad33795b0759dd5fb35fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae579243386ad33795b0759dd5fb35fab">&#9670;&nbsp;</a></span>saveRecognizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::saveRecognizer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A synonym for <a class="el" href="group__dim3.html#gaa0c68d0faa4438c15960509298e100ec" title="Writes this triangulation to the given file in Matveev&#39;s 3-manifold recogniser format.">saveRecogniser()</a>. </p>
<p>This writes this triangulation to the given file in Matveev's 3-manifold recogniser format.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is not invalid, and does not contain any boundary triangles.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the Recogniser file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="gabfdea1498a9373b31883820b01b02e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfdea1498a9373b31883820b01b02e9d">&#9670;&nbsp;</a></span>saveSnapPea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::saveSnapPea </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes this triangulation to the given file using SnapPea's native file format. </p>
<p>Regarding what gets stored in the SnapPea data file:</p>
<ul>
<li>If you are calling this from one of Regina's own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> objects, then only the tetrahedron gluings and the manifold name will be stored (the name will be derived from the packet label). All other SnapPea-specific information (such as peripheral curves) will be marked as unknown (since Regina does not track such information itself), and of course other Regina-specific information (such as the Turaev-Viro invariants) will not be written to the SnapPea file at all.</li>
<li>If you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, then all additional SnapPea-specific information will be written to the file (indeed, the SnapPea kernel itself will be used to produce the file contents).</li>
</ul>
<p>If this triangulation is empty, invalid, or contains boundary triangles (which SnapPea cannot represent), then the file will not be written and this routine will return <code>false</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the SnapPea file to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

<p>Reimplemented in <a class="el" href="group__snappea.html#ga6d3b0b358056999d12fa4dffdf35e923">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga37b16dc8a8d13d3b01f1cee099988fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b16dc8a8d13d3b01f1cee099988fd3">&#9670;&nbsp;</a></span>shellBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::shellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a boundary shelling move on the given tetrahedron. </p>
<p>This involves simply popping off a tetrahedron that touches the boundary. This can be done if:</p>
<ul>
<li>all edges of the tetrahedron are valid;</li>
<li>precisely one, two or three faces of the tetrahedron lie in the boundary;</li>
<li>if one face lies in the boundary, then the opposite vertex does not lie in the boundary, and no two of the remaining three edges are identified;</li>
<li>if two faces lie in the boundary, then the remaining edge does not lie in the boundary, and the remaining two faces of the tetrahedron are not identified.</li>
</ul>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given tetrahedron is a tetrahedron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron upon which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaf4ba73293308b8bfba1947ba4716457b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ba73293308b8bfba1947ba4716457b">&#9670;&nbsp;</a></span>simplifyExhaustive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::simplifyExhaustive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nThreads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTrackerOpen.html">ProgressTrackerOpen</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph. </p>
<p>This routine is more powerful but much slower than <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p>Specifically, this routine will iterate through all triangulations that can be reached from this triangulation via 2-3 and 3-2 Pachner moves, without ever exceeding <em>height</em> additional tetrahedra beyond the original number.</p>
<p>If at any stage it finds a triangulation with <em>fewer</em> tetrahedra than the original, then this routine will call <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> to shrink the triangulation further if possible and will then return <code>true</code>. If it cannot find a triangulation with fewer tetrahedra then it will leave this triangulation unchanged and return <code>false</code>.</p>
<p>This routine can be very slow and very memory-intensive: the number of triangulations it visits may be superexponential in the number of tetrahedra, and it records every triangulation that it visits (so as to avoid revisiting the same triangulation again). It is highly recommended that you begin with <em>height</em> = 1, and if this fails then try increasing <em>height</em> one at a time until either you find a simplification or the routine becomes too expensive to run.</p>
<p>If <em>height</em> is negative, then there will be <em>no</em> bound on the number of additional tetrahedra. This means that the routine will not terminate until a simpler triangulation is found. If no simpler diagram exists then the only way to terminate this function is to cancel the operation via a progress tracker (read on for details).</p>
<p>If you want a <em>fast</em> simplification routine, you should call <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> instead. The benefit of <a class="el" href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> is that, for very stubborn triangulations where <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> finds itself stuck at a local minimum, <a class="el" href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> is able to "climb out" of such wells.</p>
<p>If a progress tracker is passed, then the exhaustive simplification will take place in a new thread and this routine will return immediately. In this case, you will need to use some other means to determine whether the triangulation was eventually simplified (e.g., by examining <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a> after the tracker indicates that the operation has finished).</p>
<p>To assist with performance, this routine can run in parallel (multithreaded) mode; simply pass the number of parallel threads in the argument <em>nThreads</em>. Even in multithreaded mode, if no progress tracker is passed then this routine will not return until processing has finished (i.e., either the triangulation was simplified or the search was exhausted).</p>
<p>If this routine is unable to simplify the triangulation, then the triangulation will not be changed.</p>
<p>If no progress tracker was passed then it will immediately return <code>false</code>; otherwise the progress tracker will immediately be marked as finished.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>the maximum number of <em>additional</em> tetrahedra to allow beyond the number of tetrahedra originally present in the triangulation, or a negative number if this should not be bounded. </td></tr>
    <tr><td class="paramname">nThreads</td><td>the number of threads to use. If this is 1 or smaller then the routine will run single-threaded. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a progress tracker is passed, then this routine will return <code>true</code> or <code>false</code> immediately according to whether a new thread could or could not be started. If no progress tracker is passed, then this routine will return <code>true</code> if and only if the triangulation was successfully simplified to fewer tetrahedra. </dd></dl>

</div>
</div>
<a id="ga0bc067391ecf8f6269e624ee9d658761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc067391ecf8f6269e624ee9d658761">&#9670;&nbsp;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of tetrahedra. </p>
<p>End users will probably not want to call this routine. You should call <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a> if you want a fast (and usually effective) means of simplifying a triangulation, or you should call <a class="el" href="group__dim3.html#gaf4ba73293308b8bfba1947ba4716457b" title="Attempts to simplify this triangulation using a slow but exhaustive search through the Pachner graph.">simplifyExhaustive()</a> if you are still stuck and you want to try a slower but more powerful method instead.</p>
<p>The moves used by this routine include 3-2, 2-0 (edge and vertex), 2-1 and boundary shelling moves.</p>
<p>Moves that do not reduce the number of tetrahedra (such as 4-4 moves or book opening moves) are not used in this routine. Such moves do however feature in <a class="el" href="group__dim3.html#gad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">intelligentSimplify()</a>.</p>
<p>If this triangulation is currently oriented, then this operation will preserve the orientation.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the triangulation was changed to reduce the number of tetrahedra; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="gac9140993b6d06937e8126bbdd6b15fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9140993b6d06937e8126bbdd6b15fe4">&#9670;&nbsp;</a></span>snapPea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::snapPea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string containing the full contents of a SnapPea data file that describes this triangulation. </p>
<p>In particular, this string can be used in a Python session to pass the triangulation directly to SnapPy (without writing to the filesystem).</p>
<p>Regarding what gets stored in the SnapPea data file:</p>
<ul>
<li>If you are calling this from one of Regina's own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> objects, then only the tetrahedron gluings and the manifold name will be stored (the name will be derived from the packet label). All other SnapPea-specific information (such as peripheral curves) will be marked as unknown (since Regina does not track such information itself), and of course other Regina-specific information (such as the Turaev-Viro invariants) will not be written to the SnapPea file at all.</li>
<li>If you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, then all additional SnapPea-specific information will be written to the file (indeed, the SnapPea kernel itself will be used to produce the file contents).</li>
</ul>
<p>If you wish to export a triangulation to a SnapPea <em>file</em>, you should call <a class="el" href="group__dim3.html#gabfdea1498a9373b31883820b01b02e9d" title="Writes this triangulation to the given file using SnapPea&#39;s native file format.">saveSnapPea()</a> instead (which has better performance, and does not require you to construct an enormous intermediate string).</p>
<p>If this triangulation is empty, invalid, or contains boundary triangles (which SnapPea cannot represent), then the resulting string will be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>a string containing the contents of the corresponding SnapPea data file. </dd></dl>

<p>Reimplemented in <a class="el" href="group__snappea.html#ga43d1d52bc2464567b30e8fc5138cc123">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga8dd0d487462ab790649791803fe4b265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd0d487462ab790649791803fe4b265">&#9670;&nbsp;</a></span>snapPea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::snapPea </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the full contents of a SnapPea data file describing this triangulation to the given output stream. </p>
<p>Regarding what gets stored in the SnapPea data file:</p>
<ul>
<li>If you are calling this from one of Regina's own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> objects, then only the tetrahedron gluings and the manifold name will be stored (the name will be derived from the packet label). All other SnapPea-specific information (such as peripheral curves) will be marked as unknown (since Regina does not track such information itself), and of course other Regina-specific information (such as the Turaev-Viro invariants) will not be written to the SnapPea file at all.</li>
<li>If you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, then all additional SnapPea-specific information will be written to the file (indeed, the SnapPea kernel itself will be used to produce the file contents).</li>
</ul>
<p>If you wish to extract the SnapPea data file as a string, you should call the zero-argument routine <a class="el" href="group__dim3.html#gac9140993b6d06937e8126bbdd6b15fe4" title="Returns a string containing the full contents of a SnapPea data file that describes this triangulatio...">snapPea()</a> instead. If you wish to write to a real SnapPea data file on the filesystem, you should call <a class="el" href="group__dim3.html#gabfdea1498a9373b31883820b01b02e9d" title="Writes this triangulation to the given file using SnapPea&#39;s native file format.">saveSnapPea()</a> (which is also available in Python).</p>
<p>If this triangulation is empty, invalid, or contains boundary triangles (which SnapPea cannot represent), then nothing will be written to the output stream.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the SnapPea data file will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__snappea.html#gac99348d976f873be4e568483138d9066">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga327e1fe59736942aecf5acf451822679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga327e1fe59736942aecf5acf451822679">&#9670;&nbsp;</a></span>subtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 2 &gt;::subtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the triangle vertex or triangle edge that plays a special role for the triangle type of this triangle. </p>
<p>Note that this routine is only relevant for some triangle types. The triangle type is returned by <a class="el" href="group__dim3.html#ga76885f1024082f3d43fc80b84d4ea08f" title="Returns a description of the triangle type.">type()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The vertex or edge that plays a special role (this will be 0, 1 or 2), or -1 if this triangle type has no special vertex or edge. </dd></dl>

</div>
</div>
<a id="ga4f4dabe68d39bf8044b568565f1e9b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f4dabe68d39bf8044b568565f1e9b8e">&#9670;&nbsp;</a></span>threeTwoMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::threeTwoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated function that checks the eligibility of and/or performs a 3-2 move about the given edge. </p>
<p>This is an alias for pachner(Edge&lt;3&gt;*, bool, bool); see that routine for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000197">Deprecated:</a></b></dt><dd>You should use the identical routine <a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">pachner()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga0a5532d43f65d9ba0354bd8bd8c4931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5532d43f65d9ba0354bd8bd8c4931d">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty triangulation. </p>

</div>
</div>
<a id="ga8da371e375c0591bcc939a4e21923d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da371e375c0591bcc939a4e21923d62">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a triangulation. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>isomorphism signatures (see <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>);</li>
<li>dehydration strings (see <a class="el" href="group__dim3.html#gae2d2946f00ee2558b45ca08ed770490e" title="Rehydrates the given alphabetical string into a new triangulation.">rehydrate()</a>);</li>
<li>the contents of a SnapPea data file (see <a class="el" href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db" title="Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file...">fromSnapPea()</a>).</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<p>Regina will also set the packet label accordingly.</p>
<p>If Regina cannot interpret the given string, this will be left as the empty triangulation.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you pass the contents of a SnapPea data file, then only the tetrahedron gluings will be read; all other SnapPea-specific information (such as peripheral curves) will be lost. See <a class="el" href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db" title="Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file...">fromSnapPea()</a> for details, and for other alternatives that preserve SnapPea-specific data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a 3-manifold triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga050b0e057071f9e9e2561b315b7b001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050b0e057071f9e9e2561b315b7b001b">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given triangulation (such as homology, fundamental group, and so on), or <code>false</code> if the new triangulation should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f0089671524095fac72abd688bbf91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0089671524095fac72abd688bbf91c">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation. </p>
<p>The packet tree structure and packet label are <em>not</em> copied.</p>
<p>This will clone any computed properties (such as homology, fundamental group, and so on) of the given triangulation also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ca1afde1e9403a01f01e7da09ba012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca1afde1e9403a01f01e7da09ba012e">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">snappy.Manifold&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only constructor that copies the given SnapPy manifold. </p>
<dl class="section warning"><dt>Warning</dt><dd>Only the tetrahedron gluings will be copied; all other SnapPy-specific information (such as peripheral curves) will be lost. See <a class="el" href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db" title="Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file...">fromSnapPea()</a> for details, and for other alternatives that preserve SnapPy-specific data.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>a SnapPy object of type snappy.Manifold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd134f0130375e5ac15e90c0cab6c57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd134f0130375e5ac15e90c0cab6c57c">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">snappy.Triangulation&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python-only constructor that copies the given SnapPy triangulation. </p>
<dl class="section warning"><dt>Warning</dt><dd>Only the tetrahedron gluings will be copied; all other SnapPy-specific information (such as peripheral curves) will be lost. See <a class="el" href="group__dim3.html#ga1b1fb509efaa90335f0fd0863443b7db" title="Extracts the tetrahedron gluings from a string that contains the full contents of a SnapPea data file...">fromSnapPea()</a> for details, and for other alternatives that preserve SnapPy-specific data.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a SnapPy object of type snappy.Triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3c7fc5f723ce2c68158d7319dda0cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c7fc5f723ce2c68158d7319dda0cc4">&#9670;&nbsp;</a></span>turaevViro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Cyclotomic.html">Cyclotomic</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::turaevViro </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parity</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic. </p>
<p>The initial data for the Turaev-Viro invariant is as described in the paper of Turaev and Viro, "State sum invariants of 3-manifolds
and quantum 6j-symbols", Topology, vol. 31, no. 4, 1992, pp 865-902. In particular, Section 7 of this paper describes the initial data as determined by an integer r &gt;= 3, and a root of unity q0 of degree 2r for which q0^2 is a primitive root of unity of degree r. There are several cases to consider:</p>
<ul>
<li><em>r</em> may be even. In this case <em>q0</em> must be a primitive (<em>2r</em>)th root of unity, and the invariant is computed as an element of the cyclotomic field of order <em>2r</em>. There is no need to specify <em>which</em> root of unity is used, since switching between different roots of unity corresponds to an automorphism of the underlying cyclotomic field (i.e., it does not yield any new information). Therefore, if <em>r</em> is even, the additional argument <em>parity</em> is ignored.</li>
<li><em>r</em> may be odd, and <em>q0</em> may be a primitive (<em>2r</em>)th root of unity. This case corresponds to passing the argument <em>parity</em> as <code>true</code>. Here the invariant is again computed as an element of the cyclotomic field of order <em>2r</em>. As before, there is no need to give further information as to which root of unity is used, since switching between roots of unity does not yield new information.</li>
<li><em>r</em> may be odd, and <em>q0</em> may be a primitive (<em>r</em>)th root of unity. This case corresponds to passing the argument <em>parity</em> as <code>false</code>. In this case the invariant is computed as an element of the cyclotomic field of order <em>r</em>. Again, there is no need to give further information as to which root of unity is used.</li>
</ul>
<p>This routine works entirely within the relevant cyclotomic field, which yields exact results but adds a significant overhead to the running time. If you want a fast floating-point approximation, you can call <a class="el" href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> instead.</p>
<p>Unlike this routine, <a class="el" href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> requires a precise specification of which root of unity is used (since it returns a numerical real value). The numerical value obtained by calling <code>turaevViroApprox(r, whichRoot)</code> should be the same as <code>turaevViro(r, parity).evaluate(whichRoot)</code>, where <em>parity</em> is <code>true</code> or <code>false</code> according to whether <em>whichRoot</em> is odd or even respectively. Of course in practice the numerical values might be very different, since <a class="el" href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> performs significantly more floating point operations, and so is subject to a much larger potential numerical error.</p>
<p>If the requested Turaev-Viro invariant has already been computed, then the result will be cached and so this routine will be very fast (since it just returns the previously computed result). Otherwise the computation could be quite slow, particularly for larger triangulations and/or larger values of <em>r</em>. This (potentially) long computation can be managed by passing a progress tracker:</p>
<ul>
<li>If a progress tracker is passed and the requested invariant has not yet been computed, then the calculation will take place in a new thread and this routine will return immediately. Once the progress tracker indicates that the calculation has finished, you can call <a class="el" href="group__dim3.html#gad3c7fc5f723ce2c68158d7319dda0cc4" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using exact arithmetic.">turaevViro()</a> again with the same arguments for <em>r</em> and <em>parity</em> to retrieve the value of the invariant.</li>
<li>If no progress tracker is passed and the requested invariant has not yet been computed, the calculation will run in the current thread and this routine will not return until it is complete.</li>
<li>If the requested invariant has already been computed, then this routine will return immediately with the pre-computed value. If a progress tracker is passed then it will be marked as finished.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and non-empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the integer <em>r</em> as described above; this must be at least 3. </td></tr>
    <tr><td class="paramname">parity</td><td>determines for odd <em>r</em> whether <em>q0</em> is a primitive <em>2r</em>th or <em>r</em>th root of unity, as described above. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the invariant. If you are not sure, the default value (ALG_DEFAULT) is a safe choice. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through will progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested Turaev-Viro invariant. As an exception, if <em>tracker</em> is non-null and the value of this invariant has not been computed before, then (since the calculation will still be running in a new thread) the return value is undefined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#gad43a33c581d838c8d558da03acc290c7" title="Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifo...">allCalculatedTuraevViro</a> </dd></dl>

</div>
</div>
<a id="ga45d6e40d1a39ee48966c7a95f00092da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d6e40d1a39ee48966c7a95f00092da">&#9670;&nbsp;</a></span>turaevViroApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::turaevViroApprox </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>whichRoot</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__engine.html#gae6548c6577d3db2adb39ccea0c57dce1">Algorithm</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__engine.html#ggae6548c6577d3db2adb39ccea0c57dce1a0297f8b694060ac9e6179a367882ddcf">ALG_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floating-point approximation. </p>
<p>The initial data for the Turaev-Viro invariant is as described in the paper of Turaev and Viro, "State sum invariants of 3-manifolds
and quantum 6j-symbols", Topology, vol. 31, no. 4, 1992, pp 865-902. In particular, Section 7 describes the initial data as determined by an integer <em>r</em> &gt;= 3 and a root of unity <em>q0</em> of degree <em>2r</em> for which <em>q0^2</em> is a primitive root of unity of degree <em>r</em>.</p>
<p>The argument <em>whichRoot</em> specifies which root of unity is used for <em>q0</em>. Specifically, <em>q0</em> will be the root of unity <code>e^(2i * Pi * whichRoot / 2r)</code>. There are additional preconditions on <em>whichRoot</em> to ensure that <em>q0^2</em> is a <em>primitive</em> root of unity of degree <em>r</em>; see below for details.</p>
<p>This same invariant can be computed by calling <code>turaevViro(r, parity).evaluate(whichRoot)</code>, where <em>parity</em> is <code>true</code> or <code>false</code> according to whether <em>whichRoot</em> is odd or even respectively. Calling <a class="el" href="group__dim3.html#ga45d6e40d1a39ee48966c7a95f00092da" title="Computes the given Turaev-Viro state sum invariant of this 3-manifold using a fast but inexact floati...">turaevViroApprox()</a> is significantly faster (since it avoids the overhead of working in cyclotomic fields), but may also lead to a much larger numerical error (since this routine might perform an exponential number of floating point operations, whereas the alternative only uses floating point for the final call to <a class="el" href="group__maths.html#ga394e90c06b7da73ce2d3d1d959f4e0d8" title="Returns the value of this cyclotomic field element as a complex number.">Cyclotomic::evaluate()</a>).</p>
<p>These invariants, although computed in the complex field, should all be reals. Thus the return type is an ordinary double.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid, closed and non-empty. </dd>
<dd>
The argument <em>whichRoot</em> is strictly between 0 and <em>2r</em>, and has no common factors with <em>r</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the integer <em>r</em> as described above; this must be at least 3. </td></tr>
    <tr><td class="paramname">whichRoot</td><td>specifies which root of unity is used for <em>q0</em>, as described above. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm with which to compute the invariant. If you are not sure, the default value (ALG_DEFAULT) is a safe choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested Turaev-Viro invariant.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dim3.html#gad43a33c581d838c8d558da03acc290c7" title="Returns the cache of all Turaev-Viro state sum invariants that have been calculated for this 3-manifo...">allCalculatedTuraevViro</a> </dd></dl>

</div>
</div>
<a id="ga4f35dda23ea3274dbf35c3196508df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f35dda23ea3274dbf35c3196508df26">&#9670;&nbsp;</a></span>twoOneMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoOneMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-1 move about the given edge. </p>
<p>This involves taking an edge meeting only one tetrahedron just once and merging that tetrahedron with one of the tetrahedra joining it.</p>
<p>This can be done assuming the following conditions:</p>
<ul>
<li>The edge must be valid and non-boundary.</li>
<li>The two remaining faces of the tetrahedron are not joined, and the tetrahedron face opposite the given endpoint of the edge is not boundary.</li>
<li>Consider the second tetrahedron to be merged (the one joined along the face opposite the given endpoint of the edge). Moreover, consider the two edges of this second tetrahedron that run from the (identical) vertices of the original tetrahedron not touching <code>e</code> to the vertex of the second tetrahedron not touching the original tetrahedron. These edges must be distinct and may not both be in the boundary.</li>
</ul>
<p>There are additional "distinct and not both boundary" conditions on faces of the second tetrahedron, but those follow automatically from the final condition above.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>If this triangulation is currently oriented, then this 2-1 move will label the new tetrahedra in a way that preserves the orientation.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end of the edge <em>opposite</em> that at which the second tetrahedron (to be merged) is joined. The end is 0 or 1, corresponding to the labelling (0,1) of the vertices of the edge as described in <a class="el" href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">EdgeEmbedding&lt;3&gt;::vertices()</a>. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaf5fe0ada1310d50f4eee52f684bbcd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5fe0ada1310d50f4eee52f684bbcd5a">&#9670;&nbsp;</a></span>twoThreeMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoThreeMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated function that checks the eligibility of and/or performs a 2-3 move about the given triangle. </p>
<p>This is an alias for pachner(Triangle&lt;3&gt;*, bool, bool); see that routine for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given triangle is a triangle of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gac177c5e1e70fb0d0a24324108ce64ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac177c5e1e70fb0d0a24324108ce64ead">&#9670;&nbsp;</a></span>twoZeroMove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2. </p>
<p>This involves taking the two tetrahedra joined at that edge and squashing them flat. This can be done if:</p>
<ul>
<li>the edge is valid and non-boundary;</li>
<li>the two tetrahedra are distinct;</li>
<li>the edges opposite <code>e</code> in each tetrahedron are distinct and not both boundary;</li>
<li>if triangles <em>f1</em> and <em>f2</em> from one tetrahedron are to be flattened onto triangles <em>g1</em> and <em>g2</em> of the other respectively, then (a) <em>f1</em> and <em>g1</em> are distinct, (b) <em>f2</em> and <em>g2</em> are distinct, (c) we do not have both <em>f1</em> = <em>g2</em> and <em>g1</em> = <em>f2</em>, (d) we do not have both <em>f1</em> = <em>f2</em> and <em>g1</em> = <em>g2</em>, and (e) we do not have two of the triangles boundary and the other two identified.</li>
</ul>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="gacaa1cd8d7fd0334ad909beafcd75974c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa1cd8d7fd0334ad909beafcd75974c">&#9670;&nbsp;</a></span>twoZeroMove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given vertex of degree 2. </p>
<p>This involves taking the two tetrahedra joined at that vertex and squashing them flat. This can be done if:</p>
<ul>
<li>the vertex is non-boundary and has a 2-sphere vertex link;</li>
<li>the two tetrahedra are distinct;</li>
<li>the triangles opposite <code>v</code> in each tetrahedron are distinct and not both boundary;</li>
<li>the two tetrahedra meet each other on all three faces touching the vertex (as opposed to meeting each other on one face and being glued to themselves along the other two).</li>
</ul>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (triangles, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>v</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given vertex is a vertex of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vertex about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga76885f1024082f3d43fc80b84d4ea08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76885f1024082f3d43fc80b84d4ea08f">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dim3.html#gaaca65058d771fc756610f20b7eb45061">Type</a> <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 2 &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a description of the triangle type. </p>
<p>This will be one of the eight shapes described by the Type enumeration, indicating how the edges and vertices of the triangle are identified.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this triangle. This routine will never return UNKNOWN_TYPE. </dd></dl>

</div>
</div>
<a id="ga0e3c9276224681ca932912e989485266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e3c9276224681ca932912e989485266">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__snappea.html#gaf07da75247cb831ad93b1b5cd865d598">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga9df7d8a6ae50bff8311eb873daccb9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df7d8a6ae50bff8311eb873daccb9e9">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5d26032c0c2af5a7c9f931df93edaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d26032c0c2af5a7c9f931df93edaed">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__snappea.html#ga97281c7fda7388050d52d3450b83d195">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="ga3951498021127cad3b20bb1e1c415809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3951498021127cad3b20bb1e1c415809">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__snappea.html#gac22f69e3264630bc043c69d97921a316">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="gab375e6c4829ff149955889353050935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab375e6c4829ff149955889353050935c">&#9670;&nbsp;</a></span>~Face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 0 &gt;::~<a class="el" href="classregina_1_1Face.html">Face</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="ga4e699e5ba8923b37ae89eb5994f6b902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e699e5ba8923b37ae89eb5994f6b902">&#9670;&nbsp;</a></span>~Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 3 &gt;::~<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p>The constituent tetrahedra, the cellular structure and all other properties will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga830f8fd15be1fd552a1b44d4801d89e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830f8fd15be1fd552a1b44d4801d89e8">&#9670;&nbsp;</a></span>detail::TriangulationBase&lt; 3 &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">detail::TriangulationBase</a>&lt; 3 &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow access to private members. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
