<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Census of Triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Census of Triangulations</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> lookup and enumeration for triangulations of various dimensions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CensusDB.html">regina::CensusDB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the location and description of one of Regina's in-built census databases.  <a href="classregina_1_1CensusDB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CensusHit.html">regina::CensusHit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a single "hit" indicating that some given triangulation has been located in one of Regina's in-built census databases.  <a href="classregina_1_1CensusHit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CensusHits.html">regina::CensusHits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a list of "hits" indicating all the places in which a given triangulation has been located in Regina's various in-built census databases.  <a href="classregina_1_1CensusHits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CensusHitIterator.html">regina::CensusHitIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator that walks through all hits stored by a single <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object.  <a href="classregina_1_1CensusHitIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Census.html">regina::Census</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class used to search for triangulations across one or more 3-manifold census databases.  <a href="classregina_1_1Census.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1CensusHitIterator_01_4.html">std::iterator_traits&lt; regina::CensusHitIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific set of gluing permutations to complement a particular pairwise matching of simplex facets.  <a href="classregina_1_1GluingPerms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class used to build a census of triangulations, by searching through all possible sets of gluing permutations to match a given facet pairing.  <a href="classregina_1_1GluingPermSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html">regina::GluingPermSearcher&lt; 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for searching through all possible gluing permutation sets that correspond to a given triangle edge pairing.  <a href="classregina_1_1GluingPermSearcher_3_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html">regina::GluingPermSearcher&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for searching through all possible gluing permutation sets that correspond to a given tetrahedron face pairing.  <a href="classregina_1_1GluingPermSearcher_3_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1EulerSearcher.html">regina::EulerSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A gluing permutation search class that offers a specialised search algorithm for when all vertex links must all have a given fixed Euler characteristic.  <a href="classregina_1_1EulerSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">regina::EulerSearcher::TetVertexState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed.  <a href="structregina_1_1EulerSearcher_1_1TetVertexState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">regina::EulerSearcher::TetEdgeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is constructed.  <a href="structregina_1_1EulerSearcher_1_1TetEdgeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1CompactSearcher.html">regina::CompactSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A gluing permutation search class that offers a specialised search algorithm for when only compact (finite) 3-manifold triangulations are required.  <a href="classregina_1_1CompactSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">regina::CompactSearcher::TetVertexState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed.  <a href="structregina_1_1CompactSearcher_1_1TetVertexState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">regina::CompactSearcher::TetEdgeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is constructed.  <a href="structregina_1_1CompactSearcher_1_1TetEdgeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html">regina::ClosedPrimeMinSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A gluing permutation search class that offers a specialised search algorithm for when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three.  <a href="classregina_1_1ClosedPrimeMinSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HyperbolicMinSearcher.html">regina::HyperbolicMinSearcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A gluing permutation search class that offers a specialised search algorithm for when only minimal ideal triangulations of cusped finite-volume hyperbolic 3-manifolds are required.  <a href="classregina_1_1HyperbolicMinSearcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html">regina::GluingPermSearcher&lt; 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for searching through all possible gluing permutation sets that correspond to a given pentachoron facet pairing.  <a href="classregina_1_1GluingPermSearcher_3_014_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is constructed.  <a href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set is constructed.  <a href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae0ddfb76c4cb1c1fa8866a38984bf517"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae0ddfb76c4cb1c1fa8866a38984bf517">regina::NCensusDB</a></td></tr>
<tr class="memdesc:gae0ddfb76c4cb1c1fa8866a38984bf517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gae0ddfb76c4cb1c1fa8866a38984bf517">More...</a><br /></td></tr>
<tr class="separator:gae0ddfb76c4cb1c1fa8866a38984bf517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52f27bc1801baeb5716e4e90ec7db75"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad52f27bc1801baeb5716e4e90ec7db75">regina::NCensusHit</a></td></tr>
<tr class="memdesc:gad52f27bc1801baeb5716e4e90ec7db75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gad52f27bc1801baeb5716e4e90ec7db75">More...</a><br /></td></tr>
<tr class="separator:gad52f27bc1801baeb5716e4e90ec7db75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6a52e98200bdae7cd0831ba55e313b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gadb6a52e98200bdae7cd0831ba55e313b">regina::NCensusHits</a></td></tr>
<tr class="memdesc:gadb6a52e98200bdae7cd0831ba55e313b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gadb6a52e98200bdae7cd0831ba55e313b">More...</a><br /></td></tr>
<tr class="separator:gadb6a52e98200bdae7cd0831ba55e313b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6db6cd9fe93bf222b9d3570e89930a9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Census.html">Census</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa6db6cd9fe93bf222b9d3570e89930a9">regina::NCensus</a></td></tr>
<tr class="memdesc:gaa6db6cd9fe93bf222b9d3570e89930a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gaa6db6cd9fe93bf222b9d3570e89930a9">More...</a><br /></td></tr>
<tr class="separator:gaa6db6cd9fe93bf222b9d3570e89930a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29614c7f62c1011330a3ff9c9c3265cb"><td class="memItemLeft" align="right" valign="top"><a id="ga29614c7f62c1011330a3ff9c9c3265cb"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CensusHitIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga29614c7f62c1011330a3ff9c9c3265cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2916290da20c64bf8f71b60f4ca9f442"><td class="memItemLeft" align="right" valign="top"><a id="ga2916290da20c64bf8f71b60f4ca9f442"></a>
typedef const <a class="el" href="classregina_1_1CensusHit.html">regina::CensusHit</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CensusHitIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga2916290da20c64bf8f71b60f4ca9f442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6d16a14d230d6ab8b0f8b8fec88177"><td class="memItemLeft" align="right" valign="top"><a id="ga5c6d16a14d230d6ab8b0f8b8fec88177"></a>
typedef <a class="el" href="classregina_1_1CensusHit.html">regina::CensusHit</a> const  *const  *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CensusHitIterator &gt;::pointer_type</b></td></tr>
<tr class="separator:ga5c6d16a14d230d6ab8b0f8b8fec88177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785749da03007dde6baa42402f0061bc"><td class="memItemLeft" align="right" valign="top"><a id="ga785749da03007dde6baa42402f0061bc"></a>
typedef <a class="el" href="classregina_1_1CensusHit.html">regina::CensusHit</a> const  *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CensusHitIterator &gt;::reference_type</b></td></tr>
<tr class="separator:ga785749da03007dde6baa42402f0061bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fddf592f8504b03df22594b8c87356"><td class="memItemLeft" align="right" valign="top"><a id="ga60fddf592f8504b03df22594b8c87356"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::CensusHitIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga60fddf592f8504b03df22594b8c87356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ae43e34ebda86de3162276bffbfbf5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga80ae43e34ebda86de3162276bffbfbf5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__census.html#ga80ae43e34ebda86de3162276bffbfbf5">regina::NGenericGluingPerms</a> = <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt;</td></tr>
<tr class="memdesc:ga80ae43e34ebda86de3162276bffbfbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga80ae43e34ebda86de3162276bffbfbf5">More...</a><br /></td></tr>
<tr class="separator:ga80ae43e34ebda86de3162276bffbfbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8d221d88105d9e8c1e758b5f7b02e6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaef8d221d88105d9e8c1e758b5f7b02e6">regina::Dim2GluingPerms</a></td></tr>
<tr class="memdesc:gaef8d221d88105d9e8c1e758b5f7b02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gaef8d221d88105d9e8c1e758b5f7b02e6">More...</a><br /></td></tr>
<tr class="separator:gaef8d221d88105d9e8c1e758b5f7b02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470473a9f5c6481030480ff734b35fa2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga470473a9f5c6481030480ff734b35fa2">regina::NGluingPerms</a></td></tr>
<tr class="memdesc:ga470473a9f5c6481030480ff734b35fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga470473a9f5c6481030480ff734b35fa2">More...</a><br /></td></tr>
<tr class="separator:ga470473a9f5c6481030480ff734b35fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada52abc7db8f16297057c8f35d1d3882"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gada52abc7db8f16297057c8f35d1d3882">regina::Dim4GluingPerms</a></td></tr>
<tr class="memdesc:gada52abc7db8f16297057c8f35d1d3882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gada52abc7db8f16297057c8f35d1d3882">More...</a><br /></td></tr>
<tr class="separator:gada52abc7db8f16297057c8f35d1d3882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541613639a350df47748b7bdae7ed5fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">regina::GluingPermSearcher&lt; 2 &gt;::Use</a>) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *, void *)</td></tr>
<tr class="memdesc:ga541613639a350df47748b7bdae7ed5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a set of gluing permutations.  <a href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">More...</a><br /></td></tr>
<tr class="separator:ga541613639a350df47748b7bdae7ed5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80fbf2dfa9a77b6d9e37450068c4d30c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga80fbf2dfa9a77b6d9e37450068c4d30c">regina::Dim2GluingPermSearcher</a></td></tr>
<tr class="memdesc:ga80fbf2dfa9a77b6d9e37450068c4d30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga80fbf2dfa9a77b6d9e37450068c4d30c">More...</a><br /></td></tr>
<tr class="separator:ga80fbf2dfa9a77b6d9e37450068c4d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e2e457311bc6d60a2937b890e64142"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::Use&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga25e2e457311bc6d60a2937b890e64142">regina::UseDim2GluingPerms</a></td></tr>
<tr class="memdesc:ga25e2e457311bc6d60a2937b890e64142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga25e2e457311bc6d60a2937b890e64142">More...</a><br /></td></tr>
<tr class="separator:ga25e2e457311bc6d60a2937b890e64142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c89ca6699633f872a9611273995730"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">regina::GluingPermSearcher&lt; 3 &gt;::Use</a>) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *, void *)</td></tr>
<tr class="memdesc:ga40c89ca6699633f872a9611273995730"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a set of gluing permutations.  <a href="group__census.html#ga40c89ca6699633f872a9611273995730">More...</a><br /></td></tr>
<tr class="separator:ga40c89ca6699633f872a9611273995730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1438f17a8b29f6ac69ca06d81acdf3bc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga1438f17a8b29f6ac69ca06d81acdf3bc">regina::NGluingPermSearcher</a></td></tr>
<tr class="memdesc:ga1438f17a8b29f6ac69ca06d81acdf3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga1438f17a8b29f6ac69ca06d81acdf3bc">More...</a><br /></td></tr>
<tr class="separator:ga1438f17a8b29f6ac69ca06d81acdf3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bae6356869e326ca815e301e2cde637"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::Use&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9bae6356869e326ca815e301e2cde637">regina::UseGluingPerms</a></td></tr>
<tr class="memdesc:ga9bae6356869e326ca815e301e2cde637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga9bae6356869e326ca815e301e2cde637">More...</a><br /></td></tr>
<tr class="separator:ga9bae6356869e326ca815e301e2cde637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15758f12adde60cc820c419b157dd9c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1EulerSearcher.html">EulerSearcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga15758f12adde60cc820c419b157dd9c2">regina::NEulerSearcher</a></td></tr>
<tr class="memdesc:ga15758f12adde60cc820c419b157dd9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga15758f12adde60cc820c419b157dd9c2">More...</a><br /></td></tr>
<tr class="separator:ga15758f12adde60cc820c419b157dd9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga402cce4dc9c10f1679ba9849cb993f0c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1CompactSearcher.html">CompactSearcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga402cce4dc9c10f1679ba9849cb993f0c">regina::NCompactSearcher</a></td></tr>
<tr class="memdesc:ga402cce4dc9c10f1679ba9849cb993f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga402cce4dc9c10f1679ba9849cb993f0c">More...</a><br /></td></tr>
<tr class="separator:ga402cce4dc9c10f1679ba9849cb993f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f57f46909048f730f28d8f6b0b1a8b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html">ClosedPrimeMinSearcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga55f57f46909048f730f28d8f6b0b1a8b">regina::NClosedPrimeMinSearcher</a></td></tr>
<tr class="memdesc:ga55f57f46909048f730f28d8f6b0b1a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga55f57f46909048f730f28d8f6b0b1a8b">More...</a><br /></td></tr>
<tr class="separator:ga55f57f46909048f730f28d8f6b0b1a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7383f4ff3af40a893696ce95abda9a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HyperbolicMinSearcher.html">HyperbolicMinSearcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7e7383f4ff3af40a893696ce95abda9a">regina::NHyperbolicMinSearcher</a></td></tr>
<tr class="memdesc:ga7e7383f4ff3af40a893696ce95abda9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#ga7e7383f4ff3af40a893696ce95abda9a">More...</a><br /></td></tr>
<tr class="separator:ga7e7383f4ff3af40a893696ce95abda9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b50b702b41225afbd20161898e3931"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">regina::GluingPermSearcher&lt; 4 &gt;::Use</a>) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt; *, void *)</td></tr>
<tr class="memdesc:ga43b50b702b41225afbd20161898e3931"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a set of gluing permutations.  <a href="group__census.html#ga43b50b702b41225afbd20161898e3931">More...</a><br /></td></tr>
<tr class="separator:ga43b50b702b41225afbd20161898e3931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4b30355de34de4e9e86da57c85d2ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gafd4b30355de34de4e9e86da57c85d2ba">regina::Dim4GluingPermSearcher</a></td></tr>
<tr class="memdesc:gafd4b30355de34de4e9e86da57c85d2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gafd4b30355de34de4e9e86da57c85d2ba">More...</a><br /></td></tr>
<tr class="separator:gafd4b30355de34de4e9e86da57c85d2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3cf7f3e8cd90321f45c2a641e480dab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::Use&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab3cf7f3e8cd90321f45c2a641e480dab">regina::UseDim4GluingPerms</a></td></tr>
<tr class="memdesc:gab3cf7f3e8cd90321f45c2a641e480dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__census.html#gab3cf7f3e8cd90321f45c2a641e480dab">More...</a><br /></td></tr>
<tr class="separator:gab3cf7f3e8cd90321f45c2a641e480dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada3ab4fafaa359d394afabb2b56253b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gada3ab4fafaa359d394afabb2b56253b2">regina::GluingPermSearcher&lt; 3 &gt;::PurgeFlags</a> { <br />
&#160;&#160;<a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a82e983dba291b66ddf05b4f99d2e85ce">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_NONE</a> = 0
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2af774c239c72c690a3dc88527904ba57a">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_NON_MINIMAL</a> = 1
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a88dbd756465fbe8ed551b9c4089eba14">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_NON_PRIME</a> = 2
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a488784291610d2080c8fd9be7fb0d99e">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_NON_MINIMAL_PRIME</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a9d84a4d217e149b8d1340f6b2754abe4">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_NON_MINIMAL_HYP</a> = 9
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a761c00f0760cd3af4d6b07162218a6b0">regina::GluingPermSearcher&lt; 3 &gt;::PURGE_P2_REDUCIBLE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:gada3ab4fafaa359d394afabb2b56253b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations.  <a href="group__census.html#gada3ab4fafaa359d394afabb2b56253b2">More...</a><br /></td></tr>
<tr class="separator:gada3ab4fafaa359d394afabb2b56253b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78092e891f6f355e6e65876301fcaf6f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__census.html#gga78092e891f6f355e6e65876301fcaf6fa48683e64b202e5e03d093d52837c899b">regina::EulerSearcher::VLINK_JOIN_INIT</a> = -1
, <a class="el" href="group__census.html#gga78092e891f6f355e6e65876301fcaf6fa6c8e29d0377dd6124780ea5fd0169052">regina::EulerSearcher::VLINK_JOIN_HANDLE</a> = -2
, <a class="el" href="group__census.html#gga78092e891f6f355e6e65876301fcaf6fab6592b7a8fc5491a8a482f5051e3bda5">regina::EulerSearcher::VLINK_JOIN_BRIDGE</a> = -3
, <a class="el" href="group__census.html#gga78092e891f6f355e6e65876301fcaf6fa4c0a3cec3e4456fda85a4d785c9772ee">regina::EulerSearcher::VLINK_JOIN_TWIST</a> = -4
 }</td></tr>
<tr class="memdesc:ga78092e891f6f355e6e65876301fcaf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants used in the <em>vertexStateChanged</em> array to indicate how a partial vertex link becomes glued to itself along two of its boundary edges.  <a href="group__census.html#ga78092e891f6f355e6e65876301fcaf6f">More...</a><br /></td></tr>
<tr class="separator:ga78092e891f6f355e6e65876301fcaf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga78ca7b114128f407d3f582263cf5452e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga78ca7b114128f407d3f582263cf5452e">regina::CensusDB::CensusDB</a> (const std::string &amp;<a class="el" href="group__census.html#gac0e5ad5656e9a24093fc0f088a4b68b5">filename</a>, const std::string &amp;<a class="el" href="group__census.html#ga0a02e30b4c9d3a2bcc4132fb13ac5555">desc</a>)</td></tr>
<tr class="memdesc:ga78ca7b114128f407d3f582263cf5452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new reference to one of Regina's census databases.  <a href="group__census.html#ga78ca7b114128f407d3f582263cf5452e">More...</a><br /></td></tr>
<tr class="separator:ga78ca7b114128f407d3f582263cf5452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79961c926103bc0b0f10484c0fcd3f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac79961c926103bc0b0f10484c0fcd3f1">regina::CensusDB::CensusDB</a> (const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;)=default</td></tr>
<tr class="memdesc:gac79961c926103bc0b0f10484c0fcd3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new clone of the given database reference.  <a href="group__census.html#gac79961c926103bc0b0f10484c0fcd3f1">More...</a><br /></td></tr>
<tr class="separator:gac79961c926103bc0b0f10484c0fcd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d3733957b1051d451c958a68e4dcc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga24d3733957b1051d451c958a68e4dcc4">regina::CensusDB::CensusDB</a> (<a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ga24d3733957b1051d451c958a68e4dcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given database reference into this new object.  <a href="group__census.html#ga24d3733957b1051d451c958a68e4dcc4">More...</a><br /></td></tr>
<tr class="separator:ga24d3733957b1051d451c958a68e4dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e5ad5656e9a24093fc0f088a4b68b5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac0e5ad5656e9a24093fc0f088a4b68b5">regina::CensusDB::filename</a> () const</td></tr>
<tr class="memdesc:gac0e5ad5656e9a24093fc0f088a4b68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the filename where this database is stored.  <a href="group__census.html#gac0e5ad5656e9a24093fc0f088a4b68b5">More...</a><br /></td></tr>
<tr class="separator:gac0e5ad5656e9a24093fc0f088a4b68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a02e30b4c9d3a2bcc4132fb13ac5555"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0a02e30b4c9d3a2bcc4132fb13ac5555">regina::CensusDB::desc</a> () const</td></tr>
<tr class="memdesc:ga0a02e30b4c9d3a2bcc4132fb13ac5555"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a human-readable description of this database.  <a href="group__census.html#ga0a02e30b4c9d3a2bcc4132fb13ac5555">More...</a><br /></td></tr>
<tr class="separator:ga0a02e30b4c9d3a2bcc4132fb13ac5555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5bdd67c6e27bd0d434e52b98c47107"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabb5bdd67c6e27bd0d434e52b98c47107">regina::CensusDB::lookup</a> (const std::string &amp;isoSig, <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> *hits) const</td></tr>
<tr class="memdesc:gabb5bdd67c6e27bd0d434e52b98c47107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the given isomorphism signature in this database.  <a href="group__census.html#gabb5bdd67c6e27bd0d434e52b98c47107">More...</a><br /></td></tr>
<tr class="separator:gabb5bdd67c6e27bd0d434e52b98c47107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d90f11a578ef9502081434143dc8df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d90f11a578ef9502081434143dc8df7">regina::CensusDB::operator=</a> (const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;)=default</td></tr>
<tr class="memdesc:ga0d90f11a578ef9502081434143dc8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given database reference.  <a href="group__census.html#ga0d90f11a578ef9502081434143dc8df7">More...</a><br /></td></tr>
<tr class="separator:ga0d90f11a578ef9502081434143dc8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cabc4a68c14dabe46f63baf39cb4c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7cabc4a68c14dabe46f63baf39cb4c6f">regina::CensusDB::operator=</a> (<a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ga7cabc4a68c14dabe46f63baf39cb4c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given database reference into this object.  <a href="group__census.html#ga7cabc4a68c14dabe46f63baf39cb4c6f">More...</a><br /></td></tr>
<tr class="separator:ga7cabc4a68c14dabe46f63baf39cb4c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac591759fce9ed4c05d7d8a1af4b72743"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac591759fce9ed4c05d7d8a1af4b72743">regina::CensusHit::name</a> () const</td></tr>
<tr class="memdesc:gac591759fce9ed4c05d7d8a1af4b72743"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the human-readable name associated with the triangulation in the database.  <a href="group__census.html#gac591759fce9ed4c05d7d8a1af4b72743">More...</a><br /></td></tr>
<tr class="separator:gac591759fce9ed4c05d7d8a1af4b72743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ce63abf4f553af75c602ae12c632c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab3ce63abf4f553af75c602ae12c632c6">regina::CensusHit::db</a> () const</td></tr>
<tr class="memdesc:gab3ce63abf4f553af75c602ae12c632c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the census database in which the triangulation was found.  <a href="group__census.html#gab3ce63abf4f553af75c602ae12c632c6">More...</a><br /></td></tr>
<tr class="separator:gab3ce63abf4f553af75c602ae12c632c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862839100cb9ec760009127603b38f35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga862839100cb9ec760009127603b38f35">regina::CensusHit::next</a> () const</td></tr>
<tr class="memdesc:ga862839100cb9ec760009127603b38f35"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next hit for the same triangulation, or <code>null</code> if there are no more hits.  <a href="group__census.html#ga862839100cb9ec760009127603b38f35">More...</a><br /></td></tr>
<tr class="separator:ga862839100cb9ec760009127603b38f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ba85bed053f98659119b9233b0024a"><td class="memItemLeft" align="right" valign="top"><a id="gad6ba85bed053f98659119b9233b0024a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHit::CensusHit</b> (const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> &amp;)=delete</td></tr>
<tr class="separator:gad6ba85bed053f98659119b9233b0024a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18e529ad1e137335a9aef080422be02"><td class="memItemLeft" align="right" valign="top"><a id="gaa18e529ad1e137335a9aef080422be02"></a>
<a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHit::operator=</b> (const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> &amp;)=delete</td></tr>
<tr class="separator:gaa18e529ad1e137335a9aef080422be02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636bf941eacd42d508404d26d4cdfb29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga636bf941eacd42d508404d26d4cdfb29">regina::CensusHits::CensusHits</a> ()</td></tr>
<tr class="memdesc:ga636bf941eacd42d508404d26d4cdfb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty set of hits.  <a href="group__census.html#ga636bf941eacd42d508404d26d4cdfb29">More...</a><br /></td></tr>
<tr class="separator:ga636bf941eacd42d508404d26d4cdfb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14b058fa53661b829fdfd73a54017a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab14b058fa53661b829fdfd73a54017a0">regina::CensusHits::~CensusHits</a> ()</td></tr>
<tr class="memdesc:gab14b058fa53661b829fdfd73a54017a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object and all of the individual <a class="el" href="classregina_1_1CensusHit.html" title="Stores a single &quot;hit&quot; indicating that some given triangulation has been located in one of Regina&#39;s in...">CensusHit</a> objects that it contains.  <a href="group__census.html#gab14b058fa53661b829fdfd73a54017a0">More...</a><br /></td></tr>
<tr class="separator:gab14b058fa53661b829fdfd73a54017a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a6169669ab839788131dcbbc0655f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf7a6169669ab839788131dcbbc0655f0">regina::CensusHits::first</a> () const</td></tr>
<tr class="memdesc:gaf7a6169669ab839788131dcbbc0655f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first hit in this list.  <a href="group__census.html#gaf7a6169669ab839788131dcbbc0655f0">More...</a><br /></td></tr>
<tr class="separator:gaf7a6169669ab839788131dcbbc0655f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5e301be4e108c90bb4ffd563fd7404"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4e5e301be4e108c90bb4ffd563fd7404">regina::CensusHits::count</a> () const</td></tr>
<tr class="memdesc:ga4e5e301be4e108c90bb4ffd563fd7404"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of hits in this list.  <a href="group__census.html#ga4e5e301be4e108c90bb4ffd563fd7404">More...</a><br /></td></tr>
<tr class="separator:ga4e5e301be4e108c90bb4ffd563fd7404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ad74212bf23e7a01971cd40c50b5d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga22ad74212bf23e7a01971cd40c50b5d9">regina::CensusHits::empty</a> () const</td></tr>
<tr class="memdesc:ga22ad74212bf23e7a01971cd40c50b5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there are any hits at all.  <a href="group__census.html#ga22ad74212bf23e7a01971cd40c50b5d9">More...</a><br /></td></tr>
<tr class="separator:ga22ad74212bf23e7a01971cd40c50b5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96137581ba7cc8158ba933849a6b800c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga96137581ba7cc8158ba933849a6b800c">regina::CensusHits::begin</a> () const</td></tr>
<tr class="memdesc:ga96137581ba7cc8158ba933849a6b800c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of this list of hits.  <a href="group__census.html#ga96137581ba7cc8158ba933849a6b800c">More...</a><br /></td></tr>
<tr class="separator:ga96137581ba7cc8158ba933849a6b800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83afd05d0f0e761350d8cf74a132135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae83afd05d0f0e761350d8cf74a132135">regina::CensusHits::end</a> () const</td></tr>
<tr class="memdesc:gae83afd05d0f0e761350d8cf74a132135"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of this list of hits.  <a href="group__census.html#gae83afd05d0f0e761350d8cf74a132135">More...</a><br /></td></tr>
<tr class="separator:gae83afd05d0f0e761350d8cf74a132135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96d6b032b249f255cb8561dc075b356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac96d6b032b249f255cb8561dc075b356">regina::CensusHits::append</a> (<a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *hit)</td></tr>
<tr class="memdesc:gac96d6b032b249f255cb8561dc075b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new hit to the end of this list.  <a href="group__census.html#gac96d6b032b249f255cb8561dc075b356">More...</a><br /></td></tr>
<tr class="separator:gac96d6b032b249f255cb8561dc075b356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ce2cbaae8d500f591c328eb2719399"><td class="memItemLeft" align="right" valign="top"><a id="gaf2ce2cbaae8d500f591c328eb2719399"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHits::CensusHits</b> (const <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> &amp;)=delete</td></tr>
<tr class="separator:gaf2ce2cbaae8d500f591c328eb2719399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf50ef09465e31ff5cb90fd77fbeec03"><td class="memItemLeft" align="right" valign="top"><a id="gabf50ef09465e31ff5cb90fd77fbeec03"></a>
<a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHits::operator=</b> (const <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> &amp;)=delete</td></tr>
<tr class="separator:gabf50ef09465e31ff5cb90fd77fbeec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4efd819900aa2ef30657ac35d4fea61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf4efd819900aa2ef30657ac35d4fea61">regina::CensusHitIterator::CensusHitIterator</a> ()</td></tr>
<tr class="memdesc:gaf4efd819900aa2ef30657ac35d4fea61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a past-the-end iterator.  <a href="group__census.html#gaf4efd819900aa2ef30657ac35d4fea61">More...</a><br /></td></tr>
<tr class="separator:gaf4efd819900aa2ef30657ac35d4fea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50f6c08e9bc01212b8f690b559d0629"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac50f6c08e9bc01212b8f690b559d0629">regina::CensusHitIterator::CensusHitIterator</a> (const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gac50f6c08e9bc01212b8f690b559d0629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__census.html#gac50f6c08e9bc01212b8f690b559d0629">More...</a><br /></td></tr>
<tr class="separator:gac50f6c08e9bc01212b8f690b559d0629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a53e01f296f15969731071f662119a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad2a53e01f296f15969731071f662119a">regina::CensusHitIterator::CensusHitIterator</a> (const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *current)</td></tr>
<tr class="memdesc:gad2a53e01f296f15969731071f662119a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given census hit.  <a href="group__census.html#gad2a53e01f296f15969731071f662119a">More...</a><br /></td></tr>
<tr class="separator:gad2a53e01f296f15969731071f662119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396f30578a5d6cf252b213f673edf86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga396f30578a5d6cf252b213f673edf86b">regina::CensusHitIterator::operator=</a> (const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga396f30578a5d6cf252b213f673edf86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__census.html#ga396f30578a5d6cf252b213f673edf86b">More...</a><br /></td></tr>
<tr class="separator:ga396f30578a5d6cf252b213f673edf86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9bb43775dd63a77dee3aa39ac44350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaab9bb43775dd63a77dee3aa39ac44350">regina::CensusHitIterator::operator==</a> (const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gaab9bb43775dd63a77dee3aa39ac44350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="group__census.html#gaab9bb43775dd63a77dee3aa39ac44350">More...</a><br /></td></tr>
<tr class="separator:gaab9bb43775dd63a77dee3aa39ac44350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ebfeb66287d95387970e3f429eecdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac5ebfeb66287d95387970e3f429eecdd">regina::CensusHitIterator::operator!=</a> (const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gac5ebfeb66287d95387970e3f429eecdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="group__census.html#gac5ebfeb66287d95387970e3f429eecdd">More...</a><br /></td></tr>
<tr class="separator:gac5ebfeb66287d95387970e3f429eecdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1f59c0ab86f2f53b847e65a7d5c242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4d1f59c0ab86f2f53b847e65a7d5c242">regina::CensusHitIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga4d1f59c0ab86f2f53b847e65a7d5c242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__census.html#ga4d1f59c0ab86f2f53b847e65a7d5c242">More...</a><br /></td></tr>
<tr class="separator:ga4d1f59c0ab86f2f53b847e65a7d5c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b5110af488170a2309687da0e59fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga92b5110af488170a2309687da0e59fa2">regina::CensusHitIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga92b5110af488170a2309687da0e59fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__census.html#ga92b5110af488170a2309687da0e59fa2">More...</a><br /></td></tr>
<tr class="separator:ga92b5110af488170a2309687da0e59fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4616c56b52142a6292444856e32d8247"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4616c56b52142a6292444856e32d8247">regina::CensusHitIterator::operator*</a> () const</td></tr>
<tr class="memdesc:ga4616c56b52142a6292444856e32d8247"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the census hit that this iterator is currently pointing to, or <code>null</code> if this iterator is past-the-end.  <a href="group__census.html#ga4616c56b52142a6292444856e32d8247">More...</a><br /></td></tr>
<tr class="separator:ga4616c56b52142a6292444856e32d8247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10e60ed01730474c83c9337c89c41ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae">regina::Census::lookup</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:gaf10e60ed01730474c83c9337c89c41ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the given triangulation through all of Regina's in-built census databases.  <a href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae">More...</a><br /></td></tr>
<tr class="separator:gaf10e60ed01730474c83c9337c89c41ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b4382f7a74525c621549b5faaeae92"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga51b4382f7a74525c621549b5faaeae92">regina::Census::lookup</a> (const std::string &amp;isoSig)</td></tr>
<tr class="memdesc:ga51b4382f7a74525c621549b5faaeae92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the given triangulation through all of Regina's in-built census databases.  <a href="group__census.html#ga51b4382f7a74525c621549b5faaeae92">More...</a><br /></td></tr>
<tr class="separator:ga51b4382f7a74525c621549b5faaeae92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b25211be46c5f7f46f4a2fb0750e21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga66b25211be46c5f7f46f4a2fb0750e21">regina::GluingPerms&lt; dim &gt;::GluingPerms</a> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga66b25211be46c5f7f46f4a2fb0750e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of gluing permutations that is a clone of the given permutation set.  <a href="group__census.html#ga66b25211be46c5f7f46f4a2fb0750e21">More...</a><br /></td></tr>
<tr class="separator:ga66b25211be46c5f7f46f4a2fb0750e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb274fddfacdad1fbe870fa0dba57a51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gacb274fddfacdad1fbe870fa0dba57a51">regina::GluingPerms&lt; dim &gt;::GluingPerms</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:gacb274fddfacdad1fbe870fa0dba57a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new set of gluing permutations from the given input stream.  <a href="group__census.html#gacb274fddfacdad1fbe870fa0dba57a51">More...</a><br /></td></tr>
<tr class="separator:gacb274fddfacdad1fbe870fa0dba57a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d584bf4ffb32f2227db4310fd12997e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5d584bf4ffb32f2227db4310fd12997e">regina::GluingPerms&lt; dim &gt;::~GluingPerms</a> ()</td></tr>
<tr class="memdesc:ga5d584bf4ffb32f2227db4310fd12997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any memory used by this structure.  <a href="group__census.html#ga5d584bf4ffb32f2227db4310fd12997e">More...</a><br /></td></tr>
<tr class="separator:ga5d584bf4ffb32f2227db4310fd12997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1">regina::GluingPerms&lt; dim &gt;::inputError</a> () const</td></tr>
<tr class="memdesc:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1">More...</a><br /></td></tr>
<tr class="separator:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052f8788995d20de83982daedffa9868"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga052f8788995d20de83982daedffa9868">regina::GluingPerms&lt; dim &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga052f8788995d20de83982daedffa9868"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of simplices under consideration.  <a href="group__census.html#ga052f8788995d20de83982daedffa9868">More...</a><br /></td></tr>
<tr class="separator:ga052f8788995d20de83982daedffa9868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceabd6f42214d77e7cb132e2a37d790f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f">regina::GluingPerms&lt; dim &gt;::facetPairing</a> () const</td></tr>
<tr class="memdesc:gaceabd6f42214d77e7cb132e2a37d790f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f">More...</a><br /></td></tr>
<tr class="separator:gaceabd6f42214d77e7cb132e2a37d790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6efb577f8be677717e20624a75037de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6">regina::GluingPerms&lt; dim &gt;::gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:ga6efb577f8be677717e20624a75037de6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet.  <a href="group__census.html#ga6efb577f8be677717e20624a75037de6">More...</a><br /></td></tr>
<tr class="separator:ga6efb577f8be677717e20624a75037de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8621f1370a90132ec44b032c7926066f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8621f1370a90132ec44b032c7926066f">regina::GluingPerms&lt; dim &gt;::gluingPerm</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga8621f1370a90132ec44b032c7926066f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet.  <a href="group__census.html#ga8621f1370a90132ec44b032c7926066f">More...</a><br /></td></tr>
<tr class="separator:ga8621f1370a90132ec44b032c7926066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d4e4a6f2423844a747d921e1e8459c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c">regina::GluingPerms&lt; dim &gt;::triangulate</a> () const</td></tr>
<tr class="memdesc:ga48d4e4a6f2423844a747d921e1e8459c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c">More...</a><br /></td></tr>
<tr class="separator:ga48d4e4a6f2423844a747d921e1e8459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46eb76a4d962402f85f52e39aa890137"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga46eb76a4d962402f85f52e39aa890137">regina::GluingPerms&lt; dim &gt;::dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga46eb76a4d962402f85f52e39aa890137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga46eb76a4d962402f85f52e39aa890137">More...</a><br /></td></tr>
<tr class="separator:ga46eb76a4d962402f85f52e39aa890137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10a8223a2034c22b385a129b0f73057"><td class="memItemLeft" align="right" valign="top"><a id="gaf10a8223a2034c22b385a129b0f73057"></a>
<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPerms&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> &amp;)=delete</td></tr>
<tr class="separator:gaf10a8223a2034c22b385a129b0f73057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747d7a252a077b329e1411c137d220d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga747d7a252a077b329e1411c137d220d6">regina::GluingPerms&lt; dim &gt;::GluingPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *pairing)</td></tr>
<tr class="memdesc:ga747d7a252a077b329e1411c137d220d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new permutation set.  <a href="group__census.html#ga747d7a252a077b329e1411c137d220d6">More...</a><br /></td></tr>
<tr class="separator:ga747d7a252a077b329e1411c137d220d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f6711eb803742af936b68a0680888f"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga28f6711eb803742af936b68a0680888f">regina::GluingPerms&lt; dim &gt;::permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>)</td></tr>
<tr class="memdesc:ga28f6711eb803742af936b68a0680888f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#ga28f6711eb803742af936b68a0680888f">More...</a><br /></td></tr>
<tr class="separator:ga28f6711eb803742af936b68a0680888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa1eb17b2d09a1fc64176b5eda1e057e4">regina::GluingPerms&lt; dim &gt;::permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#gaa1eb17b2d09a1fc64176b5eda1e057e4">More...</a><br /></td></tr>
<tr class="separator:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb19364415afbf88d139ee26d5c6d2af"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaeb19364415afbf88d139ee26d5c6d2af">regina::GluingPerms&lt; dim &gt;::permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:gaeb19364415afbf88d139ee26d5c6d2af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#gaeb19364415afbf88d139ee26d5c6d2af">More...</a><br /></td></tr>
<tr class="separator:gaeb19364415afbf88d139ee26d5c6d2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8d9aa920a0554ac7a26b2baaab25bf25">regina::GluingPerms&lt; dim &gt;::permIndex</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#ga8d9aa920a0554ac7a26b2baaab25bf25">More...</a><br /></td></tr>
<tr class="separator:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da0ad1c66af05624ecdd711785e702c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c">regina::GluingPerms&lt; dim &gt;::gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ga8da0ad1c66af05624ecdd711785e702c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c">More...</a><br /></td></tr>
<tr class="separator:ga8da0ad1c66af05624ecdd711785e702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga254d849ef372fc0da9c02cf4b3a74a83">regina::GluingPerms&lt; dim &gt;::gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="group__census.html#ga254d849ef372fc0da9c02cf4b3a74a83">More...</a><br /></td></tr>
<tr class="separator:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96">regina::GluingPerms&lt; dim &gt;::indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, int index) const</td></tr>
<tr class="memdesc:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1.  <a href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96">More...</a><br /></td></tr>
<tr class="separator:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">regina::GluingPerms&lt; dim &gt;::indexToGluing</a> (unsigned simp, unsigned facet, int index) const</td></tr>
<tr class="memdesc:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1.  <a href="group__census.html#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">More...</a><br /></td></tr>
<tr class="separator:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385345c086bce00163471f973fc86e95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga385345c086bce00163471f973fc86e95">regina::GluingPermSearcher&lt; 2 &gt;::GluingPermSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga385345c086bce00163471f973fc86e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <a href="group__census.html#ga385345c086bce00163471f973fc86e95">More...</a><br /></td></tr>
<tr class="separator:ga385345c086bce00163471f973fc86e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a6f0651ec9f0d269d5e1e8d094f75d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga79a6f0651ec9f0d269d5e1e8d094f75d">regina::GluingPermSearcher&lt; 2 &gt;::GluingPermSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga79a6f0651ec9f0d269d5e1e8d094f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#ga79a6f0651ec9f0d269d5e1e8d094f75d">More...</a><br /></td></tr>
<tr class="separator:ga79a6f0651ec9f0d269d5e1e8d094f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694a3184398855d061d3391e372abaf7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga694a3184398855d061d3391e372abaf7">regina::GluingPermSearcher&lt; 2 &gt;::~GluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:ga694a3184398855d061d3391e372abaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#ga694a3184398855d061d3391e372abaf7">More...</a><br /></td></tr>
<tr class="separator:ga694a3184398855d061d3391e372abaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8e405571d84d85002ffe55a40726db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db">regina::GluingPermSearcher&lt; 2 &gt;::runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:ga8b8e405571d84d85002ffe55a40726db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga8b8e405571d84d85002ffe55a40726db">More...</a><br /></td></tr>
<tr class="separator:ga8b8e405571d84d85002ffe55a40726db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492bd21552c84aaa40f239f48b8b69d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga492bd21552c84aaa40f239f48b8b69d2">regina::GluingPermSearcher&lt; 2 &gt;::completePermSet</a> () const</td></tr>
<tr class="memdesc:ga492bd21552c84aaa40f239f48b8b69d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="group__census.html#ga492bd21552c84aaa40f239f48b8b69d2">More...</a><br /></td></tr>
<tr class="separator:ga492bd21552c84aaa40f239f48b8b69d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89630d016da6bcdafe5ec14c914b7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad89630d016da6bcdafe5ec14c914b7d1">regina::GluingPermSearcher&lt; 2 &gt;::dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad89630d016da6bcdafe5ec14c914b7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="group__census.html#gad89630d016da6bcdafe5ec14c914b7d1">More...</a><br /></td></tr>
<tr class="separator:gad89630d016da6bcdafe5ec14c914b7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17c98dfbc2842bbf20fd267b806ed9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad17c98dfbc2842bbf20fd267b806ed9e">regina::GluingPermSearcher&lt; 2 &gt;::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gad17c98dfbc2842bbf20fd267b806ed9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#gad17c98dfbc2842bbf20fd267b806ed9e">More...</a><br /></td></tr>
<tr class="separator:gad17c98dfbc2842bbf20fd267b806ed9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ec9d10baaa81178d6a104455b347d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2">regina::GluingPermSearcher&lt; 2 &gt;::findAllPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaa0ec9d10baaa81178d6a104455b347d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given edge pairing.  <a href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2">More...</a><br /></td></tr>
<tr class="separator:gaa0ec9d10baaa81178d6a104455b347d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcc40f8963f47e6059a0c49a115982a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gadbcc40f8963f47e6059a0c49a115982a">regina::GluingPermSearcher&lt; 2 &gt;::bestSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gadbcc40f8963f47e6059a0c49a115982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="group__census.html#gadbcc40f8963f47e6059a0c49a115982a">More...</a><br /></td></tr>
<tr class="separator:gadbcc40f8963f47e6059a0c49a115982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bdcfc6c102832450b03bd8a2a36b040"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2bdcfc6c102832450b03bd8a2a36b040">regina::GluingPermSearcher&lt; 2 &gt;::readTaggedData</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga2bdcfc6c102832450b03bd8a2a36b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="group__census.html#ga2bdcfc6c102832450b03bd8a2a36b040">More...</a><br /></td></tr>
<tr class="separator:ga2bdcfc6c102832450b03bd8a2a36b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17c0c036d72db4ef41f0139ca0ad922"><td class="memItemLeft" align="right" valign="top"><a id="gae17c0c036d72db4ef41f0139ca0ad922"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 2 &gt;::GluingPermSearcher</b> (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:gae17c0c036d72db4ef41f0139ca0ad922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56c8d4d49e8d52aa356fa56f7ed99be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad56c8d4d49e8d52aa356fa56f7ed99be">regina::GluingPermSearcher&lt; 2 &gt;::isCanonical</a> () const</td></tr>
<tr class="memdesc:gad56c8d4d49e8d52aa356fa56f7ed99be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying edge pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="group__census.html#gad56c8d4d49e8d52aa356fa56f7ed99be">More...</a><br /></td></tr>
<tr class="separator:gad56c8d4d49e8d52aa356fa56f7ed99be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e9e46143328020185ad88fb8cecc54"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga78e9e46143328020185ad88fb8cecc54">regina::GluingPermSearcher&lt; 2 &gt;::dataTag</a> () const</td></tr>
<tr class="memdesc:ga78e9e46143328020185ad88fb8cecc54"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#ga78e9e46143328020185ad88fb8cecc54">More...</a><br /></td></tr>
<tr class="separator:ga78e9e46143328020185ad88fb8cecc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4930c57b5c3ea676e189c0f9994a4203"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4930c57b5c3ea676e189c0f9994a4203">regina::GluingPermSearcher&lt; 3 &gt;::GluingPermSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga4930c57b5c3ea676e189c0f9994a4203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <a href="group__census.html#ga4930c57b5c3ea676e189c0f9994a4203">More...</a><br /></td></tr>
<tr class="separator:ga4930c57b5c3ea676e189c0f9994a4203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2c55d67ab8ea18144a5598c243f334"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3d2c55d67ab8ea18144a5598c243f334">regina::GluingPermSearcher&lt; 3 &gt;::GluingPermSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga3d2c55d67ab8ea18144a5598c243f334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#ga3d2c55d67ab8ea18144a5598c243f334">More...</a><br /></td></tr>
<tr class="separator:ga3d2c55d67ab8ea18144a5598c243f334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b7a99b96a260e7afe855ba9ce24acf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga20b7a99b96a260e7afe855ba9ce24acf">regina::GluingPermSearcher&lt; 3 &gt;::~GluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:ga20b7a99b96a260e7afe855ba9ce24acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#ga20b7a99b96a260e7afe855ba9ce24acf">More...</a><br /></td></tr>
<tr class="separator:ga20b7a99b96a260e7afe855ba9ce24acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4d7126bf7096e21c92134b59698aea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea">regina::GluingPermSearcher&lt; 3 &gt;::runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:ga5e4d7126bf7096e21c92134b59698aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea">More...</a><br /></td></tr>
<tr class="separator:ga5e4d7126bf7096e21c92134b59698aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8">regina::GluingPermSearcher&lt; 3 &gt;::completePermSet</a> () const</td></tr>
<tr class="memdesc:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8">More...</a><br /></td></tr>
<tr class="separator:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68aae09c481982555e0a9f744264e8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc">regina::GluingPermSearcher&lt; 3 &gt;::dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga68aae09c481982555e0a9f744264e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="group__census.html#ga68aae09c481982555e0a9f744264e8dc">More...</a><br /></td></tr>
<tr class="separator:ga68aae09c481982555e0a9f744264e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3fd032ae3c9ff71d80b2758cf5b978"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978">regina::GluingPermSearcher&lt; 3 &gt;::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0f3fd032ae3c9ff71d80b2758cf5b978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978">More...</a><br /></td></tr>
<tr class="separator:ga0f3fd032ae3c9ff71d80b2758cf5b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a125fcef3581b87f04eec6eb8044328"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328">regina::GluingPermSearcher&lt; 3 &gt;::findAllPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga6a125fcef3581b87f04eec6eb8044328"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <a href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328">More...</a><br /></td></tr>
<tr class="separator:ga6a125fcef3581b87f04eec6eb8044328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ac77c210fb2ae44e799f3f7db02300"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga83ac77c210fb2ae44e799f3f7db02300">regina::GluingPermSearcher&lt; 3 &gt;::bestSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga83ac77c210fb2ae44e799f3f7db02300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="group__census.html#ga83ac77c210fb2ae44e799f3f7db02300">More...</a><br /></td></tr>
<tr class="separator:ga83ac77c210fb2ae44e799f3f7db02300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987cf019e19f63f5a470f59588dd0d69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69">regina::GluingPermSearcher&lt; 3 &gt;::readTaggedData</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga987cf019e19f63f5a470f59588dd0d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69">More...</a><br /></td></tr>
<tr class="separator:ga987cf019e19f63f5a470f59588dd0d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf6f38c5460e9bf2dc6ba37cf98f705"><td class="memItemLeft" align="right" valign="top"><a id="ga0bf6f38c5460e9bf2dc6ba37cf98f705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 3 &gt;::GluingPermSearcher</b> (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:ga0bf6f38c5460e9bf2dc6ba37cf98f705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8c7e6c6d0cce1efb0335a09ae6bdcd1f">regina::GluingPermSearcher&lt; 3 &gt;::isCanonical</a> () const</td></tr>
<tr class="memdesc:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="group__census.html#ga8c7e6c6d0cce1efb0335a09ae6bdcd1f">More...</a><br /></td></tr>
<tr class="separator:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga941c419f7a3a7d86e850a8d32a6bdd86">regina::GluingPermSearcher&lt; 3 &gt;::badEdgeLink</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face) const</td></tr>
<tr class="memdesc:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <a href="group__census.html#ga941c419f7a3a7d86e850a8d32a6bdd86">More...</a><br /></td></tr>
<tr class="separator:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f4089dd2a85f436724655825f082b81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9f4089dd2a85f436724655825f082b81">regina::GluingPermSearcher&lt; 3 &gt;::lowDegreeEdge</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face, bool testDegree12, bool testDegree3) const</td></tr>
<tr class="memdesc:ga9f4089dd2a85f436724655825f082b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <a href="group__census.html#ga9f4089dd2a85f436724655825f082b81">More...</a><br /></td></tr>
<tr class="separator:ga9f4089dd2a85f436724655825f082b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccaa866825f9d8f80abbc1b31376b33"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5ccaa866825f9d8f80abbc1b31376b33">regina::GluingPermSearcher&lt; 3 &gt;::dataTag</a> () const</td></tr>
<tr class="memdesc:ga5ccaa866825f9d8f80abbc1b31376b33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#ga5ccaa866825f9d8f80abbc1b31376b33">More...</a><br /></td></tr>
<tr class="separator:ga5ccaa866825f9d8f80abbc1b31376b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fbc7349339abeb42fb3658e5cb8de3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga03fbc7349339abeb42fb3658e5cb8de3">regina::EulerSearcher::TetVertexState::TetVertexState</a> ()</td></tr>
<tr class="memdesc:ga03fbc7349339abeb42fb3658e5cb8de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone tetrahedron vertex in an equivalence class all of its own.  <a href="group__census.html#ga03fbc7349339abeb42fb3658e5cb8de3">More...</a><br /></td></tr>
<tr class="separator:ga03fbc7349339abeb42fb3658e5cb8de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82404c59a59f47997ef0d00f1fc3199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad82404c59a59f47997ef0d00f1fc3199">regina::EulerSearcher::TetVertexState::dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad82404c59a59f47997ef0d00f1fc3199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#gad82404c59a59f47997ef0d00f1fc3199">More...</a><br /></td></tr>
<tr class="separator:gad82404c59a59f47997ef0d00f1fc3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe23322c2fa99b115e369ed3bb83d4f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabe23322c2fa99b115e369ed3bb83d4f5">regina::EulerSearcher::TetVertexState::readData</a> (std::istream &amp;in, unsigned long nStates)</td></tr>
<tr class="memdesc:gabe23322c2fa99b115e369ed3bb83d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#gabe23322c2fa99b115e369ed3bb83d4f5">More...</a><br /></td></tr>
<tr class="separator:gabe23322c2fa99b115e369ed3bb83d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9084d80d633592e2ea75a8780dc65c8f"><td class="memItemLeft" align="right" valign="top"><a id="ga9084d80d633592e2ea75a8780dc65c8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::EulerSearcher::TetVertexState::TetVertexState</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:ga9084d80d633592e2ea75a8780dc65c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c533d7e9a3ba57e0625821a5669fde"><td class="memItemLeft" align="right" valign="top"><a id="gad9c533d7e9a3ba57e0625821a5669fde"></a>
<a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::EulerSearcher::TetVertexState::operator=</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:gad9c533d7e9a3ba57e0625821a5669fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga567da6d334e99909b2a7990c672c9dc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga567da6d334e99909b2a7990c672c9dc0">regina::EulerSearcher::TetEdgeState::TetEdgeState</a> ()</td></tr>
<tr class="memdesc:ga567da6d334e99909b2a7990c672c9dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone tetrahedron edge in an equivalence class all of its own.  <a href="group__census.html#ga567da6d334e99909b2a7990c672c9dc0">More...</a><br /></td></tr>
<tr class="separator:ga567da6d334e99909b2a7990c672c9dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e26f60e3f150239a1fabaee0ae1833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac9e26f60e3f150239a1fabaee0ae1833">regina::EulerSearcher::TetEdgeState::dumpData</a> (std::ostream &amp;out, unsigned nTets) const</td></tr>
<tr class="memdesc:gac9e26f60e3f150239a1fabaee0ae1833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#gac9e26f60e3f150239a1fabaee0ae1833">More...</a><br /></td></tr>
<tr class="separator:gac9e26f60e3f150239a1fabaee0ae1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71cfd9584873bcae03bee1df4c982dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa71cfd9584873bcae03bee1df4c982dc">regina::EulerSearcher::TetEdgeState::readData</a> (std::istream &amp;in, unsigned nTets)</td></tr>
<tr class="memdesc:gaa71cfd9584873bcae03bee1df4c982dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#gaa71cfd9584873bcae03bee1df4c982dc">More...</a><br /></td></tr>
<tr class="separator:gaa71cfd9584873bcae03bee1df4c982dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565467ddf22682b5e1afa35004ec22ac"><td class="memItemLeft" align="right" valign="top"><a id="ga565467ddf22682b5e1afa35004ec22ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::EulerSearcher::TetEdgeState::TetEdgeState</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;)=delete</td></tr>
<tr class="separator:ga565467ddf22682b5e1afa35004ec22ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d59e5a606bc2ce14f0eae760b615608"><td class="memItemLeft" align="right" valign="top"><a id="ga3d59e5a606bc2ce14f0eae760b615608"></a>
<a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::EulerSearcher::TetEdgeState::operator=</b> (const <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;)=delete</td></tr>
<tr class="separator:ga3d59e5a606bc2ce14f0eae760b615608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cba6cbbd79d13f8c2337920416b3291"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6cba6cbbd79d13f8c2337920416b3291">regina::EulerSearcher::EulerSearcher</a> (int useEuler, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga6cba6cbbd79d13f8c2337920416b3291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager that restricts Euler characteristic on the vertex links, as described in the class overview.  <a href="group__census.html#ga6cba6cbbd79d13f8c2337920416b3291">More...</a><br /></td></tr>
<tr class="separator:ga6cba6cbbd79d13f8c2337920416b3291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc993832f34e7e00be141bcdb6f2c85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaacc993832f34e7e00be141bcdb6f2c85">regina::EulerSearcher::EulerSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaacc993832f34e7e00be141bcdb6f2c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#gaacc993832f34e7e00be141bcdb6f2c85">More...</a><br /></td></tr>
<tr class="separator:gaacc993832f34e7e00be141bcdb6f2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63b0cf3b75f5a6a138da1b1360bd4d0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab63b0cf3b75f5a6a138da1b1360bd4d0">regina::EulerSearcher::~EulerSearcher</a> ()</td></tr>
<tr class="memdesc:gab63b0cf3b75f5a6a138da1b1360bd4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#gab63b0cf3b75f5a6a138da1b1360bd4d0">More...</a><br /></td></tr>
<tr class="separator:gab63b0cf3b75f5a6a138da1b1360bd4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666143b82a03dcc0a384b6ac46bb9ebd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd">regina::EulerSearcher::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga666143b82a03dcc0a384b6ac46bb9ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd">More...</a><br /></td></tr>
<tr class="separator:ga666143b82a03dcc0a384b6ac46bb9ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e9834f603daca08a2bae6604f58c52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52">regina::EulerSearcher::runSearch</a> (long maxDepth=-1) override</td></tr>
<tr class="memdesc:ga99e9834f603daca08a2bae6604f58c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga99e9834f603daca08a2bae6604f58c52">More...</a><br /></td></tr>
<tr class="separator:ga99e9834f603daca08a2bae6604f58c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d5beee85da518709476bdb964decf7"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad2d5beee85da518709476bdb964decf7">regina::EulerSearcher::dataTag</a> () const override</td></tr>
<tr class="memdesc:gad2d5beee85da518709476bdb964decf7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#gad2d5beee85da518709476bdb964decf7">More...</a><br /></td></tr>
<tr class="separator:gad2d5beee85da518709476bdb964decf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4263924ede95808c20084f6a596489e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4263924ede95808c20084f6a596489e8">regina::EulerSearcher::findEdgeClass</a> (int edgeID) const</td></tr>
<tr class="memdesc:ga4263924ede95808c20084f6a596489e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga4263924ede95808c20084f6a596489e8">More...</a><br /></td></tr>
<tr class="separator:ga4263924ede95808c20084f6a596489e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f479e3070fb2c5d88e00e254dde2b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga90f479e3070fb2c5d88e00e254dde2b4">regina::EulerSearcher::findEdgeClass</a> (int edgeID, char &amp;twisted) const</td></tr>
<tr class="memdesc:ga90f479e3070fb2c5d88e00e254dde2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga90f479e3070fb2c5d88e00e254dde2b4">More...</a><br /></td></tr>
<tr class="separator:ga90f479e3070fb2c5d88e00e254dde2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5f12fdba99f7dd5736b17e8acf2f3f9d">regina::EulerSearcher::mergeVertexClasses</a> ()</td></tr>
<tr class="memdesc:ga5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga5f12fdba99f7dd5736b17e8acf2f3f9d">More...</a><br /></td></tr>
<tr class="separator:ga5f12fdba99f7dd5736b17e8acf2f3f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11b3e60a84f49fdacdc12967dc88e50c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga11b3e60a84f49fdacdc12967dc88e50c">regina::EulerSearcher::mergeEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga11b3e60a84f49fdacdc12967dc88e50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga11b3e60a84f49fdacdc12967dc88e50c">More...</a><br /></td></tr>
<tr class="separator:ga11b3e60a84f49fdacdc12967dc88e50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7223404529a44de2fc26778be8780264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7223404529a44de2fc26778be8780264">regina::EulerSearcher::splitVertexClasses</a> ()</td></tr>
<tr class="memdesc:ga7223404529a44de2fc26778be8780264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga7223404529a44de2fc26778be8780264">More...</a><br /></td></tr>
<tr class="separator:ga7223404529a44de2fc26778be8780264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39fef0d44352e48acbc72179b45d2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae39fef0d44352e48acbc72179b45d2f3">regina::EulerSearcher::splitEdgeClasses</a> ()</td></tr>
<tr class="memdesc:gae39fef0d44352e48acbc72179b45d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#gae39fef0d44352e48acbc72179b45d2f3">More...</a><br /></td></tr>
<tr class="separator:gae39fef0d44352e48acbc72179b45d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7833302676fd4914f22f269e8d7e22fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7833302676fd4914f22f269e8d7e22fc">regina::EulerSearcher::vtxBdryJoin</a> (int vertexID, char end, int adjVertexID, char twist)</td></tr>
<tr class="memdesc:ga7833302676fd4914f22f269e8d7e22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent.  <a href="group__census.html#ga7833302676fd4914f22f269e8d7e22fc">More...</a><br /></td></tr>
<tr class="separator:ga7833302676fd4914f22f269e8d7e22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ace8a1a30044922e99b26d05322d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga28ace8a1a30044922e99b26d05322d2e">regina::EulerSearcher::vtxBdryFixAdj</a> (int vertexID)</td></tr>
<tr class="memdesc:ga28ace8a1a30044922e99b26d05322d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex.  <a href="group__census.html#ga28ace8a1a30044922e99b26d05322d2e">More...</a><br /></td></tr>
<tr class="separator:ga28ace8a1a30044922e99b26d05322d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c700666b468422a630e235970b0adb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6c700666b468422a630e235970b0adb3">regina::EulerSearcher::vtxBdryBackup</a> (int vertexID)</td></tr>
<tr class="memdesc:ga6c700666b468422a630e235970b0adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#ga6c700666b468422a630e235970b0adb3">More...</a><br /></td></tr>
<tr class="separator:ga6c700666b468422a630e235970b0adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77be74512daf7efdc118ab29dafb690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae77be74512daf7efdc118ab29dafb690">regina::EulerSearcher::vtxBdryRestore</a> (int vertexID)</td></tr>
<tr class="memdesc:gae77be74512daf7efdc118ab29dafb690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#gae77be74512daf7efdc118ab29dafb690">More...</a><br /></td></tr>
<tr class="separator:gae77be74512daf7efdc118ab29dafb690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b6068d0c65bc433bebb9b04fa21093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab0b6068d0c65bc433bebb9b04fa21093">regina::EulerSearcher::vtxBdryNext</a> (int vertexID, int tet, int vertex, int bdryFace, int next[2], char twist[2])</td></tr>
<tr class="memdesc:gab0b6068d0c65bc433bebb9b04fa21093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction.  <a href="group__census.html#gab0b6068d0c65bc433bebb9b04fa21093">More...</a><br /></td></tr>
<tr class="separator:gab0b6068d0c65bc433bebb9b04fa21093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db63d8c457efcd61a1482c9e3e5adfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4db63d8c457efcd61a1482c9e3e5adfb">regina::EulerSearcher::vtxBdryLength1</a> (int vertexID)</td></tr>
<tr class="memdesc:ga4db63d8c457efcd61a1482c9e3e5adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link.  <a href="group__census.html#ga4db63d8c457efcd61a1482c9e3e5adfb">More...</a><br /></td></tr>
<tr class="separator:ga4db63d8c457efcd61a1482c9e3e5adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdf8a49a3781f74df7c170b2f215d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7bdf8a49a3781f74df7c170b2f215d57">regina::EulerSearcher::vtxBdryLength2</a> (int vertexID1, int vertexID2)</td></tr>
<tr class="memdesc:ga7bdf8a49a3781f74df7c170b2f215d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle.  <a href="group__census.html#ga7bdf8a49a3781f74df7c170b2f215d57">More...</a><br /></td></tr>
<tr class="separator:ga7bdf8a49a3781f74df7c170b2f215d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c895ecdbfb0ac85b999c8fda4d0618e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5c895ecdbfb0ac85b999c8fda4d0618e">regina::EulerSearcher::vtxBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:ga5c895ecdbfb0ac85b999c8fda4d0618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class.  <a href="group__census.html#ga5c895ecdbfb0ac85b999c8fda4d0618e">More...</a><br /></td></tr>
<tr class="separator:ga5c895ecdbfb0ac85b999c8fda4d0618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ff088f3e12d5e1a0875a33ee7afa1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga63ff088f3e12d5e1a0875a33ee7afa1e">regina::EulerSearcher::vtxBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga63ff088f3e12d5e1a0875a33ee7afa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream.  <a href="group__census.html#ga63ff088f3e12d5e1a0875a33ee7afa1e">More...</a><br /></td></tr>
<tr class="separator:ga63ff088f3e12d5e1a0875a33ee7afa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc84bc55b52b4416f94b2cdc1852be8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6cc84bc55b52b4416f94b2cdc1852be8">regina::CompactSearcher::TetVertexState::TetVertexState</a> ()</td></tr>
<tr class="memdesc:ga6cc84bc55b52b4416f94b2cdc1852be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone tetrahedron vertex in an equivalence class all of its own.  <a href="group__census.html#ga6cc84bc55b52b4416f94b2cdc1852be8">More...</a><br /></td></tr>
<tr class="separator:ga6cc84bc55b52b4416f94b2cdc1852be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c1732c349de12058f800544081788b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac4c1732c349de12058f800544081788b">regina::CompactSearcher::TetVertexState::dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gac4c1732c349de12058f800544081788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#gac4c1732c349de12058f800544081788b">More...</a><br /></td></tr>
<tr class="separator:gac4c1732c349de12058f800544081788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0054acee7c5eb6435363bd1c57054886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0054acee7c5eb6435363bd1c57054886">regina::CompactSearcher::TetVertexState::readData</a> (std::istream &amp;in, unsigned long nStates)</td></tr>
<tr class="memdesc:ga0054acee7c5eb6435363bd1c57054886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#ga0054acee7c5eb6435363bd1c57054886">More...</a><br /></td></tr>
<tr class="separator:ga0054acee7c5eb6435363bd1c57054886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1cf27eb8c4598c1fbfcf6e1cb93382d"><td class="memItemLeft" align="right" valign="top"><a id="gab1cf27eb8c4598c1fbfcf6e1cb93382d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CompactSearcher::TetVertexState::TetVertexState</b> (const <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:gab1cf27eb8c4598c1fbfcf6e1cb93382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77c2ea27f9bac849f6cfc3acda6b8b1"><td class="memItemLeft" align="right" valign="top"><a id="gae77c2ea27f9bac849f6cfc3acda6b8b1"></a>
<a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CompactSearcher::TetVertexState::operator=</b> (const <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a> &amp;)=delete</td></tr>
<tr class="separator:gae77c2ea27f9bac849f6cfc3acda6b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a810e260ed6e2a8f7b042ddb580b7fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3a810e260ed6e2a8f7b042ddb580b7fa">regina::CompactSearcher::TetEdgeState::TetEdgeState</a> ()</td></tr>
<tr class="memdesc:ga3a810e260ed6e2a8f7b042ddb580b7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone tetrahedron edge in an equivalence class all of its own.  <a href="group__census.html#ga3a810e260ed6e2a8f7b042ddb580b7fa">More...</a><br /></td></tr>
<tr class="separator:ga3a810e260ed6e2a8f7b042ddb580b7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5209d223e247417f8947d1ad64f4dbaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5209d223e247417f8947d1ad64f4dbaf">regina::CompactSearcher::TetEdgeState::dumpData</a> (std::ostream &amp;out, unsigned nTets) const</td></tr>
<tr class="memdesc:ga5209d223e247417f8947d1ad64f4dbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga5209d223e247417f8947d1ad64f4dbaf">More...</a><br /></td></tr>
<tr class="separator:ga5209d223e247417f8947d1ad64f4dbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3d531a632b43dbb23f8c4681db7413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d3d531a632b43dbb23f8c4681db7413">regina::CompactSearcher::TetEdgeState::readData</a> (std::istream &amp;in, unsigned nTets)</td></tr>
<tr class="memdesc:ga0d3d531a632b43dbb23f8c4681db7413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#ga0d3d531a632b43dbb23f8c4681db7413">More...</a><br /></td></tr>
<tr class="separator:ga0d3d531a632b43dbb23f8c4681db7413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab927e94cc4badc7921e3aa827878e580"><td class="memItemLeft" align="right" valign="top"><a id="gab927e94cc4badc7921e3aa827878e580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CompactSearcher::TetEdgeState::TetEdgeState</b> (const <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;)=delete</td></tr>
<tr class="separator:gab927e94cc4badc7921e3aa827878e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3d27cf6fdebaad59f7ed9fa8f4d3b7"><td class="memItemLeft" align="right" valign="top"><a id="gaef3d27cf6fdebaad59f7ed9fa8f4d3b7"></a>
<a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CompactSearcher::TetEdgeState::operator=</b> (const <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> &amp;)=delete</td></tr>
<tr class="separator:gaef3d27cf6fdebaad59f7ed9fa8f4d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9c9b0e336f9e35995a83d38fecc93bb2">regina::CompactSearcher::CompactSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager for use when only compact 3-manifold triangulations are required.  <a href="group__census.html#ga9c9b0e336f9e35995a83d38fecc93bb2">More...</a><br /></td></tr>
<tr class="separator:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa168e472dd2efdad10fbbadff7cf64a1">regina::CompactSearcher::CompactSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#gaa168e472dd2efdad10fbbadff7cf64a1">More...</a><br /></td></tr>
<tr class="separator:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17d63870ed80ed980f5f5733881b641"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa17d63870ed80ed980f5f5733881b641">regina::CompactSearcher::~CompactSearcher</a> ()</td></tr>
<tr class="memdesc:gaa17d63870ed80ed980f5f5733881b641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#gaa17d63870ed80ed980f5f5733881b641">More...</a><br /></td></tr>
<tr class="separator:gaa17d63870ed80ed980f5f5733881b641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">regina::CompactSearcher::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">More...</a><br /></td></tr>
<tr class="separator:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">regina::CompactSearcher::runSearch</a> (long maxDepth=-1) override</td></tr>
<tr class="memdesc:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">More...</a><br /></td></tr>
<tr class="separator:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">regina::CompactSearcher::dataTag</a> () const override</td></tr>
<tr class="memdesc:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">More...</a><br /></td></tr>
<tr class="separator:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68af81af372f748e01f1cea1fe262d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga68af81af372f748e01f1cea1fe262d55">regina::CompactSearcher::findEdgeClass</a> (int edgeID) const</td></tr>
<tr class="memdesc:ga68af81af372f748e01f1cea1fe262d55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga68af81af372f748e01f1cea1fe262d55">More...</a><br /></td></tr>
<tr class="separator:ga68af81af372f748e01f1cea1fe262d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d6b44b688c1947d87b6b11f6f34fa42">regina::CompactSearcher::findEdgeClass</a> (int edgeID, char &amp;twisted) const</td></tr>
<tr class="memdesc:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga0d6b44b688c1947d87b6b11f6f34fa42">More...</a><br /></td></tr>
<tr class="separator:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac275f880cb36e0c4b8c7e9222329960f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac275f880cb36e0c4b8c7e9222329960f">regina::CompactSearcher::mergeVertexClasses</a> ()</td></tr>
<tr class="memdesc:gac275f880cb36e0c4b8c7e9222329960f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#gac275f880cb36e0c4b8c7e9222329960f">More...</a><br /></td></tr>
<tr class="separator:gac275f880cb36e0c4b8c7e9222329960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga933487c0bfbb7553b1a29aa52d9eb498">regina::CompactSearcher::mergeEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga933487c0bfbb7553b1a29aa52d9eb498">More...</a><br /></td></tr>
<tr class="separator:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe76d64503d19198a82fab9fbba1285e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gafe76d64503d19198a82fab9fbba1285e">regina::CompactSearcher::splitVertexClasses</a> ()</td></tr>
<tr class="memdesc:gafe76d64503d19198a82fab9fbba1285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#gafe76d64503d19198a82fab9fbba1285e">More...</a><br /></td></tr>
<tr class="separator:gafe76d64503d19198a82fab9fbba1285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762df77fdee5bb5202e5dc2578a45139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga762df77fdee5bb5202e5dc2578a45139">regina::CompactSearcher::splitEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga762df77fdee5bb5202e5dc2578a45139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga762df77fdee5bb5202e5dc2578a45139">More...</a><br /></td></tr>
<tr class="separator:ga762df77fdee5bb5202e5dc2578a45139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d97b7e726fed0edfa487de17fe3895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad2d97b7e726fed0edfa487de17fe3895">regina::CompactSearcher::vtxBdryJoin</a> (int vertexID, char end, int adjVertexID, char twist)</td></tr>
<tr class="memdesc:gad2d97b7e726fed0edfa487de17fe3895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent.  <a href="group__census.html#gad2d97b7e726fed0edfa487de17fe3895">More...</a><br /></td></tr>
<tr class="separator:gad2d97b7e726fed0edfa487de17fe3895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31979e14cdda4468520bafc0b5aa3b04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga31979e14cdda4468520bafc0b5aa3b04">regina::CompactSearcher::vtxBdryFixAdj</a> (int vertexID)</td></tr>
<tr class="memdesc:ga31979e14cdda4468520bafc0b5aa3b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex.  <a href="group__census.html#ga31979e14cdda4468520bafc0b5aa3b04">More...</a><br /></td></tr>
<tr class="separator:ga31979e14cdda4468520bafc0b5aa3b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac088ddb578c020c3c9e806427de158aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac088ddb578c020c3c9e806427de158aa">regina::CompactSearcher::vtxBdryBackup</a> (int vertexID)</td></tr>
<tr class="memdesc:gac088ddb578c020c3c9e806427de158aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#gac088ddb578c020c3c9e806427de158aa">More...</a><br /></td></tr>
<tr class="separator:gac088ddb578c020c3c9e806427de158aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3ffbb57a869d61b80f4c75ea6e4776d5">regina::CompactSearcher::vtxBdryRestore</a> (int vertexID)</td></tr>
<tr class="memdesc:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#ga3ffbb57a869d61b80f4c75ea6e4776d5">More...</a><br /></td></tr>
<tr class="separator:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95813159f052c7d9651006074a518dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga95813159f052c7d9651006074a518dc4">regina::CompactSearcher::vtxBdryNext</a> (int vertexID, int tet, int vertex, int bdryFace, int next[2], char twist[2])</td></tr>
<tr class="memdesc:ga95813159f052c7d9651006074a518dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction.  <a href="group__census.html#ga95813159f052c7d9651006074a518dc4">More...</a><br /></td></tr>
<tr class="separator:ga95813159f052c7d9651006074a518dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab1e9cf39a6be337c436128f7a7ff6db7">regina::CompactSearcher::vtxBdryLength1</a> (int vertexID)</td></tr>
<tr class="memdesc:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link.  <a href="group__census.html#gab1e9cf39a6be337c436128f7a7ff6db7">More...</a><br /></td></tr>
<tr class="separator:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20ad95521261ade949844c625197ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac20ad95521261ade949844c625197ad3">regina::CompactSearcher::vtxBdryLength2</a> (int vertexID1, int vertexID2)</td></tr>
<tr class="memdesc:gac20ad95521261ade949844c625197ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle.  <a href="group__census.html#gac20ad95521261ade949844c625197ad3">More...</a><br /></td></tr>
<tr class="separator:gac20ad95521261ade949844c625197ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f48b181c140153c25b69014ec3c368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga47f48b181c140153c25b69014ec3c368">regina::CompactSearcher::vtxBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:ga47f48b181c140153c25b69014ec3c368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class.  <a href="group__census.html#ga47f48b181c140153c25b69014ec3c368">More...</a><br /></td></tr>
<tr class="separator:ga47f48b181c140153c25b69014ec3c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43099ebf5e634f11439eb12be6d9b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae43099ebf5e634f11439eb12be6d9b4b">regina::CompactSearcher::vtxBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:gae43099ebf5e634f11439eb12be6d9b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream.  <a href="group__census.html#gae43099ebf5e634f11439eb12be6d9b4b">More...</a><br /></td></tr>
<tr class="separator:gae43099ebf5e634f11439eb12be6d9b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45621ba980c3face197628084aa65ba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga45621ba980c3face197628084aa65ba3">regina::ClosedPrimeMinSearcher::ClosedPrimeMinSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga45621ba980c3face197628084aa65ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager for use when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three.  <a href="group__census.html#ga45621ba980c3face197628084aa65ba3">More...</a><br /></td></tr>
<tr class="separator:ga45621ba980c3face197628084aa65ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853dc8f70159d7e989ff64ee29b2a3d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga853dc8f70159d7e989ff64ee29b2a3d6">regina::ClosedPrimeMinSearcher::ClosedPrimeMinSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga853dc8f70159d7e989ff64ee29b2a3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#ga853dc8f70159d7e989ff64ee29b2a3d6">More...</a><br /></td></tr>
<tr class="separator:ga853dc8f70159d7e989ff64ee29b2a3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a3aa9f803b56aba6cd774f348355b9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae9a3aa9f803b56aba6cd774f348355b9">regina::ClosedPrimeMinSearcher::~ClosedPrimeMinSearcher</a> ()</td></tr>
<tr class="memdesc:gae9a3aa9f803b56aba6cd774f348355b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#gae9a3aa9f803b56aba6cd774f348355b9">More...</a><br /></td></tr>
<tr class="separator:gae9a3aa9f803b56aba6cd774f348355b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5797a69d3943aea7aad7e865c3130734"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5797a69d3943aea7aad7e865c3130734">regina::ClosedPrimeMinSearcher::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga5797a69d3943aea7aad7e865c3130734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga5797a69d3943aea7aad7e865c3130734">More...</a><br /></td></tr>
<tr class="separator:ga5797a69d3943aea7aad7e865c3130734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7863fd92f6f17c81a58fd605cdf465"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465">regina::ClosedPrimeMinSearcher::runSearch</a> (long maxDepth=-1) override</td></tr>
<tr class="memdesc:ga2c7863fd92f6f17c81a58fd605cdf465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465">More...</a><br /></td></tr>
<tr class="separator:ga2c7863fd92f6f17c81a58fd605cdf465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1472a77ba27e607b4a91e1faa253544a"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga1472a77ba27e607b4a91e1faa253544a">regina::ClosedPrimeMinSearcher::dataTag</a> () const override</td></tr>
<tr class="memdesc:ga1472a77ba27e607b4a91e1faa253544a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#ga1472a77ba27e607b4a91e1faa253544a">More...</a><br /></td></tr>
<tr class="separator:ga1472a77ba27e607b4a91e1faa253544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073ff937768dad9c298dc6ff51912ec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga073ff937768dad9c298dc6ff51912ec7">regina::HyperbolicMinSearcher::HyperbolicMinSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga073ff937768dad9c298dc6ff51912ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager for use when only minimal ideal triangulations of cusped finite-volume hyperbolic 3-manifolds are required.  <a href="group__census.html#ga073ff937768dad9c298dc6ff51912ec7">More...</a><br /></td></tr>
<tr class="separator:ga073ff937768dad9c298dc6ff51912ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23813bb5b76f52c38769b62fc2f1694"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac23813bb5b76f52c38769b62fc2f1694">regina::HyperbolicMinSearcher::HyperbolicMinSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gac23813bb5b76f52c38769b62fc2f1694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#gac23813bb5b76f52c38769b62fc2f1694">More...</a><br /></td></tr>
<tr class="separator:gac23813bb5b76f52c38769b62fc2f1694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c9636e863740f51a421e433b9bd8d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6">regina::HyperbolicMinSearcher::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga78c9636e863740f51a421e433b9bd8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6">More...</a><br /></td></tr>
<tr class="separator:ga78c9636e863740f51a421e433b9bd8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3895527d2752124702bea7f2982ea220"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220">regina::HyperbolicMinSearcher::runSearch</a> (long maxDepth=-1) override</td></tr>
<tr class="memdesc:ga3895527d2752124702bea7f2982ea220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga3895527d2752124702bea7f2982ea220">More...</a><br /></td></tr>
<tr class="separator:ga3895527d2752124702bea7f2982ea220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c52a8c26bf78b2d72e01dc023adf28"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga20c52a8c26bf78b2d72e01dc023adf28">regina::HyperbolicMinSearcher::dataTag</a> () const override</td></tr>
<tr class="memdesc:ga20c52a8c26bf78b2d72e01dc023adf28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#ga20c52a8c26bf78b2d72e01dc023adf28">More...</a><br /></td></tr>
<tr class="separator:ga20c52a8c26bf78b2d72e01dc023adf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08180f2fcd3c9382de65e8ba4d095da0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga08180f2fcd3c9382de65e8ba4d095da0">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::PentEdgeState</a> ()</td></tr>
<tr class="memdesc:ga08180f2fcd3c9382de65e8ba4d095da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone pentachoron edge in an equivalence class all of its own.  <a href="group__census.html#ga08180f2fcd3c9382de65e8ba4d095da0">More...</a><br /></td></tr>
<tr class="separator:ga08180f2fcd3c9382de65e8ba4d095da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d118922562342ba63f8cec4b9329109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4d118922562342ba63f8cec4b9329109">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga4d118922562342ba63f8cec4b9329109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga4d118922562342ba63f8cec4b9329109">More...</a><br /></td></tr>
<tr class="separator:ga4d118922562342ba63f8cec4b9329109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79bfc9bbf3ecfdac9eab9f1d162d6a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga79bfc9bbf3ecfdac9eab9f1d162d6a9e">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::readData</a> (std::istream &amp;in, unsigned long nStates)</td></tr>
<tr class="memdesc:ga79bfc9bbf3ecfdac9eab9f1d162d6a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#ga79bfc9bbf3ecfdac9eab9f1d162d6a9e">More...</a><br /></td></tr>
<tr class="separator:ga79bfc9bbf3ecfdac9eab9f1d162d6a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9a6d44bdb98f8bbed3bbe791e856dd"><td class="memItemLeft" align="right" valign="top"><a id="gade9a6d44bdb98f8bbed3bbe791e856dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::PentEdgeState</b> (const PentEdgeState &amp;)=delete</td></tr>
<tr class="separator:gade9a6d44bdb98f8bbed3bbe791e856dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5391846122464fa72eb1d2148fcc71"><td class="memItemLeft" align="right" valign="top"><a id="ga2b5391846122464fa72eb1d2148fcc71"></a>
<a class="el" href="group__census.html#ga08180f2fcd3c9382de65e8ba4d095da0">PentEdgeState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::operator=</b> (const <a class="el" href="group__census.html#ga08180f2fcd3c9382de65e8ba4d095da0">PentEdgeState</a> &amp;)=delete</td></tr>
<tr class="separator:ga2b5391846122464fa72eb1d2148fcc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e72823da2841bde9a9012cfe53dcd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga20e72823da2841bde9a9012cfe53dcd0">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::PentTriangleState</a> ()</td></tr>
<tr class="memdesc:ga20e72823da2841bde9a9012cfe53dcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a standalone pentachoron triangle in an equivalence class all of its own.  <a href="group__census.html#ga20e72823da2841bde9a9012cfe53dcd0">More...</a><br /></td></tr>
<tr class="separator:ga20e72823da2841bde9a9012cfe53dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6d72926b58e488bc1eed7642d2bfd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaab6d72926b58e488bc1eed7642d2bfd6">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::dumpData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaab6d72926b58e488bc1eed7642d2bfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#gaab6d72926b58e488bc1eed7642d2bfd6">More...</a><br /></td></tr>
<tr class="separator:gaab6d72926b58e488bc1eed7642d2bfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc5eef303e35fa3a841652b7684b0ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3cc5eef303e35fa3a841652b7684b0ed">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::readData</a> (std::istream &amp;in, unsigned long nStates)</td></tr>
<tr class="memdesc:ga3cc5eef303e35fa3a841652b7684b0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills this state with data read from the given input stream.  <a href="group__census.html#ga3cc5eef303e35fa3a841652b7684b0ed">More...</a><br /></td></tr>
<tr class="separator:ga3cc5eef303e35fa3a841652b7684b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6793b902ef4b933314bbd53a711e0dac"><td class="memItemLeft" align="right" valign="top"><a id="ga6793b902ef4b933314bbd53a711e0dac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::PentTriangleState</b> (const PentTriangleState &amp;)=delete</td></tr>
<tr class="separator:ga6793b902ef4b933314bbd53a711e0dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f08c1001c4a1910b9b30c5a089ee6dc"><td class="memItemLeft" align="right" valign="top"><a id="ga8f08c1001c4a1910b9b30c5a089ee6dc"></a>
<a class="el" href="group__census.html#ga20e72823da2841bde9a9012cfe53dcd0">PentTriangleState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::operator=</b> (const <a class="el" href="group__census.html#ga20e72823da2841bde9a9012cfe53dcd0">PentTriangleState</a> &amp;)=delete</td></tr>
<tr class="separator:ga8f08c1001c4a1910b9b30c5a089ee6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b07879c6ec19f7adc3690a05e671efc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0b07879c6ec19f7adc3690a05e671efc">regina::GluingPermSearcher&lt; 4 &gt;::GluingPermSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga0b07879c6ec19f7adc3690a05e671efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <a href="group__census.html#ga0b07879c6ec19f7adc3690a05e671efc">More...</a><br /></td></tr>
<tr class="separator:ga0b07879c6ec19f7adc3690a05e671efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da29d066d8b1947a9fbd51d0eed8b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga1da29d066d8b1947a9fbd51d0eed8b2e">regina::GluingPermSearcher&lt; 4 &gt;::GluingPermSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga1da29d066d8b1947a9fbd51d0eed8b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#ga1da29d066d8b1947a9fbd51d0eed8b2e">More...</a><br /></td></tr>
<tr class="separator:ga1da29d066d8b1947a9fbd51d0eed8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf772d7783f505c1a95668b4f39cce0b5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf772d7783f505c1a95668b4f39cce0b5">regina::GluingPermSearcher&lt; 4 &gt;::~GluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:gaf772d7783f505c1a95668b4f39cce0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#gaf772d7783f505c1a95668b4f39cce0b5">More...</a><br /></td></tr>
<tr class="separator:gaf772d7783f505c1a95668b4f39cce0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a33270bfb8b3c36aecaa3cc65422b37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37">regina::GluingPermSearcher&lt; 4 &gt;::runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:ga3a33270bfb8b3c36aecaa3cc65422b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37">More...</a><br /></td></tr>
<tr class="separator:ga3a33270bfb8b3c36aecaa3cc65422b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3f66fe5f81e571112cb4c3c70f1e10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8b3f66fe5f81e571112cb4c3c70f1e10">regina::GluingPermSearcher&lt; 4 &gt;::completePermSet</a> () const</td></tr>
<tr class="memdesc:ga8b3f66fe5f81e571112cb4c3c70f1e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="group__census.html#ga8b3f66fe5f81e571112cb4c3c70f1e10">More...</a><br /></td></tr>
<tr class="separator:ga8b3f66fe5f81e571112cb4c3c70f1e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560d63b0beaa7dd6e30e443308aac148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga560d63b0beaa7dd6e30e443308aac148">regina::GluingPermSearcher&lt; 4 &gt;::dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga560d63b0beaa7dd6e30e443308aac148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="group__census.html#ga560d63b0beaa7dd6e30e443308aac148">More...</a><br /></td></tr>
<tr class="separator:ga560d63b0beaa7dd6e30e443308aac148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7342cde30895f7eb18ab8cdb0342c44f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7342cde30895f7eb18ab8cdb0342c44f">regina::GluingPermSearcher&lt; 4 &gt;::dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga7342cde30895f7eb18ab8cdb0342c44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga7342cde30895f7eb18ab8cdb0342c44f">More...</a><br /></td></tr>
<tr class="separator:ga7342cde30895f7eb18ab8cdb0342c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8477b1c2800d8c766be3e19f03e54c15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15">regina::GluingPermSearcher&lt; 4 &gt;::findAllPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga8477b1c2800d8c766be3e19f03e54c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given pentachoron facet pairing.  <a href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15">More...</a><br /></td></tr>
<tr class="separator:ga8477b1c2800d8c766be3e19f03e54c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e70fb19950cdc7294e829dd51dce15"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga17e70fb19950cdc7294e829dd51dce15">regina::GluingPermSearcher&lt; 4 &gt;::bestSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga17e70fb19950cdc7294e829dd51dce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="group__census.html#ga17e70fb19950cdc7294e829dd51dce15">More...</a><br /></td></tr>
<tr class="separator:ga17e70fb19950cdc7294e829dd51dce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1324777ea05d924dad68cc7a66222f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf1324777ea05d924dad68cc7a66222f6">regina::GluingPermSearcher&lt; 4 &gt;::readTaggedData</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaf1324777ea05d924dad68cc7a66222f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="group__census.html#gaf1324777ea05d924dad68cc7a66222f6">More...</a><br /></td></tr>
<tr class="separator:gaf1324777ea05d924dad68cc7a66222f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac475f181129e951c06f80d73b679fc45"><td class="memItemLeft" align="right" valign="top"><a id="gac475f181129e951c06f80d73b679fc45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GluingPermSearcher&lt; 4 &gt;::GluingPermSearcher</b> (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> &amp;)=delete</td></tr>
<tr class="separator:gac475f181129e951c06f80d73b679fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad97703a5aefd359352f215bb958558d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad97703a5aefd359352f215bb958558d5">regina::GluingPermSearcher&lt; 4 &gt;::isCanonical</a> () const</td></tr>
<tr class="memdesc:gad97703a5aefd359352f215bb958558d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying facet pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="group__census.html#gad97703a5aefd359352f215bb958558d5">More...</a><br /></td></tr>
<tr class="separator:gad97703a5aefd359352f215bb958558d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502b8b26f14e65f2f22e524d92e6c3b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga502b8b26f14e65f2f22e524d92e6c3b3">regina::GluingPermSearcher&lt; 4 &gt;::badTriangleLink</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 4 &gt; &amp;facet) const</td></tr>
<tr class="memdesc:ga502b8b26f14e65f2f22e524d92e6c3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a 4-manifold triangulation with a (2-dimensional) triangle identified with itself using a non-trivial rotation or reflection.  <a href="group__census.html#ga502b8b26f14e65f2f22e524d92e6c3b3">More...</a><br /></td></tr>
<tr class="separator:ga502b8b26f14e65f2f22e524d92e6c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf04a2af0e70743a2eab4865df5e9768"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gadf04a2af0e70743a2eab4865df5e9768">regina::GluingPermSearcher&lt; 4 &gt;::dataTag</a> () const</td></tr>
<tr class="memdesc:gadf04a2af0e70743a2eab4865df5e9768"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#gadf04a2af0e70743a2eab4865df5e9768">More...</a><br /></td></tr>
<tr class="separator:gadf04a2af0e70743a2eab4865df5e9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ce5618587eb118ba65131c9652c669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga00ce5618587eb118ba65131c9652c669">regina::GluingPermSearcher&lt; 4 &gt;::findTriangleClass</a> (int triID) const</td></tr>
<tr class="memdesc:ga00ce5618587eb118ba65131c9652c669"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given pentachoron triangle.  <a href="group__census.html#ga00ce5618587eb118ba65131c9652c669">More...</a><br /></td></tr>
<tr class="separator:ga00ce5618587eb118ba65131c9652c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b3ae37270a2f7bd59e09c6053f95f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa3b3ae37270a2f7bd59e09c6053f95f6">regina::GluingPermSearcher&lt; 4 &gt;::findTriangleClass</a> (int triID, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 3 &gt; &amp;twist) const</td></tr>
<tr class="memdesc:gaa3b3ae37270a2f7bd59e09c6053f95f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given pentachoron triangle.  <a href="group__census.html#gaa3b3ae37270a2f7bd59e09c6053f95f6">More...</a><br /></td></tr>
<tr class="separator:gaa3b3ae37270a2f7bd59e09c6053f95f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820649b2f87818305105551471cdea27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga820649b2f87818305105551471cdea27">regina::GluingPermSearcher&lt; 4 &gt;::mergeEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga820649b2f87818305105551471cdea27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the classes of pentachoron edges as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga820649b2f87818305105551471cdea27">More...</a><br /></td></tr>
<tr class="separator:ga820649b2f87818305105551471cdea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c692ef09954a76d0e5ed0ba266d4df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga31c692ef09954a76d0e5ed0ba266d4df">regina::GluingPermSearcher&lt; 4 &gt;::mergeTriangleClasses</a> ()</td></tr>
<tr class="memdesc:ga31c692ef09954a76d0e5ed0ba266d4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the classes of pentachoron triangles as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga31c692ef09954a76d0e5ed0ba266d4df">More...</a><br /></td></tr>
<tr class="separator:ga31c692ef09954a76d0e5ed0ba266d4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1680291cd1579fab745a265c5f437e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabd1680291cd1579fab745a265c5f437e">regina::GluingPermSearcher&lt; 4 &gt;::splitEdgeClasses</a> ()</td></tr>
<tr class="memdesc:gabd1680291cd1579fab745a265c5f437e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the classes of pentachoron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#gabd1680291cd1579fab745a265c5f437e">More...</a><br /></td></tr>
<tr class="separator:gabd1680291cd1579fab745a265c5f437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648dbdce8bec58317705493e95ab0835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga648dbdce8bec58317705493e95ab0835">regina::GluingPermSearcher&lt; 4 &gt;::splitTriangleClasses</a> ()</td></tr>
<tr class="memdesc:ga648dbdce8bec58317705493e95ab0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the classes of pentachoron triangles to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga648dbdce8bec58317705493e95ab0835">More...</a><br /></td></tr>
<tr class="separator:ga648dbdce8bec58317705493e95ab0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee6c0ad8b1072fbf419b14879f6a17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9ee6c0ad8b1072fbf419b14879f6a17a">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryJoin</a> (int edgeID, char end, int adjEdgeID, char twist)</td></tr>
<tr class="memdesc:ga9ee6c0ad8b1072fbf419b14879f6a17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the linking triangles for the two given pentachoron edges should be marked as adjacent.  <a href="group__census.html#ga9ee6c0ad8b1072fbf419b14879f6a17a">More...</a><br /></td></tr>
<tr class="separator:ga9ee6c0ad8b1072fbf419b14879f6a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f50ff9ee783cb0da38953a641e89cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2f50ff9ee783cb0da38953a641e89cb1">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryFixAdj</a> (int edgeID)</td></tr>
<tr class="memdesc:ga2f50ff9ee783cb0da38953a641e89cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby pentachoron edges, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given pentachoron edge.  <a href="group__census.html#ga2f50ff9ee783cb0da38953a641e89cb1">More...</a><br /></td></tr>
<tr class="separator:ga2f50ff9ee783cb0da38953a641e89cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214b8600d6d6d2a802c74042c42e57fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga214b8600d6d6d2a802c74042c42e57fd">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryBackup</a> (int edgeID)</td></tr>
<tr class="memdesc:ga214b8600d6d6d2a802c74042c42e57fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given pentachoron edge.  <a href="group__census.html#ga214b8600d6d6d2a802c74042c42e57fd">More...</a><br /></td></tr>
<tr class="separator:ga214b8600d6d6d2a802c74042c42e57fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82bb66171e44a26d63448af638bd6197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga82bb66171e44a26d63448af638bd6197">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryRestore</a> (int edgeID)</td></tr>
<tr class="memdesc:ga82bb66171e44a26d63448af638bd6197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given pentachoron edge.  <a href="group__census.html#ga82bb66171e44a26d63448af638bd6197">More...</a><br /></td></tr>
<tr class="separator:ga82bb66171e44a26d63448af638bd6197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9efd8dcde17d3d783165e205cb8b05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6d9efd8dcde17d3d783165e205cb8b05">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryNext</a> (int edgeID, int pent, int edge, int bdryFacet, int next[2], char twist[2])</td></tr>
<tr class="memdesc:ga6d9efd8dcde17d3d783165e205cb8b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the linking triangle for the given pentachoron edge lies on the boundary of the link, this routine identifies the adjacent boundary edges of the link in each direction.  <a href="group__census.html#ga6d9efd8dcde17d3d783165e205cb8b05">More...</a><br /></td></tr>
<tr class="separator:ga6d9efd8dcde17d3d783165e205cb8b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289322ad48ef96c0c788361cfd0cb349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga289322ad48ef96c0c788361cfd0cb349">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryLength1</a> (int edgeID)</td></tr>
<tr class="memdesc:ga289322ad48ef96c0c788361cfd0cb349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the linking triangle for the given pentachoron edge in fact forms an entire one-edge boundary component of the overall 4-manifold edge link.  <a href="group__census.html#ga289322ad48ef96c0c788361cfd0cb349">More...</a><br /></td></tr>
<tr class="separator:ga289322ad48ef96c0c788361cfd0cb349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8e96adca4df50548b41e7af9bc43f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4e8e96adca4df50548b41e7af9bc43f6">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryLength2</a> (int edgeID1, int edgeID2)</td></tr>
<tr class="memdesc:ga4e8e96adca4df50548b41e7af9bc43f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the linking triangles for each of the given pentachoron edges combine to form an entire two-edge boundary component of the overall 4-manifold edge link, with one edge from each triangle.  <a href="group__census.html#ga4e8e96adca4df50548b41e7af9bc43f6">More...</a><br /></td></tr>
<tr class="separator:ga4e8e96adca4df50548b41e7af9bc43f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f190245e1642c2e19cc2af12d170933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9f190245e1642c2e19cc2af12d170933">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:ga9f190245e1642c2e19cc2af12d170933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all pentachoron edges to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class.  <a href="group__census.html#ga9f190245e1642c2e19cc2af12d170933">More...</a><br /></td></tr>
<tr class="separator:ga9f190245e1642c2e19cc2af12d170933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398d66c70a8b0a45893e8ccb49f5b816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga398d66c70a8b0a45893e8ccb49f5b816">regina::GluingPermSearcher&lt; 4 &gt;::edgeBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga398d66c70a8b0a45893e8ccb49f5b816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every edge of every pentachoron to the given output stream.  <a href="group__census.html#ga398d66c70a8b0a45893e8ccb49f5b816">More...</a><br /></td></tr>
<tr class="separator:ga398d66c70a8b0a45893e8ccb49f5b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad9fb5bb6ec20f8822927d49c100738e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad9fb5bb6ec20f8822927d49c100738e5">regina::GluingPerms&lt; dim &gt;::pairing_</a></td></tr>
<tr class="memdesc:gad9fb5bb6ec20f8822927d49c100738e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="group__census.html#gad9fb5bb6ec20f8822927d49c100738e5">More...</a><br /></td></tr>
<tr class="separator:gad9fb5bb6ec20f8822927d49c100738e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae038d32acaf9c1fc1f086dc8a344417"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaae038d32acaf9c1fc1f086dc8a344417">regina::GluingPerms&lt; dim &gt;::permIndices_</a></td></tr>
<tr class="memdesc:gaae038d32acaf9c1fc1f086dc8a344417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="group__census.html#gaae038d32acaf9c1fc1f086dc8a344417">More...</a><br /></td></tr>
<tr class="separator:gaae038d32acaf9c1fc1f086dc8a344417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4df91f50200ff5d6e76ede8c123e8ce6">regina::GluingPerms&lt; dim &gt;::inputError_</a></td></tr>
<tr class="memdesc:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="group__census.html#ga4df91f50200ff5d6e76ede8c123e8ce6">More...</a><br /></td></tr>
<tr class="separator:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fa11fd71fce2ac44c97eeb79a723e6"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga60fa11fd71fce2ac44c97eeb79a723e6">regina::GluingPermSearcher&lt; 2 &gt;::dataTag_</a></td></tr>
<tr class="memdesc:ga60fa11fd71fce2ac44c97eeb79a723e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga60fa11fd71fce2ac44c97eeb79a723e6">More...</a><br /></td></tr>
<tr class="separator:ga60fa11fd71fce2ac44c97eeb79a723e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212ff03da851218638fb2a958aa2a13b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga212ff03da851218638fb2a958aa2a13b">regina::GluingPermSearcher&lt; 2 &gt;::autos_</a></td></tr>
<tr class="memdesc:ga212ff03da851218638fb2a958aa2a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="group__census.html#ga212ff03da851218638fb2a958aa2a13b">More...</a><br /></td></tr>
<tr class="separator:ga212ff03da851218638fb2a958aa2a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739f16439d7567092d2929bc8f3fe65d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga739f16439d7567092d2929bc8f3fe65d">regina::GluingPermSearcher&lt; 2 &gt;::autosNew</a></td></tr>
<tr class="memdesc:ga739f16439d7567092d2929bc8f3fe65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="group__census.html#ga739f16439d7567092d2929bc8f3fe65d">More...</a><br /></td></tr>
<tr class="separator:ga739f16439d7567092d2929bc8f3fe65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60ee67149b8f7e69ad70e073e5ab977"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae60ee67149b8f7e69ad70e073e5ab977">regina::GluingPermSearcher&lt; 2 &gt;::orientableOnly_</a></td></tr>
<tr class="memdesc:gae60ee67149b8f7e69ad70e073e5ab977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="group__census.html#gae60ee67149b8f7e69ad70e073e5ab977">More...</a><br /></td></tr>
<tr class="separator:gae60ee67149b8f7e69ad70e073e5ab977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4c3890c45451a0fd3872a2dd09bc0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3d4c3890c45451a0fd3872a2dd09bc0b">regina::GluingPermSearcher&lt; 2 &gt;::use_</a></td></tr>
<tr class="memdesc:ga3d4c3890c45451a0fd3872a2dd09bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="group__census.html#ga3d4c3890c45451a0fd3872a2dd09bc0b">More...</a><br /></td></tr>
<tr class="separator:ga3d4c3890c45451a0fd3872a2dd09bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326ae3e5b54a478e682ec4d3a1116f61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga326ae3e5b54a478e682ec4d3a1116f61">regina::GluingPermSearcher&lt; 2 &gt;::useArgs_</a></td></tr>
<tr class="memdesc:ga326ae3e5b54a478e682ec4d3a1116f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="group__census.html#ga326ae3e5b54a478e682ec4d3a1116f61">More...</a><br /></td></tr>
<tr class="separator:ga326ae3e5b54a478e682ec4d3a1116f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845dee0fb289ae31732acdbbebe4396c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga845dee0fb289ae31732acdbbebe4396c">regina::GluingPermSearcher&lt; 2 &gt;::started</a></td></tr>
<tr class="memdesc:ga845dee0fb289ae31732acdbbebe4396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="group__census.html#ga845dee0fb289ae31732acdbbebe4396c">More...</a><br /></td></tr>
<tr class="separator:ga845dee0fb289ae31732acdbbebe4396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1466828ee218e55095bf0e476d625a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaaf1466828ee218e55095bf0e476d625a">regina::GluingPermSearcher&lt; 2 &gt;::orientation</a></td></tr>
<tr class="memdesc:gaaf1466828ee218e55095bf0e476d625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each triangle in the underlying triangulation.  <a href="group__census.html#gaaf1466828ee218e55095bf0e476d625a">More...</a><br /></td></tr>
<tr class="separator:gaaf1466828ee218e55095bf0e476d625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ead7f5285666965fbc9d28826d82677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9ead7f5285666965fbc9d28826d82677">regina::GluingPermSearcher&lt; 2 &gt;::order</a></td></tr>
<tr class="memdesc:ga9ead7f5285666965fbc9d28826d82677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to edges.  <a href="group__census.html#ga9ead7f5285666965fbc9d28826d82677">More...</a><br /></td></tr>
<tr class="separator:ga9ead7f5285666965fbc9d28826d82677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ebe801472975c7fce7b7c0557ee2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga24ebe801472975c7fce7b7c0557ee2ff">regina::GluingPermSearcher&lt; 2 &gt;::orderSize</a></td></tr>
<tr class="memdesc:ga24ebe801472975c7fce7b7c0557ee2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the edge pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="group__census.html#ga24ebe801472975c7fce7b7c0557ee2ff">More...</a><br /></td></tr>
<tr class="separator:ga24ebe801472975c7fce7b7c0557ee2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabccdb731602614ebfb5435d539f13dad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabccdb731602614ebfb5435d539f13dad">regina::GluingPermSearcher&lt; 2 &gt;::orderElt</a></td></tr>
<tr class="memdesc:gabccdb731602614ebfb5435d539f13dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="group__census.html#gabccdb731602614ebfb5435d539f13dad">More...</a><br /></td></tr>
<tr class="separator:gabccdb731602614ebfb5435d539f13dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41684f2905a97147c96196a484cda0bd"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga41684f2905a97147c96196a484cda0bd">regina::GluingPermSearcher&lt; 3 &gt;::dataTag_</a></td></tr>
<tr class="memdesc:ga41684f2905a97147c96196a484cda0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga41684f2905a97147c96196a484cda0bd">More...</a><br /></td></tr>
<tr class="separator:ga41684f2905a97147c96196a484cda0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99ec414c677a67e55ed8588316fcf88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad99ec414c677a67e55ed8588316fcf88">regina::GluingPermSearcher&lt; 3 &gt;::autos_</a></td></tr>
<tr class="memdesc:gad99ec414c677a67e55ed8588316fcf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="group__census.html#gad99ec414c677a67e55ed8588316fcf88">More...</a><br /></td></tr>
<tr class="separator:gad99ec414c677a67e55ed8588316fcf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924106126b7edca7b1b337d52abad3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga924106126b7edca7b1b337d52abad3c2">regina::GluingPermSearcher&lt; 3 &gt;::autosNew</a></td></tr>
<tr class="memdesc:ga924106126b7edca7b1b337d52abad3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="group__census.html#ga924106126b7edca7b1b337d52abad3c2">More...</a><br /></td></tr>
<tr class="separator:ga924106126b7edca7b1b337d52abad3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7086cef35b30a1e10385ec3f12bce31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae7086cef35b30a1e10385ec3f12bce31">regina::GluingPermSearcher&lt; 3 &gt;::orientableOnly_</a></td></tr>
<tr class="memdesc:gae7086cef35b30a1e10385ec3f12bce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="group__census.html#gae7086cef35b30a1e10385ec3f12bce31">More...</a><br /></td></tr>
<tr class="separator:gae7086cef35b30a1e10385ec3f12bce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107d4ea96e2006fce01b49508221e604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga107d4ea96e2006fce01b49508221e604">regina::GluingPermSearcher&lt; 3 &gt;::finiteOnly_</a></td></tr>
<tr class="memdesc:ga107d4ea96e2006fce01b49508221e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <a href="group__census.html#ga107d4ea96e2006fce01b49508221e604">More...</a><br /></td></tr>
<tr class="separator:ga107d4ea96e2006fce01b49508221e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59856e878dab0a1eedd13521a436f7e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga59856e878dab0a1eedd13521a436f7e1">regina::GluingPermSearcher&lt; 3 &gt;::whichPurge_</a></td></tr>
<tr class="memdesc:ga59856e878dab0a1eedd13521a436f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration.  <a href="group__census.html#ga59856e878dab0a1eedd13521a436f7e1">More...</a><br /></td></tr>
<tr class="separator:ga59856e878dab0a1eedd13521a436f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24e6601298a3b8e111eaebb30223a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac24e6601298a3b8e111eaebb30223a0e">regina::GluingPermSearcher&lt; 3 &gt;::use_</a></td></tr>
<tr class="memdesc:gac24e6601298a3b8e111eaebb30223a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="group__census.html#gac24e6601298a3b8e111eaebb30223a0e">More...</a><br /></td></tr>
<tr class="separator:gac24e6601298a3b8e111eaebb30223a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf5f9d4ba646538829c4c1fafe4bd1ccb">regina::GluingPermSearcher&lt; 3 &gt;::useArgs_</a></td></tr>
<tr class="memdesc:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="group__census.html#gaf5f9d4ba646538829c4c1fafe4bd1ccb">More...</a><br /></td></tr>
<tr class="separator:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ef778b520739058cf77d70963d7ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga46ef778b520739058cf77d70963d7ab6">regina::GluingPermSearcher&lt; 3 &gt;::started</a></td></tr>
<tr class="memdesc:ga46ef778b520739058cf77d70963d7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="group__census.html#ga46ef778b520739058cf77d70963d7ab6">More...</a><br /></td></tr>
<tr class="separator:ga46ef778b520739058cf77d70963d7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07986d0a577e24601d762c07c43226eb"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga07986d0a577e24601d762c07c43226eb">regina::GluingPermSearcher&lt; 3 &gt;::orientation</a></td></tr>
<tr class="memdesc:ga07986d0a577e24601d762c07c43226eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <a href="group__census.html#ga07986d0a577e24601d762c07c43226eb">More...</a><br /></td></tr>
<tr class="separator:ga07986d0a577e24601d762c07c43226eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738eee160530cfdcf10a05f626212da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8738eee160530cfdcf10a05f626212da">regina::GluingPermSearcher&lt; 3 &gt;::order</a></td></tr>
<tr class="memdesc:ga8738eee160530cfdcf10a05f626212da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <a href="group__census.html#ga8738eee160530cfdcf10a05f626212da">More...</a><br /></td></tr>
<tr class="separator:ga8738eee160530cfdcf10a05f626212da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2208e4c544e9b5fd2e2d9ff317b94575">regina::GluingPermSearcher&lt; 3 &gt;::orderSize</a></td></tr>
<tr class="memdesc:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="group__census.html#ga2208e4c544e9b5fd2e2d9ff317b94575">More...</a><br /></td></tr>
<tr class="separator:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9db9ca62cfe5caf9ca9e357121912cb5">regina::GluingPermSearcher&lt; 3 &gt;::orderElt</a></td></tr>
<tr class="memdesc:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="group__census.html#ga9db9ca62cfe5caf9ca9e357121912cb5">More...</a><br /></td></tr>
<tr class="separator:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8612a6072262a299ecbea89a7ad646ee"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8612a6072262a299ecbea89a7ad646ee">regina::EulerSearcher::VLINK_CLOSED</a></td></tr>
<tr class="memdesc:ga8612a6072262a299ecbea89a7ad646ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges).  <a href="group__census.html#ga8612a6072262a299ecbea89a7ad646ee">More...</a><br /></td></tr>
<tr class="separator:ga8612a6072262a299ecbea89a7ad646ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8281e7335fe3c3c4946187dccb06490b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8281e7335fe3c3c4946187dccb06490b">regina::EulerSearcher::VLINK_BAD_EULER</a></td></tr>
<tr class="memdesc:ga8281e7335fe3c3c4946187dccb06490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has either (i) accumulated too high a genus (so when its punctures are filled the Euler characteristic will be too low), or has (ii) been closed off with too low a genus (so its final Euler characteristic is too high).  <a href="group__census.html#ga8281e7335fe3c3c4946187dccb06490b">More...</a><br /></td></tr>
<tr class="separator:ga8281e7335fe3c3c4946187dccb06490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53dc83da54a0646f841ea40bb0c40ab7"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga53dc83da54a0646f841ea40bb0c40ab7">regina::EulerSearcher::vertexLinkNextFace</a> [4][4]</td></tr>
<tr class="memdesc:ga53dc83da54a0646f841ea40bb0c40ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron.  <a href="group__census.html#ga53dc83da54a0646f841ea40bb0c40ab7">More...</a><br /></td></tr>
<tr class="separator:ga53dc83da54a0646f841ea40bb0c40ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4609aecf1e7fae96f3ccfa6b56fc66d5">regina::EulerSearcher::vertexLinkPrevFace</a> [4][4]</td></tr>
<tr class="memdesc:ga4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>.  <a href="group__census.html#ga4609aecf1e7fae96f3ccfa6b56fc66d5">More...</a><br /></td></tr>
<tr class="separator:ga4609aecf1e7fae96f3ccfa6b56fc66d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480a383055477920691941e909a894d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga480a383055477920691941e909a894d1">regina::EulerSearcher::TetVertexState::parent</a></td></tr>
<tr class="memdesc:ga480a383055477920691941e909a894d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#ga480a383055477920691941e909a894d1">More...</a><br /></td></tr>
<tr class="separator:ga480a383055477920691941e909a894d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345c6c08ca4695e77e395087f0dd7259"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga345c6c08ca4695e77e395087f0dd7259">regina::EulerSearcher::TetVertexState::rank</a></td></tr>
<tr class="memdesc:ga345c6c08ca4695e77e395087f0dd7259"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#ga345c6c08ca4695e77e395087f0dd7259">More...</a><br /></td></tr>
<tr class="separator:ga345c6c08ca4695e77e395087f0dd7259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c89ae1f07dd479076a05a57bdd6caa4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3c89ae1f07dd479076a05a57bdd6caa4">regina::EulerSearcher::TetVertexState::bdry</a></td></tr>
<tr class="memdesc:ga3c89ae1f07dd479076a05a57bdd6caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary edges in the vertex link for this equivalence class of vertices.  <a href="group__census.html#ga3c89ae1f07dd479076a05a57bdd6caa4">More...</a><br /></td></tr>
<tr class="separator:ga3c89ae1f07dd479076a05a57bdd6caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4115df4efb2da5dbc1fd3e31df210f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gadf4115df4efb2da5dbc1fd3e31df210f">regina::EulerSearcher::TetVertexState::euler</a></td></tr>
<tr class="memdesc:gadf4115df4efb2da5dbc1fd3e31df210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic that the vertex link would have if its punctures were all filled.  <a href="group__census.html#gadf4115df4efb2da5dbc1fd3e31df210f">More...</a><br /></td></tr>
<tr class="separator:gadf4115df4efb2da5dbc1fd3e31df210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b374687123ab8241e1cf84aff30a73"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga18b374687123ab8241e1cf84aff30a73">regina::EulerSearcher::TetVertexState::twistUp</a></td></tr>
<tr class="memdesc:ga18b374687123ab8241e1cf84aff30a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link.  <a href="group__census.html#ga18b374687123ab8241e1cf84aff30a73">More...</a><br /></td></tr>
<tr class="separator:ga18b374687123ab8241e1cf84aff30a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e9f6f128b8fb6a5c6f92d66e37422c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga61e9f6f128b8fb6a5c6f92d66e37422c">regina::EulerSearcher::TetVertexState::hadEqualRank</a></td></tr>
<tr class="memdesc:ga61e9f6f128b8fb6a5c6f92d66e37422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#ga61e9f6f128b8fb6a5c6f92d66e37422c">More...</a><br /></td></tr>
<tr class="separator:ga61e9f6f128b8fb6a5c6f92d66e37422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b8bbdc0dea2409700b8746ebe1119e"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf5b8bbdc0dea2409700b8746ebe1119e">regina::EulerSearcher::TetVertexState::bdryEdges</a></td></tr>
<tr class="memdesc:gaf5b8bbdc0dea2409700b8746ebe1119e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link.  <a href="group__census.html#gaf5b8bbdc0dea2409700b8746ebe1119e">More...</a><br /></td></tr>
<tr class="separator:gaf5b8bbdc0dea2409700b8746ebe1119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8773dd8d46d9178907432360c2ae182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf8773dd8d46d9178907432360c2ae182">regina::EulerSearcher::TetVertexState::bdryNext</a> [2]</td></tr>
<tr class="memdesc:gaf8773dd8d46d9178907432360c2ae182"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment.  <a href="group__census.html#gaf8773dd8d46d9178907432360c2ae182">More...</a><br /></td></tr>
<tr class="separator:gaf8773dd8d46d9178907432360c2ae182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf573efd973f2236d51ba379187d05f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5cf573efd973f2236d51ba379187d05f">regina::EulerSearcher::TetVertexState::bdryTwist</a> [2]</td></tr>
<tr class="memdesc:ga5cf573efd973f2236d51ba379187d05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side.  <a href="group__census.html#ga5cf573efd973f2236d51ba379187d05f">More...</a><br /></td></tr>
<tr class="separator:ga5cf573efd973f2236d51ba379187d05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0655bd26c1bdf04a55eed120ccc05937"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0655bd26c1bdf04a55eed120ccc05937">regina::EulerSearcher::TetVertexState::bdryNextOld</a> [2]</td></tr>
<tr class="memdesc:ga0655bd26c1bdf04a55eed120ccc05937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#ga0655bd26c1bdf04a55eed120ccc05937">More...</a><br /></td></tr>
<tr class="separator:ga0655bd26c1bdf04a55eed120ccc05937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa654cd4ef912a6762cd4351254d32fc4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa654cd4ef912a6762cd4351254d32fc4">regina::EulerSearcher::TetVertexState::bdryTwistOld</a> [2]</td></tr>
<tr class="memdesc:gaa654cd4ef912a6762cd4351254d32fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#gaa654cd4ef912a6762cd4351254d32fc4">More...</a><br /></td></tr>
<tr class="separator:gaa654cd4ef912a6762cd4351254d32fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daff5cb5bf31ed1c6ed28533d1d62d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3daff5cb5bf31ed1c6ed28533d1d62d0">regina::EulerSearcher::TetEdgeState::parent</a></td></tr>
<tr class="memdesc:ga3daff5cb5bf31ed1c6ed28533d1d62d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#ga3daff5cb5bf31ed1c6ed28533d1d62d0">More...</a><br /></td></tr>
<tr class="separator:ga3daff5cb5bf31ed1c6ed28533d1d62d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d64f96beead08f2c85c4af2f3854919"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4d64f96beead08f2c85c4af2f3854919">regina::EulerSearcher::TetEdgeState::rank</a></td></tr>
<tr class="memdesc:ga4d64f96beead08f2c85c4af2f3854919"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#ga4d64f96beead08f2c85c4af2f3854919">More...</a><br /></td></tr>
<tr class="separator:ga4d64f96beead08f2c85c4af2f3854919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c8b0fdfa458c64e3202a27423cc148"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae6c8b0fdfa458c64e3202a27423cc148">regina::EulerSearcher::TetEdgeState::size</a></td></tr>
<tr class="memdesc:gae6c8b0fdfa458c64e3202a27423cc148"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of objects in the subtree descending from this object (where this object is counted also).  <a href="group__census.html#gae6c8b0fdfa458c64e3202a27423cc148">More...</a><br /></td></tr>
<tr class="separator:gae6c8b0fdfa458c64e3202a27423cc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973b59e72d2662b25c8981b9049451c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga973b59e72d2662b25c8981b9049451c4">regina::EulerSearcher::TetEdgeState::bounded</a></td></tr>
<tr class="memdesc:ga973b59e72d2662b25c8981b9049451c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this equivalence class of tetrahedron edges represent a boundary edge?  <a href="group__census.html#ga973b59e72d2662b25c8981b9049451c4">More...</a><br /></td></tr>
<tr class="separator:ga973b59e72d2662b25c8981b9049451c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a9099827e0480649c98b2c9404001f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga89a9099827e0480649c98b2c9404001f">regina::EulerSearcher::TetEdgeState::twistUp</a></td></tr>
<tr class="memdesc:ga89a9099827e0480649c98b2c9404001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each tetrahedron edge can be assigned an orientation pointing from the lower numbered tetrahedron vertex to the higher.  <a href="group__census.html#ga89a9099827e0480649c98b2c9404001f">More...</a><br /></td></tr>
<tr class="separator:ga89a9099827e0480649c98b2c9404001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5682aac7cc3b1aa3596562a4cc09fade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5682aac7cc3b1aa3596562a4cc09fade">regina::EulerSearcher::TetEdgeState::hadEqualRank</a></td></tr>
<tr class="memdesc:ga5682aac7cc3b1aa3596562a4cc09fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#ga5682aac7cc3b1aa3596562a4cc09fade">More...</a><br /></td></tr>
<tr class="separator:ga5682aac7cc3b1aa3596562a4cc09fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13d7ef363eb1b6029ce4d2547c6525e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae13d7ef363eb1b6029ce4d2547c6525e">regina::EulerSearcher::TetEdgeState::facesPos</a></td></tr>
<tr class="memdesc:gae13d7ef363eb1b6029ce4d2547c6525e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how many times this edge runs along the boundary of each tetrahedron face in the positive direction.  <a href="group__census.html#gae13d7ef363eb1b6029ce4d2547c6525e">More...</a><br /></td></tr>
<tr class="separator:gae13d7ef363eb1b6029ce4d2547c6525e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3331084de89494501ee6d6de3d5aa7a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3331084de89494501ee6d6de3d5aa7a4">regina::EulerSearcher::TetEdgeState::facesNeg</a></td></tr>
<tr class="memdesc:ga3331084de89494501ee6d6de3d5aa7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how many times this edge runs along the boundary of each tetrahedron face in the negative direction.  <a href="group__census.html#ga3331084de89494501ee6d6de3d5aa7a4">More...</a><br /></td></tr>
<tr class="separator:ga3331084de89494501ee6d6de3d5aa7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd83aa21dda12aa6454d82260003be4"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9cd83aa21dda12aa6454d82260003be4">regina::EulerSearcher::dataTag_</a></td></tr>
<tr class="memdesc:ga9cd83aa21dda12aa6454d82260003be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga9cd83aa21dda12aa6454d82260003be4">More...</a><br /></td></tr>
<tr class="separator:ga9cd83aa21dda12aa6454d82260003be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642c9886af812c5fb4b30273f60e89d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga642c9886af812c5fb4b30273f60e89d8">regina::EulerSearcher::euler_</a></td></tr>
<tr class="memdesc:ga642c9886af812c5fb4b30273f60e89d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic that vertex links must have.  <a href="group__census.html#ga642c9886af812c5fb4b30273f60e89d8">More...</a><br /></td></tr>
<tr class="separator:ga642c9886af812c5fb4b30273f60e89d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f25280e8073d6493a89151c39d28eb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga24f25280e8073d6493a89151c39d28eb">regina::EulerSearcher::nVertexClasses</a></td></tr>
<tr class="memdesc:ga24f25280e8073d6493a89151c39d28eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#ga24f25280e8073d6493a89151c39d28eb">More...</a><br /></td></tr>
<tr class="separator:ga24f25280e8073d6493a89151c39d28eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82d5ea45a6d1ca689bc81c55599970d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad82d5ea45a6d1ca689bc81c55599970d">regina::EulerSearcher::vertexState</a></td></tr>
<tr class="memdesc:gad82d5ea45a6d1ca689bc81c55599970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#gad82d5ea45a6d1ca689bc81c55599970d">More...</a><br /></td></tr>
<tr class="separator:gad82d5ea45a6d1ca689bc81c55599970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12324f590ed9369a2f10c46dde4d533"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf12324f590ed9369a2f10c46dde4d533">regina::EulerSearcher::vertexStateChanged</a></td></tr>
<tr class="memdesc:gaf12324f590ed9369a2f10c46dde4d533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the vertexState[] array has been updated over time.  <a href="group__census.html#gaf12324f590ed9369a2f10c46dde4d533">More...</a><br /></td></tr>
<tr class="separator:gaf12324f590ed9369a2f10c46dde4d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f929697e568e19efc2ab0a67c608dee"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6f929697e568e19efc2ab0a67c608dee">regina::EulerSearcher::nEdgeClasses</a></td></tr>
<tr class="memdesc:ga6f929697e568e19efc2ab0a67c608dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron edges.  <a href="group__census.html#ga6f929697e568e19efc2ab0a67c608dee">More...</a><br /></td></tr>
<tr class="separator:ga6f929697e568e19efc2ab0a67c608dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cae928a1464153e1e3a4d438cee59d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7cae928a1464153e1e3a4d438cee59d5">regina::EulerSearcher::edgeState</a></td></tr>
<tr class="memdesc:ga7cae928a1464153e1e3a4d438cee59d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron edges.  <a href="group__census.html#ga7cae928a1464153e1e3a4d438cee59d5">More...</a><br /></td></tr>
<tr class="separator:ga7cae928a1464153e1e3a4d438cee59d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabea0e3d13f406561cc97c078ba7a3553"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabea0e3d13f406561cc97c078ba7a3553">regina::EulerSearcher::edgeStateChanged</a></td></tr>
<tr class="memdesc:gabea0e3d13f406561cc97c078ba7a3553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState[] array has been updated over time.  <a href="group__census.html#gabea0e3d13f406561cc97c078ba7a3553">More...</a><br /></td></tr>
<tr class="separator:gabea0e3d13f406561cc97c078ba7a3553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac363812100d31dbed52621e0ac4d4d66"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac363812100d31dbed52621e0ac4d4d66">regina::CompactSearcher::VLINK_CLOSED</a></td></tr>
<tr class="memdesc:gac363812100d31dbed52621e0ac4d4d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges).  <a href="group__census.html#gac363812100d31dbed52621e0ac4d4d66">More...</a><br /></td></tr>
<tr class="separator:gac363812100d31dbed52621e0ac4d4d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d604d18112b6385930665f88e9b0e6b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d604d18112b6385930665f88e9b0e6b">regina::CompactSearcher::VLINK_NON_SPHERE</a></td></tr>
<tr class="memdesc:ga0d604d18112b6385930665f88e9b0e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been made into something other than a 2-sphere with zero or more punctures.  <a href="group__census.html#ga0d604d18112b6385930665f88e9b0e6b">More...</a><br /></td></tr>
<tr class="separator:ga0d604d18112b6385930665f88e9b0e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea2e93753783fd73caa1805e68062d9"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaaea2e93753783fd73caa1805e68062d9">regina::CompactSearcher::vertexLinkNextFace</a> [4][4]</td></tr>
<tr class="memdesc:gaaea2e93753783fd73caa1805e68062d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron.  <a href="group__census.html#gaaea2e93753783fd73caa1805e68062d9">More...</a><br /></td></tr>
<tr class="separator:gaaea2e93753783fd73caa1805e68062d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b498e1004898fe021328583c9a397ad"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2b498e1004898fe021328583c9a397ad">regina::CompactSearcher::vertexLinkPrevFace</a> [4][4]</td></tr>
<tr class="memdesc:ga2b498e1004898fe021328583c9a397ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>.  <a href="group__census.html#ga2b498e1004898fe021328583c9a397ad">More...</a><br /></td></tr>
<tr class="separator:ga2b498e1004898fe021328583c9a397ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e8d7c736c124e1af2d11125f698567"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad7e8d7c736c124e1af2d11125f698567">regina::CompactSearcher::TetVertexState::parent</a></td></tr>
<tr class="memdesc:gad7e8d7c736c124e1af2d11125f698567"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#gad7e8d7c736c124e1af2d11125f698567">More...</a><br /></td></tr>
<tr class="separator:gad7e8d7c736c124e1af2d11125f698567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6511721be72ae76f02c7915adc6c3a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabb6511721be72ae76f02c7915adc6c3a">regina::CompactSearcher::TetVertexState::rank</a></td></tr>
<tr class="memdesc:gabb6511721be72ae76f02c7915adc6c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#gabb6511721be72ae76f02c7915adc6c3a">More...</a><br /></td></tr>
<tr class="separator:gabb6511721be72ae76f02c7915adc6c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50987067c0feb4f14c1234e4d8582ab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac50987067c0feb4f14c1234e4d8582ab">regina::CompactSearcher::TetVertexState::bdry</a></td></tr>
<tr class="memdesc:gac50987067c0feb4f14c1234e4d8582ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary edges in the vertex link for this equivalence class of vertices.  <a href="group__census.html#gac50987067c0feb4f14c1234e4d8582ab">More...</a><br /></td></tr>
<tr class="separator:gac50987067c0feb4f14c1234e4d8582ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9751beca8aa1b550a589afd341b2403d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9751beca8aa1b550a589afd341b2403d">regina::CompactSearcher::TetVertexState::twistUp</a></td></tr>
<tr class="memdesc:ga9751beca8aa1b550a589afd341b2403d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link.  <a href="group__census.html#ga9751beca8aa1b550a589afd341b2403d">More...</a><br /></td></tr>
<tr class="separator:ga9751beca8aa1b550a589afd341b2403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146172be72c90743112ff91398534e04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga146172be72c90743112ff91398534e04">regina::CompactSearcher::TetVertexState::hadEqualRank</a></td></tr>
<tr class="memdesc:ga146172be72c90743112ff91398534e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#ga146172be72c90743112ff91398534e04">More...</a><br /></td></tr>
<tr class="separator:ga146172be72c90743112ff91398534e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ac67cd0685d17a27f433847b891f0a"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga42ac67cd0685d17a27f433847b891f0a">regina::CompactSearcher::TetVertexState::bdryEdges</a></td></tr>
<tr class="memdesc:ga42ac67cd0685d17a27f433847b891f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link.  <a href="group__census.html#ga42ac67cd0685d17a27f433847b891f0a">More...</a><br /></td></tr>
<tr class="separator:ga42ac67cd0685d17a27f433847b891f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32bf50adb9ea0bff43f45bf57df13c0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga32bf50adb9ea0bff43f45bf57df13c0e">regina::CompactSearcher::TetVertexState::bdryNext</a> [2]</td></tr>
<tr class="memdesc:ga32bf50adb9ea0bff43f45bf57df13c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment.  <a href="group__census.html#ga32bf50adb9ea0bff43f45bf57df13c0e">More...</a><br /></td></tr>
<tr class="separator:ga32bf50adb9ea0bff43f45bf57df13c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42aa231dab77d54d9c980ef802f6f822"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga42aa231dab77d54d9c980ef802f6f822">regina::CompactSearcher::TetVertexState::bdryTwist</a> [2]</td></tr>
<tr class="memdesc:ga42aa231dab77d54d9c980ef802f6f822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side.  <a href="group__census.html#ga42aa231dab77d54d9c980ef802f6f822">More...</a><br /></td></tr>
<tr class="separator:ga42aa231dab77d54d9c980ef802f6f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56615b1173cda5c323ad69a6c412a699"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga56615b1173cda5c323ad69a6c412a699">regina::CompactSearcher::TetVertexState::bdryNextOld</a> [2]</td></tr>
<tr class="memdesc:ga56615b1173cda5c323ad69a6c412a699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#ga56615b1173cda5c323ad69a6c412a699">More...</a><br /></td></tr>
<tr class="separator:ga56615b1173cda5c323ad69a6c412a699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1427d1cd33eb496fa2d36e04e1e71e4"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac1427d1cd33eb496fa2d36e04e1e71e4">regina::CompactSearcher::TetVertexState::bdryTwistOld</a> [2]</td></tr>
<tr class="memdesc:gac1427d1cd33eb496fa2d36e04e1e71e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#gac1427d1cd33eb496fa2d36e04e1e71e4">More...</a><br /></td></tr>
<tr class="separator:gac1427d1cd33eb496fa2d36e04e1e71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6597a1b0cb0c116d3b68c8fc2198c55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab6597a1b0cb0c116d3b68c8fc2198c55">regina::CompactSearcher::TetEdgeState::parent</a></td></tr>
<tr class="memdesc:gab6597a1b0cb0c116d3b68c8fc2198c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#gab6597a1b0cb0c116d3b68c8fc2198c55">More...</a><br /></td></tr>
<tr class="separator:gab6597a1b0cb0c116d3b68c8fc2198c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab1eb791e10fdb954edc1b90d909396"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaeab1eb791e10fdb954edc1b90d909396">regina::CompactSearcher::TetEdgeState::rank</a></td></tr>
<tr class="memdesc:gaeab1eb791e10fdb954edc1b90d909396"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#gaeab1eb791e10fdb954edc1b90d909396">More...</a><br /></td></tr>
<tr class="separator:gaeab1eb791e10fdb954edc1b90d909396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2800d46cd4e4d487c523ffbf288f929"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad2800d46cd4e4d487c523ffbf288f929">regina::CompactSearcher::TetEdgeState::size</a></td></tr>
<tr class="memdesc:gad2800d46cd4e4d487c523ffbf288f929"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of objects in the subtree descending from this object (where this object is counted also).  <a href="group__census.html#gad2800d46cd4e4d487c523ffbf288f929">More...</a><br /></td></tr>
<tr class="separator:gad2800d46cd4e4d487c523ffbf288f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad755014bbde4ef654613b1c15145e69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaad755014bbde4ef654613b1c15145e69">regina::CompactSearcher::TetEdgeState::bounded</a></td></tr>
<tr class="memdesc:gaad755014bbde4ef654613b1c15145e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this equivalence class of tetrahedron edges represent a boundary edge?  <a href="group__census.html#gaad755014bbde4ef654613b1c15145e69">More...</a><br /></td></tr>
<tr class="separator:gaad755014bbde4ef654613b1c15145e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac020b3d2a99a7ad54fea6c9f721d105a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac020b3d2a99a7ad54fea6c9f721d105a">regina::CompactSearcher::TetEdgeState::twistUp</a></td></tr>
<tr class="memdesc:gac020b3d2a99a7ad54fea6c9f721d105a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each tetrahedron edge can be assigned an orientation pointing from the lower numbered tetrahedron vertex to the higher.  <a href="group__census.html#gac020b3d2a99a7ad54fea6c9f721d105a">More...</a><br /></td></tr>
<tr class="separator:gac020b3d2a99a7ad54fea6c9f721d105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65bf7e75b24fa8e32c014890c82dd36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab65bf7e75b24fa8e32c014890c82dd36">regina::CompactSearcher::TetEdgeState::hadEqualRank</a></td></tr>
<tr class="memdesc:gab65bf7e75b24fa8e32c014890c82dd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#gab65bf7e75b24fa8e32c014890c82dd36">More...</a><br /></td></tr>
<tr class="separator:gab65bf7e75b24fa8e32c014890c82dd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fd365cc7773fa91b9ac329ea9327c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa2fd365cc7773fa91b9ac329ea9327c8">regina::CompactSearcher::TetEdgeState::facesPos</a></td></tr>
<tr class="memdesc:gaa2fd365cc7773fa91b9ac329ea9327c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how many times this edge runs along the boundary of each tetrahedron face in the positive direction.  <a href="group__census.html#gaa2fd365cc7773fa91b9ac329ea9327c8">More...</a><br /></td></tr>
<tr class="separator:gaa2fd365cc7773fa91b9ac329ea9327c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b68879fb13d0deb92a0e918a19de264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7b68879fb13d0deb92a0e918a19de264">regina::CompactSearcher::TetEdgeState::facesNeg</a></td></tr>
<tr class="memdesc:ga7b68879fb13d0deb92a0e918a19de264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how many times this edge runs along the boundary of each tetrahedron face in the negative direction.  <a href="group__census.html#ga7b68879fb13d0deb92a0e918a19de264">More...</a><br /></td></tr>
<tr class="separator:ga7b68879fb13d0deb92a0e918a19de264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b7628164ce0e0c14232abfe3150ce4"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad5b7628164ce0e0c14232abfe3150ce4">regina::CompactSearcher::dataTag_</a></td></tr>
<tr class="memdesc:gad5b7628164ce0e0c14232abfe3150ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#gad5b7628164ce0e0c14232abfe3150ce4">More...</a><br /></td></tr>
<tr class="separator:gad5b7628164ce0e0c14232abfe3150ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aea8813a101710e3650e36e564ee1c0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7aea8813a101710e3650e36e564ee1c0">regina::CompactSearcher::nVertexClasses</a></td></tr>
<tr class="memdesc:ga7aea8813a101710e3650e36e564ee1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#ga7aea8813a101710e3650e36e564ee1c0">More...</a><br /></td></tr>
<tr class="separator:ga7aea8813a101710e3650e36e564ee1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae799bb54f485575692d7d35858b2dd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae799bb54f485575692d7d35858b2dd8f">regina::CompactSearcher::vertexState</a></td></tr>
<tr class="memdesc:gae799bb54f485575692d7d35858b2dd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#gae799bb54f485575692d7d35858b2dd8f">More...</a><br /></td></tr>
<tr class="separator:gae799bb54f485575692d7d35858b2dd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d401e8806d12fd2274bfd24e97d292"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga42d401e8806d12fd2274bfd24e97d292">regina::CompactSearcher::vertexStateChanged</a></td></tr>
<tr class="memdesc:ga42d401e8806d12fd2274bfd24e97d292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the vertexState[] array has been updated over time.  <a href="group__census.html#ga42d401e8806d12fd2274bfd24e97d292">More...</a><br /></td></tr>
<tr class="separator:ga42d401e8806d12fd2274bfd24e97d292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga395f2feb52dfc9d7d5e3506ec8bbff14">regina::CompactSearcher::nEdgeClasses</a></td></tr>
<tr class="memdesc:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron edges.  <a href="group__census.html#ga395f2feb52dfc9d7d5e3506ec8bbff14">More...</a><br /></td></tr>
<tr class="separator:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab2dbdcdd9bcbab1d2686808a2d7c2d50">regina::CompactSearcher::edgeState</a></td></tr>
<tr class="memdesc:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron edges.  <a href="group__census.html#gab2dbdcdd9bcbab1d2686808a2d7c2d50">More...</a><br /></td></tr>
<tr class="separator:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1feea9d0c86a4582d091745b8883a18"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa1feea9d0c86a4582d091745b8883a18">regina::CompactSearcher::edgeStateChanged</a></td></tr>
<tr class="memdesc:gaa1feea9d0c86a4582d091745b8883a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState[] array has been updated over time.  <a href="group__census.html#gaa1feea9d0c86a4582d091745b8883a18">More...</a><br /></td></tr>
<tr class="separator:gaa1feea9d0c86a4582d091745b8883a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192e63b74c737da78c17e73e26dc65cf"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga192e63b74c737da78c17e73e26dc65cf">regina::ClosedPrimeMinSearcher::dataTag_</a></td></tr>
<tr class="memdesc:ga192e63b74c737da78c17e73e26dc65cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga192e63b74c737da78c17e73e26dc65cf">More...</a><br /></td></tr>
<tr class="separator:ga192e63b74c737da78c17e73e26dc65cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e9bdf9251a60378232e959d3db0649"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga53e9bdf9251a60378232e959d3db0649">regina::HyperbolicMinSearcher::dataTag_</a></td></tr>
<tr class="memdesc:ga53e9bdf9251a60378232e959d3db0649"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga53e9bdf9251a60378232e959d3db0649">More...</a><br /></td></tr>
<tr class="separator:ga53e9bdf9251a60378232e959d3db0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2c269282168447863eb54b54fd9579"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0b2c269282168447863eb54b54fd9579">regina::GluingPermSearcher&lt; 4 &gt;::edgeLinkNextFacet</a> [10][5]</td></tr>
<tr class="memdesc:ga0b2c269282168447863eb54b54fd9579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three pentachoron facets surrounding an edge in a pentachoron.  <a href="group__census.html#ga0b2c269282168447863eb54b54fd9579">More...</a><br /></td></tr>
<tr class="separator:ga0b2c269282168447863eb54b54fd9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41212ebcef7b83eead004afbf077b22"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab41212ebcef7b83eead004afbf077b22">regina::GluingPermSearcher&lt; 4 &gt;::edgeLinkPrevFacet</a> [10][5]</td></tr>
<tr class="memdesc:gab41212ebcef7b83eead004afbf077b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>edgeLinkNextFacet</em>.  <a href="group__census.html#gab41212ebcef7b83eead004afbf077b22">More...</a><br /></td></tr>
<tr class="separator:gab41212ebcef7b83eead004afbf077b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead39c0215f80b97f483ce9dcf49b5c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaead39c0215f80b97f483ce9dcf49b5c2">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::parent</a></td></tr>
<tr class="memdesc:gaead39c0215f80b97f483ce9dcf49b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#gaead39c0215f80b97f483ce9dcf49b5c2">More...</a><br /></td></tr>
<tr class="separator:gaead39c0215f80b97f483ce9dcf49b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad208c689a4a7ff5e6713b739d9a17740"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad208c689a4a7ff5e6713b739d9a17740">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::rank</a></td></tr>
<tr class="memdesc:gad208c689a4a7ff5e6713b739d9a17740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#gad208c689a4a7ff5e6713b739d9a17740">More...</a><br /></td></tr>
<tr class="separator:gad208c689a4a7ff5e6713b739d9a17740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9142955f7fad791d9fbf841e0ca4ef2e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9142955f7fad791d9fbf841e0ca4ef2e">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdry</a></td></tr>
<tr class="memdesc:ga9142955f7fad791d9fbf841e0ca4ef2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary triangle edges in the link for this equivalence class of pentachoron edges.  <a href="group__census.html#ga9142955f7fad791d9fbf841e0ca4ef2e">More...</a><br /></td></tr>
<tr class="separator:ga9142955f7fad791d9fbf841e0ca4ef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d01913310f2bbc3acf7ab47b20a891"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga25d01913310f2bbc3acf7ab47b20a891">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::twistUpEdge</a></td></tr>
<tr class="memdesc:ga25d01913310f2bbc3acf7ab47b20a891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each pentachoron edge can be assigned an orientation pointing from the lower numbered pentachoron vertex to the higher.  <a href="group__census.html#ga25d01913310f2bbc3acf7ab47b20a891">More...</a><br /></td></tr>
<tr class="separator:ga25d01913310f2bbc3acf7ab47b20a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa060c96e60a01c2f2c3d71d0418f9e15"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa060c96e60a01c2f2c3d71d0418f9e15">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::twistUpTriangle</a></td></tr>
<tr class="memdesc:gaa060c96e60a01c2f2c3d71d0418f9e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the edge link.  <a href="group__census.html#gaa060c96e60a01c2f2c3d71d0418f9e15">More...</a><br /></td></tr>
<tr class="separator:gaa060c96e60a01c2f2c3d71d0418f9e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f33ceaaffe679d74758a2da4ab7cb32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7f33ceaaffe679d74758a2da4ab7cb32">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::hadEqualRank</a></td></tr>
<tr class="memdesc:ga7f33ceaaffe679d74758a2da4ab7cb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#ga7f33ceaaffe679d74758a2da4ab7cb32">More...</a><br /></td></tr>
<tr class="separator:ga7f33ceaaffe679d74758a2da4ab7cb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdd4a71c01dd25f84300ec51f690bfc"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7cdd4a71c01dd25f84300ec51f690bfc">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdryEdges</a></td></tr>
<tr class="memdesc:ga7cdd4a71c01dd25f84300ec51f690bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of edges of the triangular piece of 4-manifold edge link that are in fact boundary edges of this link.  <a href="group__census.html#ga7cdd4a71c01dd25f84300ec51f690bfc">More...</a><br /></td></tr>
<tr class="separator:ga7cdd4a71c01dd25f84300ec51f690bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8118f45817ac6cbfa26f8eac6c8ee7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4a8118f45817ac6cbfa26f8eac6c8ee7">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdryNext</a> [2]</td></tr>
<tr class="memdesc:ga4a8118f45817ac6cbfa26f8eac6c8ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the corresponding triangular piece of 4-manifold edge link has any boundary edges, <em>bdryNext</em> stores the indices of the pentachoron edges that provide the boundary edges following on from either end of this boundary segment.  <a href="group__census.html#ga4a8118f45817ac6cbfa26f8eac6c8ee7">More...</a><br /></td></tr>
<tr class="separator:ga4a8118f45817ac6cbfa26f8eac6c8ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb926c4d0a235a73c8409739ff1f08c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gabbb926c4d0a235a73c8409739ff1f08c">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdryTwist</a> [2]</td></tr>
<tr class="memdesc:gabbb926c4d0a235a73c8409739ff1f08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the orientation of this boundary segment of the 4-manifold edge link is consistent with the orientation of the adjacent segments on either side.  <a href="group__census.html#gabbb926c4d0a235a73c8409739ff1f08c">More...</a><br /></td></tr>
<tr class="separator:gabbb926c4d0a235a73c8409739ff1f08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3ec11c442d921ced6b859db20140b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6d3ec11c442d921ced6b859db20140b7">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdryNextOld</a> [2]</td></tr>
<tr class="memdesc:ga6d3ec11c442d921ced6b859db20140b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#ga6d3ec11c442d921ced6b859db20140b7">More...</a><br /></td></tr>
<tr class="separator:ga6d3ec11c442d921ced6b859db20140b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a0b8ad3f5746ce0ffcee0374dec856"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae3a0b8ad3f5746ce0ffcee0374dec856">regina::GluingPermSearcher&lt; 4 &gt;::PentEdgeState::bdryTwistOld</a> [2]</td></tr>
<tr class="memdesc:gae3a0b8ad3f5746ce0ffcee0374dec856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two.  <a href="group__census.html#gae3a0b8ad3f5746ce0ffcee0374dec856">More...</a><br /></td></tr>
<tr class="separator:gae3a0b8ad3f5746ce0ffcee0374dec856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7390516fb9eae7fdfbcdc7a5cdda94ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7390516fb9eae7fdfbcdc7a5cdda94ef">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::parent</a></td></tr>
<tr class="memdesc:ga7390516fb9eae7fdfbcdc7a5cdda94ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the parent object in the current tree, or -1 if this object is the root of the tree.  <a href="group__census.html#ga7390516fb9eae7fdfbcdc7a5cdda94ef">More...</a><br /></td></tr>
<tr class="separator:ga7390516fb9eae7fdfbcdc7a5cdda94ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffafc804456dad6fa33ad8d81d73f4b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4ffafc804456dad6fa33ad8d81d73f4b">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::rank</a></td></tr>
<tr class="memdesc:ga4ffafc804456dad6fa33ad8d81d73f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the subtree beneath this object (where a leaf node has depth zero).  <a href="group__census.html#ga4ffafc804456dad6fa33ad8d81d73f4b">More...</a><br /></td></tr>
<tr class="separator:ga4ffafc804456dad6fa33ad8d81d73f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bb371bcfdaac507f1fa4770728a99b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga53bb371bcfdaac507f1fa4770728a99b">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::size</a></td></tr>
<tr class="memdesc:ga53bb371bcfdaac507f1fa4770728a99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of objects in the subtree descending from this object (where this object is counted also).  <a href="group__census.html#ga53bb371bcfdaac507f1fa4770728a99b">More...</a><br /></td></tr>
<tr class="separator:ga53bb371bcfdaac507f1fa4770728a99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4062b02bcfba18d65793e72f066526a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad4062b02bcfba18d65793e72f066526a">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::bounded</a></td></tr>
<tr class="memdesc:gad4062b02bcfba18d65793e72f066526a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this equivalence class of pentachoron triangles represent a boundary triangle?  <a href="group__census.html#gad4062b02bcfba18d65793e72f066526a">More...</a><br /></td></tr>
<tr class="separator:gad4062b02bcfba18d65793e72f066526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51dc6c8d9dca56d7cda94d2234653bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga51dc6c8d9dca56d7cda94d2234653bf2">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::twistUp</a></td></tr>
<tr class="memdesc:ga51dc6c8d9dca56d7cda94d2234653bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertices of each pentachoron triangle can be labelled (0,1,2) by running through the underlying pentachoron vertices from smallest index to largest index.  <a href="group__census.html#ga51dc6c8d9dca56d7cda94d2234653bf2">More...</a><br /></td></tr>
<tr class="separator:ga51dc6c8d9dca56d7cda94d2234653bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b5bcaeb902b57d1ceaa1b9a595d74e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga73b5bcaeb902b57d1ceaa1b9a595d74e">regina::GluingPermSearcher&lt; 4 &gt;::PentTriangleState::hadEqualRank</a></td></tr>
<tr class="memdesc:ga73b5bcaeb902b57d1ceaa1b9a595d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone.  <a href="group__census.html#ga73b5bcaeb902b57d1ceaa1b9a595d74e">More...</a><br /></td></tr>
<tr class="separator:ga73b5bcaeb902b57d1ceaa1b9a595d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b60607f33ff68f842b317fddbd7d5a"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga16b60607f33ff68f842b317fddbd7d5a">regina::GluingPermSearcher&lt; 4 &gt;::dataTag_</a></td></tr>
<tr class="memdesc:ga16b60607f33ff68f842b317fddbd7d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#ga16b60607f33ff68f842b317fddbd7d5a">More...</a><br /></td></tr>
<tr class="separator:ga16b60607f33ff68f842b317fddbd7d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4b34d3bd6dedfc0adc460c167148cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0f4b34d3bd6dedfc0adc460c167148cb">regina::GluingPermSearcher&lt; 4 &gt;::autos_</a></td></tr>
<tr class="memdesc:ga0f4b34d3bd6dedfc0adc460c167148cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="group__census.html#ga0f4b34d3bd6dedfc0adc460c167148cb">More...</a><br /></td></tr>
<tr class="separator:ga0f4b34d3bd6dedfc0adc460c167148cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554bf3960e33083dead41024771c2d2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga554bf3960e33083dead41024771c2d2c">regina::GluingPermSearcher&lt; 4 &gt;::autosNew_</a></td></tr>
<tr class="memdesc:ga554bf3960e33083dead41024771c2d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="group__census.html#ga554bf3960e33083dead41024771c2d2c">More...</a><br /></td></tr>
<tr class="separator:ga554bf3960e33083dead41024771c2d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b467e31273576a85d0df480d893eff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac0b467e31273576a85d0df480d893eff">regina::GluingPermSearcher&lt; 4 &gt;::orientableOnly_</a></td></tr>
<tr class="memdesc:gac0b467e31273576a85d0df480d893eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="group__census.html#gac0b467e31273576a85d0df480d893eff">More...</a><br /></td></tr>
<tr class="separator:gac0b467e31273576a85d0df480d893eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a48e1511ec0a927f7557d4a6a71a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga19a48e1511ec0a927f7557d4a6a71a2e">regina::GluingPermSearcher&lt; 4 &gt;::finiteOnly_</a></td></tr>
<tr class="memdesc:ga19a48e1511ec0a927f7557d4a6a71a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite (non-ideal) triangulations?  <a href="group__census.html#ga19a48e1511ec0a927f7557d4a6a71a2e">More...</a><br /></td></tr>
<tr class="separator:ga19a48e1511ec0a927f7557d4a6a71a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d09e6ad58e87eba28798833a7c10b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5d09e6ad58e87eba28798833a7c10b42">regina::GluingPermSearcher&lt; 4 &gt;::use_</a></td></tr>
<tr class="memdesc:ga5d09e6ad58e87eba28798833a7c10b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="group__census.html#ga5d09e6ad58e87eba28798833a7c10b42">More...</a><br /></td></tr>
<tr class="separator:ga5d09e6ad58e87eba28798833a7c10b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0d8f76b5d44dcd8acf0d5715b130b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4c0d8f76b5d44dcd8acf0d5715b130b7">regina::GluingPermSearcher&lt; 4 &gt;::useArgs_</a></td></tr>
<tr class="memdesc:ga4c0d8f76b5d44dcd8acf0d5715b130b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="group__census.html#ga4c0d8f76b5d44dcd8acf0d5715b130b7">More...</a><br /></td></tr>
<tr class="separator:ga4c0d8f76b5d44dcd8acf0d5715b130b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab676f59dbec9fc1e4095c55a33d4c29f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab676f59dbec9fc1e4095c55a33d4c29f">regina::GluingPermSearcher&lt; 4 &gt;::started_</a></td></tr>
<tr class="memdesc:gab676f59dbec9fc1e4095c55a33d4c29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="group__census.html#gab676f59dbec9fc1e4095c55a33d4c29f">More...</a><br /></td></tr>
<tr class="separator:gab676f59dbec9fc1e4095c55a33d4c29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aace77bcc9e796ec07706baea501370"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga5aace77bcc9e796ec07706baea501370">regina::GluingPermSearcher&lt; 4 &gt;::orientation_</a></td></tr>
<tr class="memdesc:ga5aace77bcc9e796ec07706baea501370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each pentachoron in the underlying triangulation.  <a href="group__census.html#ga5aace77bcc9e796ec07706baea501370">More...</a><br /></td></tr>
<tr class="separator:ga5aace77bcc9e796ec07706baea501370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645b467099de1154f57a9f57a12d7c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga645b467099de1154f57a9f57a12d7c41">regina::GluingPermSearcher&lt; 4 &gt;::order_</a></td></tr>
<tr class="memdesc:ga645b467099de1154f57a9f57a12d7c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to pentachoron facets.  <a href="group__census.html#ga645b467099de1154f57a9f57a12d7c41">More...</a><br /></td></tr>
<tr class="separator:ga645b467099de1154f57a9f57a12d7c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592f3c19001c088c2b90fdcae56bbb6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga592f3c19001c088c2b90fdcae56bbb6e">regina::GluingPermSearcher&lt; 4 &gt;::orderSize_</a></td></tr>
<tr class="memdesc:ga592f3c19001c088c2b90fdcae56bbb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the facet pairing graph, i.e., the number of elements of interest in the order_[] array.  <a href="group__census.html#ga592f3c19001c088c2b90fdcae56bbb6e">More...</a><br /></td></tr>
<tr class="separator:ga592f3c19001c088c2b90fdcae56bbb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b3c59d2d196bcfdfd94c1a49154ba8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga10b3c59d2d196bcfdfd94c1a49154ba8">regina::GluingPermSearcher&lt; 4 &gt;::orderElt_</a></td></tr>
<tr class="memdesc:ga10b3c59d2d196bcfdfd94c1a49154ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order_[] we are currently examining at this stage of the search.  <a href="group__census.html#ga10b3c59d2d196bcfdfd94c1a49154ba8">More...</a><br /></td></tr>
<tr class="separator:ga10b3c59d2d196bcfdfd94c1a49154ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71723efa36609fbfac186fb3ea8d0468"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga71723efa36609fbfac186fb3ea8d0468">regina::GluingPermSearcher&lt; 4 &gt;::nEdgeClasses_</a></td></tr>
<tr class="memdesc:ga71723efa36609fbfac186fb3ea8d0468"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified pentachoron edges.  <a href="group__census.html#ga71723efa36609fbfac186fb3ea8d0468">More...</a><br /></td></tr>
<tr class="separator:ga71723efa36609fbfac186fb3ea8d0468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9daf8b6c1ce6b437dbbd294612d56b96"><td class="memItemLeft" align="right" valign="top">PentEdgeState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9daf8b6c1ce6b437dbbd294612d56b96">regina::GluingPermSearcher&lt; 4 &gt;::edgeState_</a></td></tr>
<tr class="memdesc:ga9daf8b6c1ce6b437dbbd294612d56b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified pentachoron edges.  <a href="group__census.html#ga9daf8b6c1ce6b437dbbd294612d56b96">More...</a><br /></td></tr>
<tr class="separator:ga9daf8b6c1ce6b437dbbd294612d56b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6144b675b94702dd750719578ee20da7"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6144b675b94702dd750719578ee20da7">regina::GluingPermSearcher&lt; 4 &gt;::edgeStateChanged_</a></td></tr>
<tr class="memdesc:ga6144b675b94702dd750719578ee20da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState_[] array has been updated over time.  <a href="group__census.html#ga6144b675b94702dd750719578ee20da7">More...</a><br /></td></tr>
<tr class="separator:ga6144b675b94702dd750719578ee20da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e1c2d1d04751699fedc6806a0fe6e6"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga96e1c2d1d04751699fedc6806a0fe6e6">regina::GluingPermSearcher&lt; 4 &gt;::nTriangleClasses_</a></td></tr>
<tr class="memdesc:ga96e1c2d1d04751699fedc6806a0fe6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified pentachoron triangles.  <a href="group__census.html#ga96e1c2d1d04751699fedc6806a0fe6e6">More...</a><br /></td></tr>
<tr class="separator:ga96e1c2d1d04751699fedc6806a0fe6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b739aab8500599992fdd77be379f52"><td class="memItemLeft" align="right" valign="top">PentTriangleState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga20b739aab8500599992fdd77be379f52">regina::GluingPermSearcher&lt; 4 &gt;::triState_</a></td></tr>
<tr class="memdesc:ga20b739aab8500599992fdd77be379f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified pentachoron triangles.  <a href="group__census.html#ga20b739aab8500599992fdd77be379f52">More...</a><br /></td></tr>
<tr class="separator:ga20b739aab8500599992fdd77be379f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ec34c68b08996259c375647b3fc0b3"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga16ec34c68b08996259c375647b3fc0b3">regina::GluingPermSearcher&lt; 4 &gt;::triStateChanged_</a></td></tr>
<tr class="memdesc:ga16ec34c68b08996259c375647b3fc0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the triState_[] array has been updated over time.  <a href="group__census.html#ga16ec34c68b08996259c375647b3fc0b3">More...</a><br /></td></tr>
<tr class="separator:ga16ec34c68b08996259c375647b3fc0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gac727101c9c7f9ec327d12eb587ecf83e"><td class="memItemLeft" align="right" valign="top"><a id="gac727101c9c7f9ec327d12eb587ecf83e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHit::CensusDB</b></td></tr>
<tr class="separator:gac727101c9c7f9ec327d12eb587ecf83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d92ad12408323aff4c71b723dddc07"><td class="memItemLeft" align="right" valign="top"><a id="ga97d92ad12408323aff4c71b723dddc07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::CensusHit::CensusHits</b></td></tr>
<tr class="separator:ga97d92ad12408323aff4c71b723dddc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a> lookup and enumeration for triangulations of various dimensions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaef8d221d88105d9e8c1e758b5f7b02e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef8d221d88105d9e8c1e758b5f7b02e6">&#9670;&nbsp;</a></span>Dim2GluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;2&gt; <a class="el" href="group__census.html#gaef8d221d88105d9e8c1e758b5f7b02e6">regina::Dim2GluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim2GluingPerms, you should use the full class name <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;2&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga80fbf2dfa9a77b6d9e37450068c4d30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80fbf2dfa9a77b6d9e37450068c4d30c">&#9670;&nbsp;</a></span>Dim2GluingPermSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt; <a class="el" href="group__census.html#ga80fbf2dfa9a77b6d9e37450068c4d30c">regina::Dim2GluingPermSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim2GluingPermSearcher, you should use the full class name <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a>. </dd></dl>

</div>
</div>
<a id="gada52abc7db8f16297057c8f35d1d3882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada52abc7db8f16297057c8f35d1d3882">&#9670;&nbsp;</a></span>Dim4GluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;4&gt; <a class="el" href="group__census.html#gada52abc7db8f16297057c8f35d1d3882">regina::Dim4GluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim4GluingPerms, you should use the full class name <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;4&gt;</a>. </dd></dl>

</div>
</div>
<a id="gafd4b30355de34de4e9e86da57c85d2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4b30355de34de4e9e86da57c85d2ba">&#9670;&nbsp;</a></span>Dim4GluingPermSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;4&gt; <a class="el" href="group__census.html#gafd4b30355de34de4e9e86da57c85d2ba">regina::Dim4GluingPermSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Instead of the old typedef Dim4GluingPermSearcher, you should use the full class name <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a>. </dd></dl>

</div>
</div>
<a id="gaa6db6cd9fe93bf222b9d3570e89930a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6db6cd9fe93bf222b9d3570e89930a9">&#9670;&nbsp;</a></span>NCensus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Census.html">Census</a> <a class="el" href="group__census.html#gaa6db6cd9fe93bf222b9d3570e89930a9">regina::NCensus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>The class NCensus has now been renamed to <a class="el" href="classregina_1_1Census.html" title="A utility class used to search for triangulations across one or more 3-manifold census databases.">Census</a>. </dd></dl>

</div>
</div>
<a id="gae0ddfb76c4cb1c1fa8866a38984bf517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ddfb76c4cb1c1fa8866a38984bf517">&#9670;&nbsp;</a></span>NCensusDB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> <a class="el" href="group__census.html#gae0ddfb76c4cb1c1fa8866a38984bf517">regina::NCensusDB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>The class NCensusDB has now been renamed to <a class="el" href="classregina_1_1CensusDB.html" title="Stores the location and description of one of Regina&#39;s in-built census databases.">CensusDB</a>. </dd></dl>

</div>
</div>
<a id="gad52f27bc1801baeb5716e4e90ec7db75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52f27bc1801baeb5716e4e90ec7db75">&#9670;&nbsp;</a></span>NCensusHit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> <a class="el" href="group__census.html#gad52f27bc1801baeb5716e4e90ec7db75">regina::NCensusHit</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>The class NCensusHit has now been renamed to <a class="el" href="classregina_1_1CensusHit.html" title="Stores a single &quot;hit&quot; indicating that some given triangulation has been located in one of Regina&#39;s in...">CensusHit</a>. </dd></dl>

</div>
</div>
<a id="gadb6a52e98200bdae7cd0831ba55e313b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb6a52e98200bdae7cd0831ba55e313b">&#9670;&nbsp;</a></span>NCensusHits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> <a class="el" href="group__census.html#gadb6a52e98200bdae7cd0831ba55e313b">regina::NCensusHits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>The class NCensusHits has now been renamed to <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a>. </dd></dl>

</div>
</div>
<a id="ga55f57f46909048f730f28d8f6b0b1a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f57f46909048f730f28d8f6b0b1a8b">&#9670;&nbsp;</a></span>NClosedPrimeMinSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html">ClosedPrimeMinSearcher</a> <a class="el" href="group__census.html#ga55f57f46909048f730f28d8f6b0b1a8b">regina::NClosedPrimeMinSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>The class NClosedPrimeMinSearcher has now been renamed to <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a>. </dd></dl>

</div>
</div>
<a id="ga402cce4dc9c10f1679ba9849cb993f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402cce4dc9c10f1679ba9849cb993f0c">&#9670;&nbsp;</a></span>NCompactSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1CompactSearcher.html">CompactSearcher</a> <a class="el" href="group__census.html#ga402cce4dc9c10f1679ba9849cb993f0c">regina::NCompactSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>The class NCompactSearcher has now been renamed to <a class="el" href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f...">CompactSearcher</a>. </dd></dl>

</div>
</div>
<a id="ga15758f12adde60cc820c419b157dd9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15758f12adde60cc820c419b157dd9c2">&#9670;&nbsp;</a></span>NEulerSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1EulerSearcher.html">EulerSearcher</a> <a class="el" href="group__census.html#ga15758f12adde60cc820c419b157dd9c2">regina::NEulerSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>The class NEulerSearcher has now been renamed to <a class="el" href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link...">EulerSearcher</a>. </dd></dl>

</div>
</div>
<a id="ga80ae43e34ebda86de3162276bffbfbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ae43e34ebda86de3162276bffbfbf5">&#9670;&nbsp;</a></span>NGenericGluingPerms</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__census.html#ga80ae43e34ebda86de3162276bffbfbf5">regina::NGenericGluingPerms</a> = typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Instead of the old type alias NGenericGluingPerms&lt;dim&gt;, you should use the new class name GluingPerms&lt;dim&gt;. </dd></dl>

</div>
</div>
<a id="ga470473a9f5c6481030480ff734b35fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470473a9f5c6481030480ff734b35fa2">&#9670;&nbsp;</a></span>NGluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt;3&gt; <a class="el" href="group__census.html#ga470473a9f5c6481030480ff734b35fa2">regina::NGluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Instead of the old typedef NGluingPerms, you should use the full class name <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga1438f17a8b29f6ac69ca06d81acdf3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1438f17a8b29f6ac69ca06d81acdf3bc">&#9670;&nbsp;</a></span>NGluingPermSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;3&gt; <a class="el" href="group__census.html#ga1438f17a8b29f6ac69ca06d81acdf3bc">regina::NGluingPermSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Instead of the old typedef NGluingPermSearcher, you should use the full class name <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a>. </dd></dl>

</div>
</div>
<a id="ga7e7383f4ff3af40a893696ce95abda9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7383f4ff3af40a893696ce95abda9a">&#9670;&nbsp;</a></span>NHyperbolicMinSearcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HyperbolicMinSearcher.html">HyperbolicMinSearcher</a> <a class="el" href="group__census.html#ga7e7383f4ff3af40a893696ce95abda9a">regina::NHyperbolicMinSearcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>The class NHyperbolicMinSearcher has now been renamed to <a class="el" href="classregina_1_1HyperbolicMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only minimal id...">HyperbolicMinSearcher</a>. </dd></dl>

</div>
</div>
<a id="ga541613639a350df47748b7bdae7ed5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541613639a350df47748b7bdae7ed5fa">&#9670;&nbsp;</a></span>Use <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::Use) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a set of gluing permutations. </p>
<p>Such routines are used to process permutation sets that are found when running census-building routines such as <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>.</p>
<p>The first parameter passed will be a set of gluing permutations (as this class derives from <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;2&gt;</a>). This set of gluing permutations must not be deallocated by this routine, since it may be used again later by the caller. The second parameter may contain arbitrary data; typically this will be the data passed to the relevant search routine, such as <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> or the <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> class constructor.</p>
<p>Note that the first parameter passed might be <code>null</code> to signal that gluing permutation generation has finished. </p>

</div>
</div>
<a id="ga40c89ca6699633f872a9611273995730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c89ca6699633f872a9611273995730">&#9670;&nbsp;</a></span>Use <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::Use) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a set of gluing permutations. </p>
<p>Such routines are used to process permutation sets that are found when running census-building routines such as <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>The first parameter passed will be a set of gluing permutations (as this class derives from <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;3&gt;</a>). This set of gluing permutations must not be deallocated by this routine, since it may be used again later by the caller. The second parameter may contain arbitrary data; typically this will be the data passed to the relevant search routine, such as <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> or the <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> class constructor.</p>
<p>Note that the first parameter passed might be <code>null</code> to signal that gluing permutation generation has finished. </p>

</div>
</div>
<a id="ga43b50b702b41225afbd20161898e3931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b50b702b41225afbd20161898e3931">&#9670;&nbsp;</a></span>Use <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::Use) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt; *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a set of gluing permutations. </p>
<p>Such routines are used to process permutation sets that are found when running census-building routines such as <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a>.</p>
<p>The first parameter passed will be a set of gluing permutations (as this class derives from <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;4&gt;</a>). This set of gluing permutations must not be deallocated by this routine, since it may be used again later by the caller. The second parameter may contain arbitrary data; typically this will be the data passed to the relevant search routine, such as <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a> or the <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> class constructor.</p>
<p>Note that the first parameter passed might be <code>null</code> to signal that gluing permutation generation has finished. </p>

</div>
</div>
<a id="ga25e2e457311bc6d60a2937b890e64142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e2e457311bc6d60a2937b890e64142">&#9670;&nbsp;</a></span>UseDim2GluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;::Use <a class="el" href="group__census.html#ga25e2e457311bc6d60a2937b890e64142">regina::UseDim2GluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Instead of the old typedef UseDim2GluingPerms, you should use the new type name <a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa" title="A routine that can do arbitrary processing upon a set of gluing permutations.">GluingPermSearcher&lt;2&gt;::Use</a>. </dd></dl>

</div>
</div>
<a id="gab3cf7f3e8cd90321f45c2a641e480dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3cf7f3e8cd90321f45c2a641e480dab">&#9670;&nbsp;</a></span>UseDim4GluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;4&gt;::Use <a class="el" href="group__census.html#gab3cf7f3e8cd90321f45c2a641e480dab">regina::UseDim4GluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Instead of the old typedef UseDim4GluingPerms, you should use the new type name <a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931" title="A routine that can do arbitrary processing upon a set of gluing permutations.">GluingPermSearcher&lt;4&gt;::Use</a>. </dd></dl>

</div>
</div>
<a id="ga9bae6356869e326ca815e301e2cde637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bae6356869e326ca815e301e2cde637">&#9670;&nbsp;</a></span>UseGluingPerms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;3&gt;::Use <a class="el" href="group__census.html#ga9bae6356869e326ca815e301e2cde637">regina::UseGluingPerms</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Instead of the old typedef UseGluingPerms, you should use the new type name <a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730" title="A routine that can do arbitrary processing upon a set of gluing permutations.">GluingPermSearcher&lt;3&gt;::Use</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga78092e891f6f355e6e65876301fcaf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78092e891f6f355e6e65876301fcaf6f">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants used in the <em>vertexStateChanged</em> array to indicate how a partial vertex link becomes glued to itself along two of its boundary edges. </p>
<p>See <em>vertexStateChanged</em> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga78092e891f6f355e6e65876301fcaf6fa48683e64b202e5e03d093d52837c899b"></a>VLINK_JOIN_INIT&#160;</td><td class="fielddoc"><p>A placeholder value for a join that has not yet been made. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga78092e891f6f355e6e65876301fcaf6fa6c8e29d0377dd6124780ea5fd0169052"></a>VLINK_JOIN_HANDLE&#160;</td><td class="fielddoc"><p>Signifies that two distinct boundary components of a vertex link have been connected, forming a handle (either orientable or non-orientable). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga78092e891f6f355e6e65876301fcaf6fab6592b7a8fc5491a8a482f5051e3bda5"></a>VLINK_JOIN_BRIDGE&#160;</td><td class="fielddoc"><p>Signifies that a single boundary component of the vertex link has had two edges joined together in an orientation-preserving fashion. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga78092e891f6f355e6e65876301fcaf6fa4c0a3cec3e4456fda85a4d785c9772ee"></a>VLINK_JOIN_TWIST&#160;</td><td class="fielddoc"><p>Signifies that a single boundary component of the vertex link has had two edges joined together in an orientation-reversing fashion. </p>
</td></tr>
</table>

</div>
</div>
<a id="gada3ab4fafaa359d394afabb2b56253b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada3ab4fafaa359d394afabb2b56253b2">&#9670;&nbsp;</a></span>PurgeFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#gada3ab4fafaa359d394afabb2b56253b2">PurgeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations. </p>
<p>These flags can be combined using bitwise OR.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor documentation for further details on how these flags are used.</p>
<dl class="section user"><dt>Python</dt><dd>For convenience, these constants are also made available directly in Python's regina namespace. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2a82e983dba291b66ddf05b4f99d2e85ce"></a>PURGE_NONE&#160;</td><td class="fielddoc"><p>Indicates that no triangulations should be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2af774c239c72c690a3dc88527904ba57a"></a>PURGE_NON_MINIMAL&#160;</td><td class="fielddoc"><p>Indicates that non-minimal triangulations may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2a88dbd756465fbe8ed551b9c4089eba14"></a>PURGE_NON_PRIME&#160;</td><td class="fielddoc"><p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum) and any bounded triangulation that is reducible over a disc may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2a488784291610d2080c8fd9be7fb0d99e"></a>PURGE_NON_MINIMAL_PRIME&#160;</td><td class="fielddoc"><p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum), any bounded triangulation that is reducible over a disc and any triangulation that is non-minimal may be ignored. </p>
<p>Note that this is simply a combination of the constants <em>PURGE_NON_MINIMAL</em> and <em>PURGE_NON_PRIME</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2a9d84a4d217e149b8d1340f6b2754abe4"></a>PURGE_NON_MINIMAL_HYP&#160;</td><td class="fielddoc"><p>Indicates that any triangulation that is not a minimal ideal triangulation of a cusped finite-volume hyperbolic 3-manifold may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada3ab4fafaa359d394afabb2b56253b2a761c00f0760cd3af4d6b07162218a6b0"></a>PURGE_P2_REDUCIBLE&#160;</td><td class="fielddoc"><p>Indicates that any triangulation containing an embedded two-sided projective plane may be ignored. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac96d6b032b249f255cb8561dc075b356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac96d6b032b249f255cb8561dc075b356">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CensusHits::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *&#160;</td>
          <td class="paramname"><em>hit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new hit to the end of this list. </p>
<p>This list will take ownership of the given object.</p>
<p>This operation does not invalidate any <a class="el" href="classregina_1_1CensusHitIterator.html" title="A forward iterator that walks through all hits stored by a single CensusHits object.">CensusHitIterator</a> iterators.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hit</td><td>the hit to append to this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga941c419f7a3a7d86e850a8d32a6bdd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941c419f7a3a7d86e850a8d32a6bdd86">&#9670;&nbsp;</a></span>badEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::badEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse. </p>
<p>Note that such edges can only occur in non-orientable triangulations.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<p>If <em>finiteOnly_</em> is <code>true</code> in the search criteria, additional tests will be run that can eliminate triangulations with non-orientable vertex links. Although these tests are not searching for bad edge links per se, they can be performed within this routine with very little additional work needing to be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to an edge identified with itself in reverse, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="ga502b8b26f14e65f2f22e524d92e6c3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga502b8b26f14e65f2f22e524d92e6c3b3">&#9670;&nbsp;</a></span>badTriangleLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::badTriangleLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a 4-manifold triangulation with a (2-dimensional) triangle identified with itself using a non-trivial rotation or reflection. </p>
<p>Tests that do not refer to the gluing permutation for the given pentachoron facet will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the specific pentachoron facet upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a triangle identified with itself using a non-trivial rotation or reflection, or <code>false</code> if no such triangle is found. </dd></dl>

</div>
</div>
<a id="ga96137581ba7cc8158ba933849a6b800c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96137581ba7cc8158ba933849a6b800c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> regina::CensusHits::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of this list of hits. </p>
<p>The <a class="el" href="group__census.html#ga96137581ba7cc8158ba933849a6b800c" title="Returns an iterator at the beginning of this list of hits.">begin()</a> and <a class="el" href="group__census.html#gae83afd05d0f0e761350d8cf74a132135" title="Returns an iterator beyond the end of this list of hits.">end()</a> routines allow you to iterate through all hits in this list using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__census.html#ga636bf941eacd42d508404d26d4cdfb29">CensusHits</a>* hits = <a class="code" href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae">Census::lookup</a>(...);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> CensusHit* h : *hits) { ... }</div>
<div class="ttc" id="agroup__census_html_ga636bf941eacd42d508404d26d4cdfb29"><div class="ttname"><a href="group__census.html#ga636bf941eacd42d508404d26d4cdfb29">regina::CensusHits::CensusHits</a></div><div class="ttdeci">CensusHits()</div><div class="ttdoc">Constructs an empty set of hits.</div><div class="ttdef"><b>Definition:</b> census.h:657</div></div>
<div class="ttc" id="agroup__census_html_gaf10e60ed01730474c83c9337c89c41ae"><div class="ttname"><a href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae">regina::Census::lookup</a></div><div class="ttdeci">static CensusHits * lookup(const Triangulation&lt; 3 &gt; &amp;tri)</div><div class="ttdoc">Searches for the given triangulation through all of Regina's in-built census databases.</div></div>
</div><!-- fragment --><p>In Python, a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object can be treated as an iterable object:</p>
<div class="fragment"><div class="line">hits = Census.lookup(...)</div>
<div class="line"><span class="keywordflow">for</span> h <span class="keywordflow">in</span> hits:</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this list of hits. </dd></dl>

</div>
</div>
<a id="gadbcc40f8963f47e6059a0c49a115982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbcc40f8963f47e6059a0c49a115982a">&#9670;&nbsp;</a></span>bestSearcher() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a id="ga83ac77c210fb2ae44e799f3f7db02300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ac77c210fb2ae44e799f3f7db02300">&#9670;&nbsp;</a></span>bestSearcher() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;3&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a id="ga17e70fb19950cdc7294e829dd51dce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e70fb19950cdc7294e829dd51dce15">&#9670;&nbsp;</a></span>bestSearcher() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;4&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any pentachoron from any other pentachoron via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;4&gt;::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;4&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a id="ga24d3733957b1051d451c958a68e4dcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d3733957b1051d451c958a68e4dcc4">&#9670;&nbsp;</a></span>CensusDB() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusDB::CensusDB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given database reference into this new object. </p>
<p>The reference that was passed will no longer be usable. </p>

</div>
</div>
<a id="gac79961c926103bc0b0f10484c0fcd3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79961c926103bc0b0f10484c0fcd3f1">&#9670;&nbsp;</a></span>CensusDB() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusDB::CensusDB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new clone of the given database reference. </p>

</div>
</div>
<a id="ga78ca7b114128f407d3f582263cf5452e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ca7b114128f407d3f582263cf5452e">&#9670;&nbsp;</a></span>CensusDB() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusDB::CensusDB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new reference to one of Regina's census databases. </p>
<p>This constructor will not run any checks (e.g., it will not verify that the database exists, or that it is stored in the correct format). Note that even if the database does not exist, the <a class="el" href="group__census.html#gabb5bdd67c6e27bd0d434e52b98c47107" title="Searches for the given isomorphism signature in this database.">lookup()</a> routine will fail gracefully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename where the database is stored. </td></tr>
    <tr><td class="paramname">desc</td><td>a human-readable description of the database. See the <a class="el" href="group__census.html#ga0a02e30b4c9d3a2bcc4132fb13ac5555" title="Returns a human-readable description of this database.">desc()</a> routine for further information on how this description might be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4efd819900aa2ef30657ac35d4fea61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4efd819900aa2ef30657ac35d4fea61">&#9670;&nbsp;</a></span>CensusHitIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusHitIterator::CensusHitIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a past-the-end iterator. </p>

</div>
</div>
<a id="gad2a53e01f296f15969731071f662119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a53e01f296f15969731071f662119a">&#9670;&nbsp;</a></span>CensusHitIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusHitIterator::CensusHitIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> *&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given census hit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>the census hit that the new iterator should point to, or <code>null</code> if the new iterator should be past-the-end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac50f6c08e9bc01212b8f690b559d0629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50f6c08e9bc01212b8f690b559d0629">&#9670;&nbsp;</a></span>CensusHitIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusHitIterator::CensusHitIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="ga636bf941eacd42d508404d26d4cdfb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga636bf941eacd42d508404d26d4cdfb29">&#9670;&nbsp;</a></span>CensusHits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusHits::CensusHits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty set of hits. </p>

</div>
</div>
<a id="ga45621ba980c3face197628084aa65ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45621ba980c3face197628084aa65ba3">&#9670;&nbsp;</a></span>ClosedPrimeMinSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ClosedPrimeMinSearcher::ClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager for use when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three. </p>
<p>Note that other unwanted triangulations may still be produced (e.g., non-prime or non-minimal triangulations), but there will be far fewer of these than when using the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> class directly.</p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> documentation. Note in particular that this class will be automatically used by <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">GluingPermSearcher&lt;3&gt;::findAllPerms()</a> if possible, so there is often no need for an end user to instantiate this class directly.</p>
<p>All constructor arguments are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor, though some arguments (such as <em>finiteOnly</em> and <em>whichPurge</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form. </dd>
<dd>
The given face pairing has no boundary faces and has at least three tetrahedra. </dd></dl>

</div>
</div>
<a id="ga853dc8f70159d7e989ff64ee29b2a3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853dc8f70159d7e989ff64ee29b2a3d6">&#9670;&nbsp;</a></span>ClosedPrimeMinSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ClosedPrimeMinSearcher::ClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga5797a69d3943aea7aad7e865c3130734" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c9b0e336f9e35995a83d38fecc93bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9b0e336f9e35995a83d38fecc93bb2">&#9670;&nbsp;</a></span>CompactSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::CompactSearcher::CompactSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager for use when only compact 3-manifold triangulations are required. </p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> documentation. Note in particular that this class will be automatically used by <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">GluingPermSearcher&lt;3&gt;::findAllPerms()</a> if possible, so there is often no need for an end user to instantiate this class directly.</p>
<p>All constructor arguments are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor, though some arguments (such as <em>finiteOnly</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a id="gaa168e472dd2efdad10fbbadff7cf64a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa168e472dd2efdad10fbbadff7cf64a1">&#9670;&nbsp;</a></span>CompactSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::CompactSearcher::CompactSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga492bd21552c84aaa40f239f48b8b69d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga492bd21552c84aaa40f239f48b8b69d2">&#9670;&nbsp;</a></span>completePermSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga9c0d472300ed37ee9ba02e60bb0f90f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0d472300ed37ee9ba02e60bb0f90f8">&#9670;&nbsp;</a></span>completePermSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga8b3f66fe5f81e571112cb4c3c70f1e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3f66fe5f81e571112cb4c3c70f1e10">&#9670;&nbsp;</a></span>completePermSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4e5e301be4e108c90bb4ffd563fd7404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5e301be4e108c90bb4ffd563fd7404">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::CensusHits::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of hits in this list. </p>
<p>This routine is fast, since the number of hits is cached (it does not need to walk through the entire list to count).</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of hits. </dd></dl>

</div>
</div>
<a id="ga78e9e46143328020185ad88fb8cecc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e9e46143328020185ad88fb8cecc54">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

</div>
</div>
<a id="ga5ccaa866825f9d8f80abbc1b31376b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ccaa866825f9d8f80abbc1b31376b33">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented in <a class="el" href="group__census.html#ga20c52a8c26bf78b2d72e01dc023adf28">regina::HyperbolicMinSearcher</a>, <a class="el" href="group__census.html#ga1472a77ba27e607b4a91e1faa253544a">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">regina::CompactSearcher</a>, and <a class="el" href="group__census.html#gad2d5beee85da518709476bdb964decf7">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="gadf04a2af0e70743a2eab4865df5e9768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf04a2af0e70743a2eab4865df5e9768">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

</div>
</div>
<a id="gad2d5beee85da518709476bdb964decf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d5beee85da518709476bdb964decf7">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga5ccaa866825f9d8f80abbc1b31376b33">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga20c52a8c26bf78b2d72e01dc023adf28">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="gae8f9493c7d14a63ed912bf069b4a11ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8f9493c7d14a63ed912bf069b4a11ea">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::CompactSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga5ccaa866825f9d8f80abbc1b31376b33">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga1472a77ba27e607b4a91e1faa253544a">regina::ClosedPrimeMinSearcher</a>.</p>

</div>
</div>
<a id="ga1472a77ba27e607b4a91e1faa253544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1472a77ba27e607b4a91e1faa253544a">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::ClosedPrimeMinSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">regina::CompactSearcher</a>.</p>

</div>
</div>
<a id="ga20c52a8c26bf78b2d72e01dc023adf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20c52a8c26bf78b2d72e01dc023adf28">&#9670;&nbsp;</a></span>dataTag() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::HyperbolicMinSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="group__census.html#gad2d5beee85da518709476bdb964decf7">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="gab3ce63abf4f553af75c602ae12c632c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ce63abf4f553af75c602ae12c632c6">&#9670;&nbsp;</a></span>db()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> * regina::CensusHit::db </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the census database in which the triangulation was found. </p>
<dl class="section return"><dt>Returns</dt><dd>the database for this hit. </dd></dl>

</div>
</div>
<a id="ga0a02e30b4c9d3a2bcc4132fb13ac5555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a02e30b4c9d3a2bcc4132fb13ac5555">&#9670;&nbsp;</a></span>desc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::CensusDB::desc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a human-readable description of this database. </p>
<p>The description could (for instance) be shown to users when giving a list of all available databases, or when identifying in which particular database a match was found.</p>
<dl class="section return"><dt>Returns</dt><dd>the database description. </dd></dl>

</div>
</div>
<a id="ga46eb76a4d962402f85f52e39aa890137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46eb76a4d962402f85f52e39aa890137">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__census.html#ga7342cde30895f7eb18ab8cdb0342c44f">regina::GluingPermSearcher&lt; 4 &gt;</a>, <a class="el" href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6">regina::HyperbolicMinSearcher</a>, <a class="el" href="group__census.html#ga5797a69d3943aea7aad7e865c3130734">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">regina::CompactSearcher</a>, <a class="el" href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd">regina::EulerSearcher</a>, <a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978">regina::GluingPermSearcher&lt; 3 &gt;</a>, and <a class="el" href="group__census.html#gad17c98dfbc2842bbf20fd267b806ed9e">regina::GluingPermSearcher&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="gad82404c59a59f47997ef0d00f1fc3199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82404c59a59f47997ef0d00f1fc3199">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::TetVertexState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#gabe23322c2fa99b115e369ed3bb83d4f5" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4c1732c349de12058f800544081788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c1732c349de12058f800544081788b">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::TetVertexState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#ga0054acee7c5eb6435363bd1c57054886" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d118922562342ba63f8cec4b9329109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d118922562342ba63f8cec4b9329109">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#ga79bfc9bbf3ecfdac9eab9f1d162d6a9e" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab6d72926b58e488bc1eed7642d2bfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab6d72926b58e488bc1eed7642d2bfd6">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#ga3cc5eef303e35fa3a841652b7684b0ed" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad17c98dfbc2842bbf20fd267b806ed9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad17c98dfbc2842bbf20fd267b806ed9e">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga46eb76a4d962402f85f52e39aa890137">regina::GluingPerms&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="ga0f3fd032ae3c9ff71d80b2758cf5b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3fd032ae3c9ff71d80b2758cf5b978">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga46eb76a4d962402f85f52e39aa890137">regina::GluingPerms&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6">regina::HyperbolicMinSearcher</a>, <a class="el" href="group__census.html#ga5797a69d3943aea7aad7e865c3130734">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">regina::CompactSearcher</a>, and <a class="el" href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="ga666143b82a03dcc0a384b6ac46bb9ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666143b82a03dcc0a384b6ac46bb9ebd">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::EulerSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="ga4ef94a9fe76fd50d2275a34174bf52bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef94a9fe76fd50d2275a34174bf52bb">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::CompactSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga5797a69d3943aea7aad7e865c3130734">regina::ClosedPrimeMinSearcher</a>.</p>

</div>
</div>
<a id="ga5797a69d3943aea7aad7e865c3130734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5797a69d3943aea7aad7e865c3130734">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::ClosedPrimeMinSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">regina::CompactSearcher</a>.</p>

</div>
</div>
<a id="ga78c9636e863740f51a421e433b9bd8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c9636e863740f51a421e433b9bd8d6">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::HyperbolicMinSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="ga7342cde30895f7eb18ab8cdb0342c44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7342cde30895f7eb18ab8cdb0342c44f">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga46eb76a4d962402f85f52e39aa890137">regina::GluingPerms&lt; 4 &gt;</a>.</p>

</div>
</div>
<a id="gac9e26f60e3f150239a1fabaee0ae1833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e26f60e3f150239a1fabaee0ae1833">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::TetEdgeState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#gaa71cfd9584873bcae03bee1df4c982dc" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTets</td><td>the number of tetrahedra under consideration in the census. </td></tr>
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5209d223e247417f8947d1ad64f4dbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5209d223e247417f8947d1ad64f4dbaf">&#9670;&nbsp;</a></span>dumpData() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::TetEdgeState::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This state can be recreated from this text data by calling <a class="el" href="group__census.html#ga0d3d531a632b43dbb23f8c4681db7413" title="Fills this state with data read from the given input stream.">readData()</a>.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTets</td><td>the number of tetrahedra under consideration in the census. </td></tr>
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad89630d016da6bcdafe5ec14c914b7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89630d016da6bcdafe5ec14c914b7d1">&#9670;&nbsp;</a></span>dumpTaggedData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="group__census.html#ga2bdcfc6c102832450b03bd8a2a36b040" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68aae09c481982555e0a9f744264e8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68aae09c481982555e0a9f744264e8dc">&#9670;&nbsp;</a></span>dumpTaggedData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga560d63b0beaa7dd6e30e443308aac148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga560d63b0beaa7dd6e30e443308aac148">&#9670;&nbsp;</a></span>dumpTaggedData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="group__census.html#gaf1324777ea05d924dad68cc7a66222f6" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga214b8600d6d6d2a802c74042c42e57fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga214b8600d6d6d2a802c74042c42e57fd">&#9670;&nbsp;</a></span>edgeBdryBackup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryBackup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given pentachoron edge. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the pentachoron edge on which to operate; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f190245e1642c2e19cc2af12d170933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f190245e1642c2e19cc2af12d170933">&#9670;&nbsp;</a></span>edgeBdryConsistencyCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryConsistencyCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a number of tests on all pentachoron edges to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class. </p>
<p>Any errors that are identified will be written to standard error. Note that some errors might be harmless (for instance, when a call to <a class="el" href="group__census.html#ga820649b2f87818305105551471cdea27" title="Merges the classes of pentachoron edges as required by the new gluing made at stage orderElt of the s...">mergeEdgeClasses()</a> leaves processing incomplete because it has located a bad edge link and expects the merge to be immediately undone). </p>

</div>
</div>
<a id="ga398d66c70a8b0a45893e8ccb49f5b816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398d66c70a8b0a45893e8ccb49f5b816">&#9670;&nbsp;</a></span>edgeBdryDump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryDump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every edge of every pentachoron to the given output stream. </p>
<p>The output format is relatively compact, and is subject to change in future versions of Regina. The output uses one line only, and a final newline is written.</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f50ff9ee783cb0da38953a641e89cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f50ff9ee783cb0da38953a641e89cb1">&#9670;&nbsp;</a></span>edgeBdryFixAdj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryFixAdj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby pentachoron edges, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given pentachoron edge. </p>
<p>It is assumed that the linking triangle for the given pentachoron edge contributes at least one boundary edge to the 4-manifold edge link. Recall from the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class notes that the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given pentachoron edge describe the boundary edges that follow on in either direction from the boundary edges supplied by this triangle.</p>
<p>This routine locates the pentachoron edges that provide the neighbouring boundary edges of the link, and adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for these neighbouring pentachoron edges to point back to the given pentachoron edge.</p>
<p>This routine is intended to assist with backtracking. This routine is safe to use if the given pentachoron edge points to itself (i.e., it provides a complete boundary cycle of three edges in the 4-manifold edge link).</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The linking triangle for the given pentachoron edge contributes at least one boundary edge to the 4-manifold edge link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the pentachoron edge to examine; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ee6c0ad8b1072fbf419b14879f6a17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee6c0ad8b1072fbf419b14879f6a17a">&#9670;&nbsp;</a></span>edgeBdryJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryJoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adjEdgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the boundary edges supplied by the linking triangles for the two given pentachoron edges should be marked as adjacent. </p>
<p>The <em>bdryNext</em> and <em>bdryTwist</em> arrays for each pentachoron edge will be adjusted to point to the other.</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the first pentachoron edge on which to operate; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
    <tr><td class="paramname">end</td><td>specifies in which direction the adjacent boundary edges lie. This must be either 0 or 1, and its value should correspond to the relevant index in the <em>bdryNext</em> and <em>bdryTwist</em> arrays for edge <em>edgeID</em>. </td></tr>
    <tr><td class="paramname">adjEdgeID</td><td>the pentachoron edge whose boundary edges are adjacent to the boundary edges supplied by <em>edgeID</em>; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
    <tr><td class="paramname">twist</td><td>0 if the orientations of the two boundary segments of edge link are oriented in the same direction, or 1 if they are oriented in opposite directions; see the <em>bdryTwist</em> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga289322ad48ef96c0c788361cfd0cb349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga289322ad48ef96c0c788361cfd0cb349">&#9670;&nbsp;</a></span>edgeBdryLength1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryLength1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one of the edges of the linking triangle for the given pentachoron edge in fact forms an entire one-edge boundary component of the overall 4-manifold edge link. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the pentachoron edge to examine; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a one-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4e8e96adca4df50548b41e7af9bc43f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8e96adca4df50548b41e7af9bc43f6">&#9670;&nbsp;</a></span>edgeBdryLength2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryLength2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether edges of the linking triangles for each of the given pentachoron edges combine to form an entire two-edge boundary component of the overall 4-manifold edge link, with one edge from each triangle. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID1</td><td>the first pentachoron edge to examine; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
    <tr><td class="paramname">edgeID2</td><td>the second pentachoron edge to examine; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a two-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d9efd8dcde17d3d783165e205cb8b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9efd8dcde17d3d783165e205cb8b05">&#9670;&nbsp;</a></span>edgeBdryNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bdryFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming the given edge of the linking triangle for the given pentachoron edge lies on the boundary of the link, this routine identifies the adjacent boundary edges of the link in each direction. </p>
<p>The given edge of the linking triangle must belong to one of the two pentachoron facets currently being joined.</p>
<p>The pentachoron edge to examine is passed in <em>edgeID</em>, <em>pent</em> and <em>edge</em>, and the particular edge of the linking triangle to examine is specified by <em>bdryFacet</em>. Details of the adjacent boundary edges are returned in the arrays <em>next</em> and <em>twist</em>.</p>
<p>Note that the values returned might or might not correspond to the <em>bdryNext</em> and <em>bdryTwist</em> arrays of the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class, since the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> arrays skip over adjacent edges belonging to the same linking triangle.</p>
<p>If the given edge of the linking triangle is not a boundary edge of the 4-manifold edge link, the behaviour of this routine is undefined.</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The pentachoron facet (<em>pent</em>, <em>bdryFacet</em>) is one of the two facets that are currently being joined together. That is, this facet is either order_[orderElt_] or its partner in the underlying pentachoron facet pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the pentachoron edge to examine; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
    <tr><td class="paramname">pent</td><td>the pentachoron described by <em>edgeID</em>; this must be (edgeID / 10). It is passed separately to avoid a slow division operation. </td></tr>
    <tr><td class="paramname">edge</td><td>the pentachoron edge number described by <em>edgeID</em>; this must be (edgeID % 10). It is passed separately to avoid a slow modulus operation. </td></tr>
    <tr><td class="paramname">bdryFacet</td><td>the facet number of the given pentachoron containing the edge of the linking triangle that is under consideration. This must be between 0 and 4 inclusive. </td></tr>
    <tr><td class="paramname">next</td><td>returns the pentachoron edge supplying each adjacent boundary edge of the link; see the <a class="el" href="group__census.html#ga4a8118f45817ac6cbfa26f8eac6c8ee7" title="If the corresponding triangular piece of 4-manifold edge link has any boundary edges,...">PentEdgeState::bdryNext</a> notes for details on which directions correspond to array indices 0 and 1. </td></tr>
    <tr><td class="paramname">twist</td><td>returns whether the orientations of the adjacent boundary edges are consistent with the orientation of this boundary edge; see the <a class="el" href="group__census.html#gabbb926c4d0a235a73c8409739ff1f08c" title="Describes whether the orientation of this boundary segment of the 4-manifold edge link is consistent ...">PentEdgeState::bdryTwist</a> notes for further information on orientations in the link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82bb66171e44a26d63448af638bd6197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82bb66171e44a26d63448af638bd6197">&#9670;&nbsp;</a></span>edgeBdryRestore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeBdryRestore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given pentachoron edge. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the pentachoron edge on which to operate; this must be between 0 and 10n-1 inclusive, where <em>n</em> is the number of pentachora. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22ad74212bf23e7a01971cd40c50b5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ad74212bf23e7a01971cd40c50b5d9">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CensusHits::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there are any hits at all. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list is empty (i.e., there are no hits), or <code>false</code> if the list is non-empty (i.e., there are one or more hits). </dd></dl>

</div>
</div>
<a id="gae83afd05d0f0e761350d8cf74a132135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae83afd05d0f0e761350d8cf74a132135">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> regina::CensusHits::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of this list of hits. </p>
<p>In C++, the <a class="el" href="group__census.html#ga96137581ba7cc8158ba933849a6b800c" title="Returns an iterator at the beginning of this list of hits.">begin()</a> and <a class="el" href="group__census.html#gae83afd05d0f0e761350d8cf74a132135" title="Returns an iterator beyond the end of this list of hits.">end()</a> routines allow you to iterate through an entire list of census hits using C++11 range-based <code>for</code> loops. In Python, a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object can be treated as an iterable object.</p>
<p>See the <a class="el" href="group__census.html#ga96137581ba7cc8158ba933849a6b800c" title="Returns an iterator at the beginning of this list of hits.">begin()</a> documentation for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this list of hits. </dd></dl>

</div>
</div>
<a id="ga6cba6cbbd79d13f8c2337920416b3291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cba6cbbd79d13f8c2337920416b3291">&#9670;&nbsp;</a></span>EulerSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::EulerSearcher </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>useEuler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager that restricts Euler characteristic on the vertex links, as described in the class overview. </p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> documentation. Note in particular that this class will be automatically used by <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">GluingPermSearcher&lt;3&gt;::findAllPerms()</a> if possible, so there is often no need for an end user to instantiate this class directly.</p>
<p>All constructor arguments except for <em>euler</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor, though some arguments (such as <em>finiteOnly</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Euler characteristic is at most 2. </dd>
<dd>
The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useEuler</td><td>the Euler characteristic that vertex links must have. For boundary vertices, this is the Euler characteristic of the closed surface that would be obtained if the puncture in the vertex link were filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc993832f34e7e00be141bcdb6f2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc993832f34e7e00be141bcdb6f2c85">&#9670;&nbsp;</a></span>EulerSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::EulerSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga666143b82a03dcc0a384b6ac46bb9ebd" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaceabd6f42214d77e7cb132e2a37d790f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceabd6f42214d77e7cb132e2a37d790f">&#9670;&nbsp;</a></span>facetPairing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; * <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::facetPairing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a id="gac0e5ad5656e9a24093fc0f088a4b68b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e5ad5656e9a24093fc0f088a4b68b5">&#9670;&nbsp;</a></span>filename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::CensusDB::filename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the filename where this database is stored. </p>
<dl class="section return"><dt>Returns</dt><dd>the database filename. </dd></dl>

</div>
</div>
<a id="gaa0ec9d10baaa81178d6a104455b347d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ec9d10baaa81178d6a104455b347d2">&#9670;&nbsp;</a></span>findAllPerms() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given edge pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> and then calls <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a id="ga6a125fcef3581b87f04eec6eb8044328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a125fcef3581b87f04eec6eb8044328">&#9670;&nbsp;</a></span>findAllPerms() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given face pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> and then calls <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a id="ga8477b1c2800d8c766be3e19f03e54c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8477b1c2800d8c766be3e19f03e54c15">&#9670;&nbsp;</a></span>findAllPerms() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given pentachoron facet pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> and then calls <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any pentachoron from any other pentachoron via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;4&gt;::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;4&gt;::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a id="ga4263924ede95808c20084f6a596489e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4263924ede95808c20084f6a596489e8">&#9670;&nbsp;</a></span>findEdgeClass() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga4263924ede95808c20084f6a596489e8" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly slower but which also tracks edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="ga68af81af372f748e01f1cea1fe262d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68af81af372f748e01f1cea1fe262d55">&#9670;&nbsp;</a></span>findEdgeClass() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga68af81af372f748e01f1cea1fe262d55" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly slower but which also tracks edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="ga90f479e3070fb2c5d88e00e254dde2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f479e3070fb2c5d88e00e254dde2b4">&#9670;&nbsp;</a></span>findEdgeClass() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>The argument <em>twisted</em> is also modified to indicate whether or not the identification of the given edge with the class representative preserves orientation. Note that this arugment is <em>not</em> initialised. Instead, if the identification is orientation-preserving then <em>twisted</em> will be left unmodified, and if it is orientation-reversing then <em>twisted</em> will be changed from 0 to 1 or vice-versa.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga4263924ede95808c20084f6a596489e8" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly faster but which does not track edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
    <tr><td class="paramname">twisted</td><td>used to track edge orientation, as described above. This must be either 0 or 1 as it is passed into the function, and it will also be either 0 or 1 upon returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="ga0d6b44b688c1947d87b6b11f6f34fa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d6b44b688c1947d87b6b11f6f34fa42">&#9670;&nbsp;</a></span>findEdgeClass() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>The argument <em>twisted</em> is also modified to indicate whether or not the identification of the given edge with the class representative preserves orientation. Note that this arugment is <em>not</em> initialised. Instead, if the identification is orientation-preserving then <em>twisted</em> will be left unmodified, and if it is orientation-reversing then <em>twisted</em> will be changed from 0 to 1 or vice-versa.</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga68af81af372f748e01f1cea1fe262d55" title="Returns the representative of the equivalence class containing the given tetrahedron edge.">findEdgeClass()</a>, which is slightly faster but which does not track edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
    <tr><td class="paramname">twisted</td><td>used to track edge orientation, as described above. This must be either 0 or 1 as it is passed into the function, and it will also be either 0 or 1 upon returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="ga00ce5618587eb118ba65131c9652c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ce5618587eb118ba65131c9652c669">&#9670;&nbsp;</a></span>findTriangleClass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::findTriangleClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given pentachoron triangle. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga00ce5618587eb118ba65131c9652c669" title="Returns the representative of the equivalence class containing the given pentachoron triangle.">findTriangleClass()</a>, which is slower but which also tracks triangle rotations and reflections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triID</td><td>the index of a single pentachoron triangle; this must be between 0 and 10p-1 inclusive, where <em>p</em> is the number of pentachora. See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class notes for details on triangle indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the pentachoron triangle at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="gaa3b3ae37270a2f7bd59e09c6053f95f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3b3ae37270a2f7bd59e09c6053f95f6">&#9670;&nbsp;</a></span>findTriangleClass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::findTriangleClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given pentachoron triangle. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>The argument <em>twist</em> is also modified to indicate what rotation or reflection is used to identify vertices (0,1,2) of the given triangle with vertices (0,1,2) of the class representative. Note that this argument is <em>not</em> initialised. Instead, the original <em>twist</em> will be multiplied on the left by the mapping described above.</p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class for further details. See also the other variant of <a class="el" href="group__census.html#ga00ce5618587eb118ba65131c9652c669" title="Returns the representative of the equivalence class containing the given pentachoron triangle.">findTriangleClass()</a>, which is faster but which does not track triangle rotations and reflections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triID</td><td>the index of a single pentachoron triangle; this must be between 0 and 10p-1 inclusive, where <em>p</em> is the number of pentachora. See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class notes for details on triangle indexing. </td></tr>
    <tr><td class="paramname">twist</td><td>used to track triangle rotations and reflections, as described above. This must be a mapping from (0,1,2) to (0,1,2) as it is passed into the function, and it will also be a mapping from (0,1,2) to (0,1,2) upon returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the pentachoron triangle at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a id="gaf7a6169669ab839788131dcbbc0655f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a6169669ab839788131dcbbc0655f0">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> * regina::CensusHits::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first hit in this list. </p>
<p>To continue iterating, you can call <a class="el" href="group__census.html#ga862839100cb9ec760009127603b38f35" title="Returns the next hit for the same triangulation, or null if there are no more hits.">CensusHit::next()</a> upon each individual hit to retrieve the next hit in the list.</p>
<dl class="section return"><dt>Returns</dt><dd>the first hit, or <code>null</code> if there are no hits at all. </dd></dl>

</div>
</div>
<a id="ga6efb577f8be677717e20624a75037de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6efb577f8be677717e20624a75037de6">&#9670;&nbsp;</a></span>gluingPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">facetPairing()</a>). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="ga8621f1370a90132ec44b032c7926066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8621f1370a90132ec44b032c7926066f">&#9670;&nbsp;</a></span>gluingPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">facetPairing()</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="ga747d7a252a077b329e1411c137d220d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747d7a252a077b329e1411c137d220d6">&#9670;&nbsp;</a></span>GluingPerms() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new permutation set. </p>
<p>All internal arrays will be allocated but not initialised.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of simplex facets that this permutation set will complement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66b25211be46c5f7f46f4a2fb0750e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b25211be46c5f7f46f4a2fb0750e21">&#9670;&nbsp;</a></span>GluingPerms() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of gluing permutations that is a clone of the given permutation set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the gluing permutations to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb274fddfacdad1fbe870fa0dba57a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb274fddfacdad1fbe870fa0dba57a51">&#9670;&nbsp;</a></span>GluingPerms() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a new set of gluing permutations from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga46eb76a4d962402f85f52e39aa890137" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga385345c086bce00163471f973fc86e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385345c086bce00163471f973fc86e95">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail, as well as what should be done with each gluing permutation set that is found.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of triangle edges that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given edge pairing, and will generally be the set of all such automorphisms. This parameter may be 0, in which case the set of all automorphisms of the given edge pairing will be generated and used. </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each permutation set that is found. The first parameter passed to this function will be a gluing permutation set. The second parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each permutation set found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4930c57b5c3ea676e189c0f9994a4203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4930c57b5c3ea676e189c0f9994a4203">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail, as well as what should be done with each gluing permutation set that is found.</p>
<p>Parameter <em>whichPurge</em> may be used to avoid constructing permutation sets that correspond to triangulations satisfying certain constraints (such as non-minimality). The use of this parameter, combined with parameters <em>orientableOnly</em> and <em>finiteOnly</em>, can significantly speed up the permutation set generation. For some combinations of these parameters entirely different algorithms are used.</p>
<p>Note that not all permutation sets described by parameter <em>whichPurge</em> will be avoided (i.e., you may get gluing permutation sets that you did not want). It is guaranteed however that every permutation set whose corresonding triangulation does <em>not</em> satisfy the <em>whichPurge</em> constraints will be generated.</p>
<p>Similarly, even if <em>finiteOnly</em> is set to <code>true</code>, some non-finite triangulations might still slip through the net (since the full vertex links are not always constructed). However, like <em>whichPurge</em>, setting <em>finiteOnly</em> to <code>true</code> allow the census algorithm to take shortcuts and therefore run faster. The resulting triangulations may be tested for finiteness (and other properties) by calling <a class="el" href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c" title="Returns a newly created triangulation as modelled by this set of gluing permutations and the associat...">triangulate()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of tetrahedron faces that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given face pairing, and will generally be the set of all such automorphisms. This parameter may be 0, in which case the set of all automorphisms of the given face pairing will be generated and used. </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">finiteOnly</td><td><code>true</code> if only gluing permutations corresponding to finite triangulations are required, or <code>false</code> if there is no such requirement. Note that regardless of this value, some non-finite triangulations might still be produced; see the notes above for details. </td></tr>
    <tr><td class="paramname">whichPurge</td><td>specifies which permutation sets we may avoid constructing (see the function notes above for details). This should be a bitwise OR of constants from the PurgeFlags enumeration, or 0 if we should simply generate every possible permutation set. If a variety of purge constants are bitwise ORed together, a permutation set whose triangulation satisfies <em>any</em> of these constraints may be avoided. Note that not all such permutation sets will be avoided, but enough are avoided that the performance increase is noticeable. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each permutation set that is found. The first parameter passed to this function will be a gluing permutation set. The second parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each permutation set found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b07879c6ec19f7adc3690a05e671efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b07879c6ec19f7adc3690a05e671efc">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 4 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail, as well as what should be done with each gluing permutation set that is found.</p>
<p>The appropriate use of parameters <em>orientableOnly</em> and <em>finiteOnly</em> can significantly speed up the permutation set generation. For some combinations of these parameters entirely different algorithms are used.</p>
<p>Note that even if <em>finiteOnly</em> is set to <code>true</code>, some ideal triangulations might still slip through the net (since the full vertex links are not always constructed). However, setting <em>finiteOnly</em> to <code>true</code> will allow the census algorithm to take shortcuts and therefore run faster. The resulting triangulations may be tested for finiteness (and other properties) by calling <a class="el" href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c" title="Returns a newly created triangulation as modelled by this set of gluing permutations and the associat...">triangulate()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet pairing is connected, i.e., it is possible to reach any pentachoron from any other pentachoron via a series of matched facet pairs. </dd>
<dd>
The given facet pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;4&gt;::isCanonical()</a>. Note that all facet pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;4&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of pentachoron facets that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given facet pairing, and will generally be the set of all such automorphisms. This parameter may be 0, in which case the set of all automorphisms of the given facet pairing will be generated and used. </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">finiteOnly</td><td><code>true</code> if only gluing permutations corresponding to finite (non-ideal) triangulations are required, or <code>false</code> if there is no such requirement. Note that regardless of this value, some ideal triangulations might still be produced; see the notes above for details. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each permutation set that is found. The first parameter passed to this function will be a gluing permutation set. The second parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each permutation set found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79a6f0651ec9f0d269d5e1e8d094f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79a6f0651ec9f0d269d5e1e8d094f75d">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#gad17c98dfbc2842bbf20fd267b806ed9e" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#gad89630d016da6bcdafe5ec14c914b7d1" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga2bdcfc6c102832450b03bd8a2a36b040" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">use</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor. </td></tr>
    <tr><td class="paramname">useArgs</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d2c55d67ab8ea18144a5598c243f334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d2c55d67ab8ea18144a5598c243f334">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">use</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor. </td></tr>
    <tr><td class="paramname">useArgs</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1da29d066d8b1947a9fbd51d0eed8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da29d066d8b1947a9fbd51d0eed8b2e">&#9670;&nbsp;</a></span>GluingPermSearcher() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga7342cde30895f7eb18ab8cdb0342c44f" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga560d63b0beaa7dd6e30e443308aac148" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#gaf1324777ea05d924dad68cc7a66222f6" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">use</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> constructor. </td></tr>
    <tr><td class="paramname">useArgs</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8da0ad1c66af05624ecdd711785e702c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da0ad1c66af05624ecdd711785e702c">&#9670;&nbsp;</a></span>gluingToIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="ga254d849ef372fc0da9c02cf4b3a74a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254d849ef372fc0da9c02cf4b3a74a83">&#9670;&nbsp;</a></span>gluingToIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="ga073ff937768dad9c298dc6ff51912ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073ff937768dad9c298dc6ff51912ec7">&#9670;&nbsp;</a></span>HyperbolicMinSearcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HyperbolicMinSearcher::HyperbolicMinSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager for use when only minimal ideal triangulations of cusped finite-volume hyperbolic 3-manifolds are required. </p>
<p>Here every vertex link will be a torus or Klein bottle. Note that other unwanted triangulations may still be produced (e.g., non-hyperbolic or non-minimal triangulations), but there will be far fewer of these than when using the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> class directly.</p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> documentation.</p>
<p>All constructor arguments are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor, though some arguments (such as <em>finiteOnly</em> and <em>whichPurge</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;3&gt;::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;3&gt;::findAllPairings()</a> are of this form. </dd>
<dd>
The given face pairing has no boundary faces. </dd></dl>

</div>
</div>
<a id="gac23813bb5b76f52c38769b62fc2f1694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23813bb5b76f52c38769b62fc2f1694">&#9670;&nbsp;</a></span>HyperbolicMinSearcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HyperbolicMinSearcher::HyperbolicMinSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga78c9636e863740f51a421e433b9bd8d6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47d0241ebd3fc55fd001b4ac34ccbc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d0241ebd3fc55fd001b4ac34ccbc96">&#9670;&nbsp;</a></span>indexToGluing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a id="ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">&#9670;&nbsp;</a></span>indexToGluing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a id="ga1a0d16509c016c37f87b239b77f1c8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0d16509c016c37f87b239b77f1c8f1">&#9670;&nbsp;</a></span>inputError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad56c8d4d49e8d52aa356fa56f7ed99be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56c8d4d49e8d52aa356fa56f7ed99be">&#9670;&nbsp;</a></span>isCanonical() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying edge pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7e6c6d0cce1efb0335a09ae6bdcd1f">&#9670;&nbsp;</a></span>isCanonical() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad97703a5aefd359352f215bb958558d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad97703a5aefd359352f215bb958558d5">&#9670;&nbsp;</a></span>isCanonical() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying facet pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga51b4382f7a74525c621549b5faaeae92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b4382f7a74525c621549b5faaeae92">&#9670;&nbsp;</a></span>lookup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a>* regina::Census::lookup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>isoSig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the given triangulation through all of Regina's in-built census databases. </p>
<p>For this routine you specify the triangulation by giving its isomorphism signature, as returned by <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">Triangulation&lt;3&gt;::isoSig()</a>. This is faster than the variant <a class="el" href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae" title="Searches for the given triangulation through all of Regina&#39;s in-built census databases.">lookup(const Triangulation&lt;3&gt;&amp;)</a>, since Regina's census databases store isomorphism signatures internally. If you do not already know the isomorphism signature, it is fine to just call <a class="el" href="group__census.html#gaf10e60ed01730474c83c9337c89c41ae" title="Searches for the given triangulation through all of Regina&#39;s in-built census databases.">lookup(const Triangulation&lt;3&gt;&amp;)</a> instead.</p>
<p>Note that there may be many hits (possibly from multiple databases, and in some cases possibly even within the same database). The list of hits will be returned as a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object, which you can use to iterate through the individual matches. Even if there are no matches at all, a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object will still be returned; you can call <a class="el" href="group__census.html#ga22ad74212bf23e7a01971cd40c50b5d9" title="Returns whether there are any hits at all.">CensusHits::empty()</a> to test whether any matches were found.</p>
<p>The <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object that is returned will be newly allocated, and it is the caller's responsibility to destroy it.</p>
<p>This routine is fast: it first computes the isomorphism signature of the triangulation, and then performs a logarithmic-time lookup in each database (here "logarithmic" means logarithmic in the size of the database).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoSig</td><td>the isomorphism signature of the triangulation that you wish to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created list of all database matches. </dd></dl>

</div>
</div>
<a id="gabb5bdd67c6e27bd0d434e52b98c47107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb5bdd67c6e27bd0d434e52b98c47107">&#9670;&nbsp;</a></span>lookup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CensusDB::lookup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>isoSig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1CensusHits.html">CensusHits</a> *&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the given isomorphism signature in this database. </p>
<p>All matches (if any) will be appended to the given list of hits.</p>
<p>Note that the database will be opened and closed every time this routine is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoSig</td><td>the isomorphism signature to search for. </td></tr>
    <tr><td class="paramname">hits</td><td>the list of hits to which all matches will be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lookup was correctly performed, or <code>false</code> if some error occurred (e.g., the database could not be opened). Note in particular that if there were no matches but no errors, then the return value will be <code>true</code>. </dd></dl>

</div>
</div>
<a id="gaf10e60ed01730474c83c9337c89c41ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10e60ed01730474c83c9337c89c41ae">&#9670;&nbsp;</a></span>lookup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1CensusHits.html">CensusHits</a>* regina::Census::lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the given triangulation through all of Regina's in-built census databases. </p>
<p>Internally, the census databases store isomorphism signatures as opposed to fully fleshed-out triangulations. If you already have the isomorphism signature of the triangulation, then you can call the variant <a class="el" href="group__census.html#ga51b4382f7a74525c621549b5faaeae92" title="Searches for the given triangulation through all of Regina&#39;s in-built census databases.">lookup(const std::string&amp;)</a> instead, which will be faster since it avoids some extra overhead.</p>
<p>Note that there may be many hits (possibly from multiple databases, and in some cases possibly even within the same database). The list of hits will be returned as a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object, which you can use to iterate through the individual matches. Even if there are no matches at all, a <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object will still be returned; you can call <a class="el" href="group__census.html#ga22ad74212bf23e7a01971cd40c50b5d9" title="Returns whether there are any hits at all.">CensusHits::empty()</a> to test whether any matches were found.</p>
<p>The <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> object that is returned will be newly allocated, and it is the caller's responsibility to destroy it.</p>
<p>This routine is fast: it first computes the isomorphism signature of the triangulation, and then performs a logarithmic-time lookup in each database (here "logarithmic" means logarithmic in the size of the database).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation that you wish to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created list of all database matches. </dd></dl>

</div>
</div>
<a id="ga9f4089dd2a85f436724655825f082b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f4089dd2a85f436724655825f082b81">&#9670;&nbsp;</a></span>lowDegreeEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::lowDegreeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with a low degree edge. </p>
<p>Precisely which types of low degree edges are identified must be specified through parameters <em>testDegree12</em> and <em>testDegree3</em>.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
    <tr><td class="paramname">testDegree12</td><td><code>true</code> if we should test for non-boundary edges of degree 1 or 2. </td></tr>
    <tr><td class="paramname">testDegree3</td><td><code>true</code> if we should test for non-boundary edges of degree 3 involving three distinct tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a low-degree edge as specified by parameters <em>testDegree12</em> and <em>testDegree3</em>, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a id="ga11b3e60a84f49fdacdc12967dc88e50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11b3e60a84f49fdacdc12967dc88e50c">&#9670;&nbsp;</a></span>mergeEdgeClasses() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::mergeEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details.</p>
<p>This routine returns a boolean that indicates whether this merge creates an invalid edge (i.e., an edge identified with itself in reverse).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this merge creates an invalid edge, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga933487c0bfbb7553b1a29aa52d9eb498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga933487c0bfbb7553b1a29aa52d9eb498">&#9670;&nbsp;</a></span>mergeEdgeClasses() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::mergeEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details.</p>
<p>This routine returns a boolean that indicates whether this merge creates an invalid edge (i.e., an edge identified with itself in reverse).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this merge creates an invalid edge, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga820649b2f87818305105551471cdea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga820649b2f87818305105551471cdea27">&#9670;&nbsp;</a></span>mergeEdgeClasses() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::mergeEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges the classes of pentachoron edges as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for details.</p>
<p>This routine returns a boolean that indicates whether this merge creates an invalid edge (i.e., an edge with identified with itself in reverse, or whose link is something other than a (possibly) punctured 2-sphere).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this merge creates an invalid edge, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga31c692ef09954a76d0e5ed0ba266d4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31c692ef09954a76d0e5ed0ba266d4df">&#9670;&nbsp;</a></span>mergeTriangleClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::mergeTriangleClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges the classes of pentachoron triangles as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class for details.</p>
<p>This routine returns a boolean that indicates whether this merge creates an invalid triangle (i.e., a triangle identified with itself using a non-trivial rotation or reflection).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this merge creates an invalid triangle, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga5f12fdba99f7dd5736b17e8acf2f3f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f12fdba99f7dd5736b17e8acf2f3f9d">&#9670;&nbsp;</a></span>mergeVertexClasses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::mergeVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<p>This routine returns a bitwise (OR) combination of the VLINK_... flags defined earlier in this class. These flags describe what happened to the vertex links during this particular merge. In particular, they note when a vertex link is closed off, or enters a state where it will be forced to have the wrong Euler characteristic.</p>
<dl class="section return"><dt>Returns</dt><dd>a combination of VLINK_... flags describing how the vertex links were changed, or 0 if none of the changes described by these flags were observed. </dd></dl>

</div>
</div>
<a id="gac275f880cb36e0c4b8c7e9222329960f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac275f880cb36e0c4b8c7e9222329960f">&#9670;&nbsp;</a></span>mergeVertexClasses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::mergeVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<p>This routine returns a bitwise (OR) combination of the VLINK_... flags defined earlier in this class. These flags describe what happened to the vertex links during this particular merge. In particular, they note when a vertex link is closed off, or is made into something other than a punctured 2-sphere.</p>
<dl class="section return"><dt>Returns</dt><dd>a combination of VLINK_... flags describing how the vertex links were changed, or 0 if none of the changes described by these flags were observed. </dd></dl>

</div>
</div>
<a id="gac591759fce9ed4c05d7d8a1af4b72743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac591759fce9ed4c05d7d8a1af4b72743">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::CensusHit::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the human-readable name associated with the triangulation in the database. </p>
<p>This typically contains the name of the triangulation and/or the name of the underlying manifold.</p>
<dl class="section return"><dt>Returns</dt><dd>the human-readable name for this hit. </dd></dl>

</div>
</div>
<a id="ga862839100cb9ec760009127603b38f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862839100cb9ec760009127603b38f35">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> * regina::CensusHit::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next hit for the same triangulation, or <code>null</code> if there are no more hits. </p>
<p>Recall that hits are typically returned using the <a class="el" href="classregina_1_1CensusHits.html" title="Stores a list of &quot;hits&quot; indicating all the places in which a given triangulation has been located in ...">CensusHits</a> class, which stores a list of individual <a class="el" href="classregina_1_1CensusHit.html" title="Stores a single &quot;hit&quot; indicating that some given triangulation has been located in one of Regina&#39;s in...">CensusHit</a> objects. To iterate through this list, you should begin by calling <a class="el" href="group__census.html#gaf7a6169669ab839788131dcbbc0655f0" title="Returns the first hit in this list.">CensusHits::first()</a> to retrieve the first hit, and then for each hit call <a class="el" href="group__census.html#ga862839100cb9ec760009127603b38f35" title="Returns the next hit for the same triangulation, or null if there are no more hits.">CensusHit::next()</a> (this function) to retrieve the next hit.</p>
<dl class="section return"><dt>Returns</dt><dd>the next hit after this in the list, or <code>null</code> if this is the last hit. </dd></dl>

</div>
</div>
<a id="gac5ebfeb66287d95387970e3f429eecdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5ebfeb66287d95387970e3f429eecdd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CensusHitIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="ga4616c56b52142a6292444856e32d8247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4616c56b52142a6292444856e32d8247">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1CensusHit.html">CensusHit</a> * regina::CensusHitIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the census hit that this iterator is currently pointing to, or <code>null</code> if this iterator is past-the-end. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current census hit and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current census hit, or <code>null</code> if this iterator is past-the-end. </dd></dl>

</div>
</div>
<a id="ga4d1f59c0ab86f2f53b847e65a7d5c242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d1f59c0ab86f2f53b847e65a7d5c242">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp; regina::CensusHitIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<p>This moves the iterator to point to the next hit for the same triangulation in the census databases, as defined by <a class="el" href="group__census.html#ga862839100cb9ec760009127603b38f35" title="Returns the next hit for the same triangulation, or null if there are no more hits.">CensusHit::next()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current census hit and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga92b5110af488170a2309687da0e59fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b5110af488170a2309687da0e59fa2">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> regina::CensusHitIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<p>This moves the iterator to point to the next hit for the same triangulation in the census databases, as defined by <a class="el" href="group__census.html#ga862839100cb9ec760009127603b38f35" title="Returns the next hit for the same triangulation, or null if there are no more hits.">CensusHit::next()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current census hit and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga7cabc4a68c14dabe46f63baf39cb4c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cabc4a68c14dabe46f63baf39cb4c6f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a>&amp; regina::CensusDB::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given database reference into this object. </p>
<p>The reference that was passed will no longer be usable. </p>

</div>
</div>
<a id="ga0d90f11a578ef9502081434143dc8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d90f11a578ef9502081434143dc8df7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusDB.html">CensusDB</a>&amp; regina::CensusDB::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusDB.html">CensusDB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given database reference. </p>

</div>
</div>
<a id="ga396f30578a5d6cf252b213f673edf86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga396f30578a5d6cf252b213f673edf86b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a>&amp; regina::CensusHitIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="gaab9bb43775dd63a77dee3aa39ac44350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9bb43775dd63a77dee3aa39ac44350">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CensusHitIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1CensusHitIterator.html">CensusHitIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="ga08180f2fcd3c9382de65e8ba4d095da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08180f2fcd3c9382de65e8ba4d095da0">&#9670;&nbsp;</a></span>PentEdgeState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::PentEdgeState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone pentachoron edge in an equivalence class all of its own. </p>
<p>Note that the edge link will be a single triangle with three boundary edges. </p>

</div>
</div>
<a id="ga20e72823da2841bde9a9012cfe53dcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e72823da2841bde9a9012cfe53dcd0">&#9670;&nbsp;</a></span>PentTriangleState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::PentTriangleState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone pentachoron triangle in an equivalence class all of its own. </p>

</div>
</div>
<a id="ga28f6711eb803742af936b68a0680888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f6711eb803742af936b68a0680888f">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="gaeb19364415afbf88d139ee26d5c6d2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb19364415afbf88d139ee26d5c6d2af">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="gaa1eb17b2d09a1fc64176b5eda1e057e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1eb17b2d09a1fc64176b5eda1e057e4">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="ga8d9aa920a0554ac7a26b2baaab25bf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d9aa920a0554ac7a26b2baaab25bf25">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="gabe23322c2fa99b115e369ed3bb83d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe23322c2fa99b115e369ed3bb83d4f5">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetVertexState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#gad82404c59a59f47997ef0d00f1fc3199" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nStates</td><td>the total number of vertex states under consideration (this must be four times the number of tetrahedra). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0054acee7c5eb6435363bd1c57054886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0054acee7c5eb6435363bd1c57054886">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::TetVertexState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#gac4c1732c349de12058f800544081788b" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nStates</td><td>the total number of vertex states under consideration (this must be four times the number of tetrahedra). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga79bfc9bbf3ecfdac9eab9f1d162d6a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79bfc9bbf3ecfdac9eab9f1d162d6a9e">&#9670;&nbsp;</a></span>readData() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga4d118922562342ba63f8cec4b9329109" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nStates</td><td>the total number of edge states under consideration (this must be ten times the number of tetrahedra). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga3cc5eef303e35fa3a841652b7684b0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cc5eef303e35fa3a841652b7684b0ed">&#9670;&nbsp;</a></span>readData() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#gaab6d72926b58e488bc1eed7642d2bfd6" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nStates</td><td>the total number of triangle states under consideration (this must be ten times the number of pentachora). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa71cfd9584873bcae03bee1df4c982dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa71cfd9584873bcae03bee1df4c982dc">&#9670;&nbsp;</a></span>readData() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetEdgeState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#gac9e26f60e3f150239a1fabaee0ae1833" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nTets</td><td>the number of tetrahedra under consideration in the census. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0d3d531a632b43dbb23f8c4681db7413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3d531a632b43dbb23f8c4681db7413">&#9670;&nbsp;</a></span>readData() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::TetEdgeState::readData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills this state with data read from the given input stream. </p>
<p>This routine reads data in the format written by <a class="el" href="group__census.html#ga5209d223e247417f8947d1ad64f4dbaf" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<p>This routine does test for bad input data, but it does <em>not</em> test for end-of-file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">nTets</td><td>the number of tetrahedra under consideration in the census. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if any errors were encountered during reading, or <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga2bdcfc6c102832450b03bd8a2a36b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bdcfc6c102832450b03bd8a2a36b040">&#9670;&nbsp;</a></span>readTaggedData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="group__census.html#gad89630d016da6bcdafe5ec14c914b7d1" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="group__census.html#gad17c98dfbc2842bbf20fd267b806ed9e" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga987cf019e19f63f5a470f59588dd0d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987cf019e19f63f5a470f59588dd0d69">&#9670;&nbsp;</a></span>readTaggedData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;3&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="group__census.html#ga0f3fd032ae3c9ff71d80b2758cf5b978" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1324777ea05d924dad68cc7a66222f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1324777ea05d924dad68cc7a66222f6">&#9670;&nbsp;</a></span>readTaggedData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;4&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 4 &gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="group__census.html#ga560d63b0beaa7dd6e30e443308aac148" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="group__census.html#ga7342cde30895f7eb18ab8cdb0342c44f" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the smae as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b8e405571d84d85002ffe55a40726db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8e405571d84d85002ffe55a40726db">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#gaa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given edge pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga492bd21552c84aaa40f239f48b8b69d2" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e4d7126bf7096e21c92134b59698aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e4d7126bf7096e21c92134b59698aea">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220">regina::HyperbolicMinSearcher</a>, <a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465">regina::ClosedPrimeMinSearcher</a>, <a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">regina::CompactSearcher</a>, and <a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="ga3a33270bfb8b3c36aecaa3cc65422b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a33270bfb8b3c36aecaa3cc65422b37">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga8477b1c2800d8c766be3e19f03e54c15" title="The main entry routine for running a search for all gluing permutation sets that complement a given p...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given facet pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_014_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;4&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga8b3f66fe5f81e571112cb4c3c70f1e10" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga3a33270bfb8b3c36aecaa3cc65422b37" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99e9834f603daca08a2bae6604f58c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99e9834f603daca08a2bae6604f58c52">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::EulerSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220">regina::HyperbolicMinSearcher</a>.</p>

</div>
</div>
<a id="gaf1f3fa096d1bcbacc3a52d3fc28bb503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f3fa096d1bcbacc3a52d3fc28bb503">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::CompactSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga5e4d7126bf7096e21c92134b59698aea">regina::GluingPermSearcher&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465">regina::ClosedPrimeMinSearcher</a>.</p>

</div>
</div>
<a id="ga2c7863fd92f6f17c81a58fd605cdf465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c7863fd92f6f17c81a58fd605cdf465">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::ClosedPrimeMinSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga2c7863fd92f6f17c81a58fd605cdf465" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">regina::CompactSearcher</a>.</p>

</div>
</div>
<a id="ga3895527d2752124702bea7f2982ea220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3895527d2752124702bea7f2982ea220">&#9670;&nbsp;</a></span>runSearch() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::HyperbolicMinSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;3&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="group__census.html#ga3895527d2752124702bea7f2982ea220" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__census.html#ga99e9834f603daca08a2bae6604f58c52">regina::EulerSearcher</a>.</p>

</div>
</div>
<a id="ga052f8788995d20de83982daedffa9868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052f8788995d20de83982daedffa9868">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="gae39fef0d44352e48acbc72179b45d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae39fef0d44352e48acbc72179b45d2f3">&#9670;&nbsp;</a></span>splitEdgeClasses() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::splitEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details. </p>

</div>
</div>
<a id="ga762df77fdee5bb5202e5dc2578a45139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762df77fdee5bb5202e5dc2578a45139">&#9670;&nbsp;</a></span>splitEdgeClasses() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::splitEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for details. </p>

</div>
</div>
<a id="gabd1680291cd1579fab745a265c5f437e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1680291cd1579fab745a265c5f437e">&#9670;&nbsp;</a></span>splitEdgeClasses() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::splitEdgeClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the classes of pentachoron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> class for details. </p>

</div>
</div>
<a id="ga648dbdce8bec58317705493e95ab0835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648dbdce8bec58317705493e95ab0835">&#9670;&nbsp;</a></span>splitTriangleClasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::splitTriangleClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits the classes of pentachoron triangles to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> class for details. </p>

</div>
</div>
<a id="ga7223404529a44de2fc26778be8780264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7223404529a44de2fc26778be8780264">&#9670;&nbsp;</a></span>splitVertexClasses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::splitVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details. </p>

</div>
</div>
<a id="gafe76d64503d19198a82fab9fbba1285e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe76d64503d19198a82fab9fbba1285e">&#9670;&nbsp;</a></span>splitVertexClasses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::splitVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details. </p>

</div>
</div>
<a id="ga567da6d334e99909b2a7990c672c9dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567da6d334e99909b2a7990c672c9dc0">&#9670;&nbsp;</a></span>TetEdgeState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::TetEdgeState::TetEdgeState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone tetrahedron edge in an equivalence class all of its own. </p>

</div>
</div>
<a id="ga3a810e260ed6e2a8f7b042ddb580b7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a810e260ed6e2a8f7b042ddb580b7fa">&#9670;&nbsp;</a></span>TetEdgeState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CompactSearcher::TetEdgeState::TetEdgeState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone tetrahedron edge in an equivalence class all of its own. </p>

</div>
</div>
<a id="ga03fbc7349339abeb42fb3658e5cb8de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03fbc7349339abeb42fb3658e5cb8de3">&#9670;&nbsp;</a></span>TetVertexState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::TetVertexState::TetVertexState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone tetrahedron vertex in an equivalence class all of its own. </p>
<p>Note that the vertex link will be a single triangle with three boundary edges. </p>

</div>
</div>
<a id="ga6cc84bc55b52b4416f94b2cdc1852be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc84bc55b52b4416f94b2cdc1852be8">&#9670;&nbsp;</a></span>TetVertexState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CompactSearcher::TetVertexState::TetVertexState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a standalone tetrahedron vertex in an equivalence class all of its own. </p>
<p>Note that the vertex link will be a single triangle with three boundary edges. </p>

</div>
</div>
<a id="ga48d4e4a6f2423844a747d921e1e8459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d4e4a6f2423844a747d921e1e8459c">&#9670;&nbsp;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<a id="ga6c700666b468422a630e235970b0adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c700666b468422a630e235970b0adb3">&#9670;&nbsp;</a></span>vtxBdryBackup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryBackup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac088ddb578c020c3c9e806427de158aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac088ddb578c020c3c9e806427de158aa">&#9670;&nbsp;</a></span>vtxBdryBackup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryBackup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c895ecdbfb0ac85b999c8fda4d0618e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c895ecdbfb0ac85b999c8fda4d0618e">&#9670;&nbsp;</a></span>vtxBdryConsistencyCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryConsistencyCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class. </p>
<p>Any errors that are identified will be written to standard error. Note that some errors might be harmless (for instance, when a call to <a class="el" href="group__census.html#ga5f12fdba99f7dd5736b17e8acf2f3f9d" title="Merge the classes of tetrahedron vertices as required by the new gluing made at stage orderElt of the...">mergeVertexClasses()</a> leaves processing incomplete because it has located a bad vertex link and expects the merge to be immediately undone). </p>

</div>
</div>
<a id="ga47f48b181c140153c25b69014ec3c368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f48b181c140153c25b69014ec3c368">&#9670;&nbsp;</a></span>vtxBdryConsistencyCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryConsistencyCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class. </p>
<p>Any errors that are identified will be written to standard error. Note that some errors might be harmless (for instance, when a call to <a class="el" href="group__census.html#gac275f880cb36e0c4b8c7e9222329960f" title="Merge the classes of tetrahedron vertices as required by the new gluing made at stage orderElt of the...">mergeVertexClasses()</a> leaves processing incomplete because it has located a bad vertex link and expects the merge to be immediately undone). </p>

</div>
</div>
<a id="ga63ff088f3e12d5e1a0875a33ee7afa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ff088f3e12d5e1a0875a33ee7afa1e">&#9670;&nbsp;</a></span>vtxBdryDump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryDump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream. </p>
<p>The output format is relatively compact, and is subject to change in future versions of Regina. The output uses one line only, and a final newline is written.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae43099ebf5e634f11439eb12be6d9b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43099ebf5e634f11439eb12be6d9b4b">&#9670;&nbsp;</a></span>vtxBdryDump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryDump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream. </p>
<p>The output format is relatively compact, and is subject to change in future versions of Regina. The output uses one line only, and a final newline is written.</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28ace8a1a30044922e99b26d05322d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ace8a1a30044922e99b26d05322d2e">&#9670;&nbsp;</a></span>vtxBdryFixAdj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryFixAdj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex. </p>
<p>It is assumed that the vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link. Recall from the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class notes that the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given vertex describe the boundary edges that follow on in either direction from the boundary edges supplied by this triangle.</p>
<p>This routine locates the tetrahedron vertices that provide the neighbouring boundary edges, and adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for these neighbouring vertices to point back to the given vertex.</p>
<p>This routine is intended to assist with backtracking. This routine is safe to use if the given tetrahedron vertex points to itself (i.e., it provides a complete boundary cycle of three edges in the vertex link).</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31979e14cdda4468520bafc0b5aa3b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31979e14cdda4468520bafc0b5aa3b04">&#9670;&nbsp;</a></span>vtxBdryFixAdj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryFixAdj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex. </p>
<p>It is assumed that the vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link. Recall from the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class notes that the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given vertex describe the boundary edges that follow on in either direction from the boundary edges supplied by this triangle.</p>
<p>This routine locates the tetrahedron vertices that provide the neighbouring boundary edges, and adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for these neighbouring vertices to point back to the given vertex.</p>
<p>This routine is intended to assist with backtracking. This routine is safe to use if the given tetrahedron vertex points to itself (i.e., it provides a complete boundary cycle of three edges in the vertex link).</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7833302676fd4914f22f269e8d7e22fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7833302676fd4914f22f269e8d7e22fc">&#9670;&nbsp;</a></span>vtxBdryJoin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryJoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adjVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent. </p>
<p>The <em>bdryNext</em> and <em>bdryTwist</em> arrays for each vertex will be adjusted to point to the other.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the first tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">end</td><td>specifies in which direction the adjacent boundary edges lie. This must be either 0 or 1, and its value should correspond to the relevant index in the <em>bdryNext</em> and <em>bdryTwist</em> arrays for vertex <em>vertexID</em>. </td></tr>
    <tr><td class="paramname">adjVertexID</td><td>the tetrahedron vertex whose boundary edges are adjacent to the boundary edges supplied by <em>vertexID</em>; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">twist</td><td>0 if the orientations of the two boundary segments of vertex link are oriented in the same direction, or 1 if they are oriented in opposite directions; see the <em>bdryTwist</em> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2d97b7e726fed0edfa487de17fe3895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d97b7e726fed0edfa487de17fe3895">&#9670;&nbsp;</a></span>vtxBdryJoin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryJoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adjVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent. </p>
<p>The <em>bdryNext</em> and <em>bdryTwist</em> arrays for each vertex will be adjusted to point to the other.</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the first tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">end</td><td>specifies in which direction the adjacent boundary edges lie. This must be either 0 or 1, and its value should correspond to the relevant index in the <em>bdryNext</em> and <em>bdryTwist</em> arrays for vertex <em>vertexID</em>. </td></tr>
    <tr><td class="paramname">adjVertexID</td><td>the tetrahedron vertex whose boundary edges are adjacent to the boundary edges supplied by <em>vertexID</em>; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">twist</td><td>0 if the orientations of the two boundary segments of vertex link are oriented in the same direction, or 1 if they are oriented in opposite directions; see the <em>bdryTwist</em> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4db63d8c457efcd61a1482c9e3e5adfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db63d8c457efcd61a1482c9e3e5adfb">&#9670;&nbsp;</a></span>vtxBdryLength1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::vtxBdryLength1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a one-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab1e9cf39a6be337c436128f7a7ff6db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e9cf39a6be337c436128f7a7ff6db7">&#9670;&nbsp;</a></span>vtxBdryLength1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::vtxBdryLength1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a one-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga7bdf8a49a3781f74df7c170b2f215d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bdf8a49a3781f74df7c170b2f215d57">&#9670;&nbsp;</a></span>vtxBdryLength2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::vtxBdryLength2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID1</td><td>the first tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">vertexID2</td><td>the second tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a two-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gac20ad95521261ade949844c625197ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20ad95521261ade949844c625197ad3">&#9670;&nbsp;</a></span>vtxBdryLength2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::vtxBdryLength2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID1</td><td>the first tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">vertexID2</td><td>the second tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a two-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab0b6068d0c65bc433bebb9b04fa21093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b6068d0c65bc433bebb9b04fa21093">&#9670;&nbsp;</a></span>vtxBdryNext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bdryFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction. </p>
<p>The given edge of the vertex linking triangle must belong to one of the two tetrahedron faces currently being joined.</p>
<p>The tetrahedron vertex to examine is passed in <em>vertexID</em>, <em>tet</em> and <em>vertex</em>, and the particular edge of the vertex linking triangle to examine is specified by <em>bdryFace</em>. Details of the adjacent boundary edges are returned in the arrays <em>next</em> and <em>twist</em>.</p>
<p>Note that the values returned might or might not correspond to the <em>bdryNext</em> and <em>bdryTwist</em> arrays of the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class, since the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> arrays skip over adjacent edges belonging to the same vertex linking triangle.</p>
<p>If the given edge of the vertex linking triangle is not a boundary edge of the vertex link, the behaviour of this routine is undefined.</p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tetrahedron face (<em>tet</em>, <em>bdryFace</em>) is one of the two faces that are currently being joined together. That is, this face is either order[orderElt] or its partner in the underlying face pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">tet</td><td>the tetrahedron described by <em>vertexID</em>; this must be (vertexID / 4). It is passed separately to avoid a slow division operation. </td></tr>
    <tr><td class="paramname">vertex</td><td>the tetrahedron vertex number described by <em>vertexID</em>; this must be (vertexID % 4). It is passed separately to avoid a slow modulus operation. </td></tr>
    <tr><td class="paramname">bdryFace</td><td>the face number of the given tetrahedron containing the edge of the vertex linking triangle that is under consideration. This must be between 0 and 3 inclusive, and it may not be equal to <em>vertex</em>. </td></tr>
    <tr><td class="paramname">next</td><td>returns the tetrahedron vertex supplying each adjacent boundary edge; see the <a class="el" href="group__census.html#gaf8773dd8d46d9178907432360c2ae182" title="If the corresponding triangular piece of vertex link has any boundary edges, bdryNext stores the indi...">TetVertexState::bdryNext</a> notes for details on which directions correspond to array indices 0 and 1. </td></tr>
    <tr><td class="paramname">twist</td><td>returns whether the orientations of the adjacent boundary edges are consistent with the orientation of this boundary edge; see the <a class="el" href="group__census.html#ga5cf573efd973f2236d51ba379187d05f" title="Describes whether the orientation of this boundary segment of the vertex link is consistent with the ...">TetVertexState::bdryTwist</a> notes for further information on orientations in the vertex link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95813159f052c7d9651006074a518dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95813159f052c7d9651006074a518dc4">&#9670;&nbsp;</a></span>vtxBdryNext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bdryFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction. </p>
<p>The given edge of the vertex linking triangle must belong to one of the two tetrahedron faces currently being joined.</p>
<p>The tetrahedron vertex to examine is passed in <em>vertexID</em>, <em>tet</em> and <em>vertex</em>, and the particular edge of the vertex linking triangle to examine is specified by <em>bdryFace</em>. Details of the adjacent boundary edges are returned in the arrays <em>next</em> and <em>twist</em>.</p>
<p>Note that the values returned might or might not correspond to the <em>bdryNext</em> and <em>bdryTwist</em> arrays of the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class, since the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> arrays skip over adjacent edges belonging to the same vertex linking triangle.</p>
<p>If the given edge of the vertex linking triangle is not a boundary edge of the vertex link, the behaviour of this routine is undefined.</p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tetrahedron face (<em>tet</em>, <em>bdryFace</em>) is one of the two faces that are currently being joined together. That is, this face is either order[orderElt] or its partner in the underlying face pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">tet</td><td>the tetrahedron described by <em>vertexID</em>; this must be (vertexID / 4). It is passed separately to avoid a slow division operation. </td></tr>
    <tr><td class="paramname">vertex</td><td>the tetrahedron vertex number described by <em>vertexID</em>; this must be (vertexID % 4). It is passed separately to avoid a slow modulus operation. </td></tr>
    <tr><td class="paramname">bdryFace</td><td>the face number of the given tetrahedron containing the edge of the vertex linking triangle that is under consideration. This must be between 0 and 3 inclusive, and it may not be equal to <em>vertex</em>. </td></tr>
    <tr><td class="paramname">next</td><td>returns the tetrahedron vertex supplying each adjacent boundary edge; see the <a class="el" href="group__census.html#ga32bf50adb9ea0bff43f45bf57df13c0e" title="If the corresponding triangular piece of vertex link has any boundary edges, bdryNext stores the indi...">TetVertexState::bdryNext</a> notes for details on which directions correspond to array indices 0 and 1. </td></tr>
    <tr><td class="paramname">twist</td><td>returns whether the orientations of the adjacent boundary edges are consistent with the orientation of this boundary edge; see the <a class="el" href="group__census.html#ga42aa231dab77d54d9c980ef802f6f822" title="Describes whether the orientation of this boundary segment of the vertex link is consistent with the ...">TetVertexState::bdryTwist</a> notes for further information on orientations in the vertex link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae77be74512daf7efdc118ab29dafb690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77be74512daf7efdc118ab29dafb690">&#9670;&nbsp;</a></span>vtxBdryRestore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::EulerSearcher::vtxBdryRestore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ffbb57a869d61b80f4c75ea6e4776d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ffbb57a869d61b80f4c75ea6e4776d5">&#9670;&nbsp;</a></span>vtxBdryRestore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::CompactSearcher::vtxBdryRestore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab14b058fa53661b829fdfd73a54017a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab14b058fa53661b829fdfd73a54017a0">&#9670;&nbsp;</a></span>~CensusHits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CensusHits::~CensusHits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object and all of the individual <a class="el" href="classregina_1_1CensusHit.html" title="Stores a single &quot;hit&quot; indicating that some given triangulation has been located in one of Regina&#39;s in...">CensusHit</a> objects that it contains. </p>

</div>
</div>
<a id="gae9a3aa9f803b56aba6cd774f348355b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a3aa9f803b56aba6cd774f348355b9">&#9670;&nbsp;</a></span>~ClosedPrimeMinSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ClosedPrimeMinSearcher::~ClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<a id="gaa17d63870ed80ed980f5f5733881b641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17d63870ed80ed980f5f5733881b641">&#9670;&nbsp;</a></span>~CompactSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::CompactSearcher::~CompactSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<a id="gab63b0cf3b75f5a6a138da1b1360bd4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab63b0cf3b75f5a6a138da1b1360bd4d0">&#9670;&nbsp;</a></span>~EulerSearcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::EulerSearcher::~EulerSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<a id="ga5d584bf4ffb32f2227db4310fd12997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d584bf4ffb32f2227db4310fd12997e">&#9670;&nbsp;</a></span>~GluingPerms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1GluingPerms.html">GluingPerms</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates any memory used by this structure. </p>

</div>
</div>
<a id="ga694a3184398855d061d3391e372abaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694a3184398855d061d3391e372abaf7">&#9670;&nbsp;</a></span>~GluingPermSearcher() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::~<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<a id="ga20b7a99b96a260e7afe855ba9ce24acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20b7a99b96a260e7afe855ba9ce24acf">&#9670;&nbsp;</a></span>~GluingPermSearcher() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::~<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<a id="gaf772d7783f505c1a95668b4f39cce0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf772d7783f505c1a95668b4f39cce0b5">&#9670;&nbsp;</a></span>~GluingPermSearcher() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::~<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga212ff03da851218638fb2a958aa2a13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212ff03da851218638fb2a958aa2a13b">&#9670;&nbsp;</a></span>autos_ <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;2&gt;::IsoList* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying edge pairing. </p>

</div>
</div>
<a id="gad99ec414c677a67e55ed8588316fcf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad99ec414c677a67e55ed8588316fcf88">&#9670;&nbsp;</a></span>autos_ <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;3&gt;::IsoList* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying face pairing. </p>

</div>
</div>
<a id="ga0f4b34d3bd6dedfc0adc460c167148cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f4b34d3bd6dedfc0adc460c167148cb">&#9670;&nbsp;</a></span>autos_ <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;4&gt;::IsoList* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying facet pairing. </p>

</div>
</div>
<a id="ga739f16439d7567092d2929bc8f3fe65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga739f16439d7567092d2929bc8f3fe65d">&#9670;&nbsp;</a></span>autosNew <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::autosNew</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a id="ga924106126b7edca7b1b337d52abad3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924106126b7edca7b1b337d52abad3c2">&#9670;&nbsp;</a></span>autosNew <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::autosNew</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a id="ga554bf3960e33083dead41024771c2d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554bf3960e33083dead41024771c2d2c">&#9670;&nbsp;</a></span>autosNew_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::autosNew_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a id="ga3c89ae1f07dd479076a05a57bdd6caa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c89ae1f07dd479076a05a57bdd6caa4">&#9670;&nbsp;</a></span>bdry <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::TetVertexState::bdry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of boundary edges in the vertex link for this equivalence class of vertices. </p>
<p>Any face whose gluing permutation has not yet been decided is treated as a boundary face. This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="gac50987067c0feb4f14c1234e4d8582ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50987067c0feb4f14c1234e4d8582ab">&#9670;&nbsp;</a></span>bdry <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::TetVertexState::bdry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of boundary edges in the vertex link for this equivalence class of vertices. </p>
<p>Any face whose gluing permutation has not yet been decided is treated as a boundary face. This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="ga9142955f7fad791d9fbf841e0ca4ef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9142955f7fad791d9fbf841e0ca4ef2e">&#9670;&nbsp;</a></span>bdry <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of boundary triangle edges in the link for this equivalence class of pentachoron edges. </p>
<p>Any pentachoron facet whose gluing permutation has not yet been decided is treated as a boundary facet. This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="gaf5b8bbdc0dea2409700b8746ebe1119e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5b8bbdc0dea2409700b8746ebe1119e">&#9670;&nbsp;</a></span>bdryEdges <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char regina::EulerSearcher::TetVertexState::bdryEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link. </p>
<p>Equivalently, this measures the number of faces of this tetrahedron meeting this vertex that are not yet joined to their partner faces. This always takes the value 0, 1, 2 or 3. </p>

</div>
</div>
<a id="ga42ac67cd0685d17a27f433847b891f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ac67cd0685d17a27f433847b891f0a">&#9670;&nbsp;</a></span>bdryEdges <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char regina::CompactSearcher::TetVertexState::bdryEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges of the triangular piece of vertex link that are in fact boundary edges of the vertex link. </p>
<p>Equivalently, this measures the number of faces of this tetrahedron meeting this vertex that are not yet joined to their partner faces. This always takes the value 0, 1, 2 or 3. </p>

</div>
</div>
<a id="ga7cdd4a71c01dd25f84300ec51f690bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cdd4a71c01dd25f84300ec51f690bfc">&#9670;&nbsp;</a></span>bdryEdges <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdryEdges</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges of the triangular piece of 4-manifold edge link that are in fact boundary edges of this link. </p>
<p>Equivalently, this measures the number of facets of this pentachoron meeting this pentachoron edge that are not yet joined to their partner facets. This always takes the value 0, 1, 2 or 3. </p>

</div>
</div>
<a id="gaf8773dd8d46d9178907432360c2ae182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8773dd8d46d9178907432360c2ae182">&#9670;&nbsp;</a></span>bdryNext <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetVertexState::bdryNext[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment. </p>
<p>Note that in most cases (see below) this is not the present vertex. For instance, if this vertex provides two boundary edges, then this array describes the boundary before the first edge and after the second.</p>
<p>The boundary segment described by <em>bdryNext</em>[1] follows on from this segment in the direction described by the <em>vertexLinkNextFace</em> array. The boundary segment in the other direction is described by <em>bdryNext</em>[0].</p>
<p>If the vertex link is just this one triangle (i.e., all three faces of this tetrahedron surrounding this vertex are boundary faces, or one is a boundary and the other two are joined together), then both elements of <em>bdryNext</em> refer to this vertex itself. These are the only situations in which <em>bdryNext</em> refers back to this vertex.</p>
<p>If the triangle is internal to the vertex link (i.e., <em>bdryEdges</em> is zero), then this array maintains the last values it had when there was at least one boundary edge earlier in the search.</p>
<p>Each element of this array lies between 0 and 4t-1 inclusive, where <em>t</em> is the total number of tetrahedra. </p>

</div>
</div>
<a id="ga32bf50adb9ea0bff43f45bf57df13c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32bf50adb9ea0bff43f45bf57df13c0e">&#9670;&nbsp;</a></span>bdryNext <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::TetVertexState::bdryNext[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the corresponding triangular piece of vertex link has any boundary edges, <em>bdryNext</em> stores the indices of the tetrahedron vertices that provide the boundary edges following on from either end of this boundary segment. </p>
<p>Note that in most cases (see below) this is not the present vertex. For instance, if this vertex provides two boundary edges, then this array describes the boundary before the first edge and after the second.</p>
<p>The boundary segment described by <em>bdryNext</em>[1] follows on from this segment in the direction described by the <em>vertexLinkNextFace</em> array. The boundary segment in the other direction is described by <em>bdryNext</em>[0].</p>
<p>If the vertex link is just this one triangle (i.e., all three faces of this tetrahedron surrounding this vertex are boundary faces, or one is a boundary and the other two are joined together), then both elements of <em>bdryNext</em> refer to this vertex itself. These are the only situations in which <em>bdryNext</em> refers back to this vertex.</p>
<p>If the triangle is internal to the vertex link (i.e., <em>bdryEdges</em> is zero), then this array maintains the last values it had when there was at least one boundary edge earlier in the search.</p>
<p>Each element of this array lies between 0 and 4t-1 inclusive, where <em>t</em> is the total number of tetrahedra. </p>

</div>
</div>
<a id="ga4a8118f45817ac6cbfa26f8eac6c8ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8118f45817ac6cbfa26f8eac6c8ee7">&#9670;&nbsp;</a></span>bdryNext <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdryNext[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the corresponding triangular piece of 4-manifold edge link has any boundary edges, <em>bdryNext</em> stores the indices of the pentachoron edges that provide the boundary edges following on from either end of this boundary segment. </p>
<p>Note that in most cases (see below) this is not the present pentachoron edge. For instance, if this pentachoron edge provides two boundary edges for the edge link, then this array describes the boundary before the first edge and after the second.</p>
<p>The boundary segment described by <em>bdryNext</em>[1] follows on from this segment in the direction described by the <em>edgeLinkNextFacet</em> array. The boundary segment in the other direction is described by <em>bdryNext</em>[0].</p>
<p>If the 4-manifold edge link is just this one triangle (i.e., all three facets of this pentachoron surrounding this edge are boundary facets, or one is a boundary and the other two are joined together), then both elements of <em>bdryNext</em> refer to this pentachoron edge itself. These are the only situations in which <em>bdryNext</em> refers back to this pentachoron edge.</p>
<p>If the triangle is internal to the 4-manifold edge link (i.e., <em>bdryEdges</em> is zero), then this array maintains the last values it had when there was at least one boundary edge earlier in the search.</p>
<p>Each element of this array lies between 0 and 10p-1 inclusive, where <em>p</em> is the total number of pentachora. </p>

</div>
</div>
<a id="ga0655bd26c1bdf04a55eed120ccc05937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0655bd26c1bdf04a55eed120ccc05937">&#9670;&nbsp;</a></span>bdryNextOld <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetVertexState::bdryNextOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="ga56615b1173cda5c323ad69a6c412a699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56615b1173cda5c323ad69a6c412a699">&#9670;&nbsp;</a></span>bdryNextOld <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::TetVertexState::bdryNextOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="ga6d3ec11c442d921ced6b859db20140b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3ec11c442d921ced6b859db20140b7">&#9670;&nbsp;</a></span>bdryNextOld <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdryNextOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryNext</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="ga5cf573efd973f2236d51ba379187d05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf573efd973f2236d51ba379187d05f">&#9670;&nbsp;</a></span>bdryTwist <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::bdryTwist[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side. </p>
<p>See <em>bdryNext</em> for further discussion of boundary segments. The <em>bdryNext</em> array defines an orientation for this section of vertex link, pointing from the end described by <em>bdryNext</em>[0] to the end described by <em>bdryNext</em>[1].</p>
<p>For each <em>i</em>, the value <em>bdryTwist</em>[i] is 0 if the orientation of the adjacent segment described by <em>bdryNext</em>[i] is the same as this segment (as defined by the <em>bdryNext</em> values stored with the adjacent vertex), or 1 if the orientations differ.</p>
<p>If the triangle supplied by this vertex is internal to the vertex link, this array maintains the last values it had when there was at least one boundary edge earlier in the search (just like the <em>bdryNext</em> array). </p>

</div>
</div>
<a id="ga42aa231dab77d54d9c980ef802f6f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42aa231dab77d54d9c980ef802f6f822">&#9670;&nbsp;</a></span>bdryTwist <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::CompactSearcher::TetVertexState::bdryTwist[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes whether the orientation of this boundary segment of the vertex link is consistent with the orientation of the adjacent segments on either side. </p>
<p>See <em>bdryNext</em> for further discussion of boundary segments. The <em>bdryNext</em> array defines an orientation for this section of vertex link, pointing from the end described by <em>bdryNext</em>[0] to the end described by <em>bdryNext</em>[1].</p>
<p>For each <em>i</em>, the value <em>bdryTwist</em>[i] is 0 if the orientation of the adjacent segment described by <em>bdryNext</em>[i] is the same as this segment (as defined by the <em>bdryNext</em> values stored with the adjacent vertex), or 1 if the orientations differ.</p>
<p>If the triangle supplied by this vertex is internal to the vertex link, this array maintains the last values it had when there was at least one boundary edge earlier in the search (just like the <em>bdryNext</em> array). </p>

</div>
</div>
<a id="gabbb926c4d0a235a73c8409739ff1f08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb926c4d0a235a73c8409739ff1f08c">&#9670;&nbsp;</a></span>bdryTwist <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdryTwist[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes whether the orientation of this boundary segment of the 4-manifold edge link is consistent with the orientation of the adjacent segments on either side. </p>
<p>See <em>bdryNext</em> for further discussion of boundary segments. The <em>bdryNext</em> array defines an orientation for this section of 4-manifold edge link, pointing from the end described by <em>bdryNext</em>[0] to the end described by <em>bdryNext</em>[1].</p>
<p>For each <em>i</em>, the value <em>bdryTwist</em>[i] is 0 if the orientation of the adjacent segment described by <em>bdryNext</em>[i] is the same as this segment (as defined by the <em>bdryNext</em> values stored with the adjacent pentachoron edge), or 1 if the orientations differ.</p>
<p>If the triangle supplied by this pentachoron edge is internal to the edge link, this array maintains the last values it had when there was at least one boundary edge earlier in the search (just like the <em>bdryNext</em> array). </p>

</div>
</div>
<a id="gaa654cd4ef912a6762cd4351254d32fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa654cd4ef912a6762cd4351254d32fc4">&#9670;&nbsp;</a></span>bdryTwistOld <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::bdryTwistOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="gac1427d1cd33eb496fa2d36e04e1e71e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1427d1cd33eb496fa2d36e04e1e71e4">&#9670;&nbsp;</a></span>bdryTwistOld <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::CompactSearcher::TetVertexState::bdryTwistOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="gae3a0b8ad3f5746ce0ffcee0374dec856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3a0b8ad3f5746ce0ffcee0374dec856">&#9670;&nbsp;</a></span>bdryTwistOld <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::bdryTwistOld[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a snapshot of the values in the <em>bdryTwist</em> array from the last point in the search when <em>bdryEdges</em> was precisely two. </p>
<p>If <em>bdryEdges</em> is still two or three, then this array is undefined. </p>

</div>
</div>
<a id="ga973b59e72d2662b25c8981b9049451c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973b59e72d2662b25c8981b9049451c4">&#9670;&nbsp;</a></span>bounded <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetEdgeState::bounded</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this equivalence class of tetrahedron edges represent a boundary edge? </p>
<p>If this equivalence class describes a complete loop of tetrahedron edges then the value of <em>bounded</em> is <code>false</code>. If this equivalence class describes a string of tetrahedron edges with two endpoints, the value of <em>bounded</em> is <code>true</code>. Here we treat any face whose gluing permutation has not yet been decided as a boundary face.</p>
<p>This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="gaad755014bbde4ef654613b1c15145e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad755014bbde4ef654613b1c15145e69">&#9670;&nbsp;</a></span>bounded <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::TetEdgeState::bounded</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this equivalence class of tetrahedron edges represent a boundary edge? </p>
<p>If this equivalence class describes a complete loop of tetrahedron edges then the value of <em>bounded</em> is <code>false</code>. If this equivalence class describes a string of tetrahedron edges with two endpoints, the value of <em>bounded</em> is <code>true</code>. Here we treat any face whose gluing permutation has not yet been decided as a boundary face.</p>
<p>This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="gad4062b02bcfba18d65793e72f066526a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4062b02bcfba18d65793e72f066526a">&#9670;&nbsp;</a></span>bounded <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::bounded</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this equivalence class of pentachoron triangles represent a boundary triangle? </p>
<p>If this equivalence class describes a complete loop of pentachoron triangles then the value of <em>bounded</em> is <code>false</code>. If this equivalence class describes a string of pentachoron triangles with two endpoints, the value of <em>bounded</em> is <code>true</code>. Here we treat any facet whose gluing permutation has not yet been decided as a boundary facet.</p>
<p>This value is only maintained correctly for the root of the corresponding object tree; other objects in the tree will have older values to facilitate backtracking. </p>

</div>
</div>
<a id="ga60fa11fd71fce2ac44c97eeb79a723e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fa11fd71fce2ac44c97eeb79a723e6">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga41684f2905a97147c96196a484cda0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41684f2905a97147c96196a484cda0bd">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga9cd83aa21dda12aa6454d82260003be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd83aa21dda12aa6454d82260003be4">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::EulerSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="gad5b7628164ce0e0c14232abfe3150ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7628164ce0e0c14232abfe3150ce4">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::CompactSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga192e63b74c737da78c17e73e26dc65cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192e63b74c737da78c17e73e26dc65cf">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::ClosedPrimeMinSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga53e9bdf9251a60378232e959d3db0649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e9bdf9251a60378232e959d3db0649">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::HyperbolicMinSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga16b60607f33ff68f842b317fddbd7d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b60607f33ff68f842b317fddbd7d5a">&#9670;&nbsp;</a></span>dataTag_ <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a id="ga0b2c269282168447863eb54b54fd9579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2c269282168447863eb54b54fd9579">&#9670;&nbsp;</a></span>edgeLinkNextFacet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeLinkNextFacet[10][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains an ordering of the three pentachoron facets surrounding an edge in a pentachoron. </p>
<p>This ordering is consistent with the orientations of triangles in the edge link used by PentEdgeState::twistUp.</p>
<p>For edge e (0..9), the pentachoron facet that follows f (0..5) in this ordering is <em>edgeLinkNextFacet</em>[e][f]. Note that 2/5 of the values in this array remain unaccounted for; these remaining values are set to -1. </p>

</div>
</div>
<a id="gab41212ebcef7b83eead004afbf077b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab41212ebcef7b83eead004afbf077b22">&#9670;&nbsp;</a></span>edgeLinkPrevFacet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeLinkPrevFacet[10][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides backwards links for the ordering described by <em>edgeLinkNextFacet</em>. </p>
<p>For edge e (0..9), the pentachoron facet that follows f (0..5) in this ordering is <em>edgeLinkPrevFacet</em>[e][f]. Again 2/5 of the values in this array remain unaccounted for, and these remaining values are set to -1. </p>

</div>
</div>
<a id="ga7cae928a1464153e1e3a4d438cee59d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cae928a1464153e1e3a4d438cee59d5">&#9670;&nbsp;</a></span>edgeState <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html">TetEdgeState</a>* regina::EulerSearcher::edgeState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron edges. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> description for details. This array has size 6n, where edge e of tetrahedron t has index 6t+e. </p>

</div>
</div>
<a id="gab2dbdcdd9bcbab1d2686808a2d7c2d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2dbdcdd9bcbab1d2686808a2d7c2d50">&#9670;&nbsp;</a></span>edgeState <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a>* regina::CompactSearcher::edgeState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron edges. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> description for details. This array has size 6n, where edge e of tetrahedron t has index 6t+e. </p>

</div>
</div>
<a id="ga9daf8b6c1ce6b437dbbd294612d56b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9daf8b6c1ce6b437dbbd294612d56b96">&#9670;&nbsp;</a></span>edgeState_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PentEdgeState* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeState_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified pentachoron edges. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentEdgeState.html" title="A structure used to track equivalence classes of pentachoron edges as the gluing permutation set is c...">PentEdgeState</a> description for details. This array has size 10n, where edge e of pentachoron p has index 10p+e. </p>

</div>
</div>
<a id="gabea0e3d13f406561cc97c078ba7a3553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabea0e3d13f406561cc97c078ba7a3553">&#9670;&nbsp;</a></span>edgeStateChanged <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::EulerSearcher::edgeStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the edgeState[] array has been updated over time. </p>
<p>This array has size 8n. Suppose the gluing for order[i] affects face f of tetrahedron t. Then element 4i+v of this array describes how the gluing for order[i] affects the edge of tetrahedron t opposite vertices f and v (note that a quarter of this array will remain unused, since f and v are never equal).</p>
<p>If this identification of edges results in the tree with root edgeState[p] being grafted beneath the tree with root edgeState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="gaa1feea9d0c86a4582d091745b8883a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1feea9d0c86a4582d091745b8883a18">&#9670;&nbsp;</a></span>edgeStateChanged <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::CompactSearcher::edgeStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the edgeState[] array has been updated over time. </p>
<p>This array has size 8n. Suppose the gluing for order[i] affects face f of tetrahedron t. Then element 4i+v of this array describes how the gluing for order[i] affects the edge of tetrahedron t opposite vertices f and v (note that a quarter of this array will remain unused, since f and v are never equal).</p>
<p>If this identification of edges results in the tree with root edgeState[p] being grafted beneath the tree with root edgeState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="ga6144b675b94702dd750719578ee20da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6144b675b94702dd750719578ee20da7">&#9670;&nbsp;</a></span>edgeStateChanged_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::edgeStateChanged_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the edgeState_[] array has been updated over time. </p>
<p>This array has size 25n. Suppose the gluing for order[i] affects facet k of pentachoron p. Then element 10i+e of this array describes how the gluing for order[i] affects edge e of pentachoron p. Note that almost half of this array will remain unused, since only six edges of a pentachoron are affected by any one gluing.</p>
<p>If this identification of edges results in the tree with root edgeState_[x] being grafted beneath the tree with root edgeState_[y], this array will store the value x. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="gadf4115df4efb2da5dbc1fd3e31df210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf4115df4efb2da5dbc1fd3e31df210f">&#9670;&nbsp;</a></span>euler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetVertexState::euler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Euler characteristic that the vertex link would have if its punctures were all filled. </p>
<p>As above, this value is only maintained correctly for the root of the corresponding object tree. </p>

</div>
</div>
<a id="ga642c9886af812c5fb4b30273f60e89d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga642c9886af812c5fb4b30273f60e89d8">&#9670;&nbsp;</a></span>euler_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::euler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Euler characteristic that vertex links must have. </p>
<p>For boundary vertices, this is the Euler characteristic of the closed surface that would be obtained if the puncture in the vertex link were filled. </p>

</div>
</div>
<a id="ga3331084de89494501ee6d6de3d5aa7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3331084de89494501ee6d6de3d5aa7a4">&#9670;&nbsp;</a></span>facesNeg <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a> regina::EulerSearcher::TetEdgeState::facesNeg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how many times this edge runs along the boundary of each tetrahedron face in the negative direction. </p>
<p>Specifically, the (4t+i)th trit counts how many times it runs in the negative direction around the boundary of face <em>i</em> of tetrahedron <em>t</em>. Which direction is "negative" is chosen arbitrarily for each face; for details see the implementation of the <a class="el" href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link...">EulerSearcher</a> constructor.</p>
<p>Because of the fixed-size data type, this only stores information for the faces of the first 16 tetrahedra.</p>
<p>Currently this data member is initialised by the <a class="el" href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link...">EulerSearcher</a> constructors (since it belongs to <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a>), but it is only used and updated in the subclass <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> (where it allows us to optimise the census algorithm). </p>

</div>
</div>
<a id="ga7b68879fb13d0deb92a0e918a19de264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b68879fb13d0deb92a0e918a19de264">&#9670;&nbsp;</a></span>facesNeg <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a> regina::CompactSearcher::TetEdgeState::facesNeg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how many times this edge runs along the boundary of each tetrahedron face in the negative direction. </p>
<p>Specifically, the (4t+i)th trit counts how many times it runs in the negative direction around the boundary of face <em>i</em> of tetrahedron <em>t</em>. Which direction is "negative" is chosen arbitrarily for each face; for details see the implementation of the <a class="el" href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f...">CompactSearcher</a> constructor.</p>
<p>Because of the fixed-size data type, this only stores information for the faces of the first 16 tetrahedra.</p>
<p>Currently this data member is initialised by the <a class="el" href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f...">CompactSearcher</a> constructors (since it belongs to <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a>), but it is only used and updated in the subclass <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> (where it allows us to optimise the census algorithm). </p>

</div>
</div>
<a id="gae13d7ef363eb1b6029ce4d2547c6525e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13d7ef363eb1b6029ce4d2547c6525e">&#9670;&nbsp;</a></span>facesPos <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a> regina::EulerSearcher::TetEdgeState::facesPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how many times this edge runs along the boundary of each tetrahedron face in the positive direction. </p>
<p>Specifically, the (4t+i)th trit counts how many times it runs in the positive direction around the boundary of face <em>i</em> of tetrahedron <em>t</em>. Which direction is "positive" is chosen arbitrarily for each face; for details see the implementation of the <a class="el" href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link...">EulerSearcher</a> constructor.</p>
<p>Because of the fixed-size data type, this only stores information for the faces of the first 16 tetrahedra.</p>
<p>Currently this data member is initialised by the <a class="el" href="classregina_1_1EulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link...">EulerSearcher</a> constructors (since it belongs to <a class="el" href="structregina_1_1EulerSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a>), but it is only used and updated in the subclass <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> (where it allows us to optimise the census algorithm). </p>

</div>
</div>
<a id="gaa2fd365cc7773fa91b9ac329ea9327c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fd365cc7773fa91b9ac329ea9327c8">&#9670;&nbsp;</a></span>facesPos <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utilities.html#gaf4b4c70291965332b28e1891b86ea054">QitmaskLen64</a> regina::CompactSearcher::TetEdgeState::facesPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how many times this edge runs along the boundary of each tetrahedron face in the positive direction. </p>
<p>Specifically, the (4t+i)th trit counts how many times it runs in the positive direction around the boundary of face <em>i</em> of tetrahedron <em>t</em>. Which direction is "positive" is chosen arbitrarily for each face; for details see the implementation of the <a class="el" href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f...">CompactSearcher</a> constructor.</p>
<p>Because of the fixed-size data type, this only stores information for the faces of the first 16 tetrahedra.</p>
<p>Currently this data member is initialised by the <a class="el" href="classregina_1_1CompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f...">CompactSearcher</a> constructors (since it belongs to <a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a>), but it is only used and updated in the subclass <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> (where it allows us to optimise the census algorithm). </p>

</div>
</div>
<a id="ga107d4ea96e2006fce01b49508221e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga107d4ea96e2006fce01b49508221e604">&#9670;&nbsp;</a></span>finiteOnly_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite triangulations? </p>

</div>
</div>
<a id="ga19a48e1511ec0a927f7557d4a6a71a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a48e1511ec0a927f7557d4a6a71a2e">&#9670;&nbsp;</a></span>finiteOnly_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite (non-ideal) triangulations? </p>

</div>
</div>
<a id="ga61e9f6f128b8fb6a5c6f92d66e37422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e9f6f128b8fb6a5c6f92d66e37422c">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetVertexState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="ga5682aac7cc3b1aa3596562a4cc09fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5682aac7cc3b1aa3596562a4cc09fade">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::EulerSearcher::TetEdgeState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="ga146172be72c90743112ff91398534e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146172be72c90743112ff91398534e04">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::TetVertexState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="gab65bf7e75b24fa8e32c014890c82dd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab65bf7e75b24fa8e32c014890c82dd36">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::CompactSearcher::TetEdgeState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="ga7f33ceaaffe679d74758a2da4ab7cb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f33ceaaffe679d74758a2da4ab7cb32">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="ga73b5bcaeb902b57d1ceaa1b9a595d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b5bcaeb902b57d1ceaa1b9a595d74e">&#9670;&nbsp;</a></span>hadEqualRank <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::hadEqualRank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did this tree have rank equal to its parent immediately before it was grafted beneath its parent? This information is used to maintain the ranks correctly when grafting operations are undone. </p>
<p>If this object is still the root of its tree, this value is set to false. </p>

</div>
</div>
<a id="ga4df91f50200ff5d6e76ede8c123e8ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df91f50200ff5d6e76ede8c123e8ce6">&#9670;&nbsp;</a></span>inputError_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a id="ga6f929697e568e19efc2ab0a67c608dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f929697e568e19efc2ab0a67c608dee">&#9670;&nbsp;</a></span>nEdgeClasses <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::nEdgeClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron edges. </p>

</div>
</div>
<a id="ga395f2feb52dfc9d7d5e3506ec8bbff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga395f2feb52dfc9d7d5e3506ec8bbff14">&#9670;&nbsp;</a></span>nEdgeClasses <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::nEdgeClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron edges. </p>

</div>
</div>
<a id="ga71723efa36609fbfac186fb3ea8d0468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71723efa36609fbfac186fb3ea8d0468">&#9670;&nbsp;</a></span>nEdgeClasses_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::nEdgeClasses_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified pentachoron edges. </p>

</div>
</div>
<a id="ga96e1c2d1d04751699fedc6806a0fe6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e1c2d1d04751699fedc6806a0fe6e6">&#9670;&nbsp;</a></span>nTriangleClasses_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::nTriangleClasses_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified pentachoron triangles. </p>

</div>
</div>
<a id="ga24f25280e8073d6493a89151c39d28eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24f25280e8073d6493a89151c39d28eb">&#9670;&nbsp;</a></span>nVertexClasses <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::nVertexClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron vertices. </p>

</div>
</div>
<a id="ga7aea8813a101710e3650e36e564ee1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aea8813a101710e3650e36e564ee1c0">&#9670;&nbsp;</a></span>nVertexClasses <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::nVertexClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron vertices. </p>

</div>
</div>
<a id="ga9ead7f5285666965fbc9d28826d82677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ead7f5285666965fbc9d28826d82677">&#9670;&nbsp;</a></span>order <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to edges. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying edge pairing graph, which in turn represents a triangle edge and its image under the given edge pairing.</p>
<p>The specific triangle edge stored in this array for each edge of the underlying edge pairing graph will be the smaller of the two identified triangle edges (unless otherwise specified by a subclass that uses a specialised search algorithm. </p>

</div>
</div>
<a id="ga8738eee160530cfdcf10a05f626212da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8738eee160530cfdcf10a05f626212da">&#9670;&nbsp;</a></span>order <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;3&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to faces. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying face pairing graph, which in turn represents a tetrahedron face and its image under the given face pairing.</p>
<p>The specific tetrahedron face stored in this array for each edge of the underlying face pairing graph will be the smaller of the two identified tetrahedron faces (unless otherwise specified for a particular edge type; see <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a> for examples). </p>

</div>
</div>
<a id="ga645b467099de1154f57a9f57a12d7c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645b467099de1154f57a9f57a12d7c41">&#9670;&nbsp;</a></span>order_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;4&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::order_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to pentachoron facets. </p>
<p>Specifically, this order is order_[0], order_[1], ..., order_[orderSize_-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying facet pairing graph, which in turn represents a pentachoron facet and its image under the given facet pairing.</p>
<p>The specific pentachoron facet stored in this array for each edge of the underlying facet pairing graph will be the smaller of the two identified pentachoron facets. </p>

</div>
</div>
<a id="gabccdb731602614ebfb5435d539f13dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabccdb731602614ebfb5435d539f13dad">&#9670;&nbsp;</a></span>orderElt <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a id="ga9db9ca62cfe5caf9ca9e357121912cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db9ca62cfe5caf9ca9e357121912cb5">&#9670;&nbsp;</a></span>orderElt <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a id="ga10b3c59d2d196bcfdfd94c1a49154ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b3c59d2d196bcfdfd94c1a49154ba8">&#9670;&nbsp;</a></span>orderElt_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::orderElt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order_[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a id="ga24ebe801472975c7fce7b7c0557ee2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ebe801472975c7fce7b7c0557ee2ff">&#9670;&nbsp;</a></span>orderSize <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the edge pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a id="ga2208e4c544e9b5fd2e2d9ff317b94575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2208e4c544e9b5fd2e2d9ff317b94575">&#9670;&nbsp;</a></span>orderSize <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a id="ga592f3c19001c088c2b90fdcae56bbb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592f3c19001c088c2b90fdcae56bbb6e">&#9670;&nbsp;</a></span>orderSize_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::orderSize_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the facet pairing graph, i.e., the number of elements of interest in the order_[] array. </p>

</div>
</div>
<a id="gae60ee67149b8f7e69ad70e073e5ab977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae60ee67149b8f7e69ad70e073e5ab977">&#9670;&nbsp;</a></span>orientableOnly_ <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a id="gae7086cef35b30a1e10385ec3f12bce31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7086cef35b30a1e10385ec3f12bce31">&#9670;&nbsp;</a></span>orientableOnly_ <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a id="gac0b467e31273576a85d0df480d893eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b467e31273576a85d0df480d893eff">&#9670;&nbsp;</a></span>orientableOnly_ <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a id="gaaf1466828ee218e55095bf0e476d625a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1466828ee218e55095bf0e476d625a">&#9670;&nbsp;</a></span>orientation <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each triangle in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a id="ga07986d0a577e24601d762c07c43226eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07986d0a577e24601d762c07c43226eb">&#9670;&nbsp;</a></span>orientation <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each tetrahedron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a id="ga5aace77bcc9e796ec07706baea501370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aace77bcc9e796ec07706baea501370">&#9670;&nbsp;</a></span>orientation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::orientation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each pentachoron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a id="gad9fb5bb6ec20f8822927d49c100738e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9fb5bb6ec20f8822927d49c100738e5">&#9670;&nbsp;</a></span>pairing_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a id="ga480a383055477920691941e909a894d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480a383055477920691941e909a894d1">&#9670;&nbsp;</a></span>parent <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetVertexState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="ga3daff5cb5bf31ed1c6ed28533d1d62d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daff5cb5bf31ed1c6ed28533d1d62d0">&#9670;&nbsp;</a></span>parent <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::EulerSearcher::TetEdgeState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="gad7e8d7c736c124e1af2d11125f698567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7e8d7c736c124e1af2d11125f698567">&#9670;&nbsp;</a></span>parent <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::TetVertexState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="gab6597a1b0cb0c116d3b68c8fc2198c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6597a1b0cb0c116d3b68c8fc2198c55">&#9670;&nbsp;</a></span>parent <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::CompactSearcher::TetEdgeState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="gaead39c0215f80b97f483ce9dcf49b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead39c0215f80b97f483ce9dcf49b5c2">&#9670;&nbsp;</a></span>parent <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="ga7390516fb9eae7fdfbcdc7a5cdda94ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7390516fb9eae7fdfbcdc7a5cdda94ef">&#9670;&nbsp;</a></span>parent <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index of the parent object in the current tree, or -1 if this object is the root of the tree. </p>

</div>
</div>
<a id="gaae038d32acaf9c1fc1f086dc8a344417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae038d32acaf9c1fc1f086dc8a344417">&#9670;&nbsp;</a></span>permIndices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines <a class="el" href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c" title="Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the...">gluingToIndex()</a> and <a class="el" href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<a id="ga345c6c08ca4695e77e395087f0dd7259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345c6c08ca4695e77e395087f0dd7259">&#9670;&nbsp;</a></span>rank <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::TetVertexState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="ga4d64f96beead08f2c85c4af2f3854919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d64f96beead08f2c85c4af2f3854919">&#9670;&nbsp;</a></span>rank <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::TetEdgeState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="gabb6511721be72ae76f02c7915adc6c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb6511721be72ae76f02c7915adc6c3a">&#9670;&nbsp;</a></span>rank <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::TetVertexState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="gaeab1eb791e10fdb954edc1b90d909396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab1eb791e10fdb954edc1b90d909396">&#9670;&nbsp;</a></span>rank <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::TetEdgeState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="gad208c689a4a7ff5e6713b739d9a17740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad208c689a4a7ff5e6713b739d9a17740">&#9670;&nbsp;</a></span>rank <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="ga4ffafc804456dad6fa33ad8d81d73f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ffafc804456dad6fa33ad8d81d73f4b">&#9670;&nbsp;</a></span>rank <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::rank</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth of the subtree beneath this object (where a leaf node has depth zero). </p>

</div>
</div>
<a id="gae6c8b0fdfa458c64e3202a27423cc148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c8b0fdfa458c64e3202a27423cc148">&#9670;&nbsp;</a></span>size <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::EulerSearcher::TetEdgeState::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of objects in the subtree descending from this object (where this object is counted also). </p>

</div>
</div>
<a id="gad2800d46cd4e4d487c523ffbf288f929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2800d46cd4e4d487c523ffbf288f929">&#9670;&nbsp;</a></span>size <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::CompactSearcher::TetEdgeState::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of objects in the subtree descending from this object (where this object is counted also). </p>

</div>
</div>
<a id="ga53bb371bcfdaac507f1fa4770728a99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53bb371bcfdaac507f1fa4770728a99b">&#9670;&nbsp;</a></span>size <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of objects in the subtree descending from this object (where this object is counted also). </p>

</div>
</div>
<a id="ga845dee0fb289ae31732acdbbebe4396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga845dee0fb289ae31732acdbbebe4396c">&#9670;&nbsp;</a></span>started <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a id="ga46ef778b520739058cf77d70963d7ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ef778b520739058cf77d70963d7ab6">&#9670;&nbsp;</a></span>started <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a id="gab676f59dbec9fc1e4095c55a33d4c29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab676f59dbec9fc1e4095c55a33d4c29f">&#9670;&nbsp;</a></span>started_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::started_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a id="ga20b739aab8500599992fdd77be379f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20b739aab8500599992fdd77be379f52">&#9670;&nbsp;</a></span>triState_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PentTriangleState* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::triState_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified pentachoron triangles. </p>
<p>See the <a class="el" href="structregina_1_1GluingPermSearcher_3_014_01_4_1_1PentTriangleState.html" title="A structure used to track equivalence classes of pentachoron triangles as the gluing permutation set ...">PentTriangleState</a> description for details. This array has size 10n, where triangle f of pentachoron p has index 10p+f. </p>

</div>
</div>
<a id="ga16ec34c68b08996259c375647b3fc0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ec34c68b08996259c375647b3fc0b3">&#9670;&nbsp;</a></span>triStateChanged_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::triStateChanged_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the triState_[] array has been updated over time. </p>
<p>This array has size [25n/2]. Suppose the gluing for order[i] affects facet k of pentachoron p. Then element 5i+v of this array describes how the gluing for order[i] affects the triangle of pentachoron p opposite vertices k and v (note that a fifth of this array will remain unused, since k and v are never equal).</p>
<p>If this identification of triangles results in the tree with root triState_[x] being grafted beneath the tree with root triState_[y], this array will store the value x. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="ga18b374687123ab8241e1cf84aff30a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b374687123ab8241e1cf84aff30a73">&#9670;&nbsp;</a></span>twistUp <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetVertexState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link. </p>
<p>Each of these triangles in the vertex link can be labelled with its own vertices 0, 1 and 2 and thereby be assigned a clockwise or anticlockwise orientation.</p>
<p>The parameter <em>twistUp</em> is 0 if these two triangles in the vertex link are joined in a way that preserves orientation, or 1 if the gluing does not preserve orientation.</p>
<p>If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<a id="ga89a9099827e0480649c98b2c9404001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a9099827e0480649c98b2c9404001f">&#9670;&nbsp;</a></span>twistUp <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::EulerSearcher::TetEdgeState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each tetrahedron edge can be assigned an orientation pointing from the lower numbered tetrahedron vertex to the higher. </p>
<p>The parameter <em>twistUp</em> is 0 if the identification of this object and its parent in the tree preserves this orientation, or 1 if it does not. If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<a id="ga9751beca8aa1b550a589afd341b2403d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9751beca8aa1b550a589afd341b2403d">&#9670;&nbsp;</a></span>twistUp <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::CompactSearcher::TetVertexState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the vertex link. </p>
<p>Each of these triangles in the vertex link can be labelled with its own vertices 0, 1 and 2 and thereby be assigned a clockwise or anticlockwise orientation.</p>
<p>The parameter <em>twistUp</em> is 0 if these two triangles in the vertex link are joined in a way that preserves orientation, or 1 if the gluing does not preserve orientation.</p>
<p>If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<a id="gac020b3d2a99a7ad54fea6c9f721d105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac020b3d2a99a7ad54fea6c9f721d105a">&#9670;&nbsp;</a></span>twistUp <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char regina::CompactSearcher::TetEdgeState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each tetrahedron edge can be assigned an orientation pointing from the lower numbered tetrahedron vertex to the higher. </p>
<p>The parameter <em>twistUp</em> is 0 if the identification of this object and its parent in the tree preserves this orientation, or 1 if it does not. If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<a id="ga51dc6c8d9dca56d7cda94d2234653bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51dc6c8d9dca56d7cda94d2234653bf2">&#9670;&nbsp;</a></span>twistUp <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;3&gt; <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentTriangleState::twistUp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vertices of each pentachoron triangle can be labelled (0,1,2) by running through the underlying pentachoron vertices from smallest index to largest index. </p>
<p>The parameter <em>twistUp</em> is a permutation that maps vertices (0,1,2) of this triangle to vertices (0,1,2) of its parent in the tree according to the way in which the two triangles are identified. If this object has no parent, the value of <em>twistUp</em> is undefined. </p>

</div>
</div>
<a id="ga25d01913310f2bbc3acf7ab47b20a891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d01913310f2bbc3acf7ab47b20a891">&#9670;&nbsp;</a></span>twistUpEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::twistUpEdge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each pentachoron edge can be assigned an orientation pointing from the lower numbered pentachoron vertex to the higher. </p>
<p>The parameter <em>twistUpEdge</em> is 0 if the identification of this object and its parent in the tree preserves this orientation, or 1 if it does not. If this object has no parent, the value of <em>twistUpEdge</em> is undefined. </p>

</div>
</div>
<a id="gaa060c96e60a01c2f2c3d71d0418f9e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa060c96e60a01c2f2c3d71d0418f9e15">&#9670;&nbsp;</a></span>twistUpTriangle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::PentEdgeState::twistUpTriangle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identification of this object and its parent in the tree corresponds to a gluing of two triangles in the edge link. </p>
<p>Each of these triangles in the edge link can be labelled with its own vertices 0, 1 and 2 and thereby be assigned a clockwise or anticlockwise orientation.</p>
<p>The parameter <em>twistUpTriangle</em> is 0 if these two triangles in the edge link are joined in a way that preserves orientation, or 1 if the gluing does not preserve orientation.</p>
<p>If this object has no parent, the value of <em>twistUpTriangle</em> is undefined. </p>

</div>
</div>
<a id="ga3d4c3890c45451a0fd3872a2dd09bc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d4c3890c45451a0fd3872a2dd09bc0b">&#9670;&nbsp;</a></span>use_ <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;::<a class="el" href="group__census.html#ga541613639a350df47748b7bdae7ed5fa">Use</a> <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a id="gac24e6601298a3b8e111eaebb30223a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24e6601298a3b8e111eaebb30223a0e">&#9670;&nbsp;</a></span>use_ <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;3&gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a id="ga5d09e6ad58e87eba28798833a7c10b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d09e6ad58e87eba28798833a7c10b42">&#9670;&nbsp;</a></span>use_ <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;4&gt;::<a class="el" href="group__census.html#ga43b50b702b41225afbd20161898e3931">Use</a> <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a id="ga326ae3e5b54a478e682ec4d3a1116f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga326ae3e5b54a478e682ec4d3a1116f61">&#9670;&nbsp;</a></span>useArgs_ <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<a id="gaf5f9d4ba646538829c4c1fafe4bd1ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5f9d4ba646538829c4c1fafe4bd1ccb">&#9670;&nbsp;</a></span>useArgs_ <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<a id="ga4c0d8f76b5d44dcd8acf0d5715b130b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0d8f76b5d44dcd8acf0d5715b130b7">&#9670;&nbsp;</a></span>useArgs_ <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 4 &gt;::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<a id="ga53dc83da54a0646f841ea40bb0c40ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53dc83da54a0646f841ea40bb0c40ab7">&#9670;&nbsp;</a></span>vertexLinkNextFace <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::EulerSearcher::vertexLinkNextFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron. </p>
<p>This ordering is consistent with the orientations of triangles in the vertex link used by <a class="el" href="group__census.html#ga18b374687123ab8241e1cf84aff30a73" title="The identification of this object and its parent in the tree corresponds to a gluing of two triangles...">TetVertexState::twistUp</a>.</p>
<p>For vertex v (0..3), the tetrahedron face that follows f (0..3) in this ordering is <em>vertexLinkNextFace</em>[v][f]. The remaining array elements <em>vertexLinkNextFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="gaaea2e93753783fd73caa1805e68062d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea2e93753783fd73caa1805e68062d9">&#9670;&nbsp;</a></span>vertexLinkNextFace <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::CompactSearcher::vertexLinkNextFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron. </p>
<p>This ordering is consistent with the orientations of triangles in the vertex link used by <a class="el" href="group__census.html#ga9751beca8aa1b550a589afd341b2403d" title="The identification of this object and its parent in the tree corresponds to a gluing of two triangles...">TetVertexState::twistUp</a>.</p>
<p>For vertex v (0..3), the tetrahedron face that follows f (0..3) in this ordering is <em>vertexLinkNextFace</em>[v][f]. The remaining array elements <em>vertexLinkNextFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="ga4609aecf1e7fae96f3ccfa6b56fc66d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4609aecf1e7fae96f3ccfa6b56fc66d5">&#9670;&nbsp;</a></span>vertexLinkPrevFace <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::EulerSearcher::vertexLinkPrevFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>. </p>
<p>For vertex v (0..3), the tetrahedron face that precedes f (0..3) in this ordering is <em>vertexLinkPrevFace</em>[v][f]. The remaining array elements <em>vertexLinkPrevFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="ga2b498e1004898fe021328583c9a397ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b498e1004898fe021328583c9a397ad">&#9670;&nbsp;</a></span>vertexLinkPrevFace <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::CompactSearcher::vertexLinkPrevFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>. </p>
<p>For vertex v (0..3), the tetrahedron face that precedes f (0..3) in this ordering is <em>vertexLinkPrevFace</em>[v][f]. The remaining array elements <em>vertexLinkPrevFace</em>[v][v] are all -1. </p>

</div>
</div>
<a id="gad82d5ea45a6d1ca689bc81c55599970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82d5ea45a6d1ca689bc81c55599970d">&#9670;&nbsp;</a></span>vertexState <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html">TetVertexState</a>* regina::EulerSearcher::vertexState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron vertices. </p>
<p>See the <a class="el" href="structregina_1_1EulerSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> description for details. This array has size 4n, where vertex v of tetrahedron t has index 4t+v. </p>

</div>
</div>
<a id="gae799bb54f485575692d7d35858b2dd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae799bb54f485575692d7d35858b2dd8f">&#9670;&nbsp;</a></span>vertexState <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a>* regina::CompactSearcher::vertexState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron vertices. </p>
<p>See the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> description for details. This array has size 4n, where vertex v of tetrahedron t has index 4t+v. </p>

</div>
</div>
<a id="gaf12324f590ed9369a2f10c46dde4d533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf12324f590ed9369a2f10c46dde4d533">&#9670;&nbsp;</a></span>vertexStateChanged <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::EulerSearcher::vertexStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the vertexState[] array has been updated over time. </p>
<p>This array has size 8n, where element 4i+v describes how the gluing for order[i] affects vertex v of the corresponding tetrahedron (thus a quarter of this array will remain unused, since only three vertices are affected for each gluing).</p>
<p>If this identification of vertices results in the tree with root vertexState[p] being grafted beneath the tree with root vertexState[q] (so two distinct vertex links become joined together), this array will store the value p. Otherwise it will store one of the values <em>VLINK_JOIN_HANDLE</em>, <em>VLINK_JOIN_BRIDGE</em> or <em>VLINK_JOIN_TWIST</em>, indicating how the corresponding partial link is glued to itself.</p>
<p>The value <em>VLINK_JOIN_INIT</em> will be stored for positions in the array that correspond to gluings that have not yet been made. </p>

</div>
</div>
<a id="ga42d401e8806d12fd2274bfd24e97d292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d401e8806d12fd2274bfd24e97d292">&#9670;&nbsp;</a></span>vertexStateChanged <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::CompactSearcher::vertexStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the vertexState[] array has been updated over time. </p>
<p>This array has size 8n, where element 4i+v describes how the gluing for order[i] affects vertex v of the corresponding tetrahedron (thus a quarter of this array will remain unused, since only three vertices are affected for each gluing).</p>
<p>If this identification of vertices results in the tree with root vertexState[p] being grafted beneath the tree with root vertexState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a id="ga8281e7335fe3c3c4946187dccb06490b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8281e7335fe3c3c4946187dccb06490b">&#9670;&nbsp;</a></span>VLINK_BAD_EULER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::EulerSearcher::VLINK_BAD_EULER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has either (i) accumulated too high a genus (so when its punctures are filled the Euler characteristic will be too low), or has (ii) been closed off with too low a genus (so its final Euler characteristic is too high). </p>

</div>
</div>
<a id="ga8612a6072262a299ecbea89a7ad646ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8612a6072262a299ecbea89a7ad646ee">&#9670;&nbsp;</a></span>VLINK_CLOSED <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::EulerSearcher::VLINK_CLOSED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges). </p>

</div>
</div>
<a id="gac363812100d31dbed52621e0ac4d4d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac363812100d31dbed52621e0ac4d4d66">&#9670;&nbsp;</a></span>VLINK_CLOSED <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::CompactSearcher::VLINK_CLOSED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges). </p>

</div>
</div>
<a id="ga0d604d18112b6385930665f88e9b0e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d604d18112b6385930665f88e9b0e6b">&#9670;&nbsp;</a></span>VLINK_NON_SPHERE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::CompactSearcher::VLINK_NON_SPHERE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been made into something other than a 2-sphere with zero or more punctures. </p>

</div>
</div>
<a id="ga59856e878dab0a1eedd13521a436f7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59856e878dab0a1eedd13521a436f7e1">&#9670;&nbsp;</a></span>whichPurge_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 3 &gt;::whichPurge_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration. </p>
<p>See the constructor documentation for further details on this search parameter. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
