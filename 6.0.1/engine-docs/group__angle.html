<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Angle Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Angle Structures</div>  </div>
</div><!--header-->
<div class="contents">

<p>Angle structures on triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructureVector.html">regina::AngleStructureVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of integers used to indirectly store the individual angles in an angle structure.  <a href="classregina_1_1AngleStructureVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructure.html">regina::AngleStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an angle structure on a triangulation.  <a href="classregina_1_1AngleStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html">regina::AngleStructures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a collection of angle structures on a triangulation.  <a href="classregina_1_1AngleStructures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">regina::AngleStructures::StructureInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator used to insert angle structures into an <a class="el" href="classregina_1_1AngleStructures.html" title="A packet representing a collection of angle structures on a triangulation.">AngleStructures</a> list.  <a href="structregina_1_1AngleStructures_1_1StructureInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLAngleStructureReader.html">regina::XMLAngleStructureReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single angle structure.  <a href="classregina_1_1XMLAngleStructureReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLAngleStructuresReader.html">regina::XMLAngleStructuresReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single angle structure list.  <a href="classregina_1_1XMLAngleStructuresReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaac1bf02f9102e7c43d58183df4c61a56"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaac1bf02f9102e7c43d58183df4c61a56">regina::NAngleStructureVector</a></td></tr>
<tr class="memdesc:gaac1bf02f9102e7c43d58183df4c61a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__angle.html#gaac1bf02f9102e7c43d58183df4c61a56">More...</a><br /></td></tr>
<tr class="separator:gaac1bf02f9102e7c43d58183df4c61a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075895da482702ed35240561b489eb10"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga075895da482702ed35240561b489eb10">regina::NAngleStructure</a></td></tr>
<tr class="memdesc:ga075895da482702ed35240561b489eb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__angle.html#ga075895da482702ed35240561b489eb10">More...</a><br /></td></tr>
<tr class="separator:ga075895da482702ed35240561b489eb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931feae62c739e3aba152ba18171c835"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga931feae62c739e3aba152ba18171c835">regina::NAngleStructureList</a></td></tr>
<tr class="memdesc:ga931feae62c739e3aba152ba18171c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__angle.html#ga931feae62c739e3aba152ba18171c835">More...</a><br /></td></tr>
<tr class="separator:ga931feae62c739e3aba152ba18171c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga588878f6fb458eec87974b698de8dc5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga588878f6fb458eec87974b698de8dc5e">regina::AngleStructureVector::AngleStructureVector</a> (size_t length)</td></tr>
<tr class="memdesc:ga588878f6fb458eec87974b698de8dc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__angle.html#ga588878f6fb458eec87974b698de8dc5e">More...</a><br /></td></tr>
<tr class="separator:ga588878f6fb458eec87974b698de8dc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5081e81e7fe6c79ec397a74a934e4e84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga5081e81e7fe6c79ec397a74a934e4e84">regina::AngleStructureVector::AngleStructureVector</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga5081e81e7fe6c79ec397a74a934e4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__angle.html#ga5081e81e7fe6c79ec397a74a934e4e84">More...</a><br /></td></tr>
<tr class="separator:ga5081e81e7fe6c79ec397a74a934e4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ce017585b99cfdcdd809ee3c4ed96a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a">regina::AngleStructureVector::makeAngleEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga83ce017585b99cfdcdd809ee3c4ed96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of angle structure equations for the given triangulation.  <a href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a">More...</a><br /></td></tr>
<tr class="separator:ga83ce017585b99cfdcdd809ee3c4ed96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff4fddec3d9b1feb527d4a3ba6aa8c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga9ff4fddec3d9b1feb527d4a3ba6aa8c0">regina::AngleStructure::AngleStructure</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> *newVector)</td></tr>
<tr class="memdesc:ga9ff4fddec3d9b1feb527d4a3ba6aa8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new angle structure on the given triangulation with the given coordinate vector.  <a href="group__angle.html#ga9ff4fddec3d9b1feb527d4a3ba6aa8c0">More...</a><br /></td></tr>
<tr class="separator:ga9ff4fddec3d9b1feb527d4a3ba6aa8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376ba82a67b2022f48a07c2b9cc17997"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga376ba82a67b2022f48a07c2b9cc17997">regina::AngleStructure::~AngleStructure</a> ()</td></tr>
<tr class="memdesc:ga376ba82a67b2022f48a07c2b9cc17997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this angle structure.  <a href="group__angle.html#ga376ba82a67b2022f48a07c2b9cc17997">More...</a><br /></td></tr>
<tr class="separator:ga376ba82a67b2022f48a07c2b9cc17997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f030fd4aaa582b22a5bebaaa6d248d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gab0f030fd4aaa582b22a5bebaaa6d248d">regina::AngleStructure::clone</a> () const</td></tr>
<tr class="memdesc:gab0f030fd4aaa582b22a5bebaaa6d248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this angle structure.  <a href="group__angle.html#gab0f030fd4aaa582b22a5bebaaa6d248d">More...</a><br /></td></tr>
<tr class="separator:gab0f030fd4aaa582b22a5bebaaa6d248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea338a9ebd27177640d8c8ec193fb18f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Rational.html">Rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaea338a9ebd27177640d8c8ec193fb18f">regina::AngleStructure::angle</a> (size_t tetIndex, int edgePair) const</td></tr>
<tr class="memdesc:gaea338a9ebd27177640d8c8ec193fb18f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested angle in this angle structure.  <a href="group__angle.html#gaea338a9ebd27177640d8c8ec193fb18f">More...</a><br /></td></tr>
<tr class="separator:gaea338a9ebd27177640d8c8ec193fb18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46f0f8a4c5b86074af82faa176c1074"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gad46f0f8a4c5b86074af82faa176c1074">regina::AngleStructure::triangulation</a> () const</td></tr>
<tr class="memdesc:gad46f0f8a4c5b86074af82faa176c1074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which this angle structure lies.  <a href="group__angle.html#gad46f0f8a4c5b86074af82faa176c1074">More...</a><br /></td></tr>
<tr class="separator:gad46f0f8a4c5b86074af82faa176c1074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6b3db616a85e5557a62996499b5994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaea6b3db616a85e5557a62996499b5994">regina::AngleStructure::isStrict</a> () const</td></tr>
<tr class="memdesc:gaea6b3db616a85e5557a62996499b5994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a strict angle structure.  <a href="group__angle.html#gaea6b3db616a85e5557a62996499b5994">More...</a><br /></td></tr>
<tr class="separator:gaea6b3db616a85e5557a62996499b5994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41850883aa5d36f82a0ef708bd1e26ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga41850883aa5d36f82a0ef708bd1e26ef">regina::AngleStructure::isTaut</a> () const</td></tr>
<tr class="memdesc:ga41850883aa5d36f82a0ef708bd1e26ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a taut angle structure.  <a href="group__angle.html#ga41850883aa5d36f82a0ef708bd1e26ef">More...</a><br /></td></tr>
<tr class="separator:ga41850883aa5d36f82a0ef708bd1e26ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0472d7d8a0ee856401574c7a792e903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaf0472d7d8a0ee856401574c7a792e903">regina::AngleStructure::isVeering</a> () const</td></tr>
<tr class="memdesc:gaf0472d7d8a0ee856401574c7a792e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is a veering structure.  <a href="group__angle.html#gaf0472d7d8a0ee856401574c7a792e903">More...</a><br /></td></tr>
<tr class="separator:gaf0472d7d8a0ee856401574c7a792e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d36dfc5f722298d67bc98ed821151eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga1d36dfc5f722298d67bc98ed821151eb">regina::AngleStructure::rawVector</a> () const</td></tr>
<tr class="memdesc:ga1d36dfc5f722298d67bc98ed821151eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the raw vector that sits beneath this angle structure.  <a href="group__angle.html#ga1d36dfc5f722298d67bc98ed821151eb">More...</a><br /></td></tr>
<tr class="separator:ga1d36dfc5f722298d67bc98ed821151eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522cde26b08bcc6322d307e25526cf4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga522cde26b08bcc6322d307e25526cf4a">regina::AngleStructure::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga522cde26b08bcc6322d307e25526cf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__angle.html#ga522cde26b08bcc6322d307e25526cf4a">More...</a><br /></td></tr>
<tr class="separator:ga522cde26b08bcc6322d307e25526cf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c806514589938e0a0347d2cb5bc3e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gad8c806514589938e0a0347d2cb5bc3e7">regina::AngleStructure::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad8c806514589938e0a0347d2cb5bc3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this angle structure and all of its properties.  <a href="group__angle.html#gad8c806514589938e0a0347d2cb5bc3e7">More...</a><br /></td></tr>
<tr class="separator:gad8c806514589938e0a0347d2cb5bc3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5729e49fdebce92826335e4031aa025"><td class="memItemLeft" align="right" valign="top"><a id="gaa5729e49fdebce92826335e4031aa025"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::AngleStructure::AngleStructure</b> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;)=delete</td></tr>
<tr class="separator:gaa5729e49fdebce92826335e4031aa025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad289022eb192c6824c5c286427fea51e"><td class="memItemLeft" align="right" valign="top"><a id="gad289022eb192c6824c5c286427fea51e"></a>
<a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::AngleStructure::operator=</b> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> &amp;)=delete</td></tr>
<tr class="separator:gad289022eb192c6824c5c286427fea51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9075f1f388865567ef56259db35b07e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gae9075f1f388865567ef56259db35b07e">regina::AngleStructure::calculateType</a> () const</td></tr>
<tr class="memdesc:gae9075f1f388865567ef56259db35b07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the structure type (strict or taut) and stores it as a property.  <a href="group__angle.html#gae9075f1f388865567ef56259db35b07e">More...</a><br /></td></tr>
<tr class="separator:gae9075f1f388865567ef56259db35b07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae365bea588f1787b1ffee38fc6d70dc6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gae365bea588f1787b1ffee38fc6d70dc6">regina::AngleStructures::~AngleStructures</a> ()</td></tr>
<tr class="memdesc:gae365bea588f1787b1ffee38fc6d70dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all the angle structures within.  <a href="group__angle.html#gae365bea588f1787b1ffee38fc6d70dc6">More...</a><br /></td></tr>
<tr class="separator:gae365bea588f1787b1ffee38fc6d70dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2d244430aeec23a20f060e2c876866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga4f2d244430aeec23a20f060e2c876866">regina::AngleStructures::triangulation</a> () const</td></tr>
<tr class="memdesc:ga4f2d244430aeec23a20f060e2c876866"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which these angle structures lie.  <a href="group__angle.html#ga4f2d244430aeec23a20f060e2c876866">More...</a><br /></td></tr>
<tr class="separator:ga4f2d244430aeec23a20f060e2c876866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315d5492ed03fc096678261e6583d6c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga315d5492ed03fc096678261e6583d6c6">regina::AngleStructures::isTautOnly</a> () const</td></tr>
<tr class="memdesc:ga315d5492ed03fc096678261e6583d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was produced by enumerating taut angle structures only.  <a href="group__angle.html#ga315d5492ed03fc096678261e6583d6c6">More...</a><br /></td></tr>
<tr class="separator:ga315d5492ed03fc096678261e6583d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bfa1531d425a1c33b920d8f83586b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga25bfa1531d425a1c33b920d8f83586b3">regina::AngleStructures::size</a> () const</td></tr>
<tr class="memdesc:ga25bfa1531d425a1c33b920d8f83586b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of angle structures stored in this list.  <a href="group__angle.html#ga25bfa1531d425a1c33b920d8f83586b3">More...</a><br /></td></tr>
<tr class="separator:ga25bfa1531d425a1c33b920d8f83586b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f333def3b5ffc6dec4f9ccbd00c8466"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga5f333def3b5ffc6dec4f9ccbd00c8466">regina::AngleStructures::structure</a> (size_t index) const</td></tr>
<tr class="memdesc:ga5f333def3b5ffc6dec4f9ccbd00c8466"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure at the requested index in this list.  <a href="group__angle.html#ga5f333def3b5ffc6dec4f9ccbd00c8466">More...</a><br /></td></tr>
<tr class="separator:ga5f333def3b5ffc6dec4f9ccbd00c8466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c8446f4a8bbbb387104397bfde140d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gac4c8446f4a8bbbb387104397bfde140d">regina::AngleStructures::spansStrict</a> () const</td></tr>
<tr class="memdesc:gac4c8446f4a8bbbb387104397bfde140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any convex combination of the angle structures in this list is a strict angle structure.  <a href="group__angle.html#gac4c8446f4a8bbbb387104397bfde140d">More...</a><br /></td></tr>
<tr class="separator:gac4c8446f4a8bbbb387104397bfde140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f5a2614871da2375a68cdaca5fefa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gae0f5a2614871da2375a68cdaca5fefa8">regina::AngleStructures::spansTaut</a> () const</td></tr>
<tr class="memdesc:gae0f5a2614871da2375a68cdaca5fefa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any angle structure in this list is a taut structure.  <a href="group__angle.html#gae0f5a2614871da2375a68cdaca5fefa8">More...</a><br /></td></tr>
<tr class="separator:gae0f5a2614871da2375a68cdaca5fefa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c339156d162a54d6a66c949dda62a3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga9c339156d162a54d6a66c949dda62a3c">regina::AngleStructures::enumerate</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner, bool tautOnly=false, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0)</td></tr>
<tr class="memdesc:ga9c339156d162a54d6a66c949dda62a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all angle structures on the given triangulation.  <a href="group__angle.html#ga9c339156d162a54d6a66c949dda62a3c">More...</a><br /></td></tr>
<tr class="separator:ga9c339156d162a54d6a66c949dda62a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4cd806b356e57973456e5350c98fb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gabe4cd806b356e57973456e5350c98fb6">regina::AngleStructures::enumerateTautDD</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner)</td></tr>
<tr class="memdesc:gabe4cd806b356e57973456e5350c98fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slower, alternative method to enumerate all taut angle structures on the given triangulation.  <a href="group__angle.html#gabe4cd806b356e57973456e5350c98fb6">More...</a><br /></td></tr>
<tr class="separator:gabe4cd806b356e57973456e5350c98fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125b651b08f8aa07d79f450a6f29ff7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga125b651b08f8aa07d79f450a6f29ff7d">regina::AngleStructures::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga125b651b08f8aa07d79f450a6f29ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__angle.html#ga125b651b08f8aa07d79f450a6f29ff7d">More...</a><br /></td></tr>
<tr class="separator:ga125b651b08f8aa07d79f450a6f29ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c0c8c9b7bb190f32e48573b4299de4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga12c0c8c9b7bb190f32e48573b4299de4">regina::AngleStructures::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga12c0c8c9b7bb190f32e48573b4299de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__angle.html#ga12c0c8c9b7bb190f32e48573b4299de4">More...</a><br /></td></tr>
<tr class="separator:ga12c0c8c9b7bb190f32e48573b4299de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8b726b927d8e08928736527d41e9b4"><td class="memItemLeft" align="right" valign="top"><a id="ga2c8b726b927d8e08928736527d41e9b4"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::AngleStructures::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga2c8b726b927d8e08928736527d41e9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5ac676fbceae4514b483fb661a11c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga7c5ac676fbceae4514b483fb661a11c9">regina::AngleStructures::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga7c5ac676fbceae4514b483fb661a11c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__angle.html#ga7c5ac676fbceae4514b483fb661a11c9">More...</a><br /></td></tr>
<tr class="separator:ga7c5ac676fbceae4514b483fb661a11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d596ce2f45572f0ed2d03c8d807e97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga17d596ce2f45572f0ed2d03c8d807e97">regina::AngleStructures::AngleStructures</a> (bool tautOnly)</td></tr>
<tr class="memdesc:ga17d596ce2f45572f0ed2d03c8d807e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty angle structure list.  <a href="group__angle.html#ga17d596ce2f45572f0ed2d03c8d807e97">More...</a><br /></td></tr>
<tr class="separator:ga17d596ce2f45572f0ed2d03c8d807e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045880691b243edd429661aa1d0fc859"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga045880691b243edd429661aa1d0fc859">regina::AngleStructures::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga045880691b243edd429661aa1d0fc859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__angle.html#ga045880691b243edd429661aa1d0fc859">More...</a><br /></td></tr>
<tr class="separator:ga045880691b243edd429661aa1d0fc859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe639ef03c5af712afaae0b602dab37f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gafe639ef03c5af712afaae0b602dab37f">regina::AngleStructures::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gafe639ef03c5af712afaae0b602dab37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__angle.html#gafe639ef03c5af712afaae0b602dab37f">More...</a><br /></td></tr>
<tr class="separator:gafe639ef03c5af712afaae0b602dab37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb315298423dc92a072462d9d9b6a110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gabb315298423dc92a072462d9d9b6a110">regina::AngleStructures::calculateSpanStrict</a> () const</td></tr>
<tr class="memdesc:gabb315298423dc92a072462d9d9b6a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a strict angle structure.  <a href="group__angle.html#gabb315298423dc92a072462d9d9b6a110">More...</a><br /></td></tr>
<tr class="separator:gabb315298423dc92a072462d9d9b6a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gad34f5f7ee0c4397353cf4edb4791ecd1">regina::AngleStructures::calculateSpanTaut</a> () const</td></tr>
<tr class="memdesc:gad34f5f7ee0c4397353cf4edb4791ecd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a taut structure.  <a href="group__angle.html#gad34f5f7ee0c4397353cf4edb4791ecd1">More...</a><br /></td></tr>
<tr class="separator:gad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb55b938c0800a15e86f0f61d01af2bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gabb55b938c0800a15e86f0f61d01af2bd">regina::AngleStructures::StructureInserter::StructureInserter</a> ()</td></tr>
<tr class="memdesc:gabb55b938c0800a15e86f0f61d01af2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised output iterator.  <a href="group__angle.html#gabb55b938c0800a15e86f0f61d01af2bd">More...</a><br /></td></tr>
<tr class="separator:gabb55b938c0800a15e86f0f61d01af2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffda79c58a698f9305ea69862bbfd787"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaffda79c58a698f9305ea69862bbfd787">regina::AngleStructures::StructureInserter::StructureInserter</a> (<a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;newList, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newOwner)</td></tr>
<tr class="memdesc:gaffda79c58a698f9305ea69862bbfd787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator.  <a href="group__angle.html#gaffda79c58a698f9305ea69862bbfd787">More...</a><br /></td></tr>
<tr class="separator:gaffda79c58a698f9305ea69862bbfd787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a203cb4be4858f4026dade6c104942"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga80a203cb4be4858f4026dade6c104942">regina::AngleStructures::StructureInserter::StructureInserter</a> (const <a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga80a203cb4be4858f4026dade6c104942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator that is a clone of the given iterator.  <a href="group__angle.html#ga80a203cb4be4858f4026dade6c104942">More...</a><br /></td></tr>
<tr class="separator:ga80a203cb4be4858f4026dade6c104942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac045dcfe8017d4c38df20f665687a63e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gac045dcfe8017d4c38df20f665687a63e">regina::AngleStructures::StructureInserter::operator=</a> (const <a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gac045dcfe8017d4c38df20f665687a63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this iterator to be a clone of the given output iterator.  <a href="group__angle.html#gac045dcfe8017d4c38df20f665687a63e">More...</a><br /></td></tr>
<tr class="separator:gac045dcfe8017d4c38df20f665687a63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370ec533d84877f765621f3d01310566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga370ec533d84877f765621f3d01310566">regina::AngleStructures::StructureInserter::operator=</a> (<a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *<a class="el" href="group__angle.html#ga5f333def3b5ffc6dec4f9ccbd00c8466">structure</a>)</td></tr>
<tr class="memdesc:ga370ec533d84877f765621f3d01310566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an angle structure to the end of the appropriate structure list.  <a href="group__angle.html#ga370ec533d84877f765621f3d01310566">More...</a><br /></td></tr>
<tr class="separator:ga370ec533d84877f765621f3d01310566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043d1aa125078c4331223dd978d5d518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga043d1aa125078c4331223dd978d5d518">regina::AngleStructures::StructureInserter::operator=</a> (<a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> *vector)</td></tr>
<tr class="memdesc:ga043d1aa125078c4331223dd978d5d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the angle structure corresponding to the given vector to the end of the appropriate structure list.  <a href="group__angle.html#ga043d1aa125078c4331223dd978d5d518">More...</a><br /></td></tr>
<tr class="separator:ga043d1aa125078c4331223dd978d5d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f54c5702e9e6c64eedf4cb9831a171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gab5f54c5702e9e6c64eedf4cb9831a171">regina::AngleStructures::StructureInserter::operator*</a> ()</td></tr>
<tr class="memdesc:gab5f54c5702e9e6c64eedf4cb9831a171"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__angle.html#gab5f54c5702e9e6c64eedf4cb9831a171">More...</a><br /></td></tr>
<tr class="separator:gab5f54c5702e9e6c64eedf4cb9831a171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85c34b41f1f2dafd4d49999a10c1bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gae85c34b41f1f2dafd4d49999a10c1bc9">regina::AngleStructures::StructureInserter::operator++</a> ()</td></tr>
<tr class="memdesc:gae85c34b41f1f2dafd4d49999a10c1bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__angle.html#gae85c34b41f1f2dafd4d49999a10c1bc9">More...</a><br /></td></tr>
<tr class="separator:gae85c34b41f1f2dafd4d49999a10c1bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d512b5a61b7056b32b3fb3c8534f966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga4d512b5a61b7056b32b3fb3c8534f966">regina::AngleStructures::StructureInserter::operator++</a> (int)</td></tr>
<tr class="memdesc:ga4d512b5a61b7056b32b3fb3c8534f966"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__angle.html#ga4d512b5a61b7056b32b3fb3c8534f966">More...</a><br /></td></tr>
<tr class="separator:ga4d512b5a61b7056b32b3fb3c8534f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b01d60168764493e2f53fa738ff567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga52b01d60168764493e2f53fa738ff567">regina::makeAngleEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:ga52b01d60168764493e2f53fa738ff567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of angle structure equations for the given triangulation.  <a href="group__angle.html#ga52b01d60168764493e2f53fa738ff567">More...</a><br /></td></tr>
<tr class="separator:ga52b01d60168764493e2f53fa738ff567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d55d117ac9e7f55c6ff690eed71209f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga7d55d117ac9e7f55c6ff690eed71209f">regina::XMLAngleStructureReader::XMLAngleStructureReader</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri)</td></tr>
<tr class="memdesc:ga7d55d117ac9e7f55c6ff690eed71209f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new angle structure reader.  <a href="group__angle.html#ga7d55d117ac9e7f55c6ff690eed71209f">More...</a><br /></td></tr>
<tr class="separator:ga7d55d117ac9e7f55c6ff690eed71209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2134f0d8ae76f6febb28e8299006a97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga2134f0d8ae76f6febb28e8299006a97e">regina::XMLAngleStructureReader::structure</a> ()</td></tr>
<tr class="memdesc:ga2134f0d8ae76f6febb28e8299006a97e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure that has been read.  <a href="group__angle.html#ga2134f0d8ae76f6febb28e8299006a97e">More...</a><br /></td></tr>
<tr class="separator:ga2134f0d8ae76f6febb28e8299006a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a27ede8f53241386f1169e3394f9258"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga4a27ede8f53241386f1169e3394f9258">regina::XMLAngleStructureReader::startElement</a> (const std::string &amp;tagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;tagProps, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *parentReader) override</td></tr>
<tr class="memdesc:ga4a27ede8f53241386f1169e3394f9258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__angle.html#ga4a27ede8f53241386f1169e3394f9258">More...</a><br /></td></tr>
<tr class="separator:ga4a27ede8f53241386f1169e3394f9258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad7b198eed5b4db9ef829a3b7952c15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga3ad7b198eed5b4db9ef829a3b7952c15">regina::XMLAngleStructureReader::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:ga3ad7b198eed5b4db9ef829a3b7952c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__angle.html#ga3ad7b198eed5b4db9ef829a3b7952c15">More...</a><br /></td></tr>
<tr class="separator:ga3ad7b198eed5b4db9ef829a3b7952c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b82b0a5daa7d543acfa4d7e384bfd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga7f7b82b0a5daa7d543acfa4d7e384bfd">regina::XMLAngleStructureReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga7f7b82b0a5daa7d543acfa4d7e384bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__angle.html#ga7f7b82b0a5daa7d543acfa4d7e384bfd">More...</a><br /></td></tr>
<tr class="separator:ga7f7b82b0a5daa7d543acfa4d7e384bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5939b2afa99db914d57e2fb785784182"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga5939b2afa99db914d57e2fb785784182">regina::XMLAngleStructuresReader::XMLAngleStructuresReader</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga5939b2afa99db914d57e2fb785784182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new angle structure list reader.  <a href="group__angle.html#ga5939b2afa99db914d57e2fb785784182">More...</a><br /></td></tr>
<tr class="separator:ga5939b2afa99db914d57e2fb785784182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ac47d991921cb6e14c780fbd9c8d95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga28ac47d991921cb6e14c780fbd9c8d95">regina::XMLAngleStructuresReader::packet</a> () override</td></tr>
<tr class="memdesc:ga28ac47d991921cb6e14c780fbd9c8d95"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__angle.html#ga28ac47d991921cb6e14c780fbd9c8d95">More...</a><br /></td></tr>
<tr class="separator:ga28ac47d991921cb6e14c780fbd9c8d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b64ec2647a1c62138028feb61afbed6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga8b64ec2647a1c62138028feb61afbed6">regina::XMLAngleStructuresReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga8b64ec2647a1c62138028feb61afbed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__angle.html#ga8b64ec2647a1c62138028feb61afbed6">More...</a><br /></td></tr>
<tr class="separator:ga8b64ec2647a1c62138028feb61afbed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb4c8c0c6b03102190875fbf18768f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gaccb4c8c0c6b03102190875fbf18768f0">regina::XMLAngleStructuresReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gaccb4c8c0c6b03102190875fbf18768f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__angle.html#gaccb4c8c0c6b03102190875fbf18768f0">More...</a><br /></td></tr>
<tr class="separator:gaccb4c8c0c6b03102190875fbf18768f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad3560a46286c605af832d8e4f64c67c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#gad3560a46286c605af832d8e4f64c67c4">regina::AngleStructures::StructureInserter::list</a></td></tr>
<tr class="memdesc:gad3560a46286c605af832d8e4f64c67c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list into which angle structures will be inserted.  <a href="group__angle.html#gad3560a46286c605af832d8e4f64c67c4">More...</a><br /></td></tr>
<tr class="separator:gad3560a46286c605af832d8e4f64c67c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7f7f6d288c84b75a8aa2c6cb12a77e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__angle.html#ga5b7f7f6d288c84b75a8aa2c6cb12a77e">regina::AngleStructures::StructureInserter::owner</a></td></tr>
<tr class="memdesc:ga5b7f7f6d288c84b75a8aa2c6cb12a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation on which the angle structures to be inserted lie.  <a href="group__angle.html#ga5b7f7f6d288c84b75a8aa2c6cb12a77e">More...</a><br /></td></tr>
<tr class="separator:ga5b7f7f6d288c84b75a8aa2c6cb12a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gaaffea10f963cba6be6b330c0c7ad2cfd"><td class="memItemLeft" align="right" valign="top"><a id="gaaffea10f963cba6be6b330c0c7ad2cfd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLAngleStructureReader</b></td></tr>
<tr class="separator:gaaffea10f963cba6be6b330c0c7ad2cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memItemLeft" align="right" valign="top"><a id="ga7d43cee2f6d4a3a3ee51964ad7e3e7f4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLAngleStructuresReader</b></td></tr>
<tr class="separator:ga7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Angle structures on triangulations. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga075895da482702ed35240561b489eb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075895da482702ed35240561b489eb10">&#9670;&nbsp;</a></span>NAngleStructure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> <a class="el" href="group__angle.html#ga075895da482702ed35240561b489eb10">regina::NAngleStructure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>The class NAngleStructure has now been renamed to <a class="el" href="classregina_1_1AngleStructure.html" title="Represents an angle structure on a triangulation.">AngleStructure</a>. </dd></dl>

</div>
</div>
<a id="ga931feae62c739e3aba152ba18171c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga931feae62c739e3aba152ba18171c835">&#9670;&nbsp;</a></span>NAngleStructureList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> <a class="el" href="group__angle.html#ga931feae62c739e3aba152ba18171c835">regina::NAngleStructureList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>The class NAngleStructureList has now been renamed to <a class="el" href="classregina_1_1AngleStructures.html" title="A packet representing a collection of angle structures on a triangulation.">AngleStructures</a>. </dd></dl>

</div>
</div>
<a id="gaac1bf02f9102e7c43d58183df4c61a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac1bf02f9102e7c43d58183df4c61a56">&#9670;&nbsp;</a></span>NAngleStructureVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> <a class="el" href="group__angle.html#gaac1bf02f9102e7c43d58183df4c61a56">regina::NAngleStructureVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>The class NAngleStructureVector has now been renamed to <a class="el" href="classregina_1_1AngleStructureVector.html" title="A vector of integers used to indirectly store the individual angles in an angle structure.">AngleStructureVector</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaea338a9ebd27177640d8c8ec193fb18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea338a9ebd27177640d8c8ec193fb18f">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Rational.html">Rational</a> regina::AngleStructure::angle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgePair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested angle in this angle structure. </p>
<p>The angle returned will be scaled down; the actual angle is the returned value multiplied by <em>pi</em>.</p>
<p>Within a tetrahedron, the three angles are indexed 0, 1 and 2. Angle <em>i</em> appears on edge <em>i</em> of the tetrahedron as well as its opposite edge (5-<em>i</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested angle lives; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">edgePair</td><td>the number representing the pair of edges holding the requested angle, as described above; this should be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested angle scaled down by <em>pi</em>. </dd></dl>

</div>
</div>
<a id="ga9ff4fddec3d9b1feb527d4a3ba6aa8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff4fddec3d9b1feb527d4a3ba6aa8c0">&#9670;&nbsp;</a></span>AngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructure::AngleStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> *&#160;</td>
          <td class="paramname"><em>newVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new angle structure on the given triangulation with the given coordinate vector. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation on which this angle structure lies. </td></tr>
    <tr><td class="paramname">newVector</td><td>a vector containing the individual angles in the angle structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17d596ce2f45572f0ed2d03c8d807e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17d596ce2f45572f0ed2d03c8d807e97">&#9670;&nbsp;</a></span>AngleStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty angle structure list. </p>
<p>All properties are marked as unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated (when the time comes for enumeration to be performed), or <code>false</code> if we should enumerate all vertices of the angle structure solution space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5081e81e7fe6c79ec397a74a934e4e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5081e81e7fe6c79ec397a74a934e4e84">&#9670;&nbsp;</a></span>AngleStructureVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructureVector::AngleStructureVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga588878f6fb458eec87974b698de8dc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga588878f6fb458eec87974b698de8dc5e">&#9670;&nbsp;</a></span>AngleStructureVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructureVector::AngleStructureVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb315298423dc92a072462d9d9b6a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb315298423dc92a072462d9d9b6a110">&#9670;&nbsp;</a></span>calculateSpanStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a strict angle structure. </p>

</div>
</div>
<a id="gad34f5f7ee0c4397353cf4edb4791ecd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34f5f7ee0c4397353cf4edb4791ecd1">&#9670;&nbsp;</a></span>calculateSpanTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a taut structure. </p>

</div>
</div>
<a id="gae9075f1f388865567ef56259db35b07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9075f1f388865567ef56259db35b07e">&#9670;&nbsp;</a></span>calculateType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructure::calculateType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the structure type (strict or taut) and stores it as a property. </p>

</div>
</div>
<a id="gab0f030fd4aaa582b22a5bebaaa6d248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f030fd4aaa582b22a5bebaaa6d248d">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a>* regina::AngleStructure::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this angle structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a clone of this angle structure. </dd></dl>

</div>
</div>
<a id="ga7c5ac676fbceae4514b483fb661a11c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5ac676fbceae4514b483fb661a11c9">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="gaccb4c8c0c6b03102190875fbf18768f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb4c8c0c6b03102190875fbf18768f0">&#9670;&nbsp;</a></span>endContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLAngleStructuresReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__angle.html#ga8b64ec2647a1c62138028feb61afbed6" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga9c339156d162a54d6a66c949dda62a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c339156d162a54d6a66c949dda62a3c">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>* regina::AngleStructures::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all angle structures on the given triangulation. </p>
<p>A list containing all vertices of the angle structure solution space will be returned.</p>
<p>The option is offered to find only taut structures (which are considerably faster to enumerate) instead of enumerating all vertex angle structures. See the <em>tautOnly</em> argument below.</p>
<p>The angle structure list that is created will be inserted as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this angle structure list, and must not change while this angle structure list remains in existence.</p>
<p>If a progress tracker is passed, the angle structure enumeration will take place in a new thread and this routine will return immediately. If the user cancels the operation from another thread, then the angle structure list will <em>not</em> be inserted into the packet tree (but the caller of this routine will still need to delete it). Regarding progress tracking, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p>If no progress tracker is passed, the enumeration will run in the current thread and this routine will return only when the enumeration is complete. Note that this enumeration can be extremely slow for larger triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation for which the vertex angle structures will be enumerated. </td></tr>
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated, or <code>false</code> if we should enumerate all vertices of the angle structure solution space; this defaults to <code>false</code>. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created angle structure list. Note that if a progress tracker is passed then this list may not be completely filled when this routine returns. If a progress tracker is passed and a new thread could not be started, this routine returns 0 (and no angle structure list is created). </dd></dl>

</div>
</div>
<a id="gabe4cd806b356e57973456e5350c98fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4cd806b356e57973456e5350c98fb6">&#9670;&nbsp;</a></span>enumerateTautDD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>* regina::AngleStructures::enumerateTautDD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A slower, alternative method to enumerate all taut angle structures on the given triangulation. </p>
<p>A list containing all taut angle structures will be returned.</p>
<p>The algorithm used by this routine is based on the double description method. The algorithm used by <a class="el" href="group__angle.html#ga9c339156d162a54d6a66c949dda62a3c" title="Enumerates all angle structures on the given triangulation.">enumerate()</a> (the preferred method) is instead based on linear programming, and is typically <em>much</em> faster than this routine for larger triangulations.</p>
<p>The angle structure list that is created will be inserted as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this angle structure list, and must not change while this angle structure list remains in existence.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, and users will not want to call it unless they have some specialised need.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation for which the taut angle structures will be enumerated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created angle structure list. </dd></dl>

</div>
</div>
<a id="ga3ad7b198eed5b4db9ef829a3b7952c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad7b198eed5b4db9ef829a3b7952c15">&#9670;&nbsp;</a></span>initialChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLAngleStructureReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga045880691b243edd429661aa1d0fc859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga045880691b243edd429661aa1d0fc859">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::AngleStructures::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="gaea6b3db616a85e5557a62996499b5994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6b3db616a85e5557a62996499b5994">&#9670;&nbsp;</a></span>isStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructure::isStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a strict angle structure. </p>
<p>A strict angle structure has all angles strictly between (not including) 0 and <em>pi</em>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a strict angle structure. </dd></dl>

</div>
</div>
<a id="ga41850883aa5d36f82a0ef708bd1e26ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41850883aa5d36f82a0ef708bd1e26ef">&#9670;&nbsp;</a></span>isTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructure::isTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a taut angle structure. </p>
<p>A taut angle structure contains only angles 0 and <em>pi</em>.</p>
<p>Here we use the Kang-Rubinstein definition of a taut angle structure [1], which is based on the angles alone. In his original paper [2], Lackenby has an extra condition whereby 2-faces of the triangulation must have consistent coorientations, which we do not enforce here.</p>
<p>[1] E. Kang and J. H. Rubinstein, "Ideal triangulations of
3-manifolds II; Taut and angle structures", Algebr. Geom. Topol. 5 (2005), pp. 1505-1533.</p>
<p>[2] M. Lackenby, "Taut ideal triangulations of 3-manifolds", Geom. Topol. 4 (2000), pp. 369-395.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a taut structure. </dd></dl>

</div>
</div>
<a id="ga315d5492ed03fc096678261e6583d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315d5492ed03fc096678261e6583d6c6">&#9670;&nbsp;</a></span>isTautOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::isTautOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was produced by enumerating taut angle structures only. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was produced by enumerating taut angle structures only, or <code>false</code> if the enumeration procedure allowed for any angle structures. </dd></dl>

</div>
</div>
<a id="gaf0472d7d8a0ee856401574c7a792e903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0472d7d8a0ee856401574c7a792e903">&#9670;&nbsp;</a></span>isVeering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructure::isVeering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is a veering structure. </p>
<p>A veering structure is taut angle structure with additional strong combinatorial constraints, which we do not outline here. For a definition, see C. D. Hodgson, J. H. Rubinstein, H. Segerman, and S. Tillmann, "Veering triangulations admit
strict angle structures", Geom. Topol., 15 (2011), pp. 2073-2089.</p>
<p>Note that the Hodgson et al. definition is slightly more general than Agol's veering taut triangulations from his original paper: I. Agol, " Ideal triangulations of pseudo-Anosov mapping tori", in "Topology and Geometry in Dimension Three", volume 560 of Contemp. Math., pp. 1-17, Amer. Math. Soc., 2011. This mirrors the way in which the Kang-Rubinstein definition of taut angle structure is slightly more general than Lackenby's. See the Hodgson et al. paper for full details and comparisons between the two settings.</p>
<p>If this angle structure is not taut, or if the underlying triangulation is non-orientable, then this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a veering structure. </dd></dl>

</div>
</div>
<a id="ga83ce017585b99cfdcdd809ee3c4ed96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ce017585b99cfdcdd809ee3c4ed96a">&#9670;&nbsp;</a></span>makeAngleEquations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::AngleStructureVector::makeAngleEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of angle structure equations for the given triangulation. </p>
<p>Each equation will be represented as a row of the matrix, and each column will represent a coordinate in the underlying coordinate system (which is described in the <a class="el" href="classregina_1_1AngleStructureVector.html" title="A vector of integers used to indirectly store the individual angles in an angle structure.">AngleStructureVector</a> class notes).</p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>This is identical to the global function <a class="el" href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a" title="Creates a new set of angle structure equations for the given triangulation.">makeAngleEquations()</a>. It is offered again here in the vector class for consistency with the normal surface vector classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation upon which these angle structure equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of equations. </dd></dl>

</div>
</div>
<a id="ga52b01d60168764493e2f53fa738ff567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b01d60168764493e2f53fa738ff567">&#9670;&nbsp;</a></span>makeAngleEquations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> * regina::makeAngleEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of angle structure equations for the given triangulation. </p>
<p>Each equation will be represented as a row of the matrix, and each column will represent a coordinate in the underlying coordinate system (which is described in the <a class="el" href="classregina_1_1AngleStructureVector.html" title="A vector of integers used to indirectly store the individual angles in an angle structure.">AngleStructureVector</a> class notes).</p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>This routine is identical to the static class method <a class="el" href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a" title="Creates a new set of angle structure equations for the given triangulation.">AngleStructureVector::makeAngleEquations()</a>. It is offered again here as a global routine so that it is accessible to Python users (who cannot access the <a class="el" href="classregina_1_1AngleStructureVector.html" title="A vector of integers used to indirectly store the individual angles in an angle structure.">AngleStructureVector</a> class).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation upon which these angle structure equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of equations. </dd></dl>

</div>
</div>
<a id="gab5f54c5702e9e6c64eedf4cb9831a171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f54c5702e9e6c64eedf4cb9831a171">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">AngleStructures::StructureInserter</a> &amp; regina::AngleStructures::StructureInserter::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gae85c34b41f1f2dafd4d49999a10c1bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae85c34b41f1f2dafd4d49999a10c1bc9">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">AngleStructures::StructureInserter</a> &amp; regina::AngleStructures::StructureInserter::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga4d512b5a61b7056b32b3fb3c8534f966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d512b5a61b7056b32b3fb3c8534f966">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">AngleStructures::StructureInserter</a> &amp; regina::AngleStructures::StructureInserter::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga370ec533d84877f765621f3d01310566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370ec533d84877f765621f3d01310566">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">AngleStructures::StructureInserter</a> &amp; regina::AngleStructures::StructureInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td>
          <td class="paramname"><em>structure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an angle structure to the end of the appropriate structure list. </p>
<p>The given angle structure will be deallocated with the other angle structures in this list when the list is eventually destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure</td><td>the angle structure to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga043d1aa125078c4331223dd978d5d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043d1aa125078c4331223dd978d5d518">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">AngleStructures::StructureInserter</a> &amp; regina::AngleStructures::StructureInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the angle structure corresponding to the given vector to the end of the appropriate structure list. </p>
<p>The given vector will be owned by the newly created angle structure and will be deallocated with the other angle structures in this list when the list is eventually destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector of the angle structure to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gac045dcfe8017d4c38df20f665687a63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac045dcfe8017d4c38df20f665687a63e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a>&amp; regina::AngleStructures::StructureInserter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this iterator to be a clone of the given output iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga28ac47d991921cb6e14c780fbd9c8d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ac47d991921cb6e14c780fbd9c8d95">&#9670;&nbsp;</a></span>packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLAngleStructuresReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga1d36dfc5f722298d67bc98ed821151eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d36dfc5f722298d67bc98ed821151eb">&#9670;&nbsp;</a></span>rawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructureVector.html">AngleStructureVector</a> * regina::AngleStructure::rawVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the raw vector that sits beneath this angle structure. </p>
<p>Generally users should not need this function. However, it is provided here in case the need should arise (e.g., for reasons of efficiency).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying raw vector. </dd></dl>

</div>
</div>
<a id="ga25bfa1531d425a1c33b920d8f83586b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25bfa1531d425a1c33b920d8f83586b3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AngleStructures::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of angle structures stored in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of angle structures. </dd></dl>

</div>
</div>
<a id="gac4c8446f4a8bbbb387104397bfde140d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c8446f4a8bbbb387104397bfde140d">&#9670;&nbsp;</a></span>spansStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any convex combination of the angle structures in this list is a strict angle structure. </p>
<p>See <a class="el" href="group__angle.html#gaea6b3db616a85e5557a62996499b5994" title="Determines whether this is a strict angle structure.">AngleStructure::isStrict()</a> for details on strict angle structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a strict angle structure can be produced. </dd></dl>

</div>
</div>
<a id="gae0f5a2614871da2375a68cdaca5fefa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f5a2614871da2375a68cdaca5fefa8">&#9670;&nbsp;</a></span>spansTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any angle structure in this list is a taut structure. </p>
<p>Because taut structures always appear as vertices of the angle structure solution space, this routine is equivalent to testing whether any convex combination of the angle structures in this list is a taut structure.</p>
<p>See <a class="el" href="group__angle.html#ga41850883aa5d36f82a0ef708bd1e26ef" title="Determines whether this is a taut angle structure.">AngleStructure::isTaut()</a> for details on taut structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a taut structure can be produced. </dd></dl>

</div>
</div>
<a id="ga8b64ec2647a1c62138028feb61afbed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b64ec2647a1c62138028feb61afbed6">&#9670;&nbsp;</a></span>startContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLAngleStructuresReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga4a27ede8f53241386f1169e3394f9258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a27ede8f53241386f1169e3394f9258">&#9670;&nbsp;</a></span>startElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLAngleStructureReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__angle.html#ga7f7b82b0a5daa7d543acfa4d7e384bfd" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga7f7b82b0a5daa7d543acfa4d7e384bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7b82b0a5daa7d543acfa4d7e384bfd">&#9670;&nbsp;</a></span>startSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLAngleStructureReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga2134f0d8ae76f6febb28e8299006a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2134f0d8ae76f6febb28e8299006a97e">&#9670;&nbsp;</a></span>structure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> * regina::XMLAngleStructureReader::structure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure that has been read. </p>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated angle structure, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="ga5f333def3b5ffc6dec4f9ccbd00c8466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f333def3b5ffc6dec4f9ccbd00c8466">&#9670;&nbsp;</a></span>structure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> * regina::AngleStructures::structure </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure at the requested index in this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested angle structure in this list; this must be between 0 and <a class="el" href="group__angle.html#ga25bfa1531d425a1c33b920d8f83586b3" title="Returns the number of angle structures stored in this list.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle structure at the requested index. </dd></dl>

</div>
</div>
<a id="gabb55b938c0800a15e86f0f61d01af2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb55b938c0800a15e86f0f61d01af2bd">&#9670;&nbsp;</a></span>StructureInserter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::StructureInserter::StructureInserter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised output iterator. </p>
<dl class="section warning"><dt>Warning</dt><dd>This iterator must not be used until its structure list and triangulation have been initialised. </dd></dl>

</div>
</div>
<a id="gaffda79c58a698f9305ea69862bbfd787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffda79c58a698f9305ea69862bbfd787">&#9670;&nbsp;</a></span>StructureInserter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::StructureInserter::StructureInserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> &amp;&#160;</td>
          <td class="paramname"><em>newList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newOwner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator. </p>
<p>The member variables of this iterator will be initialised according to the parameters passed to this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newList</td><td>the list into which angle structures will be inserted. </td></tr>
    <tr><td class="paramname">newOwner</td><td>the triangulation on which the structures to be inserted lie. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80a203cb4be4858f4026dade6c104942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a203cb4be4858f4026dade6c104942">&#9670;&nbsp;</a></span>StructureInserter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::StructureInserter::StructureInserter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator that is a clone of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad46f0f8a4c5b86074af82faa176c1074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad46f0f8a4c5b86074af82faa176c1074">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * regina::AngleStructure::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which this angle structure lies. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ga4f2d244430aeec23a20f060e2c876866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2d244430aeec23a20f060e2c876866">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::AngleStructures::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which these angle structures lie. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding triangulation. </dd></dl>

</div>
</div>
<a id="ga12c0c8c9b7bb190f32e48573b4299de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c0c8c9b7bb190f32e48573b4299de4">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga522cde26b08bcc6322d307e25526cf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga522cde26b08bcc6322d307e25526cf4a">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructure::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga125b651b08f8aa07d79f450a6f29ff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125b651b08f8aa07d79f450a6f29ff7d">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="gad8c806514589938e0a0347d2cb5bc3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c806514589938e0a0347d2cb5bc3e7">&#9670;&nbsp;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructure::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this angle structure and all of its properties. </p>
<p>This routine will be called from within <a class="el" href="group__angle.html#gafe639ef03c5af712afaae0b602dab37f" title="Writes a chunk of XML containing the data for this packet only.">AngleStructures::writeXMLPacketData()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe639ef03c5af712afaae0b602dab37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe639ef03c5af712afaae0b602dab37f">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="ga7d55d117ac9e7f55c6ff690eed71209f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d55d117ac9e7f55c6ff690eed71209f">&#9670;&nbsp;</a></span>XMLAngleStructureReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLAngleStructureReader::XMLAngleStructureReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new angle structure reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTri</td><td>the triangulation on which this angle structure lies. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5939b2afa99db914d57e2fb785784182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5939b2afa99db914d57e2fb785784182">&#9670;&nbsp;</a></span>XMLAngleStructuresReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLAngleStructuresReader::XMLAngleStructuresReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new angle structure list reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTri</td><td>the triangulation on which these angle structures are placed. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga376ba82a67b2022f48a07c2b9cc17997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga376ba82a67b2022f48a07c2b9cc17997">&#9670;&nbsp;</a></span>~AngleStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructure::~AngleStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this angle structure. </p>
<p>The underlying vector of angles will also be deallocated. </p>

</div>
</div>
<a id="gae365bea588f1787b1ffee38fc6d70dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae365bea588f1787b1ffee38fc6d70dc6">&#9670;&nbsp;</a></span>~AngleStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::~AngleStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all the angle structures within. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad3560a46286c605af832d8e4f64c67c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3560a46286c605af832d8e4f64c67c4">&#9670;&nbsp;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>* regina::AngleStructures::StructureInserter::list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list into which angle structures will be inserted. </p>

</div>
</div>
<a id="ga5b7f7f6d288c84b75a8aa2c6cb12a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7f7f6d288c84b75a8aa2c6cb12a77e">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::AngleStructures::StructureInserter::owner</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulation on which the angle structures to be inserted lie. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
