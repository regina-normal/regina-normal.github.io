<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Vertex Enumeration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Vertex Enumeration</div>  </div>
</div><!--header-->
<div class="contents">

<p>Polytope vertex enumeration algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DoubleDescription.html">regina::DoubleDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a modified double description method for polytope vertex enumeration.  <a href="classregina_1_1DoubleDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HilbertCD.html">regina::HilbertCD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a modified Contejean-Devie algorithm for enumerating Hilbert bases.  <a href="classregina_1_1HilbertCD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HilbertDual.html">regina::HilbertDual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a modified dual algorithm for enumerating Hilbert bases.  <a href="classregina_1_1HilbertDual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HilbertPrimal.html">regina::HilbertPrimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a modified primal algorithm for enumerating Hilbert bases.  <a href="classregina_1_1HilbertPrimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MaxAdmissible.html">regina::MaxAdmissible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to enumerate all maximal admissible faces of a polyhedral cone under a given set of admissibility constraints.  <a href="classregina_1_1MaxAdmissible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PosOrder.html">regina::PosOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison object that sorts hyperplanes by position vectors.  <a href="classregina_1_1PosOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPConstraintBase.html">regina::LPConstraintBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for additional linear constraints that we can add to the tableaux of normal surface or angle structure matching equations.  <a href="classregina_1_1LPConstraintBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html">regina::LPConstraintBase::Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the extra coefficients in a single column for the <em>nConstraints</em> additional rows that we add to the tableaux to describe the <em>nConstraints</em> additional linear equations or inequalities.  <a href="structregina_1_1LPConstraintBase_1_1Coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPConstraintSubspace.html">regina::LPConstraintSubspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subclass of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> used for constraints defined entirely by homogeneous linear equations.  <a href="classregina_1_1LPConstraintSubspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPConstraintNone.html">regina::LPConstraintNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or angle structure matching equations.  <a href="classregina_1_1LPConstraintNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LPConstraintNone_1_1Coefficients.html">regina::LPConstraintNone::Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the extra coefficients in the tableaux associated with this constraint class (which for this class is a no-op, since in this case there are no extra coefficients).  <a href="structregina_1_1LPConstraintNone_1_1Coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPConstraintEuler.html">regina::LPConstraintEuler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that constraints the tableaux of normal surface matching equations to ensure that Euler characteristic is strictly positive.  <a href="classregina_1_1LPConstraintEuler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LPConstraintEuler_1_1Coefficients.html">regina::LPConstraintEuler::Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the extra coefficients in the tableaux associated with this constraint class (in this case, one extra integer per column).  <a href="structregina_1_1LPConstraintEuler_1_1Coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPConstraintNonSpun.html">regina::LPConstraintNonSpun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that constraints the tableaux of normal surface matching equations to ensure that normal surfaces in an ideal triangulation are compact (thereby avoiding spun normal surfaces with infinitely many triangles).  <a href="classregina_1_1LPConstraintNonSpun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LPConstraintNonSpun_1_1Coefficients.html">regina::LPConstraintNonSpun::Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the extra coefficients in the tableaux associated with this constraint class (in this case, two extra integers per column).  <a href="structregina_1_1LPConstraintNonSpun_1_1Coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BanConstraintBase.html">regina::BanConstraintBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for additional banning and marking constraints that we can place on tree traversal algorithms.  <a href="classregina_1_1BanConstraintBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BanNone.html">regina::BanNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A do-nothing class that bans no coordinates and marks no coordinates.  <a href="classregina_1_1BanNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BanBoundary.html">regina::BanBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that bans normal disc types that meet the boundary of the underlying triangulation.  <a href="classregina_1_1BanBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BanTorusBoundary.html">regina::BanTorusBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that bans and marks disc types associated with torus boundary components.  <a href="classregina_1_1BanTorusBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix&lt; IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix class for use with linear programming.  <a href="classregina_1_1LPMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1LPCol.html">regina::LPCol&lt; LPConstraint &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by LPInitialTableaux&lt;LPConstraint&gt; to store a single column of the adjusted matching equation matrix in sparse form.  <a href="structregina_1_1LPCol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux&lt; LPConstraint &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation, in sparse form.  <a href="classregina_1_1LPInitialTableaux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPData.html">regina::LPData&lt; LPConstraint, IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery for using the dual simplex method.  <a href="classregina_1_1LPData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for searches that employ the tree traversal algorithm for enumerating and locating vertex normal surfaces and taut angle structures.  <a href="classregina_1_1TreeTraversal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal surfaces in a 3-manifold triangulation.  <a href="classregina_1_1TreeEnumeration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-manifold triangulation.  <a href="classregina_1_1TautEnumeration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeSingleSoln.html">regina::TreeSingleSoln&lt; LPConstraint, BanConstraint, IntType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry point for the tree traversal / branching algorithm to locate a single non-trivial normal surface satisfying given constraints within a 3-manifold triangulation.  <a href="classregina_1_1TreeSingleSoln.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie&lt; nTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie that stores a set of type vectors of a fixed length.  <a href="classregina_1_1TypeTrie.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga932696433895d99b74143666ef7ae947"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1DoubleDescription.html">DoubleDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga932696433895d99b74143666ef7ae947">regina::NDoubleDescription</a></td></tr>
<tr class="memdesc:ga932696433895d99b74143666ef7ae947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga932696433895d99b74143666ef7ae947">More...</a><br /></td></tr>
<tr class="separator:ga932696433895d99b74143666ef7ae947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6a2d141f3bd1255506c8d87bc17c64"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::set&lt; unsigned long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">regina::EnumConstraints</a></td></tr>
<tr class="memdesc:ga1c6a2d141f3bd1255506c8d87bc17c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an individual validity constraint for use with polytope vertex enumeration.  <a href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">More...</a><br /></td></tr>
<tr class="separator:ga1c6a2d141f3bd1255506c8d87bc17c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2755d69dcbf805f4b0027a5ee58a7ca9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2755d69dcbf805f4b0027a5ee58a7ca9">regina::NEnumConstraintList</a></td></tr>
<tr class="memdesc:ga2755d69dcbf805f4b0027a5ee58a7ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga2755d69dcbf805f4b0027a5ee58a7ca9">More...</a><br /></td></tr>
<tr class="separator:ga2755d69dcbf805f4b0027a5ee58a7ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac396e8ec180e5036606065f8a3db7a44"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HilbertCD.html">HilbertCD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac396e8ec180e5036606065f8a3db7a44">regina::NHilbertCD</a></td></tr>
<tr class="memdesc:gac396e8ec180e5036606065f8a3db7a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#gac396e8ec180e5036606065f8a3db7a44">More...</a><br /></td></tr>
<tr class="separator:gac396e8ec180e5036606065f8a3db7a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9474adadc2a6e91e59e82b5abb2e48"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HilbertDual.html">HilbertDual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gace9474adadc2a6e91e59e82b5abb2e48">regina::NHilbertDual</a></td></tr>
<tr class="memdesc:gace9474adadc2a6e91e59e82b5abb2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#gace9474adadc2a6e91e59e82b5abb2e48">More...</a><br /></td></tr>
<tr class="separator:gace9474adadc2a6e91e59e82b5abb2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fca485f0d5d6f32d2fc607ce403868"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HilbertPrimal.html">HilbertPrimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae0fca485f0d5d6f32d2fc607ce403868">regina::NHilbertPrimal</a></td></tr>
<tr class="memdesc:gae0fca485f0d5d6f32d2fc607ce403868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#gae0fca485f0d5d6f32d2fc607ce403868">More...</a><br /></td></tr>
<tr class="separator:gae0fca485f0d5d6f32d2fc607ce403868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecc802fbb202d343fb30e31cb339b3a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PosOrder.html">PosOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga5ecc802fbb202d343fb30e31cb339b3a">regina::NPosOrder</a></td></tr>
<tr class="memdesc:ga5ecc802fbb202d343fb30e31cb339b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga5ecc802fbb202d343fb30e31cb339b3a">More...</a><br /></td></tr>
<tr class="separator:ga5ecc802fbb202d343fb30e31cb339b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082f81a1541447787a30abd8065a6b60"><td class="memTemplParams" colspan="2">template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </td></tr>
<tr class="memitem:ga082f81a1541447787a30abd8065a6b60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga082f81a1541447787a30abd8065a6b60">regina::NTreeTraversal</a> = <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;</td></tr>
<tr class="memdesc:ga082f81a1541447787a30abd8065a6b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga082f81a1541447787a30abd8065a6b60">More...</a><br /></td></tr>
<tr class="separator:ga082f81a1541447787a30abd8065a6b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9532df611aa4afb1991a287a84fa6c60"><td class="memTemplParams" colspan="2">template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </td></tr>
<tr class="memitem:ga9532df611aa4afb1991a287a84fa6c60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9532df611aa4afb1991a287a84fa6c60">regina::NTreeEnumeration</a> = <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;</td></tr>
<tr class="memdesc:ga9532df611aa4afb1991a287a84fa6c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga9532df611aa4afb1991a287a84fa6c60">More...</a><br /></td></tr>
<tr class="separator:ga9532df611aa4afb1991a287a84fa6c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fac336725c3482ac0b01cb91eb8362b"><td class="memTemplParams" colspan="2">template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </td></tr>
<tr class="memitem:ga5fac336725c3482ac0b01cb91eb8362b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga5fac336725c3482ac0b01cb91eb8362b">regina::NTautEnumeration</a> = <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;</td></tr>
<tr class="memdesc:ga5fac336725c3482ac0b01cb91eb8362b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga5fac336725c3482ac0b01cb91eb8362b">More...</a><br /></td></tr>
<tr class="separator:ga5fac336725c3482ac0b01cb91eb8362b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4079a32ae31f68147815169c6f6b0b"><td class="memTemplParams" colspan="2">template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </td></tr>
<tr class="memitem:ga5f4079a32ae31f68147815169c6f6b0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga5f4079a32ae31f68147815169c6f6b0b">regina::NTreeSingleSoln</a> = <a class="el" href="classregina_1_1TreeSingleSoln.html">TreeSingleSoln</a>&lt; LPConstraint, BanConstraint, IntType &gt;</td></tr>
<tr class="memdesc:ga5f4079a32ae31f68147815169c6f6b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#ga5f4079a32ae31f68147815169c6f6b0b">More...</a><br /></td></tr>
<tr class="separator:ga5f4079a32ae31f68147815169c6f6b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ce23853786e9bc8778b2431390b3a0"><td class="memTemplParams" colspan="2">template&lt;int nTypes&gt; </td></tr>
<tr class="memitem:gac6ce23853786e9bc8778b2431390b3a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac6ce23853786e9bc8778b2431390b3a0">regina::NTypeTrie</a> = <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt; nTypes &gt;</td></tr>
<tr class="memdesc:gac6ce23853786e9bc8778b2431390b3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__enumerate.html#gac6ce23853786e9bc8778b2431390b3a0">More...</a><br /></td></tr>
<tr class="separator:gac6ce23853786e9bc8778b2431390b3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5553e0320e5479034278641c8cc08e95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__enumerate.html#gga5553e0320e5479034278641c8cc08e95a7a3bbb525442f796a52b3ad07f310360">regina::LPConstraintBase::nConstraints</a>
 }</td></tr>
<tr class="separator:ga5553e0320e5479034278641c8cc08e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4c9a801eec1820842fc909ae90fa9b"><td class="memItemLeft" align="right" valign="top"><a id="ga7c4c9a801eec1820842fc909ae90fa9b"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>nConstraints</b> = 0
 }</td></tr>
<tr class="separator:ga7c4c9a801eec1820842fc909ae90fa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d2f7876beada28d46288d007ad867c"><td class="memItemLeft" align="right" valign="top"><a id="ga29d2f7876beada28d46288d007ad867c"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>nConstraints</b> = 1
 }</td></tr>
<tr class="separator:ga29d2f7876beada28d46288d007ad867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30400804c65a05051f46eca4eb1358a5"><td class="memItemLeft" align="right" valign="top"><a id="ga30400804c65a05051f46eca4eb1358a5"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>nConstraints</b> = 2
 }</td></tr>
<tr class="separator:ga30400804c65a05051f46eca4eb1358a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6efe21b1f1cd8cd4b29f6cec14b9cbe9"><td class="memTemplParams" colspan="2">template&lt;class RayClass , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga6efe21b1f1cd8cd4b29f6cec14b9cbe9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6efe21b1f1cd8cd4b29f6cec14b9cbe9">regina::DoubleDescription::enumerateExtremalRays</a> (OutputIterator results, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace, const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *constraints, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0, unsigned long initialRows=0)</td></tr>
<tr class="memdesc:ga6efe21b1f1cd8cd4b29f6cec14b9cbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the extremal rays of the intersection of the <em>n</em>-dimensional non-negative orthant with the given linear subspace.  <a href="group__enumerate.html#ga6efe21b1f1cd8cd4b29f6cec14b9cbe9">More...</a><br /></td></tr>
<tr class="separator:ga6efe21b1f1cd8cd4b29f6cec14b9cbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a923288dfd789988efd354870bdf797"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2a923288dfd789988efd354870bdf797">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec</a> (unsigned long axis, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace, const long *hypOrder)</td></tr>
<tr class="memdesc:ga2a923288dfd789988efd354870bdf797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ray specification for the non-negative portion of the given coordinate axis.  <a href="group__enumerate.html#ga2a923288dfd789988efd354870bdf797">More...</a><br /></td></tr>
<tr class="separator:ga2a923288dfd789988efd354870bdf797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4a2ea77ad8e0538dac811a077c00bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabf4a2ea77ad8e0538dac811a077c00bc">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec</a> (const RaySpec&lt; BitmaskType &gt; &amp;trunc)</td></tr>
<tr class="memdesc:gabf4a2ea77ad8e0538dac811a077c00bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given ray specification, with the first dot product removed.  <a href="group__enumerate.html#gabf4a2ea77ad8e0538dac811a077c00bc">More...</a><br /></td></tr>
<tr class="separator:gabf4a2ea77ad8e0538dac811a077c00bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af4b6458256b8702a80703028f588b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7af4b6458256b8702a80703028f588b5">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec</a> (const RaySpec &amp;first, const RaySpec &amp;second)</td></tr>
<tr class="memdesc:ga7af4b6458256b8702a80703028f588b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ray, describing where the plane between two given rays meets the next intersecting hyperplane.  <a href="group__enumerate.html#ga7af4b6458256b8702a80703028f588b5">More...</a><br /></td></tr>
<tr class="separator:ga7af4b6458256b8702a80703028f588b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0098fed8ddd568c86e6e70b00b7583b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf0098fed8ddd568c86e6e70b00b7583b">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::sign</a> () const</td></tr>
<tr class="memdesc:gaf0098fed8ddd568c86e6e70b00b7583b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the dot product of this ray with the next hyperplane.  <a href="group__enumerate.html#gaf0098fed8ddd568c86e6e70b00b7583b">More...</a><br /></td></tr>
<tr class="separator:gaf0098fed8ddd568c86e6e70b00b7583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882965aa895794954f0fab822b573909"><td class="memItemLeft" align="right" valign="top">const BitmaskType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga882965aa895794954f0fab822b573909">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::facets</a> () const</td></tr>
<tr class="memdesc:ga882965aa895794954f0fab822b573909"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitmask listing which facets of the original cone this ray belongs to.  <a href="group__enumerate.html#ga882965aa895794954f0fab822b573909">More...</a><br /></td></tr>
<tr class="separator:ga882965aa895794954f0fab822b573909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6ea02608d08fb3e772a6f46d0a61da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1c6ea02608d08fb3e772a6f46d0a61da">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::onAllCommonFacets</a> (const RaySpec &amp;x, const RaySpec &amp;y) const</td></tr>
<tr class="memdesc:ga1c6ea02608d08fb3e772a6f46d0a61da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this ray belongs to all of the facets that are common to both given rays.  <a href="group__enumerate.html#ga1c6ea02608d08fb3e772a6f46d0a61da">More...</a><br /></td></tr>
<tr class="separator:ga1c6ea02608d08fb3e772a6f46d0a61da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b7f47c601539fc794a0bb768d2f637"><td class="memTemplParams" colspan="2">template&lt;typename RayClass &gt; </td></tr>
<tr class="memitem:ga79b7f47c601539fc794a0bb768d2f637"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga79b7f47c601539fc794a0bb768d2f637">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::recover</a> (RayClass &amp;dest, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace) const</td></tr>
<tr class="memdesc:ga79b7f47c601539fc794a0bb768d2f637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the coordinates of the actual ray that is described by this object.  <a href="group__enumerate.html#ga79b7f47c601539fc794a0bb768d2f637">More...</a><br /></td></tr>
<tr class="separator:ga79b7f47c601539fc794a0bb768d2f637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c47981b6c1d9a6f11c00ff9b1da6b"><td class="memTemplParams" colspan="2">template&lt;class RayClass , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga672c47981b6c1d9a6f11c00ff9b1da6b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga672c47981b6c1d9a6f11c00ff9b1da6b">regina::HilbertCD::enumerateHilbertBasis</a> (OutputIterator results, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace, const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *constraints)</td></tr>
<tr class="memdesc:ga672c47981b6c1d9a6f11c00ff9b1da6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with some linear subspace.  <a href="group__enumerate.html#ga672c47981b6c1d9a6f11c00ff9b1da6b">More...</a><br /></td></tr>
<tr class="separator:ga672c47981b6c1d9a6f11c00ff9b1da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca692d0f3531179076044ded1d35ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabca692d0f3531179076044ded1d35ec4">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::VecSpec</a> (size_t dim)</td></tr>
<tr class="memdesc:gabca692d0f3531179076044ded1d35ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the zero vector.  <a href="group__enumerate.html#gabca692d0f3531179076044ded1d35ec4">More...</a><br /></td></tr>
<tr class="separator:gabca692d0f3531179076044ded1d35ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2222c5fe6eaf0a2d35e0ecc27b46d63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac2222c5fe6eaf0a2d35e0ecc27b46d63">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::VecSpec</a> (const VecSpec &amp;)=default</td></tr>
<tr class="memdesc:gac2222c5fe6eaf0a2d35e0ecc27b46d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new clone of the given vector.  <a href="group__enumerate.html#gac2222c5fe6eaf0a2d35e0ecc27b46d63">More...</a><br /></td></tr>
<tr class="separator:gac2222c5fe6eaf0a2d35e0ecc27b46d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723dade67a200c66ec2e4eb87e460688"><td class="memItemLeft" align="right" valign="top">VecSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga723dade67a200c66ec2e4eb87e460688">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::operator=</a> (const VecSpec &amp;)=default</td></tr>
<tr class="memdesc:ga723dade67a200c66ec2e4eb87e460688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given vector.  <a href="group__enumerate.html#ga723dade67a200c66ec2e4eb87e460688">More...</a><br /></td></tr>
<tr class="separator:ga723dade67a200c66ec2e4eb87e460688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e009c4ba4e8110c590bf4df47dc6c2"><td class="memTemplParams" colspan="2">template&lt;class RayClass , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga90e009c4ba4e8110c590bf4df47dc6c2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga90e009c4ba4e8110c590bf4df47dc6c2">regina::HilbertDual::enumerateHilbertBasis</a> (OutputIterator results, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace, const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *constraints, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0, unsigned initialRows=0)</td></tr>
<tr class="memdesc:ga90e009c4ba4e8110c590bf4df47dc6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with the given linear subspace.  <a href="group__enumerate.html#ga90e009c4ba4e8110c590bf4df47dc6c2">More...</a><br /></td></tr>
<tr class="separator:ga90e009c4ba4e8110c590bf4df47dc6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c10cf7cb826dc6f5867d333a591fd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga21c10cf7cb826dc6f5867d333a591fd4">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec</a> (size_t dim)</td></tr>
<tr class="memdesc:ga21c10cf7cb826dc6f5867d333a591fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the zero vector.  <a href="group__enumerate.html#ga21c10cf7cb826dc6f5867d333a591fd4">More...</a><br /></td></tr>
<tr class="separator:ga21c10cf7cb826dc6f5867d333a591fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530c40e81f44abdc6e939f6e4ed8aaa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga530c40e81f44abdc6e939f6e4ed8aaa5">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec</a> (size_t pos, size_t dim)</td></tr>
<tr class="memdesc:ga530c40e81f44abdc6e939f6e4ed8aaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the given unit vector.  <a href="group__enumerate.html#ga530c40e81f44abdc6e939f6e4ed8aaa5">More...</a><br /></td></tr>
<tr class="separator:ga530c40e81f44abdc6e939f6e4ed8aaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462ad677eedcb24ba485865675ccbe0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga462ad677eedcb24ba485865675ccbe0b">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec</a> (const VecSpec &amp;other)=default</td></tr>
<tr class="memdesc:ga462ad677eedcb24ba485865675ccbe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given vector.  <a href="group__enumerate.html#ga462ad677eedcb24ba485865675ccbe0b">More...</a><br /></td></tr>
<tr class="separator:ga462ad677eedcb24ba485865675ccbe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82be4e78af38fd1cfb3f01e22ba5427"><td class="memItemLeft" align="right" valign="top">VecSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac82be4e78af38fd1cfb3f01e22ba5427">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator=</a> (const VecSpec &amp;other)=default</td></tr>
<tr class="memdesc:gac82be4e78af38fd1cfb3f01e22ba5427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given vector.  <a href="group__enumerate.html#gac82be4e78af38fd1cfb3f01e22ba5427">More...</a><br /></td></tr>
<tr class="separator:gac82be4e78af38fd1cfb3f01e22ba5427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73cd5d5925e4b4f9799843888e77aa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa73cd5d5925e4b4f9799843888e77aa5">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::initNextHyp</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;subspace, unsigned row)</td></tr>
<tr class="memdesc:gaa73cd5d5925e4b4f9799843888e77aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the <em>nextHyp_</em> member to reflect the dot product with the given hyperplane.  <a href="group__enumerate.html#gaa73cd5d5925e4b4f9799843888e77aa5">More...</a><br /></td></tr>
<tr class="separator:gaa73cd5d5925e4b4f9799843888e77aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7916581803edac0e48b4985ed3e41f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7916581803edac0e48b4985ed3e41f29">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::formSum</a> (const VecSpec &amp;pos, const VecSpec &amp;neg)</td></tr>
<tr class="memdesc:ga7916581803edac0e48b4985ed3e41f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the sum of the two given vectors.  <a href="group__enumerate.html#ga7916581803edac0e48b4985ed3e41f29">More...</a><br /></td></tr>
<tr class="separator:ga7916581803edac0e48b4985ed3e41f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ffbc7d280c4bd28718ed0ac9dd7b60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa0ffbc7d280c4bd28718ed0ac9dd7b60">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::nextHyp</a> () const</td></tr>
<tr class="memdesc:gaa0ffbc7d280c4bd28718ed0ac9dd7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the dot product of this vector with the hyperplane currently being processed.  <a href="group__enumerate.html#gaa0ffbc7d280c4bd28718ed0ac9dd7b60">More...</a><br /></td></tr>
<tr class="separator:gaa0ffbc7d280c4bd28718ed0ac9dd7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689c37403c7d1f78077936f09f46fa69"><td class="memItemLeft" align="right" valign="top">const BitmaskType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga689c37403c7d1f78077936f09f46fa69">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::mask</a> () const</td></tr>
<tr class="memdesc:ga689c37403c7d1f78077936f09f46fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitmask describing which coordinate are non-zero.  <a href="group__enumerate.html#ga689c37403c7d1f78077936f09f46fa69">More...</a><br /></td></tr>
<tr class="separator:ga689c37403c7d1f78077936f09f46fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcb1cbfe6889b544a9281bc7cd92d87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaafcb1cbfe6889b544a9281bc7cd92d87">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::sign</a> () const</td></tr>
<tr class="memdesc:gaafcb1cbfe6889b544a9281bc7cd92d87"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the dot product of this vector with the hyperplane currently being processed.  <a href="group__enumerate.html#gaafcb1cbfe6889b544a9281bc7cd92d87">More...</a><br /></td></tr>
<tr class="separator:gaafcb1cbfe6889b544a9281bc7cd92d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949be804adac359047d6c98a0df84c15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga949be804adac359047d6c98a0df84c15">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator==</a> (const VecSpec &amp;other) const</td></tr>
<tr class="memdesc:ga949be804adac359047d6c98a0df84c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given vector are identical.  <a href="group__enumerate.html#ga949be804adac359047d6c98a0df84c15">More...</a><br /></td></tr>
<tr class="separator:ga949be804adac359047d6c98a0df84c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daef1aaf8977b428005b4a9f39c3e14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga3daef1aaf8977b428005b4a9f39c3e14">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator&lt;=</a> (const VecSpec &amp;other) const</td></tr>
<tr class="memdesc:ga3daef1aaf8977b428005b4a9f39c3e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if every element of this vector is less than or equal to every element of the given vector.  <a href="group__enumerate.html#ga3daef1aaf8977b428005b4a9f39c3e14">More...</a><br /></td></tr>
<tr class="separator:ga3daef1aaf8977b428005b4a9f39c3e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae6cff730678e5f6a745a53e339c61f"><td class="memTemplParams" colspan="2">template&lt;class RayClass , class RayIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:gacae6cff730678e5f6a745a53e339c61f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gacae6cff730678e5f6a745a53e339c61f">regina::HilbertPrimal::enumerateHilbertBasis</a> (OutputIterator results, const RayIterator &amp;raysBegin, const RayIterator &amp;raysEnd, const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *constraints, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0)</td></tr>
<tr class="memdesc:gacae6cff730678e5f6a745a53e339c61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with some linear subspace.  <a href="group__enumerate.html#gacae6cff730678e5f6a745a53e339c61f">More...</a><br /></td></tr>
<tr class="separator:gacae6cff730678e5f6a745a53e339c61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e93e5bb833e6ba53d99808f8d30e205"><td class="memTemplParams" colspan="2">template&lt;class BitmaskType , class RayIterator &gt; </td></tr>
<tr class="memitem:ga2e93e5bb833e6ba53d99808f8d30e205"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; BitmaskType &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2e93e5bb833e6ba53d99808f8d30e205">regina::MaxAdmissible::enumerate</a> (RayIterator beginExtremalRays, RayIterator endExtremalRays, const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *constraints)</td></tr>
<tr class="memdesc:ga2e93e5bb833e6ba53d99808f8d30e205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all maximal admissible faces of the given polyhedral cone.  <a href="group__enumerate.html#ga2e93e5bb833e6ba53d99808f8d30e205">More...</a><br /></td></tr>
<tr class="separator:ga2e93e5bb833e6ba53d99808f8d30e205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397f6dab404adfa747e9c4f07cb92782"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga397f6dab404adfa747e9c4f07cb92782">regina::PosOrder::PosOrder</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;matrix)</td></tr>
<tr class="memdesc:ga397f6dab404adfa747e9c4f07cb92782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new helper object for comparing hyperplanes.  <a href="group__enumerate.html#ga397f6dab404adfa747e9c4f07cb92782">More...</a><br /></td></tr>
<tr class="separator:ga397f6dab404adfa747e9c4f07cb92782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac373a4f958e45cca8036b98d92982b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga8ac373a4f958e45cca8036b98d92982b">regina::PosOrder::PosOrder</a> (const <a class="el" href="classregina_1_1PosOrder.html">PosOrder</a> &amp;)=default</td></tr>
<tr class="memdesc:ga8ac373a4f958e45cca8036b98d92982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given helper objet.  <a href="group__enumerate.html#ga8ac373a4f958e45cca8036b98d92982b">More...</a><br /></td></tr>
<tr class="separator:ga8ac373a4f958e45cca8036b98d92982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd99c5837e7a1f1f293e57419ecbb28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga4dd99c5837e7a1f1f293e57419ecbb28">regina::PosOrder::operator()</a> (long i, long j) const</td></tr>
<tr class="memdesc:ga4dd99c5837e7a1f1f293e57419ecbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the hyperplane described by row <em>i</em> of the matrix is smaller than the hyperplane described by row <em>j</em>.  <a href="group__enumerate.html#ga4dd99c5837e7a1f1f293e57419ecbb28">More...</a><br /></td></tr>
<tr class="separator:ga4dd99c5837e7a1f1f293e57419ecbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec45a437ef779bb69ab9714f67f68dc9"><td class="memItemLeft" align="right" valign="top"><a id="gaec45a437ef779bb69ab9714f67f68dc9"></a>
<a class="el" href="classregina_1_1PosOrder.html">PosOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PosOrder::operator=</b> (const <a class="el" href="classregina_1_1PosOrder.html">PosOrder</a> &amp;)=delete</td></tr>
<tr class="separator:gaec45a437ef779bb69ab9714f67f68dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b4c270ce9f7ebedce05636a6391e47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga85b4c270ce9f7ebedce05636a6391e47">regina::LPConstraintBase::Coefficients::Coefficients</a> ()</td></tr>
<tr class="memdesc:ga85b4c270ce9f7ebedce05636a6391e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised set of coefficients for a single column.  <a href="group__enumerate.html#ga85b4c270ce9f7ebedce05636a6391e47">More...</a><br /></td></tr>
<tr class="separator:ga85b4c270ce9f7ebedce05636a6391e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58303ac129d99491f1b82d0e116f546"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gad58303ac129d99491f1b82d0e116f546"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad58303ac129d99491f1b82d0e116f546">regina::LPConstraintBase::Coefficients::fillFinalRows</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned col) const</td></tr>
<tr class="memdesc:gad58303ac129d99491f1b82d0e116f546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly fills the final row(s) of the given tableaux matrix with the coefficients stored in this <a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html" title="Stores the extra coefficients in a single column for the nConstraints additional rows that we add to ...">Coefficients</a> structure.  <a href="group__enumerate.html#gad58303ac129d99491f1b82d0e116f546">More...</a><br /></td></tr>
<tr class="separator:gad58303ac129d99491f1b82d0e116f546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e9ef3807590e6a5b754276397b6c29e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga6e9ef3807590e6a5b754276397b6c29e"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6e9ef3807590e6a5b754276397b6c29e">regina::LPConstraintBase::Coefficients::innerProduct</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="memdesc:ga6e9ef3807590e6a5b754276397b6c29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of (i) the final <em>nConstraints</em> entries in the given row of the given matrix with (ii) the <em>nConstraints</em> column coefficients stored in this data structure.  <a href="group__enumerate.html#ga6e9ef3807590e6a5b754276397b6c29e">More...</a><br /></td></tr>
<tr class="separator:ga6e9ef3807590e6a5b754276397b6c29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c6ff37ed763967cc826e5520d88694"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga61c6ff37ed763967cc826e5520d88694"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga61c6ff37ed763967cc826e5520d88694">regina::LPConstraintBase::Coefficients::innerProductOct</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="memdesc:ga61c6ff37ed763967cc826e5520d88694"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="group__enumerate.html#ga6e9ef3807590e6a5b754276397b6c29e" title="Computes the inner product of (i) the final nConstraints entries in the given row of the given matrix...">innerProduct()</a> that takes into account any adjustments to these linear constraint(s) that are required when this is a quadrilateral column being used to represent an octagon type.  <a href="group__enumerate.html#ga61c6ff37ed763967cc826e5520d88694">More...</a><br /></td></tr>
<tr class="separator:ga61c6ff37ed763967cc826e5520d88694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac663caf3a27a7f814eec98e42cce10cf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac663caf3a27a7f814eec98e42cce10cf">regina::LPConstraintBase::addRows</a> (<a class="el" href="structregina_1_1LPCol.html">LPCol</a>&lt; <a class="el" href="classregina_1_1LPConstraintBase.html">LPConstraintBase</a> &gt; *col, const int *columnPerm, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:gac663caf3a27a7f814eec98e42cce10cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly constructs equations for the linear function(s) constrained by this class.  <a href="group__enumerate.html#gac663caf3a27a7f814eec98e42cce10cf">More...</a><br /></td></tr>
<tr class="separator:gac663caf3a27a7f814eec98e42cce10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d90776df2cdaa5cf7fbf55b9762e1e2"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga6d90776df2cdaa5cf7fbf55b9762e1e2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6d90776df2cdaa5cf7fbf55b9762e1e2">regina::LPConstraintBase::constrain</a> (<a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, IntType &gt; &amp;lp, unsigned numCols)</td></tr>
<tr class="memdesc:ga6d90776df2cdaa5cf7fbf55b9762e1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly constraints each of these linear functions to an equality or inequality in the underlying tableaux.  <a href="group__enumerate.html#ga6d90776df2cdaa5cf7fbf55b9762e1e2">More...</a><br /></td></tr>
<tr class="separator:ga6d90776df2cdaa5cf7fbf55b9762e1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3473818bf1e24235d4b9705cdfccfbf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad3473818bf1e24235d4b9705cdfccfbf">regina::LPConstraintBase::verify</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *s)</td></tr>
<tr class="memdesc:gad3473818bf1e24235d4b9705cdfccfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given normal surface satisfies the extra constraints described by this class.  <a href="group__enumerate.html#gad3473818bf1e24235d4b9705cdfccfbf">More...</a><br /></td></tr>
<tr class="separator:gad3473818bf1e24235d4b9705cdfccfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bfeab411c86ea6b91eb7cf1afb655c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2bfeab411c86ea6b91eb7cf1afb655c1">regina::LPConstraintBase::verify</a> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *s)</td></tr>
<tr class="memdesc:ga2bfeab411c86ea6b91eb7cf1afb655c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given angle structure satisfies the extra constraints described by this class.  <a href="group__enumerate.html#ga2bfeab411c86ea6b91eb7cf1afb655c1">More...</a><br /></td></tr>
<tr class="separator:ga2bfeab411c86ea6b91eb7cf1afb655c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba753d9c3432becdfcb3a7e08b7762e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9ba753d9c3432becdfcb3a7e08b7762e">regina::LPConstraintBase::supported</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga9ba753d9c3432becdfcb3a7e08b7762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the given coordinate system is supported by this constraint class.  <a href="group__enumerate.html#ga9ba753d9c3432becdfcb3a7e08b7762e">More...</a><br /></td></tr>
<tr class="separator:ga9ba753d9c3432becdfcb3a7e08b7762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434743ff68dbd0ebf824521b08b449cd"><td class="memTemplParams" colspan="2"><a id="ga434743ff68dbd0ebf824521b08b449cd"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga434743ff68dbd0ebf824521b08b449cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNone::Coefficients::fillFinalRows</b> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned col) const</td></tr>
<tr class="separator:ga434743ff68dbd0ebf824521b08b449cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d705b70568d9c0a369a807820044803"><td class="memTemplParams" colspan="2"><a id="ga2d705b70568d9c0a369a807820044803"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga2d705b70568d9c0a369a807820044803"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNone::Coefficients::innerProduct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;, unsigned) const</td></tr>
<tr class="separator:ga2d705b70568d9c0a369a807820044803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca80617b3ecc0aeba9d04a7cd84107bc"><td class="memTemplParams" colspan="2"><a id="gaca80617b3ecc0aeba9d04a7cd84107bc"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaca80617b3ecc0aeba9d04a7cd84107bc"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNone::Coefficients::innerProductOct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;, unsigned) const</td></tr>
<tr class="separator:gaca80617b3ecc0aeba9d04a7cd84107bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababca86ca22d5888c44fa5e0e34da3c4"><td class="memItemLeft" align="right" valign="top"><a id="gababca86ca22d5888c44fa5e0e34da3c4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNone::addRows</b> (<a class="el" href="structregina_1_1LPCol.html">LPCol</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">regina::LPConstraintNone</a> &gt; *, const int *, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *)</td></tr>
<tr class="separator:gababca86ca22d5888c44fa5e0e34da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449af83cdae83ee418fed74ad19f25df"><td class="memTemplParams" colspan="2"><a id="ga449af83cdae83ee418fed74ad19f25df"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga449af83cdae83ee418fed74ad19f25df"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNone::constrain</b> (<a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">regina::LPConstraintNone</a>, IntType &gt; &amp;, unsigned)</td></tr>
<tr class="separator:ga449af83cdae83ee418fed74ad19f25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee48a3405675777a8f4f3b5033f3ead"><td class="memItemLeft" align="right" valign="top"><a id="gafee48a3405675777a8f4f3b5033f3ead"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNone::verify</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *)</td></tr>
<tr class="separator:gafee48a3405675777a8f4f3b5033f3ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13624374af987b91f5c0adde53b74f14"><td class="memItemLeft" align="right" valign="top"><a id="ga13624374af987b91f5c0adde53b74f14"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNone::verify</b> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *)</td></tr>
<tr class="separator:ga13624374af987b91f5c0adde53b74f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc9db31216a61b583e186b673768c53"><td class="memItemLeft" align="right" valign="top"><a id="ga5bc9db31216a61b583e186b673768c53"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNone::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:ga5bc9db31216a61b583e186b673768c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0f7c77e483e24923518c65ed1f4d30"><td class="memTemplParams" colspan="2"><a id="ga3c0f7c77e483e24923518c65ed1f4d30"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga3c0f7c77e483e24923518c65ed1f4d30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintEuler::Coefficients::fillFinalRows</b> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned col) const</td></tr>
<tr class="separator:ga3c0f7c77e483e24923518c65ed1f4d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd85992e0dc09e705d8437d6410bbb6"><td class="memTemplParams" colspan="2"><a id="gaedd85992e0dc09e705d8437d6410bbb6"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaedd85992e0dc09e705d8437d6410bbb6"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintEuler::Coefficients::innerProduct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="separator:gaedd85992e0dc09e705d8437d6410bbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6808f3c55eff8bac04544c58b977d520"><td class="memTemplParams" colspan="2"><a id="ga6808f3c55eff8bac04544c58b977d520"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga6808f3c55eff8bac04544c58b977d520"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintEuler::Coefficients::innerProductOct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="separator:ga6808f3c55eff8bac04544c58b977d520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eba1165d3b7b6cd791b42171636482d"><td class="memItemLeft" align="right" valign="top"><a id="ga0eba1165d3b7b6cd791b42171636482d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintEuler::addRows</b> (<a class="el" href="structregina_1_1LPCol.html">LPCol</a>&lt; <a class="el" href="classregina_1_1LPConstraintEuler.html">regina::LPConstraintEuler</a> &gt; *col, const int *columnPerm, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="separator:ga0eba1165d3b7b6cd791b42171636482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec4cc13f1f838c84ffd36b041dbe26c"><td class="memTemplParams" colspan="2"><a id="gafec4cc13f1f838c84ffd36b041dbe26c"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gafec4cc13f1f838c84ffd36b041dbe26c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintEuler::constrain</b> (<a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintEuler.html">regina::LPConstraintEuler</a>, IntType &gt; &amp;lp, unsigned numCols)</td></tr>
<tr class="separator:gafec4cc13f1f838c84ffd36b041dbe26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3baf9179af417f8a81bd82319d48bdf"><td class="memItemLeft" align="right" valign="top"><a id="gac3baf9179af417f8a81bd82319d48bdf"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintEuler::verify</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *s)</td></tr>
<tr class="separator:gac3baf9179af417f8a81bd82319d48bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91566a6bb88a76270d5a8630dacafa8e"><td class="memItemLeft" align="right" valign="top"><a id="ga91566a6bb88a76270d5a8630dacafa8e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintEuler::verify</b> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *)</td></tr>
<tr class="separator:ga91566a6bb88a76270d5a8630dacafa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4d072e865c4bbb9c28a31c2b8c6006"><td class="memItemLeft" align="right" valign="top"><a id="ga5c4d072e865c4bbb9c28a31c2b8c6006"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintEuler::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:ga5c4d072e865c4bbb9c28a31c2b8c6006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd01ff2221b6684774c254a427b6434"><td class="memTemplParams" colspan="2"><a id="gaddd01ff2221b6684774c254a427b6434"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaddd01ff2221b6684774c254a427b6434"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::Coefficients::fillFinalRows</b> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned col) const</td></tr>
<tr class="separator:gaddd01ff2221b6684774c254a427b6434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01135689c6b7da7b5ad5014b1f3b2f13"><td class="memTemplParams" colspan="2"><a id="ga01135689c6b7da7b5ad5014b1f3b2f13"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga01135689c6b7da7b5ad5014b1f3b2f13"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::Coefficients::innerProduct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="separator:ga01135689c6b7da7b5ad5014b1f3b2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239baaedbcded1fcb8791b56b4c051ea"><td class="memTemplParams" colspan="2"><a id="ga239baaedbcded1fcb8791b56b4c051ea"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga239baaedbcded1fcb8791b56b4c051ea"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::Coefficients::innerProductOct</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow) const</td></tr>
<tr class="separator:ga239baaedbcded1fcb8791b56b4c051ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab800b858b04fa329e00f244d74a075d2"><td class="memItemLeft" align="right" valign="top"><a id="gab800b858b04fa329e00f244d74a075d2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::addRows</b> (<a class="el" href="structregina_1_1LPCol.html">LPCol</a>&lt; <a class="el" href="classregina_1_1LPConstraintNonSpun.html">regina::LPConstraintNonSpun</a> &gt; *col, const int *columnPerm, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="separator:gab800b858b04fa329e00f244d74a075d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09d899939c29d1183ee0efdfc8c1702"><td class="memTemplParams" colspan="2"><a id="gab09d899939c29d1183ee0efdfc8c1702"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gab09d899939c29d1183ee0efdfc8c1702"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::constrain</b> (<a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNonSpun.html">regina::LPConstraintNonSpun</a>, IntType &gt; &amp;lp, unsigned numCols)</td></tr>
<tr class="separator:gab09d899939c29d1183ee0efdfc8c1702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090f31cd1d8021af7418be0bfbca30c2"><td class="memItemLeft" align="right" valign="top"><a id="ga090f31cd1d8021af7418be0bfbca30c2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::verify</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *s)</td></tr>
<tr class="separator:ga090f31cd1d8021af7418be0bfbca30c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd4f1844f245f2ba5537466c4be1f58"><td class="memItemLeft" align="right" valign="top"><a id="gafbd4f1844f245f2ba5537466c4be1f58"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::verify</b> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *)</td></tr>
<tr class="separator:gafbd4f1844f245f2ba5537466c4be1f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07e3609f095510bfce708d4f39e06c3b"><td class="memItemLeft" align="right" valign="top"><a id="ga07e3609f095510bfce708d4f39e06c3b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPConstraintNonSpun::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:ga07e3609f095510bfce708d4f39e06c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d836c495ce55d65cda27ef4e022391"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae8d836c495ce55d65cda27ef4e022391">regina::BanConstraintBase::BanConstraintBase</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, int coords)</td></tr>
<tr class="memdesc:gae8d836c495ce55d65cda27ef4e022391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>.  <a href="group__enumerate.html#gae8d836c495ce55d65cda27ef4e022391">More...</a><br /></td></tr>
<tr class="separator:gae8d836c495ce55d65cda27ef4e022391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e53c6bd1b2feebdee47ce63fb4ab21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga63e53c6bd1b2feebdee47ce63fb4ab21">regina::BanConstraintBase::~BanConstraintBase</a> ()</td></tr>
<tr class="memdesc:ga63e53c6bd1b2feebdee47ce63fb4ab21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object and all associated data.  <a href="group__enumerate.html#ga63e53c6bd1b2feebdee47ce63fb4ab21">More...</a><br /></td></tr>
<tr class="separator:ga63e53c6bd1b2feebdee47ce63fb4ab21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6d61d9769d6027aefd312a73634c43"><td class="memTemplParams" colspan="2">template&lt;class LPConstraint , typename IntType &gt; </td></tr>
<tr class="memitem:ga5b6d61d9769d6027aefd312a73634c43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga5b6d61d9769d6027aefd312a73634c43">regina::BanConstraintBase::enforceBans</a> (<a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;lp) const</td></tr>
<tr class="memdesc:ga5b6d61d9769d6027aefd312a73634c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces all bans described by this class in the given tableaux.  <a href="group__enumerate.html#ga5b6d61d9769d6027aefd312a73634c43">More...</a><br /></td></tr>
<tr class="separator:ga5b6d61d9769d6027aefd312a73634c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5d0e821aa954ed8f76ec6d62c03f67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9e5d0e821aa954ed8f76ec6d62c03f67">regina::BanConstraintBase::init</a> (const int *columnPerm)</td></tr>
<tr class="memdesc:ga9e5d0e821aa954ed8f76ec6d62c03f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies which coordinates to ban and mark, and records the corresponding tableaux columns in the <em>banned_</em> and <em>marked_</em> arrays respectively.  <a href="group__enumerate.html#ga9e5d0e821aa954ed8f76ec6d62c03f67">More...</a><br /></td></tr>
<tr class="separator:ga9e5d0e821aa954ed8f76ec6d62c03f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0473c6da2e31d9ea3f23047a5362983c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga0473c6da2e31d9ea3f23047a5362983c">regina::BanConstraintBase::supported</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga0473c6da2e31d9ea3f23047a5362983c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the given coordinate system is supported by this constraint class.  <a href="group__enumerate.html#ga0473c6da2e31d9ea3f23047a5362983c">More...</a><br /></td></tr>
<tr class="separator:ga0473c6da2e31d9ea3f23047a5362983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14058380a7dc6d5d4eb78d4ebdd7c0c1"><td class="memItemLeft" align="right" valign="top"><a id="ga14058380a7dc6d5d4eb78d4ebdd7c0c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanConstraintBase::BanConstraintBase</b> (const <a class="el" href="classregina_1_1BanConstraintBase.html">BanConstraintBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga14058380a7dc6d5d4eb78d4ebdd7c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c88ee1099370d2ea289daac13a83cda"><td class="memItemLeft" align="right" valign="top"><a id="ga5c88ee1099370d2ea289daac13a83cda"></a>
<a class="el" href="classregina_1_1BanConstraintBase.html">BanConstraintBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanConstraintBase::operator=</b> (const <a class="el" href="classregina_1_1BanConstraintBase.html">BanConstraintBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga5c88ee1099370d2ea289daac13a83cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf96a84e3760ddf0062c3a9eabc118952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf96a84e3760ddf0062c3a9eabc118952">regina::BanNone::BanNone</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, int coords)</td></tr>
<tr class="memdesc:gaf96a84e3760ddf0062c3a9eabc118952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor.  <a href="group__enumerate.html#gaf96a84e3760ddf0062c3a9eabc118952">More...</a><br /></td></tr>
<tr class="separator:gaf96a84e3760ddf0062c3a9eabc118952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5cc2226b5ea0ab2e9f931645817866"><td class="memItemLeft" align="right" valign="top"><a id="gaeb5cc2226b5ea0ab2e9f931645817866"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanNone::init</b> (const int *)</td></tr>
<tr class="separator:gaeb5cc2226b5ea0ab2e9f931645817866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5c9351d560b434b561b4dfadbacf14"><td class="memItemLeft" align="right" valign="top"><a id="gafb5c9351d560b434b561b4dfadbacf14"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanNone::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:gafb5c9351d560b434b561b4dfadbacf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc96d6a7dfbd8dc0316cfced17cde497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabc96d6a7dfbd8dc0316cfced17cde497">regina::BanBoundary::BanBoundary</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, int coords)</td></tr>
<tr class="memdesc:gabc96d6a7dfbd8dc0316cfced17cde497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor.  <a href="group__enumerate.html#gabc96d6a7dfbd8dc0316cfced17cde497">More...</a><br /></td></tr>
<tr class="separator:gabc96d6a7dfbd8dc0316cfced17cde497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b1705b85ecb5059ffadf9d7896b874"><td class="memItemLeft" align="right" valign="top"><a id="gab3b1705b85ecb5059ffadf9d7896b874"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanBoundary::init</b> (const int *columnPerm)</td></tr>
<tr class="separator:gab3b1705b85ecb5059ffadf9d7896b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dafb411ddc985ec09b0e8c424eb8e51"><td class="memItemLeft" align="right" valign="top"><a id="ga2dafb411ddc985ec09b0e8c424eb8e51"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanBoundary::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:ga2dafb411ddc985ec09b0e8c424eb8e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924d2ff9bdaeb2ce963c46d7410a4d5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga924d2ff9bdaeb2ce963c46d7410a4d5b">regina::BanTorusBoundary::BanTorusBoundary</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, int coords)</td></tr>
<tr class="memdesc:ga924d2ff9bdaeb2ce963c46d7410a4d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor.  <a href="group__enumerate.html#ga924d2ff9bdaeb2ce963c46d7410a4d5b">More...</a><br /></td></tr>
<tr class="separator:ga924d2ff9bdaeb2ce963c46d7410a4d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034a4d77b4fd42c1a41974e7711537b4"><td class="memItemLeft" align="right" valign="top"><a id="ga034a4d77b4fd42c1a41974e7711537b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanTorusBoundary::init</b> (const int *columnPerm)</td></tr>
<tr class="separator:ga034a4d77b4fd42c1a41974e7711537b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fa29e443c0a3dec60d267b6ef8cbea"><td class="memItemLeft" align="right" valign="top"><a id="ga58fa29e443c0a3dec60d267b6ef8cbea"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::BanTorusBoundary::supported</b> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="separator:ga58fa29e443c0a3dec60d267b6ef8cbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc147112c87842fa3f81f983b1a74fae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabc147112c87842fa3f81f983b1a74fae">regina::LPMatrix&lt; IntType &gt;::LPMatrix</a> ()</td></tr>
<tr class="memdesc:gabc147112c87842fa3f81f983b1a74fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised matrix with no memory storage.  <a href="group__enumerate.html#gabc147112c87842fa3f81f983b1a74fae">More...</a><br /></td></tr>
<tr class="separator:gabc147112c87842fa3f81f983b1a74fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd286b6b0f9ea3176934d00b8c1cc0c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gacd286b6b0f9ea3176934d00b8c1cc0c8">regina::LPMatrix&lt; IntType &gt;::LPMatrix</a> (unsigned <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a">rows</a>, unsigned cols)</td></tr>
<tr class="memdesc:gacd286b6b0f9ea3176934d00b8c1cc0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero.  <a href="group__enumerate.html#gacd286b6b0f9ea3176934d00b8c1cc0c8">More...</a><br /></td></tr>
<tr class="separator:gacd286b6b0f9ea3176934d00b8c1cc0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac4b64820129111953fb8fd76ccbed2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7ac4b64820129111953fb8fd76ccbed2">regina::LPMatrix&lt; IntType &gt;::~LPMatrix</a> ()</td></tr>
<tr class="memdesc:ga7ac4b64820129111953fb8fd76ccbed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix and all of the data it contains.  <a href="group__enumerate.html#ga7ac4b64820129111953fb8fd76ccbed2">More...</a><br /></td></tr>
<tr class="separator:ga7ac4b64820129111953fb8fd76ccbed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e8f80901ea9c05b3fc97db4a365c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94">regina::LPMatrix&lt; IntType &gt;::reserve</a> (unsigned maxRows, unsigned maxCols)</td></tr>
<tr class="memdesc:ga87e8f80901ea9c05b3fc97db4a365c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix.  <a href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94">More...</a><br /></td></tr>
<tr class="separator:ga87e8f80901ea9c05b3fc97db4a365c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6806f38ae07678edd93b44219943a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad6806f38ae07678edd93b44219943a70">regina::LPMatrix&lt; IntType &gt;::initClone</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;clone)</td></tr>
<tr class="memdesc:gad6806f38ae07678edd93b44219943a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to a copy of the given matrix.  <a href="group__enumerate.html#gad6806f38ae07678edd93b44219943a70">More...</a><br /></td></tr>
<tr class="separator:gad6806f38ae07678edd93b44219943a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756eaa237b40e6b640655622d4fc57a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga756eaa237b40e6b640655622d4fc57a6">regina::LPMatrix&lt; IntType &gt;::initIdentity</a> (unsigned size)</td></tr>
<tr class="memdesc:ga756eaa237b40e6b640655622d4fc57a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to the identity matrix of the given size.  <a href="group__enumerate.html#ga756eaa237b40e6b640655622d4fc57a6">More...</a><br /></td></tr>
<tr class="separator:ga756eaa237b40e6b640655622d4fc57a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="memItemLeft" align="right" valign="top">IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga66e1ff5aebfd645cf4c9cac1b5a149d6">regina::LPMatrix&lt; IntType &gt;::entry</a> (unsigned row, unsigned col)</td></tr>
<tr class="memdesc:ga66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the given element of this matrix.  <a href="group__enumerate.html#ga66e1ff5aebfd645cf4c9cac1b5a149d6">More...</a><br /></td></tr>
<tr class="separator:ga66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="memItemLeft" align="right" valign="top">const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad8e0af3ad3d609a2c27b8c65a8423aa5">regina::LPMatrix&lt; IntType &gt;::entry</a> (unsigned row, unsigned col) const</td></tr>
<tr class="memdesc:gad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only reference to the given element of this matrix.  <a href="group__enumerate.html#gad8e0af3ad3d609a2c27b8c65a8423aa5">More...</a><br /></td></tr>
<tr class="separator:gad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7dcd27036a3970aa80a523b2c86f43a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a">regina::LPMatrix&lt; IntType &gt;::rows</a> () const</td></tr>
<tr class="memdesc:gaf7dcd27036a3970aa80a523b2c86f43a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix.  <a href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a">More...</a><br /></td></tr>
<tr class="separator:gaf7dcd27036a3970aa80a523b2c86f43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442958409fd076f06fa54e6e24d37405"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga442958409fd076f06fa54e6e24d37405">regina::LPMatrix&lt; IntType &gt;::columns</a> () const</td></tr>
<tr class="memdesc:ga442958409fd076f06fa54e6e24d37405"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix.  <a href="group__enumerate.html#ga442958409fd076f06fa54e6e24d37405">More...</a><br /></td></tr>
<tr class="separator:ga442958409fd076f06fa54e6e24d37405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee81a1df448f26c82f389cdbafcb52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga0ee81a1df448f26c82f389cdbafcb52c">regina::LPMatrix&lt; IntType &gt;::swapRows</a> (unsigned r1, unsigned r2)</td></tr>
<tr class="memdesc:ga0ee81a1df448f26c82f389cdbafcb52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two given rows of this matrix.  <a href="group__enumerate.html#ga0ee81a1df448f26c82f389cdbafcb52c">More...</a><br /></td></tr>
<tr class="separator:ga0ee81a1df448f26c82f389cdbafcb52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad77b3d164a3c52cb5908069c99c37da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaad77b3d164a3c52cb5908069c99c37da">regina::LPMatrix&lt; IntType &gt;::combRow</a> (const IntType &amp;destCoeff, unsigned dest, const IntType &amp;srcCoeff, unsigned src, const IntType &amp;div)</td></tr>
<tr class="memdesc:gaad77b3d164a3c52cb5908069c99c37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix.  <a href="group__enumerate.html#gaad77b3d164a3c52cb5908069c99c37da">More...</a><br /></td></tr>
<tr class="separator:gaad77b3d164a3c52cb5908069c99c37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0dcf7e72e994c8b0c1ec953db3ad18e"><td class="memItemLeft" align="right" valign="top">IntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf0dcf7e72e994c8b0c1ec953db3ad18e">regina::LPMatrix&lt; IntType &gt;::combRowAndNorm</a> (const IntType &amp;destCoeff, unsigned dest, const IntType &amp;srcCoeff, unsigned src)</td></tr>
<tr class="memdesc:gaf0dcf7e72e994c8b0c1ec953db3ad18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix, and then normalises.  <a href="group__enumerate.html#gaf0dcf7e72e994c8b0c1ec953db3ad18e">More...</a><br /></td></tr>
<tr class="separator:gaf0dcf7e72e994c8b0c1ec953db3ad18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948a2c32521ba570aa0693cfce49953c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga948a2c32521ba570aa0693cfce49953c">regina::LPMatrix&lt; IntType &gt;::negateRow</a> (unsigned row)</td></tr>
<tr class="memdesc:ga948a2c32521ba570aa0693cfce49953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements in the given row of this matrix.  <a href="group__enumerate.html#ga948a2c32521ba570aa0693cfce49953c">More...</a><br /></td></tr>
<tr class="separator:ga948a2c32521ba570aa0693cfce49953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46722ff71404c0849f5aaf8b0ac3aa64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga46722ff71404c0849f5aaf8b0ac3aa64">regina::LPMatrix&lt; IntType &gt;::dump</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga46722ff71404c0849f5aaf8b0ac3aa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this matrix to the given output stream.  <a href="group__enumerate.html#ga46722ff71404c0849f5aaf8b0ac3aa64">More...</a><br /></td></tr>
<tr class="separator:ga46722ff71404c0849f5aaf8b0ac3aa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d3a7177a1a3aca1460b0192361db6e"><td class="memItemLeft" align="right" valign="top"><a id="ga98d3a7177a1a3aca1460b0192361db6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPMatrix&lt; IntType &gt;::LPMatrix</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:ga98d3a7177a1a3aca1460b0192361db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffaabab07a4f7dac40c4a320bd366df"><td class="memItemLeft" align="right" valign="top"><a id="ga8ffaabab07a4f7dac40c4a320bd366df"></a>
<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPMatrix&lt; IntType &gt;::operator=</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:ga8ffaabab07a4f7dac40c4a320bd366df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76de76a1885d36d88e7eaf911ebf2c01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga76de76a1885d36d88e7eaf911ebf2c01">regina::LPCol&lt; LPConstraint &gt;::LPCol</a> ()</td></tr>
<tr class="memdesc:ga76de76a1885d36d88e7eaf911ebf2c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises an empty column.  <a href="group__enumerate.html#ga76de76a1885d36d88e7eaf911ebf2c01">More...</a><br /></td></tr>
<tr class="separator:ga76de76a1885d36d88e7eaf911ebf2c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df6f848af8f0173cbdcda0bd885299f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9df6f848af8f0173cbdcda0bd885299f">regina::LPCol&lt; LPConstraint &gt;::push</a> (unsigned row, int val)</td></tr>
<tr class="memdesc:ga9df6f848af8f0173cbdcda0bd885299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given entry in the given row to this column.  <a href="group__enumerate.html#ga9df6f848af8f0173cbdcda0bd885299f">More...</a><br /></td></tr>
<tr class="separator:ga9df6f848af8f0173cbdcda0bd885299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625eb46c59180f92500fb8064f49fb27"><td class="memItemLeft" align="right" valign="top"><a id="ga625eb46c59180f92500fb8064f49fb27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPCol&lt; LPConstraint &gt;::LPCol</b> (const <a class="el" href="structregina_1_1LPCol.html">LPCol</a> &amp;)=delete</td></tr>
<tr class="separator:ga625eb46c59180f92500fb8064f49fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0189cc9d024e62bc91f124b22e997d7a"><td class="memItemLeft" align="right" valign="top"><a id="ga0189cc9d024e62bc91f124b22e997d7a"></a>
<a class="el" href="structregina_1_1LPCol.html">LPCol</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPCol&lt; LPConstraint &gt;::operator=</b> (const <a class="el" href="structregina_1_1LPCol.html">LPCol</a> &amp;)=delete</td></tr>
<tr class="separator:ga0189cc9d024e62bc91f124b22e997d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe983e975f8883df9f512622f43ccaf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabe983e975f8883df9f512622f43ccaf3">regina::LPInitialTableaux&lt; LPConstraint &gt;::LPInitialTableaux</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *<a class="el" href="group__enumerate.html#gaa3c878d36aceccf7a104e7b72b7f9a99">tri</a>, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="group__enumerate.html#ga15c66a19d6a2037cef94b004ecbde3df">coords</a>, bool enumeration)</td></tr>
<tr class="memdesc:gabe983e975f8883df9f512622f43ccaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts this adjusted sparse matrix of matching equations.  <a href="group__enumerate.html#gabe983e975f8883df9f512622f43ccaf3">More...</a><br /></td></tr>
<tr class="separator:gabe983e975f8883df9f512622f43ccaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9e1d9717a1363524eb40fd75f81f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6d9e1d9717a1363524eb40fd75f81f23">regina::LPInitialTableaux&lt; LPConstraint &gt;::~LPInitialTableaux</a> ()</td></tr>
<tr class="memdesc:ga6d9e1d9717a1363524eb40fd75f81f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix.  <a href="group__enumerate.html#ga6d9e1d9717a1363524eb40fd75f81f23">More...</a><br /></td></tr>
<tr class="separator:ga6d9e1d9717a1363524eb40fd75f81f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c878d36aceccf7a104e7b72b7f9a99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa3c878d36aceccf7a104e7b72b7f9a99">regina::LPInitialTableaux&lt; LPConstraint &gt;::tri</a> () const</td></tr>
<tr class="memdesc:gaa3c878d36aceccf7a104e7b72b7f9a99"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the underlying 3-manifold triangulation from which the matching equations were derived.  <a href="group__enumerate.html#gaa3c878d36aceccf7a104e7b72b7f9a99">More...</a><br /></td></tr>
<tr class="separator:gaa3c878d36aceccf7a104e7b72b7f9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c66a19d6a2037cef94b004ecbde3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga15c66a19d6a2037cef94b004ecbde3df">regina::LPInitialTableaux&lt; LPConstraint &gt;::coords</a> () const</td></tr>
<tr class="memdesc:ga15c66a19d6a2037cef94b004ecbde3df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system that is used for the matrix of matching equations.  <a href="group__enumerate.html#ga15c66a19d6a2037cef94b004ecbde3df">More...</a><br /></td></tr>
<tr class="separator:ga15c66a19d6a2037cef94b004ecbde3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga15bc3370dbf2b873b65d37e4d0cb2ccf">regina::LPInitialTableaux&lt; LPConstraint &gt;::rank</a> () const</td></tr>
<tr class="memdesc:ga15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of this matrix.  <a href="group__enumerate.html#ga15bc3370dbf2b873b65d37e4d0cb2ccf">More...</a><br /></td></tr>
<tr class="separator:ga15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55f15c0bf782905c9749f3e0a4c7767"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac55f15c0bf782905c9749f3e0a4c7767">regina::LPInitialTableaux&lt; LPConstraint &gt;::columns</a> () const</td></tr>
<tr class="memdesc:gac55f15c0bf782905c9749f3e0a4c7767"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix.  <a href="group__enumerate.html#gac55f15c0bf782905c9749f3e0a4c7767">More...</a><br /></td></tr>
<tr class="separator:gac55f15c0bf782905c9749f3e0a4c7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad311a7137ce157d3aacce9f0d7158eff"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad311a7137ce157d3aacce9f0d7158eff">regina::LPInitialTableaux&lt; LPConstraint &gt;::coordinateColumns</a> () const</td></tr>
<tr class="memdesc:gad311a7137ce157d3aacce9f0d7158eff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns that correspond to normal coordinates or angle structure coordinates.  <a href="group__enumerate.html#gad311a7137ce157d3aacce9f0d7158eff">More...</a><br /></td></tr>
<tr class="separator:gad311a7137ce157d3aacce9f0d7158eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93944a288a1ad231acb0adda4532ce4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa93944a288a1ad231acb0adda4532ce4">regina::LPInitialTableaux&lt; LPConstraint &gt;::constraintsBroken</a> () const</td></tr>
<tr class="memdesc:gaa93944a288a1ad231acb0adda4532ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully.  <a href="group__enumerate.html#gaa93944a288a1ad231acb0adda4532ce4">More...</a><br /></td></tr>
<tr class="separator:gaa93944a288a1ad231acb0adda4532ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e37e376183084bd90d4d4f19466015"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga16e37e376183084bd90d4d4f19466015">regina::LPInitialTableaux&lt; LPConstraint &gt;::columnPerm</a> () const</td></tr>
<tr class="memdesc:ga16e37e376183084bd90d4d4f19466015"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutation that describes how the columns of the matching equation matrix were reordered.  <a href="group__enumerate.html#ga16e37e376183084bd90d4d4f19466015">More...</a><br /></td></tr>
<tr class="separator:ga16e37e376183084bd90d4d4f19466015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351acbaa960c9dc0bb6c58cd947a544d"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga351acbaa960c9dc0bb6c58cd947a544d"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga351acbaa960c9dc0bb6c58cd947a544d">regina::LPInitialTableaux&lt; LPConstraint &gt;::multColByRow</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow, unsigned thisCol) const</td></tr>
<tr class="memdesc:ga351acbaa960c9dc0bb6c58cd947a544d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix.  <a href="group__enumerate.html#ga351acbaa960c9dc0bb6c58cd947a544d">More...</a><br /></td></tr>
<tr class="separator:ga351acbaa960c9dc0bb6c58cd947a544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ddc39309b9839190b5be4ec894fcc1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga87ddc39309b9839190b5be4ec894fcc1"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga87ddc39309b9839190b5be4ec894fcc1">regina::LPInitialTableaux&lt; LPConstraint &gt;::multColByRowOct</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow, unsigned thisCol) const</td></tr>
<tr class="memdesc:ga87ddc39309b9839190b5be4ec894fcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="group__enumerate.html#ga351acbaa960c9dc0bb6c58cd947a544d" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type.  <a href="group__enumerate.html#ga87ddc39309b9839190b5be4ec894fcc1">More...</a><br /></td></tr>
<tr class="separator:ga87ddc39309b9839190b5be4ec894fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa16772af7dc89a65a3547bab10c4e6b1">regina::LPInitialTableaux&lt; LPConstraint &gt;::fillInitialTableaux</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m) const</td></tr>
<tr class="memdesc:gaa16772af7dc89a65a3547bab10c4e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given matrix with the contents of this matrix.  <a href="group__enumerate.html#gaa16772af7dc89a65a3547bab10c4e6b1">More...</a><br /></td></tr>
<tr class="separator:gaa16772af7dc89a65a3547bab10c4e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dda040b565a8e653b81d2d150909426"><td class="memItemLeft" align="right" valign="top"><a id="ga9dda040b565a8e653b81d2d150909426"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPInitialTableaux&lt; LPConstraint &gt;::LPInitialTableaux</b> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;)=delete</td></tr>
<tr class="separator:ga9dda040b565a8e653b81d2d150909426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81951ea4aeaf1b5e83e01c3cd84d53aa"><td class="memItemLeft" align="right" valign="top"><a id="ga81951ea4aeaf1b5e83e01c3cd84d53aa"></a>
<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPInitialTableaux&lt; LPConstraint &gt;::operator=</b> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;)=delete</td></tr>
<tr class="separator:ga81951ea4aeaf1b5e83e01c3cd84d53aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac45a4647f5f984621209b6b0b3f68c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac45a4647f5f984621209b6b0b3f68c4b">regina::LPData&lt; LPConstraint, IntType &gt;::LPData</a> ()</td></tr>
<tr class="memdesc:gac45a4647f5f984621209b6b0b3f68c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new tableaux.  <a href="group__enumerate.html#gac45a4647f5f984621209b6b0b3f68c4b">More...</a><br /></td></tr>
<tr class="separator:gac45a4647f5f984621209b6b0b3f68c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294602a33df9186b5ccf57afdeb6c879"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga294602a33df9186b5ccf57afdeb6c879">regina::LPData&lt; LPConstraint, IntType &gt;::~LPData</a> ()</td></tr>
<tr class="memdesc:ga294602a33df9186b5ccf57afdeb6c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tableaux.  <a href="group__enumerate.html#ga294602a33df9186b5ccf57afdeb6c879">More...</a><br /></td></tr>
<tr class="separator:ga294602a33df9186b5ccf57afdeb6c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5120903a7dd47e0e09ce98efd3885bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb">regina::LPData&lt; LPConstraint, IntType &gt;::reserve</a> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; *origTableaux)</td></tr>
<tr class="memdesc:gab5120903a7dd47e0e09ce98efd3885bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough memory for this tableaux to work with.  <a href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb">More...</a><br /></td></tr>
<tr class="separator:gab5120903a7dd47e0e09ce98efd3885bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac48f34d3d8d79b3823f95bc2f64cf7a3">regina::LPData&lt; LPConstraint, IntType &gt;::initStart</a> ()</td></tr>
<tr class="memdesc:gac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this tableaux by beginning at the original starting tableaux and working our way to any feasible basis.  <a href="group__enumerate.html#gac48f34d3d8d79b3823f95bc2f64cf7a3">More...</a><br /></td></tr>
<tr class="separator:gac48f34d3d8d79b3823f95bc2f64cf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb498c421ccd15a2853821057078ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gadfb498c421ccd15a2853821057078ff2">regina::LPData&lt; LPConstraint, IntType &gt;::initClone</a> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;parent)</td></tr>
<tr class="memdesc:gadfb498c421ccd15a2853821057078ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this tableaux to be a clone of the given tableaux.  <a href="group__enumerate.html#gadfb498c421ccd15a2853821057078ff2">More...</a><br /></td></tr>
<tr class="separator:gadfb498c421ccd15a2853821057078ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2bfd2bac90cee1ab7f9beb6fba0aef"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef">regina::LPData&lt; LPConstraint, IntType &gt;::columns</a> () const</td></tr>
<tr class="memdesc:ga6c2bfd2bac90cee1ab7f9beb6fba0aef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this tableaux.  <a href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef">More...</a><br /></td></tr>
<tr class="separator:ga6c2bfd2bac90cee1ab7f9beb6fba0aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b04c6ddcbbfe2be49817bf58c72b66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga66b04c6ddcbbfe2be49817bf58c72b66">regina::LPData&lt; LPConstraint, IntType &gt;::coordinateColumns</a> () const</td></tr>
<tr class="memdesc:ga66b04c6ddcbbfe2be49817bf58c72b66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this tableaux that correspond to normal coordinates or angle structure coordinates.  <a href="group__enumerate.html#ga66b04c6ddcbbfe2be49817bf58c72b66">More...</a><br /></td></tr>
<tr class="separator:ga66b04c6ddcbbfe2be49817bf58c72b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89cafcaf61506e02ff12c7699424bedd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga89cafcaf61506e02ff12c7699424bedd">regina::LPData&lt; LPConstraint, IntType &gt;::isFeasible</a> () const</td></tr>
<tr class="memdesc:ga89cafcaf61506e02ff12c7699424bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this system is feasible.  <a href="group__enumerate.html#ga89cafcaf61506e02ff12c7699424bedd">More...</a><br /></td></tr>
<tr class="separator:ga89cafcaf61506e02ff12c7699424bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86606754589974c018ca660e6a96c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae86606754589974c018ca660e6a96c31">regina::LPData&lt; LPConstraint, IntType &gt;::isActive</a> (unsigned pos) const</td></tr>
<tr class="memdesc:gae86606754589974c018ca660e6a96c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given variable is currently active.  <a href="group__enumerate.html#gae86606754589974c018ca660e6a96c31">More...</a><br /></td></tr>
<tr class="separator:gae86606754589974c018ca660e6a96c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f652192f66a2b5c4229e4f8e9c1879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf3f652192f66a2b5c4229e4f8e9c1879">regina::LPData&lt; LPConstraint, IntType &gt;::sign</a> (unsigned pos) const</td></tr>
<tr class="memdesc:gaf3f652192f66a2b5c4229e4f8e9c1879"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the given variable under the current basis.  <a href="group__enumerate.html#gaf3f652192f66a2b5c4229e4f8e9c1879">More...</a><br /></td></tr>
<tr class="separator:gaf3f652192f66a2b5c4229e4f8e9c1879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05d6e693c09fadde2c43d62951effe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac05d6e693c09fadde2c43d62951effe6">regina::LPData&lt; LPConstraint, IntType &gt;::constrainZero</a> (unsigned pos)</td></tr>
<tr class="memdesc:gac05d6e693c09fadde2c43d62951effe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains this system further by setting the given variable to zero and deactivating it.  <a href="group__enumerate.html#gac05d6e693c09fadde2c43d62951effe6">More...</a><br /></td></tr>
<tr class="separator:gac05d6e693c09fadde2c43d62951effe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13df31bf31dabdeba22a4d0e7e77197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197">regina::LPData&lt; LPConstraint, IntType &gt;::constrainPositive</a> (unsigned pos)</td></tr>
<tr class="memdesc:gad13df31bf31dabdeba22a4d0e7e77197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains this system further by constraining the given variable to be strictly positive.  <a href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197">More...</a><br /></td></tr>
<tr class="separator:gad13df31bf31dabdeba22a4d0e7e77197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3de34d05aa11d2f75f7d63b0d56f9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae">regina::LPData&lt; LPConstraint, IntType &gt;::constrainOct</a> (unsigned quad1, unsigned quad2)</td></tr>
<tr class="memdesc:gae3de34d05aa11d2f75f7d63b0d56f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single octagon coordinate, for use with almost normal surfaces, and constrains the system accordingly.  <a href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae">More...</a><br /></td></tr>
<tr class="separator:gae3de34d05aa11d2f75f7d63b0d56f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af57d2924355a48c3c0f6343e56f69a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga8af57d2924355a48c3c0f6343e56f69a">regina::LPData&lt; LPConstraint, IntType &gt;::dump</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga8af57d2924355a48c3c0f6343e56f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of this tableaux to the given output stream.  <a href="group__enumerate.html#ga8af57d2924355a48c3c0f6343e56f69a">More...</a><br /></td></tr>
<tr class="separator:ga8af57d2924355a48c3c0f6343e56f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bc03626c7b12c8a49cd512fd4be9b1"><td class="memTemplParams" colspan="2">template&lt;class RayClass &gt; </td></tr>
<tr class="memitem:gaf7bc03626c7b12c8a49cd512fd4be9b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf7bc03626c7b12c8a49cd512fd4be9b1">regina::LPData&lt; LPConstraint, IntType &gt;::extractSolution</a> (RayClass &amp;v, const char *type) const</td></tr>
<tr class="memdesc:gaf7bc03626c7b12c8a49cd512fd4be9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the values of the individual variables from the current basis, with some modifications (as described below).  <a href="group__enumerate.html#gaf7bc03626c7b12c8a49cd512fd4be9b1">More...</a><br /></td></tr>
<tr class="separator:gaf7bc03626c7b12c8a49cd512fd4be9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11328811a59f0f1d2ddd8f2b909f371"><td class="memItemLeft" align="right" valign="top"><a id="gad11328811a59f0f1d2ddd8f2b909f371"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPData&lt; LPConstraint, IntType &gt;::LPData</b> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;)=delete</td></tr>
<tr class="separator:gad11328811a59f0f1d2ddd8f2b909f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50197a856e06d4428a7e61b801b1d58"><td class="memItemLeft" align="right" valign="top"><a id="gab50197a856e06d4428a7e61b801b1d58"></a>
<a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::LPData&lt; LPConstraint, IntType &gt;::operator=</b> (const <a class="el" href="classregina_1_1LPData.html">LPData</a> &amp;)=delete</td></tr>
<tr class="separator:gab50197a856e06d4428a7e61b801b1d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbb5b7727d4014b41636e20017bfb7e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga7fbb5b7727d4014b41636e20017bfb7e">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::supported</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga7fbb5b7727d4014b41636e20017bfb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the given coordinate system is supported by this tree traversal infrastructure.  <a href="group__enumerate.html#ga7fbb5b7727d4014b41636e20017bfb7e">More...</a><br /></td></tr>
<tr class="separator:ga7fbb5b7727d4014b41636e20017bfb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d287e45aaeccb9fcc065645364cef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac2d287e45aaeccb9fcc065645364cef2">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::constraintsBroken</a> () const</td></tr>
<tr class="memdesc:gac2d287e45aaeccb9fcc065645364cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully to the infrastructure for the search tree.  <a href="group__enumerate.html#gac2d287e45aaeccb9fcc065645364cef2">More...</a><br /></td></tr>
<tr class="separator:gac2d287e45aaeccb9fcc065645364cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1656d8fec6e9cfa7cec544f636dd1396"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1656d8fec6e9cfa7cec544f636dd1396">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nVisited</a> () const</td></tr>
<tr class="memdesc:ga1656d8fec6e9cfa7cec544f636dd1396"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of nodes in the search tree that we have visited thus far in the tree traversal.  <a href="group__enumerate.html#ga1656d8fec6e9cfa7cec544f636dd1396">More...</a><br /></td></tr>
<tr class="separator:ga1656d8fec6e9cfa7cec544f636dd1396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17103e248164f04e3b5d50b322cf772e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::dumpTypes</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga17103e248164f04e3b5d50b322cf772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current type vector to the given output stream.  <a href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e">More...</a><br /></td></tr>
<tr class="separator:ga17103e248164f04e3b5d50b322cf772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd66260d35869bc74418b6e1bf246468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::buildSurface</a> () const</td></tr>
<tr class="memdesc:gadd66260d35869bc74418b6e1bf246468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full normal surface that is represented by the type vector at the current stage of the search.  <a href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468">More...</a><br /></td></tr>
<tr class="separator:gadd66260d35869bc74418b6e1bf246468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b11b28eca4fe085eec4d9cf7891ddb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::buildStructure</a> () const</td></tr>
<tr class="memdesc:ga0b11b28eca4fe085eec4d9cf7891ddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search.  <a href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9">More...</a><br /></td></tr>
<tr class="separator:ga0b11b28eca4fe085eec4d9cf7891ddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04172f2396e949298a137034c0e608d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa04172f2396e949298a137034c0e608d">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::verify</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *s, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *matchingEqns=0) const</td></tr>
<tr class="memdesc:gaa04172f2396e949298a137034c0e608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given normal or almost normal surface satisfies the matching equations, as well as any additional constraints from the template parameter LPConstraint.  <a href="group__enumerate.html#gaa04172f2396e949298a137034c0e608d">More...</a><br /></td></tr>
<tr class="separator:gaa04172f2396e949298a137034c0e608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b222fac01e81df79115ec9132075448"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1b222fac01e81df79115ec9132075448">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::verify</a> (const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *s, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *angleEqns=0) const</td></tr>
<tr class="memdesc:ga1b222fac01e81df79115ec9132075448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the given angle structure satisfies the angle equations, as well as any additional constraints from the template parameter LPConstraint.  <a href="group__enumerate.html#ga1b222fac01e81df79115ec9132075448">More...</a><br /></td></tr>
<tr class="separator:ga1b222fac01e81df79115ec9132075448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3515a4db53a25354441cf2d9d9d397"><td class="memItemLeft" align="right" valign="top"><a id="ga9b3515a4db53a25354441cf2d9d9d397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::TreeTraversal</b> (const <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a> &amp;)=delete</td></tr>
<tr class="separator:ga9b3515a4db53a25354441cf2d9d9d397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e4037b7c80b9c1095a0887b6dac663"><td class="memItemLeft" align="right" valign="top"><a id="gab5e4037b7c80b9c1095a0887b6dac663"></a>
<a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::operator=</b> (const <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a> &amp;)=delete</td></tr>
<tr class="separator:gab5e4037b7c80b9c1095a0887b6dac663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1407f91ab30c5445f560506b19157c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf1407f91ab30c5445f560506b19157c4">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::TreeTraversal</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, int branchesPerQuad, int branchesPerTri, bool enumeration)</td></tr>
<tr class="memdesc:gaf1407f91ab30c5445f560506b19157c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new base object for running the tree traversal algorithm.  <a href="group__enumerate.html#gaf1407f91ab30c5445f560506b19157c4">More...</a><br /></td></tr>
<tr class="separator:gaf1407f91ab30c5445f560506b19157c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5682768cd64e18047f7a155e107960"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2b5682768cd64e18047f7a155e107960">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::~TreeTraversal</a> ()</td></tr>
<tr class="memdesc:ga2b5682768cd64e18047f7a155e107960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object.  <a href="group__enumerate.html#ga2b5682768cd64e18047f7a155e107960">More...</a><br /></td></tr>
<tr class="separator:ga2b5682768cd64e18047f7a155e107960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14d88b7380ef7d19d181991e9b2fe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf14d88b7380ef7d19d181991e9b2fe79">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::setNext</a> (int nextType)</td></tr>
<tr class="memdesc:gaf14d88b7380ef7d19d181991e9b2fe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges the search tree so that <em>nextType</em> becomes the next type that we process.  <a href="group__enumerate.html#gaf14d88b7380ef7d19d181991e9b2fe79">More...</a><br /></td></tr>
<tr class="separator:gaf14d88b7380ef7d19d181991e9b2fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133246fc0feecf761c6f1b023630e0c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga133246fc0feecf761c6f1b023630e0c7">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nextUnmarkedTriangleType</a> (int startFrom)</td></tr>
<tr class="memdesc:ga133246fc0feecf761c6f1b023630e0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next unmarked triangle type from a given starting point.  <a href="group__enumerate.html#ga133246fc0feecf761c6f1b023630e0c7">More...</a><br /></td></tr>
<tr class="separator:ga133246fc0feecf761c6f1b023630e0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46815f41b24319ef2de3a91939bfa37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae46815f41b24319ef2de3a91939bfa37">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::feasibleBranches</a> (int quadType)</td></tr>
<tr class="memdesc:gae46815f41b24319ef2de3a91939bfa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system.  <a href="group__enumerate.html#gae46815f41b24319ef2de3a91939bfa37">More...</a><br /></td></tr>
<tr class="separator:gae46815f41b24319ef2de3a91939bfa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b02f4672e87c516777b146ab70bd5fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga0b02f4672e87c516777b146ab70bd5fa">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::percent</a> () const</td></tr>
<tr class="memdesc:ga0b02f4672e87c516777b146ab70bd5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree.  <a href="group__enumerate.html#ga0b02f4672e87c516777b146ab70bd5fa">More...</a><br /></td></tr>
<tr class="separator:ga0b02f4672e87c516777b146ab70bd5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac53f9077d41478f5ec66bf131eab2f22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac53f9077d41478f5ec66bf131eab2f22">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::TreeEnumeration</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:gac53f9077d41478f5ec66bf131eab2f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for running the tree traversal algorithm.  <a href="group__enumerate.html#gac53f9077d41478f5ec66bf131eab2f22">More...</a><br /></td></tr>
<tr class="separator:gac53f9077d41478f5ec66bf131eab2f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3615f140b03ca3e65af71abac131fecb"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga3615f140b03ca3e65af71abac131fecb">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::nSolns</a> () const</td></tr>
<tr class="memdesc:ga3615f140b03ca3e65af71abac131fecb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of vertex normal or almost normal surfaces found thus far in the tree traversal search.  <a href="group__enumerate.html#ga3615f140b03ca3e65af71abac131fecb">More...</a><br /></td></tr>
<tr class="separator:ga3615f140b03ca3e65af71abac131fecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0893b762beded243bd8a3d7445a92d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::run</a> (bool(*useSoln)(const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;, void *), void *arg=0)</td></tr>
<tr class="memdesc:gaf0893b762beded243bd8a3d7445a92d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.  <a href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0">More...</a><br /></td></tr>
<tr class="separator:gaf0893b762beded243bd8a3d7445a92d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a02cade5fd5c8db9b5d92e0defb2ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::next</a> (<a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0)</td></tr>
<tr class="memdesc:gae5a02cade5fd5c8db9b5d92e0defb2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An incremental step in the tree traversal algorithm that runs forward until it finds the next solution.  <a href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab">More...</a><br /></td></tr>
<tr class="separator:gae5a02cade5fd5c8db9b5d92e0defb2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa527c26359b3989cd9ea6fb1ce85efb8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaa527c26359b3989cd9ea6fb1ce85efb8">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::writeTypes</a> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;tree, void *)</td></tr>
<tr class="memdesc:gaa527c26359b3989cd9ea6fb1ce85efb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the type vector at the current point in the given tree traversal search.  <a href="group__enumerate.html#gaa527c26359b3989cd9ea6fb1ce85efb8">More...</a><br /></td></tr>
<tr class="separator:gaa527c26359b3989cd9ea6fb1ce85efb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0fbf60b1328751f7cc03c9aa334578"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9c0fbf60b1328751f7cc03c9aa334578">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::writeSurface</a> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;tree, void *)</td></tr>
<tr class="memdesc:ga9c0fbf60b1328751f7cc03c9aa334578"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the full triangle-quadrilateral coordinates of the vertex normal or almost normal surface at the current point in the given tree traversal search.  <a href="group__enumerate.html#ga9c0fbf60b1328751f7cc03c9aa334578">More...</a><br /></td></tr>
<tr class="separator:ga9c0fbf60b1328751f7cc03c9aa334578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad434a10033bf29d5771094cbbe5ea6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaad434a10033bf29d5771094cbbe5ea6a">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::TautEnumeration</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri)</td></tr>
<tr class="memdesc:gaad434a10033bf29d5771094cbbe5ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for running the tree traversal algorithm.  <a href="group__enumerate.html#gaad434a10033bf29d5771094cbbe5ea6a">More...</a><br /></td></tr>
<tr class="separator:gaad434a10033bf29d5771094cbbe5ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5b392e101f339872f79f8d8e1725c3"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga6c5b392e101f339872f79f8d8e1725c3">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::nSolns</a> () const</td></tr>
<tr class="memdesc:ga6c5b392e101f339872f79f8d8e1725c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of taut angle structures found thus far in the tree traversal search.  <a href="group__enumerate.html#ga6c5b392e101f339872f79f8d8e1725c3">More...</a><br /></td></tr>
<tr class="separator:ga6c5b392e101f339872f79f8d8e1725c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf905f788522242ffaf9def76faa42067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::run</a> (bool(*useSoln)(const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a> &amp;, void *), void *arg=0)</td></tr>
<tr class="memdesc:gaf905f788522242ffaf9def76faa42067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the complete tree traversal algorithm to enumerate all taut angle structures.  <a href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067">More...</a><br /></td></tr>
<tr class="separator:gaf905f788522242ffaf9def76faa42067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef628d8527d115ea92798957459bcf06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::next</a> (<a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0)</td></tr>
<tr class="memdesc:gaef628d8527d115ea92798957459bcf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">An incremental step in the enumeration algorithm that runs forward until it finds the next solution.  <a href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06">More...</a><br /></td></tr>
<tr class="separator:gaef628d8527d115ea92798957459bcf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf430013a213dbf0ecb2487f389710551"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf430013a213dbf0ecb2487f389710551">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::writeTypes</a> (const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a> &amp;tree, void *)</td></tr>
<tr class="memdesc:gaf430013a213dbf0ecb2487f389710551"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the type vector at the current point in the given tree traversal search.  <a href="group__enumerate.html#gaf430013a213dbf0ecb2487f389710551">More...</a><br /></td></tr>
<tr class="separator:gaf430013a213dbf0ecb2487f389710551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5ec27c9170315f1977ee4f47f0686"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1cf5ec27c9170315f1977ee4f47f0686">regina::TautEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;::writeStructure</a> (const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a> &amp;tree, void *)</td></tr>
<tr class="memdesc:ga1cf5ec27c9170315f1977ee4f47f0686"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the full angle structure coordinates of the taut angle structure at the current point in the given tree traversal search.  <a href="group__enumerate.html#ga1cf5ec27c9170315f1977ee4f47f0686">More...</a><br /></td></tr>
<tr class="separator:ga1cf5ec27c9170315f1977ee4f47f0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe79652f80c71ab48e763d55ba1b3d7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gafe79652f80c71ab48e763d55ba1b3d7e">regina::TreeSingleSoln&lt; LPConstraint, BanConstraint, IntType &gt;::TreeSingleSoln</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *tri, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:gafe79652f80c71ab48e763d55ba1b3d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for running the tree traversal / branching algorithm to locate a non-trivial surface that satisfies the chosen constraints.  <a href="group__enumerate.html#gafe79652f80c71ab48e763d55ba1b3d7e">More...</a><br /></td></tr>
<tr class="separator:gafe79652f80c71ab48e763d55ba1b3d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6434978ea0aac9ffb43bdcbd26da214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214">regina::TreeSingleSoln&lt; LPConstraint, BanConstraint, IntType &gt;::find</a> ()</td></tr>
<tr class="memdesc:gaf6434978ea0aac9ffb43bdcbd26da214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen constraints, or else proves that no such solution exists.  <a href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214">More...</a><br /></td></tr>
<tr class="separator:gaf6434978ea0aac9ffb43bdcbd26da214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa22f9310d660f1165ffdc3aaa687801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaaa22f9310d660f1165ffdc3aaa687801">regina::TreeSingleSoln&lt; LPConstraint, BanConstraint, IntType &gt;::cancel</a> ()</td></tr>
<tr class="memdesc:gaaa22f9310d660f1165ffdc3aaa687801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels the current <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a> operation.  <a href="group__enumerate.html#gaaa22f9310d660f1165ffdc3aaa687801">More...</a><br /></td></tr>
<tr class="separator:gaaa22f9310d660f1165ffdc3aaa687801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2faa804e5db1858dff9ab7a59c4d0725"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2faa804e5db1858dff9ab7a59c4d0725">regina::TypeTrie&lt; nTypes &gt;::TypeTrie</a> ()</td></tr>
<tr class="memdesc:ga2faa804e5db1858dff9ab7a59c4d0725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises an empty trie.  <a href="group__enumerate.html#ga2faa804e5db1858dff9ab7a59c4d0725">More...</a><br /></td></tr>
<tr class="separator:ga2faa804e5db1858dff9ab7a59c4d0725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4951053bb78a2c34ecc67fb8fbcc7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2b4951053bb78a2c34ecc67fb8fbcc7b">regina::TypeTrie&lt; nTypes &gt;::~TypeTrie</a> ()</td></tr>
<tr class="memdesc:ga2b4951053bb78a2c34ecc67fb8fbcc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this trie.  <a href="group__enumerate.html#ga2b4951053bb78a2c34ecc67fb8fbcc7b">More...</a><br /></td></tr>
<tr class="separator:ga2b4951053bb78a2c34ecc67fb8fbcc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17e1012c1c221ab783180e33ad40cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf17e1012c1c221ab783180e33ad40cb7">regina::TypeTrie&lt; nTypes &gt;::clear</a> ()</td></tr>
<tr class="memdesc:gaf17e1012c1c221ab783180e33ad40cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this to the empty trie.  <a href="group__enumerate.html#gaf17e1012c1c221ab783180e33ad40cb7">More...</a><br /></td></tr>
<tr class="separator:gaf17e1012c1c221ab783180e33ad40cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4704879425f37b425555f89c01f53a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga4704879425f37b425555f89c01f53a57">regina::TypeTrie&lt; nTypes &gt;::insert</a> (const char *entry, unsigned len)</td></tr>
<tr class="memdesc:ga4704879425f37b425555f89c01f53a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given type vector into this trie.  <a href="group__enumerate.html#ga4704879425f37b425555f89c01f53a57">More...</a><br /></td></tr>
<tr class="separator:ga4704879425f37b425555f89c01f53a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94d6a45380d1229c6ce64daa05ea816"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae94d6a45380d1229c6ce64daa05ea816">regina::TypeTrie&lt; nTypes &gt;::dominates</a> (const char *vec, unsigned len) const</td></tr>
<tr class="memdesc:gae94d6a45380d1229c6ce64daa05ea816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type vector dominates any vector in this trie.  <a href="group__enumerate.html#gae94d6a45380d1229c6ce64daa05ea816">More...</a><br /></td></tr>
<tr class="separator:gae94d6a45380d1229c6ce64daa05ea816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f6c488b38a32724ddad9ed106a8e49"><td class="memItemLeft" align="right" valign="top"><a id="ga97f6c488b38a32724ddad9ed106a8e49"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TypeTrie&lt; nTypes &gt;::TypeTrie</b> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;)=delete</td></tr>
<tr class="separator:ga97f6c488b38a32724ddad9ed106a8e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20baae91eaa487c0bb6ae21968ca5b0c"><td class="memItemLeft" align="right" valign="top"><a id="ga20baae91eaa487c0bb6ae21968ca5b0c"></a>
<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TypeTrie&lt; nTypes &gt;::operator=</b> (const <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a> &amp;)=delete</td></tr>
<tr class="separator:ga20baae91eaa487c0bb6ae21968ca5b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga98ceee8fc0afeb2fea1ced18fa70f506"><td class="memItemLeft" align="right" valign="top">BitmaskType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga98ceee8fc0afeb2fea1ced18fa70f506">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::mask_</a></td></tr>
<tr class="memdesc:ga98ceee8fc0afeb2fea1ced18fa70f506"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask indicating which coordinates are zero (<code>false</code>) and which are non-zero (<code>true</code>).  <a href="group__enumerate.html#ga98ceee8fc0afeb2fea1ced18fa70f506">More...</a><br /></td></tr>
<tr class="separator:ga98ceee8fc0afeb2fea1ced18fa70f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c096e6ebafffe44d0e3ba62e6c0b00e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga2c096e6ebafffe44d0e3ba62e6c0b00e">regina::LPConstraintEuler::Coefficients::euler</a></td></tr>
<tr class="memdesc:ga2c096e6ebafffe44d0e3ba62e6c0b00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficient of the Euler characteristic function for the corresponding column of the matching equation matrix.  <a href="group__enumerate.html#ga2c096e6ebafffe44d0e3ba62e6c0b00e">More...</a><br /></td></tr>
<tr class="separator:ga2c096e6ebafffe44d0e3ba62e6c0b00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41bee94672244d2ce13b02cb0c52bef2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga41bee94672244d2ce13b02cb0c52bef2">regina::LPConstraintNonSpun::Coefficients::meridian</a></td></tr>
<tr class="memdesc:ga41bee94672244d2ce13b02cb0c52bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficient of the meridian equation for the corresponding column of the matching equation matrix.  <a href="group__enumerate.html#ga41bee94672244d2ce13b02cb0c52bef2">More...</a><br /></td></tr>
<tr class="separator:ga41bee94672244d2ce13b02cb0c52bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1fbd8365ea666a28e29d401e3ba808"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaed1fbd8365ea666a28e29d401e3ba808">regina::LPConstraintNonSpun::Coefficients::longitude</a></td></tr>
<tr class="memdesc:gaed1fbd8365ea666a28e29d401e3ba808"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficient of the longitude equation for the corresponding column of the matching equation matrix.  <a href="group__enumerate.html#gaed1fbd8365ea666a28e29d401e3ba808">More...</a><br /></td></tr>
<tr class="separator:gaed1fbd8365ea666a28e29d401e3ba808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00f1953eebfb29c9398be3be9b20811"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad00f1953eebfb29c9398be3be9b20811">regina::BanConstraintBase::tri_</a></td></tr>
<tr class="memdesc:gad00f1953eebfb29c9398be3be9b20811"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation with which we are working.  <a href="group__enumerate.html#gad00f1953eebfb29c9398be3be9b20811">More...</a><br /></td></tr>
<tr class="separator:gad00f1953eebfb29c9398be3be9b20811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a6acd436e0c868617def15827b0dd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae6a6acd436e0c868617def15827b0dd1">regina::BanConstraintBase::coords_</a></td></tr>
<tr class="memdesc:gae6a6acd436e0c868617def15827b0dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normal or almost normal coordinate system in which we are working.  <a href="group__enumerate.html#gae6a6acd436e0c868617def15827b0dd1">More...</a><br /></td></tr>
<tr class="separator:gae6a6acd436e0c868617def15827b0dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ca0d7c865641b559d540992ef1f022"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga04ca0d7c865641b559d540992ef1f022">regina::BanConstraintBase::banned_</a></td></tr>
<tr class="memdesc:ga04ca0d7c865641b559d540992ef1f022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which columns of a tableaux correspond to banned coordinates (e.g., banned normal disc types).  <a href="group__enumerate.html#ga04ca0d7c865641b559d540992ef1f022">More...</a><br /></td></tr>
<tr class="separator:ga04ca0d7c865641b559d540992ef1f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e953b2d69f3b5712cb228fb2e3ad9a"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga60e953b2d69f3b5712cb228fb2e3ad9a">regina::BanConstraintBase::marked_</a></td></tr>
<tr class="memdesc:ga60e953b2d69f3b5712cb228fb2e3ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which columns of a tableaux correspond to marked coordinates (e.g., marked normal disc types).  <a href="group__enumerate.html#ga60e953b2d69f3b5712cb228fb2e3ad9a">More...</a><br /></td></tr>
<tr class="separator:ga60e953b2d69f3b5712cb228fb2e3ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada30f12b826f02258d9916152cd0a5cf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gada30f12b826f02258d9916152cd0a5cf">regina::LPCol&lt; LPConstraint &gt;::nPlus</a></td></tr>
<tr class="memdesc:gada30f12b826f02258d9916152cd0a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of +1 entries in this column.  <a href="group__enumerate.html#gada30f12b826f02258d9916152cd0a5cf">More...</a><br /></td></tr>
<tr class="separator:gada30f12b826f02258d9916152cd0a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f053dc500939bfaa094efb70ee0e550"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9f053dc500939bfaa094efb70ee0e550">regina::LPCol&lt; LPConstraint &gt;::plus</a> [4]</td></tr>
<tr class="memdesc:ga9f053dc500939bfaa094efb70ee0e550"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rows containing these +1 entries, in any order.  <a href="group__enumerate.html#ga9f053dc500939bfaa094efb70ee0e550">More...</a><br /></td></tr>
<tr class="separator:ga9f053dc500939bfaa094efb70ee0e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e03d9c29e24a019cb70b5b124ee307a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga1e03d9c29e24a019cb70b5b124ee307a">regina::LPCol&lt; LPConstraint &gt;::nMinus</a></td></tr>
<tr class="memdesc:ga1e03d9c29e24a019cb70b5b124ee307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of -1 entries in this column.  <a href="group__enumerate.html#ga1e03d9c29e24a019cb70b5b124ee307a">More...</a><br /></td></tr>
<tr class="separator:ga1e03d9c29e24a019cb70b5b124ee307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e5e7853637ad4579f4b4783d3f324c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac0e5e7853637ad4579f4b4783d3f324c">regina::LPCol&lt; LPConstraint &gt;::minus</a> [4]</td></tr>
<tr class="memdesc:gac0e5e7853637ad4579f4b4783d3f324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rows containing these -1 entries, in any order.  <a href="group__enumerate.html#gac0e5e7853637ad4579f4b4783d3f324c">More...</a><br /></td></tr>
<tr class="separator:gac0e5e7853637ad4579f4b4783d3f324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883cfd719b17e7ddde2093019e8213d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga883cfd719b17e7ddde2093019e8213d4">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::origTableaux_</a></td></tr>
<tr class="memdesc:ga883cfd719b17e7ddde2093019e8213d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins.  <a href="group__enumerate.html#ga883cfd719b17e7ddde2093019e8213d4">More...</a><br /></td></tr>
<tr class="separator:ga883cfd719b17e7ddde2093019e8213d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95fd4b924809b9f74639b855830dee99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga95fd4b924809b9f74639b855830dee99">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::coords_</a></td></tr>
<tr class="memdesc:ga95fd4b924809b9f74639b855830dee99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate system in which we are enumerating or searching for normal surfaces, almost normal surfaces, or taut angle structures.  <a href="group__enumerate.html#ga95fd4b924809b9f74639b855830dee99">More...</a><br /></td></tr>
<tr class="separator:ga95fd4b924809b9f74639b855830dee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d93ed3fb68589d4636512f918808dd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gab7d93ed3fb68589d4636512f918808dd">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nTets_</a></td></tr>
<tr class="memdesc:gab7d93ed3fb68589d4636512f918808dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tetrahedra in the underlying triangulation.  <a href="group__enumerate.html#gab7d93ed3fb68589d4636512f918808dd">More...</a><br /></td></tr>
<tr class="separator:gab7d93ed3fb68589d4636512f918808dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa69f409c9c907f44f27d02d765c649"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gabaa69f409c9c907f44f27d02d765c649">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nTypes_</a></td></tr>
<tr class="memdesc:gabaa69f409c9c907f44f27d02d765c649"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total length of a type vector.  <a href="group__enumerate.html#gabaa69f409c9c907f44f27d02d765c649">More...</a><br /></td></tr>
<tr class="separator:gabaa69f409c9c907f44f27d02d765c649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51922fd588f4521499e28d3fe399df5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gac51922fd588f4521499e28d3fe399df5">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nTableaux_</a></td></tr>
<tr class="memdesc:gac51922fd588f4521499e28d3fe399df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search.  <a href="group__enumerate.html#gac51922fd588f4521499e28d3fe399df5">More...</a><br /></td></tr>
<tr class="separator:gac51922fd588f4521499e28d3fe399df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f957a2834e470907a883c15694bff3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga9f957a2834e470907a883c15694bff3d">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::type_</a></td></tr>
<tr class="memdesc:ga9f957a2834e470907a883c15694bff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current working type vector.  <a href="group__enumerate.html#ga9f957a2834e470907a883c15694bff3d">More...</a><br /></td></tr>
<tr class="separator:ga9f957a2834e470907a883c15694bff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ae7d45353f99075de18edf6bd72291"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga85ae7d45353f99075de18edf6bd72291">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::typeOrder_</a></td></tr>
<tr class="memdesc:ga85ae7d45353f99075de18edf6bd72291"><td class="mdescLeft">&#160;</td><td class="mdescRight">A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]].  <a href="group__enumerate.html#ga85ae7d45353f99075de18edf6bd72291">More...</a><br /></td></tr>
<tr class="separator:ga85ae7d45353f99075de18edf6bd72291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3269d2da06523312eed52e328c6fe06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gad3269d2da06523312eed52e328c6fe06">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::level_</a></td></tr>
<tr class="memdesc:gad3269d2da06523312eed52e328c6fe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current level in the search tree.  <a href="group__enumerate.html#gad3269d2da06523312eed52e328c6fe06">More...</a><br /></td></tr>
<tr class="separator:gad3269d2da06523312eed52e328c6fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b922a1b3ce46f848c76e5105e80acb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gaf7b922a1b3ce46f848c76e5105e80acb">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::octLevel_</a></td></tr>
<tr class="memdesc:gaf7b922a1b3ce46f848c76e5105e80acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level at which we are enforcing an octagon type (with a strictly positive number of octagons).  <a href="group__enumerate.html#gaf7b922a1b3ce46f848c76e5105e80acb">More...</a><br /></td></tr>
<tr class="separator:gaf7b922a1b3ce46f848c76e5105e80acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399bdd3aa3c2aad75d17b65c3b81715c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga399bdd3aa3c2aad75d17b65c3b81715c">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::lp_</a></td></tr>
<tr class="memdesc:ga399bdd3aa3c2aad75d17b65c3b81715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores tableaux for linear programming at various nodes in the search tree.  <a href="group__enumerate.html#ga399bdd3aa3c2aad75d17b65c3b81715c">More...</a><br /></td></tr>
<tr class="separator:ga399bdd3aa3c2aad75d17b65c3b81715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16999f1b18c4f3738fc78ab7230c46c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga16999f1b18c4f3738fc78ab7230c46c0">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::lpSlot_</a></td></tr>
<tr class="memdesc:ga16999f1b18c4f3738fc78ab7230c46c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors.  <a href="group__enumerate.html#ga16999f1b18c4f3738fc78ab7230c46c0">More...</a><br /></td></tr>
<tr class="separator:ga16999f1b18c4f3738fc78ab7230c46c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63265bf71e0086a5ad1e47657550a521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga63265bf71e0086a5ad1e47657550a521">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nextSlot_</a></td></tr>
<tr class="memdesc:ga63265bf71e0086a5ad1e47657550a521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the next available tableaux in lp_ that is free to use at each level of the search tree.  <a href="group__enumerate.html#ga63265bf71e0086a5ad1e47657550a521">More...</a><br /></td></tr>
<tr class="separator:ga63265bf71e0086a5ad1e47657550a521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835a117f24c5a359d4f6cd20af50179f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#ga835a117f24c5a359d4f6cd20af50179f">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::nVisited_</a></td></tr>
<tr class="memdesc:ga835a117f24c5a359d4f6cd20af50179f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the total number of nodes in the search tree that we have visited thus far.  <a href="group__enumerate.html#ga835a117f24c5a359d4f6cd20af50179f">More...</a><br /></td></tr>
<tr class="separator:ga835a117f24c5a359d4f6cd20af50179f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae041b264994cb18b5dcae4ebafff7f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enumerate.html#gae041b264994cb18b5dcae4ebafff7f16">regina::TreeTraversal&lt; LPConstraint, BanConstraint, IntType &gt;::tmpLP_</a> [4]</td></tr>
<tr class="memdesc:gae041b264994cb18b5dcae4ebafff7f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary tableaux used by the function <a class="el" href="group__enumerate.html#gae46815f41b24319ef2de3a91939bfa37" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree.  <a href="group__enumerate.html#gae041b264994cb18b5dcae4ebafff7f16">More...</a><br /></td></tr>
<tr class="separator:gae041b264994cb18b5dcae4ebafff7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Polytope vertex enumeration algorithms. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1c6a2d141f3bd1255506c8d87bc17c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6a2d141f3bd1255506c8d87bc17c64">&#9670;&nbsp;</a></span>EnumConstraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::set&lt;unsigned long&gt; &gt; <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">regina::EnumConstraints</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an individual validity constraint for use with polytope vertex enumeration. </p>
<p>Vertex enumeration routines such as <a class="el" href="group__enumerate.html#ga6efe21b1f1cd8cd4b29f6cec14b9cbe9" title="Determines the extremal rays of the intersection of the n-dimensional non-negative orthant with the g...">DoubleDescription::enumerateExtremalRays()</a> take a cone (specifically the non-negative orthant), form the intersection of that cone with a given linear subspace, and return the extremal rays of the new cone that results.</p>
<p>In some cases we are only interested in <em>valid</em> rays of the new cone. The EnumConstraints class stores a number of "validity constraints"; a ray is then "valid" if it satisfies all of these constraints.</p>
<p>Each individual constraint is presented as a set of integers; the meaning of such a constraint is as follows. We number the facets of the original cone 0,1,2,... (where the <em>i</em>th facet is the plane perpendicular to the <em>i</em>th coordinate axis). If a constraint is described by the integers <em>x</em>, <em>y</em>, <em>z</em>, ..., then it indicates that a ray can only lie outside at most one of the facets numbered <em>x</em>, <em>y</em>, <em>z</em>, ... .</p>
<p>In practice, this allows us to represent constraints in normal surface theory. For instance, to insist that some tetrahedron contains at most one quadrilateral disc type, we add a constraint with three integers, representing the original facets <em>q1=0</em>, <em>q2=0</em>, <em>q3=0</em> (where <em>q1</em>, <em>q2</em> and <em>q3</em> are the three quadrilateral coordinates for that tetrahedron).</p>
<p>The EnumConstraints class is simply a std::vector of constraints, where each constraint is a std::set of unsigned integers. Typically one will create a vector containing the desired number of constraints and then walk through each constraint, filling the sets as appropriate.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga932696433895d99b74143666ef7ae947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932696433895d99b74143666ef7ae947">&#9670;&nbsp;</a></span>NDoubleDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1DoubleDescription.html">DoubleDescription</a> <a class="el" href="group__enumerate.html#ga932696433895d99b74143666ef7ae947">regina::NDoubleDescription</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>The class NDoubleDescription has now been renamed to <a class="el" href="classregina_1_1DoubleDescription.html" title="Implements a modified double description method for polytope vertex enumeration.">DoubleDescription</a>. </dd></dl>

</div>
</div>
<a id="ga2755d69dcbf805f4b0027a5ee58a7ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2755d69dcbf805f4b0027a5ee58a7ca9">&#9670;&nbsp;</a></span>NEnumConstraintList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> <a class="el" href="group__enumerate.html#ga2755d69dcbf805f4b0027a5ee58a7ca9">regina::NEnumConstraintList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>The class NEnumConstraintList has now been renamed to EnumConstraints. </dd></dl>

</div>
</div>
<a id="gac396e8ec180e5036606065f8a3db7a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac396e8ec180e5036606065f8a3db7a44">&#9670;&nbsp;</a></span>NHilbertCD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HilbertCD.html">HilbertCD</a> <a class="el" href="group__enumerate.html#gac396e8ec180e5036606065f8a3db7a44">regina::NHilbertCD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>The class NHilbertCD has now been renamed to <a class="el" href="classregina_1_1HilbertCD.html" title="Implements a modified Contejean-Devie algorithm for enumerating Hilbert bases.">HilbertCD</a>. </dd></dl>

</div>
</div>
<a id="gace9474adadc2a6e91e59e82b5abb2e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9474adadc2a6e91e59e82b5abb2e48">&#9670;&nbsp;</a></span>NHilbertDual</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HilbertDual.html">HilbertDual</a> <a class="el" href="group__enumerate.html#gace9474adadc2a6e91e59e82b5abb2e48">regina::NHilbertDual</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>The class NHilbertDual has now been renamed to <a class="el" href="classregina_1_1HilbertDual.html" title="Implements a modified dual algorithm for enumerating Hilbert bases.">HilbertDual</a>. </dd></dl>

</div>
</div>
<a id="gae0fca485f0d5d6f32d2fc607ce403868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0fca485f0d5d6f32d2fc607ce403868">&#9670;&nbsp;</a></span>NHilbertPrimal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HilbertPrimal.html">HilbertPrimal</a> <a class="el" href="group__enumerate.html#gae0fca485f0d5d6f32d2fc607ce403868">regina::NHilbertPrimal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>The class NHilbertPrimal has now been renamed to <a class="el" href="classregina_1_1HilbertPrimal.html" title="Implements a modified primal algorithm for enumerating Hilbert bases.">HilbertPrimal</a>. </dd></dl>

</div>
</div>
<a id="ga5ecc802fbb202d343fb30e31cb339b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ecc802fbb202d343fb30e31cb339b3a">&#9670;&nbsp;</a></span>NPosOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PosOrder.html">PosOrder</a> <a class="el" href="group__enumerate.html#ga5ecc802fbb202d343fb30e31cb339b3a">regina::NPosOrder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>The class NPosOrder has now been renamed to <a class="el" href="classregina_1_1PosOrder.html" title="A comparison object that sorts hyperplanes by position vectors.">PosOrder</a>. </dd></dl>

</div>
</div>
<a id="ga5fac336725c3482ac0b01cb91eb8362b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fac336725c3482ac0b01cb91eb8362b">&#9670;&nbsp;</a></span>NTautEnumeration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__enumerate.html#ga5fac336725c3482ac0b01cb91eb8362b">regina::NTautEnumeration</a> = typedef <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a>&lt;LPConstraint, BanConstraint, IntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>The class NTautEnumeration has now been renamed to <a class="el" href="classregina_1_1TautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">TautEnumeration</a>. </dd></dl>

</div>
</div>
<a id="ga9532df611aa4afb1991a287a84fa6c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9532df611aa4afb1991a287a84fa6c60">&#9670;&nbsp;</a></span>NTreeEnumeration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__enumerate.html#ga9532df611aa4afb1991a287a84fa6c60">regina::NTreeEnumeration</a> = typedef <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt;LPConstraint, BanConstraint, IntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>The class NTreeEnumeration has now been renamed to <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a>. </dd></dl>

</div>
</div>
<a id="ga5f4079a32ae31f68147815169c6f6b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f4079a32ae31f68147815169c6f6b0b">&#9670;&nbsp;</a></span>NTreeSingleSoln</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__enumerate.html#ga5f4079a32ae31f68147815169c6f6b0b">regina::NTreeSingleSoln</a> = typedef <a class="el" href="classregina_1_1TreeSingleSoln.html">TreeSingleSoln</a>&lt;LPConstraint, BanConstraint, IntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>The class NTreeSingleSoln has now been renamed to <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a>. </dd></dl>

</div>
</div>
<a id="ga082f81a1541447787a30abd8065a6b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082f81a1541447787a30abd8065a6b60">&#9670;&nbsp;</a></span>NTreeTraversal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__enumerate.html#ga082f81a1541447787a30abd8065a6b60">regina::NTreeTraversal</a> = typedef <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt;LPConstraint, BanConstraint, IntType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>The class NTreeTraversal has now been renamed to <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a>. </dd></dl>

</div>
</div>
<a id="gac6ce23853786e9bc8778b2431390b3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ce23853786e9bc8778b2431390b3a0">&#9670;&nbsp;</a></span>NTypeTrie</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__enumerate.html#gac6ce23853786e9bc8778b2431390b3a0">regina::NTypeTrie</a> = typedef <a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a>&lt;nTypes&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>The class NTypeTrie has now been renamed to <a class="el" href="classregina_1_1TypeTrie.html" title="A trie that stores a set of type vectors of a fixed length.">TypeTrie</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5553e0320e5479034278641c8cc08e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5553e0320e5479034278641c8cc08e95">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5553e0320e5479034278641c8cc08e95a7a3bbb525442f796a52b3ad07f310360"></a>nConstraints&#160;</td><td class="fielddoc"><p>The number of additional linear constraints that we impose. </p>
<p>Each constraint will generate one new variable (column) and one new equation (row) in the tableaux. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac663caf3a27a7f814eec98e42cce10cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac663caf3a27a7f814eec98e42cce10cf">&#9670;&nbsp;</a></span>addRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::LPConstraintBase::addRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregina_1_1LPCol.html">LPCol</a>&lt; <a class="el" href="classregina_1_1LPConstraintBase.html">LPConstraintBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>columnPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly constructs equations for the linear function(s) constrained by this class. </p>
<p>Specifically, this routine takes an array of <a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html" title="Stores the extra coefficients in a single column for the nConstraints additional rows that we add to ...">Coefficients</a> objects (one for each column of the initial tableaux) and fills in the necessary coefficient data.</p>
<p>The precise form of the linear function(s) will typically depend upon the underlying triangulation. For this reason, the triangulation is explicitly passed, along with the permutation that indicates which columns of the initial tableaux correspond to which normal or angle structure coordinates.</p>
<p>More precisely: recall that, for each linear function, the initial tableaux acquires one new variable <em>x_i</em> that evaluates this linear function f(x). This routine must create the corresponding row that sets <code>f(x) - x_i = 0</code>. Thus it must construct the coefficients of f(x) in the columns corresponding to normal coordinates, and it must also set a coefficient of -1 in the column for the corresponding new variable.</p>
<p>For each subclass <em>S</em> of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a>, the array <em>col</em> must be an array of objects of type <a class="el" href="structregina_1_1LPCol.html" title="Used by LPInitialTableaux&lt;LPConstraint&gt; to store a single column of the adjusted matching equation ma...">LPCol</a><s>. The class <a class="el" href="structregina_1_1LPCol.html" title="Used by LPInitialTableaux&lt;LPConstraint&gt; to store a single column of the adjusted matching equation ma...">LPCol</a><s> is itself a larger subclass of the <a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html" title="Stores the extra coefficients in a single column for the nConstraints additional rows that we add to ...">Coefficients</a> class. This exact type must be used because the compiler must know how large each column object is in order to correct access each element of the given array.</s></s></p>
<p><s><s>As described in the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class notes, it might not be possible to construct the linear functions (since the triangulation might not satisfy the necessary requirements). In this case, this routine should ensure that the linear functions are in fact the zero functions, and should return <code>false</code> (but it must still set -1 coefficients for the new variables as described above). Otherwise (if the linear function were successfully constructed) this routine should return <code>true</code>.</s></s></p>
<p><s><s>If you are implementing this routine in a subclass that works with angle structure coordinates, remember that your linear constraints must not interact with the scaling coordinate (the final angle structure coordinate that is used to projectivise the angle structure polytope into a polyhedral cone). Your implementation of this routine <em>must</em> ensure that your linear constraints all have coefficient zero in this column.</s></s></p>
<p><s><s></p><dl class="section pre"><dt>Precondition</dt><dd>For all coefficients in the array <em>col</em>, the <a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html" title="Stores the extra coefficients in a single column for the nConstraints additional rows that we add to ...">Coefficients</a> substructures have all been initialised with the default constructor and not modified since.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the array of columns as stored in the initial tableaux (i.e., the data member LPInitialTableaux::col_). </td></tr>
    <tr><td class="paramname">columnPerm</td><td>the corresponding permutation of columns that describes how columns of the tableaux correspond to normal or angle structure coordinates in the underlying triangulation (i.e., the data member LPInitialTableaux::columnPerm_). </td></tr>
    <tr><td class="paramname">tri</td><td>the underlying triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the linear functions were successfully constructed, or <code>false</code> if not (in which case they will be replaced with the zero functions instead). </dd></dl>
<p></s></s></p>

</div>
</div>
<a id="gabc96d6a7dfbd8dc0316cfced17cde497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc96d6a7dfbd8dc0316cfced17cde497">&#9670;&nbsp;</a></span>BanBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BanBoundary::BanBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor. </p>
<dl class="section warning"><dt>Warning</dt><dd>Before you use this object, the routine init() must be called to fill in the <em>banned_</em> and <em>marked_</em> arrays with the correct data. Otherwise you will have no banned or marked disc types at all.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation with which we are working. </td></tr>
    <tr><td class="paramname">coords</td><td>the normal or almost normal coordinate system in which we are working. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, or NS_AN_STANDARD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8d836c495ce55d65cda27ef4e022391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d836c495ce55d65cda27ef4e022391">&#9670;&nbsp;</a></span>BanConstraintBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BanConstraintBase::BanConstraintBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>. </p>
<p>The only purpose of passing the triangulation and coordinate system is to determine how many normal or angle structure coordinates we are dealing with.</p>
<dl class="section warning"><dt>Warning</dt><dd>Before you use this object, the routine <a class="el" href="group__enumerate.html#ga9e5d0e821aa954ed8f76ec6d62c03f67" title="Identifies which coordinates to ban and mark, and records the corresponding tableaux columns in the b...">init()</a> must be called to fill in the <em>banned_</em> and <em>marked_</em> arrays with the correct data. Otherwise you will have no banned or marked disc types at all.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation with which we are working. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system in which we are working. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, NS_AN_STANDARD, or NS_ANGLE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf96a84e3760ddf0062c3a9eabc118952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf96a84e3760ddf0062c3a9eabc118952">&#9670;&nbsp;</a></span>BanNone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BanNone::BanNone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor. </p>
<p>Although one should normally call the routine init() before using this object, for <a class="el" href="classregina_1_1BanNone.html" title="A do-nothing class that bans no coordinates and marks no coordinates.">BanNone</a> this is not strictly necessary since there are no coordinates to ban or mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation with which we are working. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system in which we are working. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, NS_AN_STANDARD, or NS_ANGLE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga924d2ff9bdaeb2ce963c46d7410a4d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924d2ff9bdaeb2ce963c46d7410a4d5b">&#9670;&nbsp;</a></span>BanTorusBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BanTorusBoundary::BanTorusBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and initialises the <em>banned_</em> and <em>marked_</em> arrays to be entirely <code>false</code>, as described in the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> superclass constructor. </p>
<dl class="section warning"><dt>Warning</dt><dd>Before you use this object, the routine init() must be called to fill in the <em>banned_</em> and <em>marked_</em> arrays with the correct data. Otherwise you will have no banned or marked disc types at all.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation with which we are working. </td></tr>
    <tr><td class="paramname">coords</td><td>the normal or almost normal coordinate system in which we are working. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, or NS_AN_STANDARD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b11b28eca4fe085eec4d9cf7891ddb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b11b28eca4fe085eec4d9cf7891ddb9">&#9670;&nbsp;</a></span>buildStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a>* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::buildStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search. </p>
<p>This routine is for use only with taut angle structures, not normal or almost normal surfaces.</p>
<p>The angle structure that is returned will be newly constructed, and it is the caller's responsibility to destroy it when it is no longer required.</p>
<p>There will always be a unique taut angle structure corresponding to this type vector (this follows from the preconditions below).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a taut angle structure. This condition is always true after <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">TautEnumeration::next()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">TautEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with angle structure coordinates; that is, the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was NS_ANGLE.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the taut angle structure that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a id="gadd66260d35869bc74418b6e1bf246468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd66260d35869bc74418b6e1bf246468">&#9670;&nbsp;</a></span>buildSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::buildSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the full normal surface that is represented by the type vector at the current stage of the search. </p>
<p>This routine is for use only with normal (or almost normal) surfaces, not taut angle structures.</p>
<p>The surface that is returned will be newly constructed, and it is the caller's responsibility to destroy it when it is no longer required.</p>
<p>If the current type vector does not represent a <em>vertex</em> normal surface (which may be the case when calling <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a>), then there may be many normal surfaces all represented by the same type vector; in this case there are no further guarantees about <em>which</em> of these normal surfaces you will get.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a normal surface (though this need not be a vertex surface). This condition is always true after <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> or <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">TreeEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with normal or almost normal surfaces. That is, the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was not NS_ANGLE.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a normal surface that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a id="gaaa22f9310d660f1165ffdc3aaa687801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa22f9310d660f1165ffdc3aaa687801">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeSingleSoln.html">regina::TreeSingleSoln</a>&lt; LPConstraint, BanConstraint, IntType &gt;::cancel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels the current <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a> operation. </p>
<p>This may be called from another thread (it is thread-safe). If called, it signals that if <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a> is currently running then it should be cancelled at the earliest convenient opportunity. </p>

</div>
</div>
<a id="gaf17e1012c1c221ab783180e33ad40cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf17e1012c1c221ab783180e33ad40cb7">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets this to the empty trie. </p>

</div>
</div>
<a id="ga85b4c270ce9f7ebedce05636a6391e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85b4c270ce9f7ebedce05636a6391e47">&#9670;&nbsp;</a></span>Coefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::LPConstraintBase::Coefficients::Coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialised set of coefficients for a single column. </p>
<p>These cofficients must be initialised through a call to <a class="el" href="group__enumerate.html#gac663caf3a27a7f814eec98e42cce10cf" title="Explicitly constructs equations for the linear function(s) constrained by this class.">addRows()</a> before they can be used. </p>

</div>
</div>
<a id="ga16e37e376183084bd90d4d4f19466015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e37e376183084bd90d4d4f19466015">&#9670;&nbsp;</a></span>columnPerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int * <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columnPerm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutation that describes how the columns of the matching equation matrix were reordered. </p>
<p>This permutation maps column numbers in this adjusted matching equation matrix to column numbers in the original (unmodified) matching equation matrix that was originally derived from the triangulation.</p>
<p>The permutation is returned as an array of <a class="el" href="group__enumerate.html#gac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a> integers, such that column <em>i</em> of this adjusted matrix corresponds to column <code><a class="el" href="group__enumerate.html#ga16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a>[i]</code> of the original matrix.</p>
<p>If you are imposing additional constraints through the template parameter LPConstraint, then the corresponding extra variables will be included in the permutation; however, these are never moved and will always remain the rightmost variables in this system (i.e., the columns of highest index).</p>
<p>As well as the requirement that this is a genuine permutation of 0,...,<a class="el" href="group__enumerate.html#gac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a>-1, this array will also adhere to the following constraints. In the following discussion, <em>n</em> refers to the number of tetrahedra in the underlying triangulation.</p>
<ul>
<li>The quadrilateral coordinate columns must appear as the first 3<em>n</em> columns of the adjusted matrix. In particular, when working in the 7<em>n</em>-dimensional standard normal coordinate system, the remaining 4<em>n</em> triangle coordinate columns must appear last.</li>
<li>The quadrilateral coordinate columns must be grouped by tetrahedron and ordered by quadrilateral type. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, there will be some tetrahedron <em>j</em> for which the three columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 refer to the quadrilaterals in tetrahedron <em>j</em> of types 0, 1 and 2 respectively. Phrased loosely, we are allowed to reorder the tetrahedra, but not the quadrilateral coordinates within each tetrahedron.</li>
<li>The triangle coordinate columns (if we are working in standard normal coordinates) must likewise be grouped by tetrahedron, and these tetrahedra must appear in the same order as for the quadrilateral types. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, the quadrilateral columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 and the triangle columns 3<em>n</em>+4<em>i</em>, 3<em>n</em>+4<em>i</em>+1, 3<em>n</em>+4<em>i</em>+2 and 3<em>n</em>+4<em>i</em>+3 all refer to the same tetrahedron.</li>
<li>For angle structure coordinates, the constraints are analogous to those for quadrilateral coordinates: the angle coordinates must be grouped by tetrahedron and ordered by angle type, and the final scaling coordinate must remain last.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>details of the permutation describing how columns were reordered. </dd></dl>

</div>
</div>
<a id="ga442958409fd076f06fa54e6e24d37405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga442958409fd076f06fa54e6e24d37405">&#9670;&nbsp;</a></span>columns() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix. </p>
<p>This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="gac55f15c0bf782905c9749f3e0a4c7767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55f15c0bf782905c9749f3e0a4c7767">&#9670;&nbsp;</a></span>columns() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the number of columns will be larger than in the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="ga6c2bfd2bac90cee1ab7f9beb6fba0aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2bfd2bac90cee1ab7f9beb6fba0aef">&#9670;&nbsp;</a></span>columns() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this tableaux. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the number of columns will be larger than in the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="gaad77b3d164a3c52cb5908069c99c37da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad77b3d164a3c52cb5908069c99c37da">&#9670;&nbsp;</a></span>combRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::combRow </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix. </p>
<p>Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) / <em>div</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal. </dd>
<dd>
It is known in advance that every integer in (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) will be divisible by <em>div</em>. In other words, it is known in advance that we can use exact integer division without remainders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">div</td><td>the integer to divide the final row by. This must be non-zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0dcf7e72e994c8b0c1ec953db3ad18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0dcf7e72e994c8b0c1ec953db3ad18e">&#9670;&nbsp;</a></span>combRowAndNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::combRowAndNorm </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix, and then normalises. </p>
<p>Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>); then, if row <em>dest</em> is non-zero, it will be normalised by dividing through by the gcd of its elements. Note that this gcd is always taken to be positive (i.e., the final normalisation will never change the signs of the elements in the row).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the positive gcd that row <em>dest</em> was scaled down by, or 0 if row <em>dest</em> is entirely zero. </dd></dl>

</div>
</div>
<a id="ga6d90776df2cdaa5cf7fbf55b9762e1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d90776df2cdaa5cf7fbf55b9762e1e2">&#9670;&nbsp;</a></span>constrain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::LPConstraintBase::constrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly constraints each of these linear functions to an equality or inequality in the underlying tableaux. </p>
<p>This will typically consist of a series of calls to <a class="el" href="group__enumerate.html#gac05d6e693c09fadde2c43d62951effe6" title="Constrains this system further by setting the given variable to zero and deactivating it.">LPData::constrainZero()</a> and/or <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">LPData::constrainPositive()</a>.</p>
<p>The variables for these extra linear functions are stored in columns <code>numCols - nConstraints</code>, ..., <code>numCols - 1</code> of the given tableaux, and so your calls to <a class="el" href="group__enumerate.html#gac05d6e693c09fadde2c43d62951effe6" title="Constrains this system further by setting the given variable to zero and deactivating it.">LPData::constrainZero()</a> and/or <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">LPData::constrainPositive()</a> should operate on these (and only these) columns.</p>
<dl class="section pre"><dt>Precondition</dt><dd>These column coefficients belong to the initial starting tableaux (<a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a>) from which the given tableaux is derived.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>the tableaux in which to constrain these linear functions. </td></tr>
    <tr><td class="paramname">numCols</td><td>the number of columns in the given tableaux. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3de34d05aa11d2f75f7d63b0d56f9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3de34d05aa11d2f75f7d63b0d56f9ae">&#9670;&nbsp;</a></span>constrainOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainOct </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>quad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>quad2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single octagon coordinate, for use with almost normal surfaces, and constrains the system accordingly. </p>
<p>This constrains the system in several ways, as discussed in detail in the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes. In theory, we set the two quadrilateral coordinates to be equal, and also insist that the number of octagons be strictly positive. In practice, we do this through several changes of variable; see the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for a detailed discussion of precisely how the variables and tableaux will change.</p>
<p>This routine will work even if one of the given quadrilateral variables has already been deactivated, but in this case the routine will immediately set the system to infeasible and return.</p>
<p>This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is the first time <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> has been called on this tableaux. This is because this class can only handle one octagon type in the entire system.</dd>
<dd>
Variables <em>quad1</em> and <em>quad2</em> represent different quadrilateral coordinates in the same tetrahedron of the underlying triangulation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on one of the given variables, then these prior routines will have performed a change of variable. Any new call to <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> involving this same variable will constrain the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad1</td><td>one of the two quadrilateral types that we combine to form the new octagon type. </td></tr>
    <tr><td class="paramname">quad2</td><td>the other of the two quadrilateral types that we combine to form the new octagon type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad13df31bf31dabdeba22a4d0e7e77197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad13df31bf31dabdeba22a4d0e7e77197">&#9670;&nbsp;</a></span>constrainPositive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainPositive </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains this system further by constraining the given variable to be strictly positive. </p>
<p>We do this using a change of variable that effectively replaces x_pos with the new variable x'_pos = x_pos - 1 (which we simply constrain to be non-negative as usual). See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<p>This routine will work even if the given variable has already been deactivated, but in this case the routine will immediately set the system to infeasible and return.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on this variable, then these prior routines will have performed a change of variable. Any new call to <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> on this same variable will constrain the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable that is to be constrained as positive. This must be between 0 and origTableaux_-&gt;<a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa93944a288a1ad231acb0adda4532ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa93944a288a1ad231acb0adda4532ce4">&#9670;&nbsp;</a></span>constraintsBroken() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::constraintsBroken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully. </p>
<p>This query function is important because some constraints require additional preconditions on the underlying triangulation, and cannot be added if these preconditions are not satisfied.</p>
<p>Even if the extra constraints were not added successfully, this tableaux will be left in a consistent state (the extra constraints will be treated as zero functions). See the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the constraints were <em>not</em> added successfully, or <code>false</code> if the constraints were added successfully. </dd></dl>

</div>
</div>
<a id="gac2d287e45aaeccb9fcc065645364cef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2d287e45aaeccb9fcc065645364cef2">&#9670;&nbsp;</a></span>constraintsBroken() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::constraintsBroken</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully to the infrastructure for the search tree. </p>
<p>This query function is important because some constraints require additional preconditions on the underlying triangulation, and so these constraints cannot be added in some circumstances. If it is possible that the constraints might not be added successfully, this function should be tested as soon as the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> object has been created.</p>
<p>If the extra constraints were not added successfully, the search tree will be left in a consistent state but will give incorrect results (specifically, the extra constraints will be treated as zero functions).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the constraints were <em>not</em> added successfully, or <code>false</code> if the constraints were added successfully. </dd></dl>

</div>
</div>
<a id="gac05d6e693c09fadde2c43d62951effe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05d6e693c09fadde2c43d62951effe6">&#9670;&nbsp;</a></span>constrainZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::constrainZero </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains this system further by setting the given variable to zero and deactivating it. </p>
<p>See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<p>This routine will work even if the given variable has already been deactivated (and it will do nothing in this case).</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have previously called <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> on this variable, then these prior routines will have performed a change of variable. Any new call to constraintZero() on this same variable will constraint the <em>new</em> variable, not the original, and so might not have the intended effect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable that is to be set to zero. This must be between 0 and origTableaux_-&gt;<a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad311a7137ce157d3aacce9f0d7158eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad311a7137ce157d3aacce9f0d7158eff">&#9670;&nbsp;</a></span>coordinateColumns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::coordinateColumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns that correspond to normal coordinates or angle structure coordinates. </p>
<p>This is precisely the number of columns in the original matrix of matching equations.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of normal or angle structure coordinate columns. </dd></dl>

</div>
</div>
<a id="ga66b04c6ddcbbfe2be49817bf58c72b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b04c6ddcbbfe2be49817bf58c72b66">&#9670;&nbsp;</a></span>coordinateColumns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::coordinateColumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this tableaux that correspond to normal coordinates or angle structure coordinates. </p>
<p>This is precisely the number of columns in the original matrix of matching equations.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of normal or angle structure coordinate columns. </dd></dl>

</div>
</div>
<a id="ga15c66a19d6a2037cef94b004ecbde3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c66a19d6a2037cef94b004ecbde3df">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::coords</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system that is used for the matrix of matching equations. </p>
<p>This will be the same coordinate system that was passed to the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> constructor; in particular, it will always be one of NS_QUAD, NS_STANDARD, or NS_ANGLE.</p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system. </dd></dl>

</div>
</div>
<a id="gae94d6a45380d1229c6ce64daa05ea816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94d6a45380d1229c6ce64daa05ea816">&#9670;&nbsp;</a></span>dominates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::dominates </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given type vector dominates any vector in this trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given length <em>len</em> is non-zero, and is fixed throughout the life of this trie; that is, it is the same every time <a class="el" href="group__enumerate.html#ga4704879425f37b425555f89c01f53a57" title="Inserts the given type vector into this trie.">insert()</a> or <a class="el" href="group__enumerate.html#gae94d6a45380d1229c6ce64daa05ea816" title="Determines whether the given type vector dominates any vector in this trie.">dominates()</a> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the type vector to test. </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the given type vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>vec</em> dominates some type vector stored in this trie. </dd></dl>

</div>
</div>
<a id="ga46722ff71404c0849f5aaf8b0ac3aa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46722ff71404c0849f5aaf8b0ac3aa64">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this matrix to the given output stream. </p>
<p>The output is "rough" and wasteful, and is intended for debugging purposes only. The precise output format is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8af57d2924355a48c3c0f6343e56f69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af57d2924355a48c3c0f6343e56f69a">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes details of this tableaux to the given output stream. </p>
<p>The output is "rough" and wasteful, and is intended for debugging purposes only.</p>
<p>The precise output is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17103e248164f04e3b5d50b322cf772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17103e248164f04e3b5d50b322cf772e">&#9670;&nbsp;</a></span>dumpTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::dumpTypes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current type vector to the given output stream. </p>
<p>There will be no spaces between the types, and there will be no final newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b6d61d9769d6027aefd312a73634c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b6d61d9769d6027aefd312a73634c43">&#9670;&nbsp;</a></span>enforceBans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BanConstraintBase::enforceBans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforces all bans described by this class in the given tableaux. </p>
<p>Specifically, for each banned coordinate, this routine calls <a class="el" href="group__enumerate.html#gac05d6e693c09fadde2c43d62951effe6" title="Constrains this system further by setting the given variable to zero and deactivating it.">LPData::constrainZero()</a> on the corresponding coordinate column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>the tableaux in which to enforce the bans. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66e1ff5aebfd645cf4c9cac1b5a149d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e1ff5aebfd645cf4c9cac1b5a149d6">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the given element of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="group__enumerate.html#ga442958409fd076f06fa54e6e24d37405" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8e0af3ad3d609a2c27b8c65a8423aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e0af3ad3d609a2c27b8c65a8423aa5">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IntType &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-only reference to the given element of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="group__enumerate.html#ga442958409fd076f06fa54e6e24d37405" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e93e5bb833e6ba53d99808f8d30e205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e93e5bb833e6ba53d99808f8d30e205">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType , class RayIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;BitmaskType&gt;* regina::MaxAdmissible::enumerate </td>
          <td>(</td>
          <td class="paramtype">RayIterator&#160;</td>
          <td class="paramname"><em>beginExtremalRays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RayIterator&#160;</td>
          <td class="paramname"><em>endExtremalRays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all maximal admissible faces of the given polyhedral cone. </p>
<p>The cone must be the intersection of the non-negative orthant in some Euclidean space R^n with a linear subspace.</p>
<p>Admissibility is defined by the given set of constraints. Each constraint requires that at most one of a given set of coordinates can be non-zero; see the EnumConstraints class for details. In particular, the quadrilateral constraints from normal surface theory are of this type.</p>
<p>It is simple to show that the admissible region of the cone is a union of faces, which we call "admissible faces". Those admissible faces that do not appear as a strict subface of some other admissible face are called "maximal admissible faces". The admissible region can therefore be expressed as the union of all maximal admissible faces.</p>
<p>The input for this routine is the set of all admissible extremal rays of the cone. These should be computed beforehand; for instance, using the routine <a class="el" href="group__enumerate.html#ga6efe21b1f1cd8cd4b29f6cec14b9cbe9" title="Determines the extremal rays of the intersection of the n-dimensional non-negative orthant with the g...">DoubleDescription::enumerateExtremalRays()</a>.</p>
<p>The return value is the set of all maximal admissible faces, stored in a newly allocated vector. Each face <em>F</em> is described by a bitmask. Specifically: if we are working in R^n, then each face is described by a bitmask <em>b</em> of length n, where <code>b[i]</code> is <code>false</code> if every point <em>x</em> in <em>F</em> has <code>x[i]=0</code>, and <code>b[i]</code> is <code>true</code> if every point <em>x</em> in the relative interior of <em>F</em> has <code>x[i] &gt; 0</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument RayIterator should be an iterator type that, when dereferenced, can be cast to (const <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a>&amp;).</dd>
<dd>
The template argument BitmaskType is one of the bitmask types <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</dd>
<dd>
Bitmasks of type BitmaskType can hold <em>n</em> bits, where <em>n</em> is the dimension of the underlying space (i.e., the size of the input vectors described by <em>beginExtremalRays</em> and <em>endExtremalRays</em>). This is always true of <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, but you must be careful when using one of the fast but size-limited types <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginExtremalRays</td><td>an iterator that begins the set of admissible extremal rays, as described above. Typically this would be rays.begin() if <em>rays</em> is a standard container type. </td></tr>
    <tr><td class="paramname">endExtremalRays</td><td>an iterator that is past-the-end of the set of admissible extremal rays. Typically this would be rays.end() if <em>rays</em> is a standard container type. </td></tr>
    <tr><td class="paramname">constraints</td><td>a set of validity constraints as described above. This may be 0 to indicate no constraints (in which case there will be just one maximal admissible face). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated list containing one bitmask representing each maximal admissible face, as described above. </dd></dl>

</div>
</div>
<a id="ga6efe21b1f1cd8cd4b29f6cec14b9cbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6efe21b1f1cd8cd4b29f6cec14b9cbe9">&#9670;&nbsp;</a></span>enumerateExtremalRays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RayClass , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::DoubleDescription::enumerateExtremalRays </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>initialRows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the extremal rays of the intersection of the <em>n</em>-dimensional non-negative orthant with the given linear subspace. </p>
<p>The resulting rays will be of the class <em>RayClass</em>, will be newly allocated, and will be written to the given output iterator. Their deallocation is the responsibility of whoever called this routine.</p>
<p>The non-negative orthant is an <em>n</em>-dimensional cone with its vertex at the origin. The extremal rays of this cone are the <em>n</em> non-negative coordinate axes. This cone also has <em>n</em> facets, where the <em>i</em>th facet is the non-negative orthant of the plane perpendicular to the <em>i</em>th coordinate axis.</p>
<p>This routine takes a linear subspace, defined by the intersection of a set of hyperplanes through the origin (this subspace is described as a matrix, with each row giving the equation for one hyperplane).</p>
<p>The purpose of this routine is to compute the extremal rays of the new cone formed by intersecting the original cone with this linear subspace. The resulting list of extremal rays will contain no duplicates or redundancies.</p>
<p>Parameter <em>constraints</em> may contain a set of validity constraints, in which case this routine will only return <em>valid</em> extremal rays. Each validity constraint is of the form "an extremal ray may only lie outside at most one of these facets of the original cone"; see the EnumConstraints class for details. These contraints have the important property that, although validity is not preserved under convex combination, <em>invalidity</em> is.</p>
<p>An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="group__progress.html#ga5338763cfe4684d71b57e6118c414540" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="group__progress.html#ga1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument RayClass is derived from <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> (or may possibly be <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> itself).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting extremal rays will be written; this must accept objects of type <code>RayClass*</code>. </td></tr>
    <tr><td class="paramname">subspace</td><td>a matrix defining the linear subspace to intersect with the given cone. Each row of this matrix is the equation for one of the hyperplanes whose intersection forms this linear subspace. The number of columns in this matrix must be the dimension of the overall space in which we are working. </td></tr>
    <tr><td class="paramname">constraints</td><td>a set of validity constraints as described above, or 0 if no additional constraints should be imposed. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
    <tr><td class="paramname">initialRows</td><td>specifies how many initial rows of <em>subspace</em> are to be processed in the precise order in which they appear. The remaining rows will be sorted using the <a class="el" href="classregina_1_1PosOrder.html" title="A comparison object that sorts hyperplanes by position vectors.">PosOrder</a> class before they are processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga672c47981b6c1d9a6f11c00ff9b1da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672c47981b6c1d9a6f11c00ff9b1da6b">&#9670;&nbsp;</a></span>enumerateHilbertBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RayClass , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::HilbertCD::enumerateHilbertBasis </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with some linear subspace. </p>
<p>The resulting basis elements will be of the class <em>RayClass</em>, will be newly allocated, and will be written to the given output iterator. Their deallocation is the responsibility of whoever called this routine.</p>
<p>The non-negative orthant is an <em>n</em>-dimensional cone with its vertex at the origin. The extremal rays of this cone are the <em>n</em> non-negative coordinate axes. This cone also has <em>n</em> facets, where the <em>i</em>th facet is the non-negative orthant of the plane perpendicular to the <em>i</em>th coordinate axis.</p>
<p>This routine takes a linear subspace, defined by the intersection of a set of hyperplanes through the origin (this subspace is described as a matrix, with each row giving the equation for one hyperplane).</p>
<p>The purpose of this routine is to compute the Hilbert basis of the set of all integer points in the intersection of the original cone with this linear subspace. The resulting list of basis vectors will contain no duplicates or redundancies.</p>
<p>The parameter <em>constraints</em> may contain a set of validity constraints, in which case this routine will only return <em>valid</em> basis elements. Each validity constraint is of the form "at
most one of these coordinates may be non-zero"; see the EnumConstraints class for details. These contraints have the important property that, although validity is not preserved under addition, <em>invalidity</em> is.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument RayClass is derived from <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> (or may possibly be <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> itself).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For normal surface theory, the Contejean-Devie algorithm is extremely slow, even when modified to incorporate admissibility constraints. Consider using the much faster <a class="el" href="classregina_1_1HilbertPrimal.html" title="Implements a modified primal algorithm for enumerating Hilbert bases.">HilbertPrimal</a> or <a class="el" href="classregina_1_1HilbertDual.html" title="Implements a modified dual algorithm for enumerating Hilbert bases.">HilbertDual</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting basis elements will be written; this must accept objects of type <code>RayClass*</code>. </td></tr>
    <tr><td class="paramname">subspace</td><td>a matrix defining the linear subspace to intersect with the given cone. Each row of this matrix is the equation for one of the hyperplanes whose intersection forms this linear subspace. The number of columns in this matrix must be the dimension of the overall space in which we are working. </td></tr>
    <tr><td class="paramname">constraints</td><td>a set of validity constraints as described above, or 0 if no additional constraints should be imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90e009c4ba4e8110c590bf4df47dc6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e009c4ba4e8110c590bf4df47dc6c2">&#9670;&nbsp;</a></span>enumerateHilbertBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RayClass , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::HilbertDual::enumerateHilbertBasis </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>initialRows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with the given linear subspace. </p>
<p>The resulting basis elements will be of the class <em>RayClass</em>, will be newly allocated, and will be written to the given output iterator. Their deallocation is the responsibility of whoever called this routine.</p>
<p>The non-negative orthant is an <em>n</em>-dimensional cone with its vertex at the origin. The extremal rays of this cone are the <em>n</em> non-negative coordinate axes. This cone also has <em>n</em> facets, where the <em>i</em>th facet is the non-negative orthant of the plane perpendicular to the <em>i</em>th coordinate axis.</p>
<p>This routine takes a linear subspace, defined by the intersection of a set of hyperplanes through the origin (this subspace is described as a matrix, with each row giving the equation for one hyperplane).</p>
<p>The purpose of this routine is to compute the Hilbert basis of the set of all integer points in the intersection of the original cone with this linear subspace. The resulting list of basis vectors will contain no duplicates or redundancies.</p>
<p>Parameter <em>constraints</em> may contain a set of validity constraints, in which case this routine will only return <em>valid</em> basis elements. Each validity constraint is of the form "a basis element may only lie outside at most one of these facets of the original cone"; see the EnumConstraints class for details. These contraints have the important property that, although validity is not preserved under addition, <em>invalidity</em> is.</p>
<p>An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="group__progress.html#ga5338763cfe4684d71b57e6118c414540" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="group__progress.html#ga1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument RayClass is derived from <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> (or may possibly be <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> itself).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting basis elements will be written; this must accept objects of type <code>RayClass*</code>. </td></tr>
    <tr><td class="paramname">subspace</td><td>a matrix defining the linear subspace to intersect with the given cone. Each row of this matrix is the equation for one of the hyperplanes whose intersection forms this linear subspace. The number of columns in this matrix must be the dimension of the overall space in which we are working. </td></tr>
    <tr><td class="paramname">constraints</td><td>a set of validity constraints as described above, or 0 if no additional constraints should be imposed. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
    <tr><td class="paramname">initialRows</td><td>specifies how many initial rows of <em>subspace</em> are to be processed in the precise order in which they appear. The remaining rows will be sorted using the <a class="el" href="classregina_1_1PosOrder.html" title="A comparison object that sorts hyperplanes by position vectors.">PosOrder</a> class before they are processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacae6cff730678e5f6a745a53e339c61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacae6cff730678e5f6a745a53e339c61f">&#9670;&nbsp;</a></span>enumerateHilbertBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RayClass , class RayIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::HilbertPrimal::enumerateHilbertBasis </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RayIterator &amp;&#160;</td>
          <td class="paramname"><em>raysBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RayIterator &amp;&#160;</td>
          <td class="paramname"><em>raysEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the Hilbert basis that generates all integer points in the intersection of the <em>n</em>-dimensional non-negative orthant with some linear subspace. </p>
<p>The resulting basis elements will be of the class <em>RayClass</em>, will be newly allocated, and will be written to the given output iterator. Their deallocation is the responsibility of whoever called this routine.</p>
<p>The intersection of the non-negative orthant with this linear subspace is a pointed polyhedral cone with apex at the origin, and this routine requires the extremal rays of this cone to be provided as input. The extremal rays can be computed using DoubleDescription::enumerate() in general cases, though sometimes (such as with normal surface theory) more efficient methods are available.</p>
<p>This routine computes the Hilbert basis of all integer points in this cone. The resulting list of basis vectors will contain no duplicates or redundancies.</p>
<p>The parameter <em>constraints</em> may contain a set of validity constraints, in which case this routine will only return <em>valid</em> basis elements. Each validity constraint is of the form "at
most one of these coordinates may be non-zero"; see the EnumConstraints class for details. These contraints have the important property that, although validity is not preserved under addition, <em>invalidity</em> is.</p>
<p>An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="group__progress.html#ga5338763cfe4684d71b57e6118c414540" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="group__progress.html#ga1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>constraints</em> is passed, then the given list of extremal rays contains <em>only</em> those extremal rays that satisfy all of the given constraints. </dd>
<dd>
The template argument RayClass is derived from <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> (or may possibly be <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> itself). </dd>
<dd>
The template argument RayIterator is a forward iterator type, and when dereferenced can be cast to (const <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a>&amp;).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If a progress tracker is passed, be aware that the present implementation updates percentage progress very infrequently, and may take a very long time to honour cancellation requests.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting basis elements will be written; this must accept objects of type <code>RayClass*</code>. </td></tr>
    <tr><td class="paramname">raysBegin</td><td>an iterator pointing to the beginning of the list of extremal rays. </td></tr>
    <tr><td class="paramname">raysEnd</td><td>an iterator pointing past the end of the list of extremal rays. </td></tr>
    <tr><td class="paramname">constraints</td><td>a set of validity constraints as described above, or 0 if no additional constraints should be imposed. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7bc03626c7b12c8a49cd512fd4be9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bc03626c7b12c8a49cd512fd4be9b1">&#9670;&nbsp;</a></span>extractSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<div class="memtemplate">
template&lt;class RayClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::extractSolution&lt; <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">RayClass &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the values of the individual variables from the current basis, with some modifications (as described below). </p>
<p>The values of the variables are store in the given vector <em>v</em>.</p>
<p>The modifications are as follows:</p>
<ul>
<li>We extract variables that correspond to the original matching equations obtained from the underlying triangulation, <em>not</em> the current tableaux and <em>not</em> even the original starting tableaux stored in origTableaux_. In other words, when we fill the vector <em>v</em> we undo the column permutation described by <a class="el" href="group__enumerate.html#ga16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">LPInitialTableaux::columnPerm()</a>, and we undo any changes of variable that were caused by calls to <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> and/or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a>.</li>
<li>To ensure that the variables are all integers, we scale the final vector by the smallest positive rational multiple for which all elements of the vector are integers. (This is why the output class is <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> and not <a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a>.)</li>
</ul>
<p>This routine is not used as an internal part of the tree traversal algorithm; instead it is offered as a helper routine for reconstructing the normal surfaces or angle structures that result.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given vector <em>v</em> has been initialised to the zero vector of length origTableaux_-&gt;<a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef" title="Returns the number of columns in this tableaux.">columns()</a>. Note that the <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> constructor will automatically initialise all elements to zero as required.</dd>
<dd>
No individual coordinate column has had more than one call to either of <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a> (otherwise the coordinate will not be correctly reconstructed). Any additional columns arising from LPConstraint are exempt from this requirement.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RayClass</td><td>the class used to hold the output vector <em>v</em>. This should either be <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a>, or some other class that provides analogous functions size(), setElement() and scaleDown().</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector into which the values of the variables will be placed. </td></tr>
    <tr><td class="paramname">type</td><td>the type vector corresponding to the current state of this tableaux, indicating which variables were previously fixed as positive via calls to <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a>. This is necessary because <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> does not keep such historical data on its own. As a special case, when extracting a strict angle structure one may pass <em>type</em> = 0, in which case this routine will assume that <em>every</em> coordinate was constrained as positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga882965aa895794954f0fab822b573909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga882965aa895794954f0fab822b573909">&#9670;&nbsp;</a></span>facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BitmaskType &amp; regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitmask listing which facets of the original cone this ray belongs to. </p>
<p>Each bit is set to <code>true</code> if and only if this ray belongs to the corresponding facet.</p>
<dl class="section return"><dt>Returns</dt><dd>a bitmask of facets. </dd></dl>

</div>
</div>
<a id="gae46815f41b24319ef2de3a91939bfa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae46815f41b24319ef2de3a91939bfa37">&#9670;&nbsp;</a></span>feasibleBranches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::feasibleBranches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system. </p>
<p>This will involve solving three or four linear programs, all based on the current state of the tableaux at the current level of the search tree. These assign 0, 1, 2 and 3 to the given quadrilateral or angle type in turn (here 0 is not used for angle types), and then enforce the corresponding constraints. For quadrilateral types, we count types 0 and 1 separately as in <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a>, not merged together as in <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given quadrilateral or angle type has not yet been processed in the search tree (i.e., it has not had an explicit value selected).</dd>
<dd>
When using angle structure coordinates, the final scaling coordinate has already been enforced as positive. (This is because, for angle structures, this routine does nothing to eliminate the zero solution.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadType</td><td>the quadrilateral or angle type to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of type values 0, 1, 2 or 3 that yield a feasible system; this will be between 0 and 4 inclusive for quadrilateral types, or between 0 and 3 inclusive for angle types. </dd></dl>

</div>
</div>
<a id="gad58303ac129d99491f1b82d0e116f546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad58303ac129d99491f1b82d0e116f546">&#9670;&nbsp;</a></span>fillFinalRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::LPConstraintBase::Coefficients::fillFinalRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly fills the final row(s) of the given tableaux matrix with the coefficients stored in this <a class="el" href="structregina_1_1LPConstraintBase_1_1Coefficients.html" title="Stores the extra coefficients in a single column for the nConstraints additional rows that we add to ...">Coefficients</a> structure. </p>
<p>In essence, this routine simply copies this sparse and/or specialised representation of the final row(s) into a more standard dense matrix representation.</p>
<p>This routine should only affect the final <em>nConstraints</em> entries in the given column of the matrix. It may assume that these final row(s) have already been initialised to zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has at least <em>nConstraints</em> rows and at least <em>col</em> + 1 columns. </dd>
<dd>
The final <em>nConstraints</em> entries in column <em>col</em> of the given matrix have already been set to zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix in which to place these column coefficients. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the given matrix in which to place these coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa16772af7dc89a65a3547bab10c4e6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16772af7dc89a65a3547bab10c4e6b1">&#9670;&nbsp;</a></span>fillInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::fillInitialTableaux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given matrix with the contents of this matrix. </p>
<p>This effectively copies this sparse but highly specialised matrix representation into a dense but more flexible matrix representation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has already been initialised to size <a class="el" href="group__enumerate.html#ga15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> * <a class="el" href="group__enumerate.html#gac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a>, and all of its elements have already been set to zero. Note that this can all be arranged by calling the constructor <a class="el" href="group__enumerate.html#gacd286b6b0f9ea3176934d00b8c1cc0c8" title="Creates a fully initialised rows by cols matrix with all elements set to zero.">LPMatrix::LPMatrix(unsigned, unsigned)</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6434978ea0aac9ffb43bdcbd26da214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6434978ea0aac9ffb43bdcbd26da214">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeSingleSoln.html">regina::TreeSingleSoln</a>&lt; LPConstraint, BanConstraint, IntType &gt;::find </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen constraints, or else proves that no such solution exists. </p>
<p>Note that, if a solution is found, it will have a maximal (but not necessarily maximum) set of zero coordinates, which in some settings is enough to guarantee a vertex normal surface. See the <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a> class notes for details.</p>
<p>If <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a> does return <code>true</code>, you can extract details of the corresponding surface directly from this tree enumeration object: for instance, you can dump the type vector using <a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full surface using <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a>. Be warned that this class defines the type vector in an unusual way (see the <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a> class notes for details). If you call <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a>, remember to delete the surface once you are finished with it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The algorithm has not yet been run, i.e., you have not called <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a> before.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we found a non-trivial solution as described in the class notes, or <code>false</code> if no such solution exists. </dd></dl>

</div>
</div>
<a id="ga7916581803edac0e48b4985ed3e41f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7916581803edac0e48b4985ed3e41f29">&#9670;&nbsp;</a></span>formSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::formSum </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>neg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the sum of the two given vectors. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>pos.nextHyp() &gt; 0</code>, and <code>neg.nextHyp() &lt; 0</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the first vector to add, which must lie on the strictly positive side of the current hyperplane. </td></tr>
    <tr><td class="paramname">neg</td><td>the second vector to add, which must lie on the strictly negative side of the current hyperplane. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e5d0e821aa954ed8f76ec6d62c03f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e5d0e821aa954ed8f76ec6d62c03f67">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::BanConstraintBase::init </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>columnPerm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies which coordinates to ban and mark, and records the corresponding tableaux columns in the <em>banned_</em> and <em>marked_</em> arrays respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnPerm</td><td>the permutation of columns that describes how columns of the tableaux correspond to normal or angle strutcure coordinates in the underlying triangulation. Specifically, this permutation must be the same permutation returned by <a class="el" href="group__enumerate.html#ga16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">LPInitialTableaux::columnPerm()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfb498c421ccd15a2853821057078ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb498c421ccd15a2853821057078ff2">&#9670;&nbsp;</a></span>initClone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::initClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; LPConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises this tableaux to be a clone of the given tableaux. </p>
<p>This is used in the tree traversal algorithm as we work our way down the search tree, and child nodes "inherit" tableaux from their parent nodes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb" title="Reserves enough memory for this tableaux to work with.">reserve()</a> has already been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the tableaux to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6806f38ae07678edd93b44219943a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6806f38ae07678edd93b44219943a70">&#9670;&nbsp;</a></span>initClone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::initClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>clone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to a copy of the given matrix. </p>
<p>This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p>You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least clone.rows() * clone.columns() elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clone</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga756eaa237b40e6b640655622d4fc57a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756eaa237b40e6b640655622d4fc57a6">&#9670;&nbsp;</a></span>initIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::initIdentity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to the identity matrix of the given size. </p>
<p>This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p>You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least <em>size</em> * <em>size</em> elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows, and also the number of columns, that will be assigned to this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa73cd5d5925e4b4f9799843888e77aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73cd5d5925e4b4f9799843888e77aa5">&#9670;&nbsp;</a></span>initNextHyp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::initNextHyp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the <em>nextHyp_</em> member to reflect the dot product with the given hyperplane. </p>
<p>This routine also sets the member <em>srcNextHyp_</em> to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subspace</td><td>the matrix containing the full set of hyperplanes. </td></tr>
    <tr><td class="paramname">row</td><td>the row of the given matrix that stores the specific hyperplane in which we are interested. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac48f34d3d8d79b3823f95bc2f64cf7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac48f34d3d8d79b3823f95bc2f64cf7a3">&#9670;&nbsp;</a></span>initStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::initStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises this tableaux by beginning at the original starting tableaux and working our way to any feasible basis. </p>
<p>This routine also explicitly enforces the additional constraints from the template parameter LPConstraint (i.e., this routine is responsible for forcing the corresponding linear function(s) to be zero or strictly positive as appropriate).</p>
<p>It is possible that a feasible basis cannot be found; you should test <a class="el" href="group__enumerate.html#ga89cafcaf61506e02ff12c7699424bedd" title="Returns whether or not this system is feasible.">isFeasible()</a> after running this routine to see whether this is the case.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb" title="Reserves enough memory for this tableaux to work with.">reserve()</a> has already been called. </dd></dl>

</div>
</div>
<a id="ga6e9ef3807590e6a5b754276397b6c29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9ef3807590e6a5b754276397b6c29e">&#9670;&nbsp;</a></span>innerProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType regina::LPConstraintBase::Coefficients::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inner product of (i) the final <em>nConstraints</em> entries in the given row of the given matrix with (ii) the <em>nConstraints</em> column coefficients stored in this data structure. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has at least <em>nConstraints</em> columns and at least <em>mRow</em> + 1 rows.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting portion of the inner product. </dd></dl>

</div>
</div>
<a id="ga61c6ff37ed763967cc826e5520d88694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61c6ff37ed763967cc826e5520d88694">&#9670;&nbsp;</a></span>innerProductOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType regina::LPConstraintBase::Coefficients::innerProductOct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="group__enumerate.html#ga6e9ef3807590e6a5b754276397b6c29e" title="Computes the inner product of (i) the final nConstraints entries in the given row of the given matrix...">innerProduct()</a> that takes into account any adjustments to these linear constraint(s) that are required when this is a quadrilateral column being used to represent an octagon type. </p>
<p>The <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class offers support for octagonal almost normal surfaces, in which exactly one tetrahedron is allowed to have exactly one octagon type. We represent such an octagon as a <em>pair</em> of incompatible quadrilaterals within the same tetrahedron. See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on how this works.</p>
<p>In some settings, our extra linear constraints must behave differently in the presence of octagons (i.e., the coefficient of the octagon type is not just the sum of coefficients of the two constituent quadrilateral types). This routine effectively allows us to adjust the tableaux accordingly.</p>
<p>Specifically: this routine computes the inner product of (i) the final <em>nConstraints</em> entries in the given row of the given matrix with (ii) the <em>nConstraints</em> column coefficients stored in this data structure. We assume that this column in the underlying tableaux describes one of the two quadrilateral coordinates in some tetrahedron that together form an octagon type, and if necessary we implicitly adjust the coefficients stored in this data structure accordingly.</p>
<p>This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has at least <em>nConstraints</em> columns and at least <em>mRow</em> + 1 rows.</dd>
<dd>
This column of the underlying tableaux describes one of the two quadrilateral coordinates that are being combined to form an octagon type within some tetrahedron.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting portion of the inner product. </dd></dl>

</div>
</div>
<a id="ga4704879425f37b425555f89c01f53a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4704879425f37b425555f89c01f53a57">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given type vector into this trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given length <em>len</em> is non-zero, and is fixed throughout the life of this trie; that is, it is the same every time <a class="el" href="group__enumerate.html#ga4704879425f37b425555f89c01f53a57" title="Inserts the given type vector into this trie.">insert()</a> or <a class="el" href="group__enumerate.html#gae94d6a45380d1229c6ce64daa05ea816" title="Determines whether the given type vector dominates any vector in this trie.">dominates()</a> is called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the type vector to insert. </td></tr>
    <tr><td class="paramname">len</td><td>the number of elements in the given type vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae86606754589974c018ca660e6a96c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae86606754589974c018ca660e6a96c31">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::isActive </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given variable is currently active. </p>
<p>See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable to query. This must be between 0 and origTableaux_-&gt;<a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89cafcaf61506e02ff12c7699424bedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89cafcaf61506e02ff12c7699424bedd">&#9670;&nbsp;</a></span>isFeasible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::isFeasible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this system is feasible. </p>
<p>A system may become infeasible when we add too many extra constraints on the variables (such as forcing them to be positive, or setting them to zero); see the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on these constraints.</p>
<dl class="section warning"><dt>Warning</dt><dd>As explained in the class notes, if this system is infeasible then any queries or operations (other than calling <a class="el" href="group__enumerate.html#ga89cafcaf61506e02ff12c7699424bedd" title="Returns whether or not this system is feasible.">isFeasible()</a> itself) are undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this system is feasible, or <code>false</code> if it is infeasible. </dd></dl>

</div>
</div>
<a id="ga76de76a1885d36d88e7eaf911ebf2c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76de76a1885d36d88e7eaf911ebf2c01">&#9670;&nbsp;</a></span>LPCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::<a class="el" href="structregina_1_1LPCol.html">LPCol</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises an empty column. </p>

</div>
</div>
<a id="gac45a4647f5f984621209b6b0b3f68c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac45a4647f5f984621209b6b0b3f68c4b">&#9670;&nbsp;</a></span>LPData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::<a class="el" href="classregina_1_1LPData.html">LPData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new tableaux. </p>
<p>You <em>must</em> call <a class="el" href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb" title="Reserves enough memory for this tableaux to work with.">reserve()</a> before doing anything else with this tableaux. </p>

</div>
</div>
<a id="gabe983e975f8883df9f512622f43ccaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe983e975f8883df9f512622f43ccaf3">&#9670;&nbsp;</a></span>LPInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enumeration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construts this adjusted sparse matrix of matching equations. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the underlying 3-manifold triangulation. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to use for the matrix of matching equations; this must be one of NS_QUAD, NS_STANDARD, or NS_ANGLE. </td></tr>
    <tr><td class="paramname">enumeration</td><td><code>true</code> if we should optimise the tableaux for a full enumeration of vertex surfaces or taut angle structures, or <code>false</code> if we should optimise the tableaux for an existence test (such as searching for a non-trivial normal disc or sphere, or a strict angle structure). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc147112c87842fa3f81f983b1a74fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc147112c87842fa3f81f983b1a74fae">&#9670;&nbsp;</a></span>LPMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised matrix with no memory storage. </p>
<p>You <em>must</em> call <a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> and then either <a class="el" href="group__enumerate.html#gad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="group__enumerate.html#ga756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a> before this matrix will become initialised. </p>

</div>
</div>
<a id="gacd286b6b0f9ea3176934d00b8c1cc0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd286b6b0f9ea3176934d00b8c1cc0c8">&#9670;&nbsp;</a></span>LPMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero. </p>
<p>This routine reserves space for precisely <em>rows</em> * <em>cols</em> elements. In other words, you may later re-initialise the matrix to become smaller if you like, but you cannot re-initialise the matrix to become larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga689c37403c7d1f78077936f09f46fa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga689c37403c7d1f78077936f09f46fa69">&#9670;&nbsp;</a></span>mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BitmaskType &amp; regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitmask describing which coordinate are non-zero. </p>

</div>
</div>
<a id="ga351acbaa960c9dc0bb6c58cd947a544d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351acbaa960c9dc0bb6c58cd947a544d">&#9670;&nbsp;</a></span>multColByRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. </p>
<p>This routine is optimised to use the sparse representation of columns in this matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="group__enumerate.html#ga15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> columns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting inner product. </dd></dl>

</div>
</div>
<a id="ga87ddc39309b9839190b5be4ec894fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ddc39309b9839190b5be4ec894fcc1">&#9670;&nbsp;</a></span>multColByRowOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRowOct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="group__enumerate.html#ga351acbaa960c9dc0bb6c58cd947a544d" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type. </p>
<p>The <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class offers support for octagonal almost normal surfaces, in which exactly one tetrahedron is allowed to have exactly one octagon type. We represent such an octagon as a <em>pair</em> of incompatible quadrilaterals within the same tetrahedron. See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on how this works.</p>
<p>In some settings where we are using additional constraints through the template parameter LPConstraint, these extra constraints behave differently in the presence of octagons (i.e., the coefficient of the octagon type is not just the sum of coefficients of the two constituent quadrilateral types). This routine effectively allows us to adjust the tableaux accordingly.</p>
<p>Specifically: this routine computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. We assume that the given column of this matrix describes one of the two quadrilateral coordinates in some tetrahedron that together form an octagon type, and (via the helper routine LPConstraint::Coefficients::innerProductOct) we implicitly adjust the coefficients of our extra constraints accordingly.</p>
<p>This routine is optimised to use the sparse representation of columns in this matrix.</p>
<p>This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="group__enumerate.html#ga15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> columns.</dd>
<dd>
Column <em>thisCol</em> of this matrix describes one of the two quadrilateral coordinates that are being combined to form an octagon type within some tetrahedron.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the adjusted inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting adjusted inner product. </dd></dl>

</div>
</div>
<a id="ga948a2c32521ba570aa0693cfce49953c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga948a2c32521ba570aa0693cfce49953c">&#9670;&nbsp;</a></span>negateRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::negateRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all elements in the given row of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row whose elements should be negated. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5a02cade5fd5c8db9b5d92e0defb2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a02cade5fd5c8db9b5d92e0defb2ab">&#9670;&nbsp;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An incremental step in the tree traversal algorithm that runs forward until it finds the next solution. </p>
<p>Specifically: this continues the tree traversal from the current point until either it finds the next vertex normal or almost normal surface (in which case it returns <code>true</code>), or until the tree traversal is completely finished with no more solutions to be found (in which case it returns <code>false</code>).</p>
<p>If you simply wish to find and process all vertex surfaces, you may wish to consider the all-in-one routine <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> instead. By using <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> to step through one solution at a time however, you obtain more fine-grained control: for instance, you can "pause" and restart the search, or have tighter control over multithreading.</p>
<p>If <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> does return <code>true</code> because it found a solution, you can extract details of the solution directly from this tree enumeration object: for instance, you can dump the type vector using <a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full normal or almost normal surface using <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a> and perform some other operations upon it. If you do call <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a>, remember to delete the normal surface once you are finished with it.</p>
<p>An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="group__progress.html#ga5338763cfe4684d71b57e6118c414540" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="group__progress.html#ga1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns (and presumably not until the entire search tree is exhausted). The percentage progress will be given in the context of a complete enumeration of the entire search tree (i.e., it will typically start at a percentage greater than 0, and end at a percentage less than 100).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tree traversal algorithm has not yet finished. That is, you have not called <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> before, and if you have called <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we found another vertex surface, or <code>false</code> if the search has now finished and no more vertex surfaces were found. </dd></dl>

</div>
</div>
<a id="gaef628d8527d115ea92798957459bcf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef628d8527d115ea92798957459bcf06">&#9670;&nbsp;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An incremental step in the enumeration algorithm that runs forward until it finds the next solution. </p>
<p>Specifically: this continues the enumeration from the current point until either it finds the next taut angle structure (in which case it returns <code>true</code>), or until the enumeration algorithm is completely finished with no more solutions to be found (in which case it returns <code>false</code>).</p>
<p>If you simply wish to find and process all taut angle structures, you may wish to consider the all-in-one routine <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> instead. By using <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> to step through one solution at a time however, you obtain more fine-grained control: for instance, you can "pause" and restart the search, or have tighter control over multithreading.</p>
<p>If <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> does return <code>true</code> because it found a solution, you can extract details of the solution directly from this enumeration object: for instance, you can dump the type vector using <a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full taut angle structure using <a class="el" href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9" title="Reconstructs the full taut angle structure that is represented by the type vector at the current stag...">buildStructure()</a> and perform some other operations upon it. If you do call <a class="el" href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9" title="Reconstructs the full taut angle structure that is represented by the type vector at the current stag...">buildStructure()</a>, remember to delete the angle structure once you are finished with it.</p>
<p>An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="group__progress.html#ga5338763cfe4684d71b57e6118c414540" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="group__progress.html#ga1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns (and presumably not until the entire search tree is exhausted). The percentage progress will be given in the context of a complete enumeration of the entire search tree (i.e., it will typically start at a percentage greater than 0, and end at a percentage less than 100).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The enumeration algorithm has not yet finished. That is, you have not called <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> before, and if you have called <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we found another vertex surface, or <code>false</code> if the search has now finished and no more taut angle strutures were found. </dd></dl>

</div>
</div>
<a id="gaa0ffbc7d280c4bd28718ed0ac9dd7b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ffbc7d280c4bd28718ed0ac9dd7b60">&#9670;&nbsp;</a></span>nextHyp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::nextHyp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the dot product of this vector with the hyperplane currently being processed. </p>

</div>
</div>
<a id="ga133246fc0feecf761c6f1b023630e0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133246fc0feecf761c6f1b023630e0c7">&#9670;&nbsp;</a></span>nextUnmarkedTriangleType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nextUnmarkedTriangleType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next unmarked triangle type from a given starting point. </p>
<p>Specifically, this routine returns the first unmarked triangle type whose type number is greater than or equal to <em>startFrom</em>. For more information on marking, see the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes.</p>
<p>This routine simply searches through types by increasing index into the type vector; in particular, it does <em>not</em> make any use of the reordering defined by the <em>typeOrder_</em> array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>We are working in standard normal or almost normal coordinates. That is, the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was one of NS_STANDARD or NS_AN_STANDARD.</dd>
<dd>
The argument <em>startFrom</em> is at least <em>nTets_</em> (i.e., it is at least as large as the index of the first triangle type).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startFrom</td><td>the index into the type vector of the triangle type from which we begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into the type vector of the next unmarked triangle type from <em>startFrom</em> onwards, or -1 if there are no more remaining. </dd></dl>

</div>
</div>
<a id="ga3615f140b03ca3e65af71abac131fecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3615f140b03ca3e65af71abac131fecb">&#9670;&nbsp;</a></span>nSolns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nSolns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of vertex normal or almost normal surfaces found thus far in the tree traversal search. </p>
<p>If you called <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>, then this will simply be the total number of vertex surfaces. If you are calling <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> one surface at time, this will be the partial count of how many vertex surfaces have been found until now.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of solutions found so far. </dd></dl>

</div>
</div>
<a id="ga6c5b392e101f339872f79f8d8e1725c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5b392e101f339872f79f8d8e1725c3">&#9670;&nbsp;</a></span>nSolns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nSolns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of taut angle structures found thus far in the tree traversal search. </p>
<p>If you called <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>, then this will simply be the total number of taut angle structures. If you are calling <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> one surface at time, this will be the partial count of how many taut angle structures have been found until now.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of solutions found so far. </dd></dl>

</div>
</div>
<a id="ga1656d8fec6e9cfa7cec544f636dd1396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1656d8fec6e9cfa7cec544f636dd1396">&#9670;&nbsp;</a></span>nVisited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nVisited</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of nodes in the search tree that we have visited thus far in the tree traversal. </p>
<p>This figure might grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree.</p>
<p>This counts all nodes that we visit, including those that fail any or all of the domination, feasibility and zero tests. The precise way that this number is calculated is subject to change in future versions of Regina.</p>
<p>If you called an "all at once" routine such as <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">TreeEnumeration::run()</a> or <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a>, then this will be the total number of nodes that were visited in the entire tree traversal. If you are calling an "incremental" routine such as <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> (i.e., you are generating one solution at time), then this will be the partial count of how many nodes have been visited so far.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes visited so far. </dd></dl>

</div>
</div>
<a id="ga1c6ea02608d08fb3e772a6f46d0a61da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6ea02608d08fb3e772a6f46d0a61da">&#9670;&nbsp;</a></span>onAllCommonFacets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::onAllCommonFacets </td>
          <td>(</td>
          <td class="paramtype">const RaySpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RaySpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this ray belongs to all of the facets that are common to both given rays. </p>
<p>For this routine to return <code>true</code>, every facet that contains both <em>x</em> and <em>y</em> must contain this ray also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first of the given rays. </td></tr>
    <tr><td class="paramname">y</td><td>the second of the given rays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this ray belongs to all of the facets that <em>both</em> <em>x</em> and <em>y</em> belong to. </dd></dl>

</div>
</div>
<a id="ga4dd99c5837e7a1f1f293e57419ecbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd99c5837e7a1f1f293e57419ecbb28">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PosOrder::operator() </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the hyperplane described by row <em>i</em> of the matrix is smaller than the hyperplane described by row <em>j</em>. </p>
<p>Here "smaller" is defined by position vectors; see the <a class="el" href="classregina_1_1PosOrder.html" title="A comparison object that sorts hyperplanes by position vectors.">PosOrder</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the first matrix row index; this must be between 0 and matrix.rows()-1 inclusive, where <em>matrix</em> is the matrix passed to the class constructor. </td></tr>
    <tr><td class="paramname">j</td><td>the second matrix row index; this must also be between 0 and matrix.rows()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the hyperplane described by row <em>i</em> is smaller than the hyperplane described by row <em>j</em>. </dd></dl>

</div>
</div>
<a id="ga3daef1aaf8977b428005b4a9f39c3e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daef1aaf8977b428005b4a9f39c3e14">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if every element of this vector is less than or equal to every element of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of this vector is less than or equal to every element of <em>other</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga723dade67a200c66ec2e4eb87e460688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723dade67a200c66ec2e4eb87e460688">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VecSpec&amp; regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given vector. </p>

</div>
</div>
<a id="gac82be4e78af38fd1cfb3f01e22ba5427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac82be4e78af38fd1cfb3f01e22ba5427">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VecSpec&amp; regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga949be804adac359047d6c98a0df84c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949be804adac359047d6c98a0df84c15">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given vector are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this vector is identical to the given vector, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga0b02f4672e87c516777b146ab70bd5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b02f4672e87c516777b146ab70bd5fa">&#9670;&nbsp;</a></span>percent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::percent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree. </p>
<p>This is useful for progress tracking.</p>
<p>This routine only attemps to determine the percentage within a reasonable range of error (at the time of writing, 0.01%). This allows it to be more efficient (in particular, by only examining the branches closest to the root of the search tree).</p>
<dl class="section return"><dt>Returns</dt><dd>the percentage, as a number between 0 and 100 inclusive. </dd></dl>

</div>
</div>
<a id="ga397f6dab404adfa747e9c4f07cb92782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397f6dab404adfa747e9c4f07cb92782">&#9670;&nbsp;</a></span>PosOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PosOrder::PosOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new helper object for comparing hyperplanes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the <em>subspace</em> matrix as passed to the normal surface enumeration routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ac373a4f958e45cca8036b98d92982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ac373a4f958e45cca8036b98d92982b">&#9670;&nbsp;</a></span>PosOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PosOrder::PosOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PosOrder.html">PosOrder</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given helper objet. </p>

</div>
</div>
<a id="ga9df6f848af8f0173cbdcda0bd885299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df6f848af8f0173cbdcda0bd885299f">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::push </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given entry in the given row to this column. </p>
<dl class="section pre"><dt>Precondition</dt><dd>No entry in the given row has been added to this column yet.</dd>
<dd>
The sum of absolute values of all entries in this column must never exceed 4.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row containing the given value. </td></tr>
    <tr><td class="paramname">val</td><td>the value at this location in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15bc3370dbf2b873b65d37e4d0cb2ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15bc3370dbf2b873b65d37e4d0cb2ccf">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of this matrix. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the rank will be larger than the rank of the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix rank. </dd></dl>

</div>
</div>
<a id="ga7af4b6458256b8702a80703028f588b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af4b6458256b8702a80703028f588b5">&#9670;&nbsp;</a></span>RaySpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec </td>
          <td>(</td>
          <td class="paramtype">const RaySpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RaySpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new ray, describing where the plane between two given rays meets the next intersecting hyperplane. </p>
<p>The list of dot products for the new ray will be one element shorter than the lists for the given rays (since there will be one less hyperplane remaining to intersect).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rays come from the same partial solution space (i.e., their lists of dot products are the same length). Moreover, this partial solution space still has at least one hyperplane remaining to intersect (i.e., the lists of dot products are not empty). </dd>
<dd>
The two given rays lie on opposite sides of the next hyperplane to intersect, and neither ray actually lies <em>in</em> this next hyperplane.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first of the given rays. </td></tr>
    <tr><td class="paramname">second</td><td>the second of the given rays. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf4a2ea77ad8e0538dac811a077c00bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4a2ea77ad8e0538dac811a077c00bc">&#9670;&nbsp;</a></span>RaySpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec </td>
          <td>(</td>
          <td class="paramtype">const RaySpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>trunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given ray specification, with the first dot product removed. </p>
<p>The resulting list of dot products is thus one element shorter.</p>
<p>This routine is typically called when we intersect a hyperplane with a partial solution space and some ray lies directly in this hyperplane (not on either side).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunc</td><td>the ray to copy and truncate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a923288dfd789988efd354870bdf797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a923288dfd789988efd354870bdf797">&#9670;&nbsp;</a></span>RaySpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::RaySpec </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long *&#160;</td>
          <td class="paramname"><em>hypOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a ray specification for the non-negative portion of the given coordinate axis. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The dimension of the space in which we are working is strictly positive, but is small enough that <em>BitmaskType</em> can hold the corresponding number of bits (one bit per dimension).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>indicates which coordinate axis to use; this must be at least zero but strictly less than the dimension of the entire space. </td></tr>
    <tr><td class="paramname">subspace</td><td>the matrix containing the set of hyperplanes to intersect with the original cone (one hyperplane for each row of the matrix). </td></tr>
    <tr><td class="paramname">hypOrder</td><td>the order in which we plan to intersect the hyperplanes. The length of this array must be the number of rows in <em>subspace</em>, and the <em>i</em>th hyperplane to intersect must be described by row <code>hypOrder[i]</code> of <em>subspace</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79b7f47c601539fc794a0bb768d2f637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b7f47c601539fc794a0bb768d2f637">&#9670;&nbsp;</a></span>recover()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<div class="memtemplate">
template&lt;typename RayClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::recover </td>
          <td>(</td>
          <td class="paramtype">RayClass &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>subspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovers the coordinates of the actual ray that is described by this object. </p>
<p>This routine is not fast, since it needs to solve a system of linear equations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This ray is a member of the <em>final</em> solution space. That is, all hyperplanes have been intersected with the original cone, and the list of dot products stored in this object is empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the ray in which the final coordinates will be stored; the length of this ray must be the dimension of the overall space in which we are working. </td></tr>
    <tr><td class="paramname">subspace</td><td>the matrix containing the set of hyperplanes that were intersected with the original cone (one hyperplane for each row of the matrix). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5120903a7dd47e0e09ce98efd3885bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5120903a7dd47e0e09ce98efd3885bb">&#9670;&nbsp;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; *&#160;</td>
          <td class="paramname"><em>origTableaux</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough memory for this tableaux to work with. </p>
<p>You <em>must</em> call this routine before doing anything else with this tableaux.</p>
<p>The data in this tableaux will not be initialised, and the contents and behaviour of this tableaux will remain undefined until you call one of the initialisation routines <a class="el" href="group__enumerate.html#gac48f34d3d8d79b3823f95bc2f64cf7a3" title="Initialises this tableaux by beginning at the original starting tableaux and working our way to any f...">initStart()</a> or <a class="el" href="group__enumerate.html#gadfb498c421ccd15a2853821057078ff2" title="Initialises this tableaux to be a clone of the given tableaux.">initClone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origTableaux</td><td>the original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm began. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87e8f80901ea9c05b3fc97db4a365c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e8f80901ea9c05b3fc97db4a365c94">&#9670;&nbsp;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix. </p>
<p>This is just an upper bound: your matrix may end up using fewer elements than this, but it cannot use more.</p>
<p>This matrix will still not be initialised until you call either <a class="el" href="group__enumerate.html#gad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="group__enumerate.html#ga756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a>. See the class notes for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This matrix was created using the default (no-argument) constructor, and you have not called any other routines on this matrix since.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>To elaborate on the precondition above: you can only call <a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> once, and if you did not use the default <a class="el" href="classregina_1_1LPMatrix.html" title="A matrix class for use with linear programming.">LPMatrix</a> constructor then you cannot call it at all. Any additional calls to <a class="el" href="group__enumerate.html#ga87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> will result in a memory leak.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRows</td><td>an upper bound on the number of rows that you will need for this matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">maxCols</td><td>an upper bound on the number of columns that you will need for this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7dcd27036a3970aa80a523b2c86f43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7dcd27036a3970aa80a523b2c86f43a">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix. </p>
<p>This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>

</div>
</div>
<a id="gaf905f788522242ffaf9def76faa42067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf905f788522242ffaf9def76faa42067">&#9670;&nbsp;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::run </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;, void *)&#160;</td>
          <td class="paramname"><em>useSoln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the complete tree traversal algorithm to enumerate all taut angle structures. </p>
<p>For each taut angle structure that is found, this routine will call the function <em>useSoln</em>. It will pass two arguments to this function: (i) this enumeration object, and (ii) an arbitrary piece of data that you can supply via the argument <em>arg</em>.</p>
<p>You can extract details of the solution directly from the enumeration object: for instance, you can dump the type vector using <a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full taut angle structure using <a class="el" href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9" title="Reconstructs the full taut angle structure that is represented by the type vector at the current stag...">buildStructure()</a> and perform some other operations upon it. If you do call <a class="el" href="group__enumerate.html#ga0b11b28eca4fe085eec4d9cf7891ddb9" title="Reconstructs the full taut angle structure that is represented by the type vector at the current stag...">buildStructure()</a>, remember to delete the angle structure once you are finished with it.</p>
<p>The enumeration will block until your callback function <em>useSoln</em> returns. If the callback function returns <code>true</code>, then <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> will continue the enumeration. If it returns <code>false</code>, then <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> will abort the search and return immediately.</p>
<p>The usual way of using this routine is to construct an <a class="el" href="classregina_1_1TautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">TautEnumeration</a> object and then immediately call <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>. However, if you prefer, you may call <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> after one or more calls to <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a>. In this case, <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> will continue the search from the current point and run it to its completion. In other words, <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> will locate and call <em>useSoln</em> for all taut angle structures that had not yet been found, but it will not call <em>useSoln</em> on those solutions that had previously been found during earlier calls to <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The enumeration algorithm has not yet finished. That is, you have not called <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> before, and if you have called <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useSoln</td><td>a callback function that will be called each time we locate a taut angle structure, as described above. </td></tr>
    <tr><td class="paramname">arg</td><td>the second argument to pass to the callback function; this may be any type of data that you like. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0893b762beded243bd8a3d7445a92d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0893b762beded243bd8a3d7445a92d0">&#9670;&nbsp;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::run </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;, void *)&#160;</td>
          <td class="paramname"><em>useSoln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces. </p>
<p>For each vertex surface that is found, this routine will call the function <em>useSoln</em>. It will pass two arguments to this function: (i) this tree enumeration object, and (ii) an arbitrary piece of data that you can supply via the argument <em>arg</em>.</p>
<p>You can extract details of the solution directly from the tree enumeration object: for instance, you can dump the type vector using <a class="el" href="group__enumerate.html#ga17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full normal or almost normal surface using <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a> and perform some other operations upon it. If you do call <a class="el" href="group__enumerate.html#gadd66260d35869bc74418b6e1bf246468" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a>, remember to delete the normal surface once you are finished with it.</p>
<p>The tree traversal will block until your callback function <em>useSoln</em> returns. If the callback function returns <code>true</code>, then <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will continue the tree traversal. If it returns <code>false</code>, then <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will abort the search and return immediately.</p>
<p>The usual way of using this routine is to construct a <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object and then immediately call <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>. However, if you prefer, you may call <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> after one or more calls to <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>. In this case, <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will continue the search from the current point and run it to its completion. In other words, <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will locate and call <em>useSoln</em> for all vertex surfaces that had not yet been found, but it will not call <em>useSoln</em> on those surfaces that had previously been found during earlier calls to <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tree traversal algorithm has not yet finished. That is, you have not called <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> before, and if you have called <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useSoln</td><td>a callback function that will be called each time we locate a vertex surface, as described above. </td></tr>
    <tr><td class="paramname">arg</td><td>the second argument to pass to the callback function; this may be any type of data that you like. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf14d88b7380ef7d19d181991e9b2fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14d88b7380ef7d19d181991e9b2fe79">&#9670;&nbsp;</a></span>setNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::setNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges the search tree so that <em>nextType</em> becomes the next type that we process. </p>
<p>Specifically, this routine will set typeOrder_[level_ + 1] to <em>nextType_</em>, and will move other elements of typeOrder_ back by one position to make space as required.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>nextType</em> is in the range 0,...,<em>nTypes-1</em> inclusive. </dd>
<dd>
<em>nextType</em> is still waiting to be processed; that is, <em>nextType</em> does not appear in the list typeOrder_[0,...,level_].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextType</td><td>the next type to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0098fed8ddd568c86e6e70b00b7583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0098fed8ddd568c86e6e70b00b7583b">&#9670;&nbsp;</a></span>sign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::DoubleDescription::RaySpec&lt; BitmaskType &gt;::sign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the dot product of this ray with the next hyperplane. </p>
<p>This is simply the sign of the first element in the list of remaining dot products.</p>
<dl class="section return"><dt>Returns</dt><dd>1, 0 or -1 according to the sign of the next dot product. </dd></dl>

</div>
</div>
<a id="gaafcb1cbfe6889b544a9281bc7cd92d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcb1cbfe6889b544a9281bc7cd92d87">&#9670;&nbsp;</a></span>sign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::sign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the dot product of this vector with the hyperplane currently being processed. </p>
<p>This is simply the sign of the data member <em>nextHyp_</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>1, 0 or -1 according to the sign of <em>nextHyp_</em>. </dd></dl>

</div>
</div>
<a id="gaf3f652192f66a2b5c4229e4f8e9c1879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3f652192f66a2b5c4229e4f8e9c1879">&#9670;&nbsp;</a></span>sign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::sign </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the sign of the given variable under the current basis. </p>
<p>This does <em>not</em> attempt to "undo" any changes of variable caused by prior calls to <a class="el" href="group__enumerate.html#gad13df31bf31dabdeba22a4d0e7e77197" title="Constrains this system further by constraining the given variable to be strictly positive.">constrainPositive()</a> or <a class="el" href="group__enumerate.html#gae3de34d05aa11d2f75f7d63b0d56f9ae" title="Declares that two quadrilateral coordinates within a tetrahedron are to be combined into a single oct...">constrainOct()</a>; it simply tests the sign of the variable in the given column of the tableaux in its current form.</p>
<p>Specifically: if the given variable is inactive or non-basic, this routine returns zero. If the given variable is in the basis, this routine returns the sign of the corresponding integer on the right-hand side of the tableaux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the index of the variable to query. This must be between 0 and origTableaux_-&gt;<a class="el" href="group__enumerate.html#ga6c2bfd2bac90cee1ab7f9beb6fba0aef" title="Returns the number of columns in this tableaux.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sign of the variable as described above; this will be either 1, 0 or -1. </dd></dl>

</div>
</div>
<a id="ga9ba753d9c3432becdfcb3a7e08b7762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ba753d9c3432becdfcb3a7e08b7762e">&#9670;&nbsp;</a></span>supported() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::LPConstraintBase::supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the given coordinate system is supported by this constraint class. </p>
<p>This routine assumes that the given system is already known to be supported by the generic tree traversal infrastructure, and only returns <code>false</code> if there are additional prerequisites imposed by this particular constraint class that the given system does not satisfy. If this constraint class does not impose any of its own additional conditions, this routine may simply return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system being queried; this must be one of the coordinate systems known to be supported by the generic <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> infrastructure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this coordinate system is also supported by this specific constraint class. </dd></dl>

</div>
</div>
<a id="ga0473c6da2e31d9ea3f23047a5362983c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0473c6da2e31d9ea3f23047a5362983c">&#9670;&nbsp;</a></span>supported() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::BanConstraintBase::supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the given coordinate system is supported by this constraint class. </p>
<p>This routine assumes that the given system is already known to be supported by the generic tree traversal infrastructure, and only returns <code>false</code> if there are additional prerequisites imposed by this particular constraint class that the given system does not satisfy. If this constraint class does not impose any of its own additional conditions, this routine may simply return <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system being queried; this must be one of the coordinate systems known to be supported by the generic <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> infrastructure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this coordinate system is also supported by this specific constraint class. </dd></dl>

</div>
</div>
<a id="ga7fbb5b7727d4014b41636e20017bfb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fbb5b7727d4014b41636e20017bfb7e">&#9670;&nbsp;</a></span>supported() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the given coordinate system is supported by this tree traversal infrastructure. </p>
<p>Currently this is true only for NS_STANDARD and NS_QUAD (for normal surfaces), NS_AN_STANDARD and NS_AN_QUAD_OCT (for almost normal surfaces), and NS_ANGLE (for taut angle structures). Any additional restrictions imposed by LPConstraint and BanConstraint will also be taken into account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this coordinate system is supported. </dd></dl>

</div>
</div>
<a id="ga0ee81a1df448f26c82f389cdbafcb52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee81a1df448f26c82f389cdbafcb52c">&#9670;&nbsp;</a></span>swapRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::swapRows </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the two given rows of this matrix. </p>
<p>The two arguments <em>r1</em> and <em>r2</em> may be equal (in which case the matrix will be left unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>the index of the first row to swap. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">r2</td><td>the index of the second row to swap. This must be between 0 and <a class="el" href="group__enumerate.html#gaf7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad434a10033bf29d5771094cbbe5ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad434a10033bf29d5771094cbbe5ea6a">&#9670;&nbsp;</a></span>TautEnumeration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::<a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for running the tree traversal algorithm. </p>
<p>This prepares the algorithm; in order to run the algorithm and enumerate taut angle structures, you can either:</p>
<ul>
<li>call <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>, which enumerates all taut angle structures with a single function call;</li>
<li>repeatedly call <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a>, which will step to the next taut angle struture surface each time you call it.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd>
<dd>
The trianglation adheres to any preconditions required by the template parameters LPConstraint and BanConstraint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to enumerate taut angle structures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac53f9077d41478f5ec66bf131eab2f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac53f9077d41478f5ec66bf131eab2f22">&#9670;&nbsp;</a></span>TreeEnumeration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::<a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for running the tree traversal algorithm. </p>
<p>This prepares the algorithm; in order to run the algorithm and enumerate vertex surfaces, you can either:</p>
<ul>
<li>call <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>, which enumerates all vertex surfaces with a single function call;</li>
<li>repeatedly call <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>, which will step to the next vertex surface each time you call it.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Although it is supported, it is highly recommended that you do <em>not</em> run a full vertex enumeration in standard normal or almost normal coordinates (this is for performance reasons). See the class notes for further discussion and better alternatives. In normal circumstances you should run a full vertex enumeration in quadrilateral or quadrilateral-octagon coordinates only.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd>
<dd>
Both the trianglation and the given coordinate system adhere to any preconditions required by the template parameters LPConstraint and BanConstraint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to enumerate vertex surfaces. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system in which wish to enumerate vertex surfaces. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, or NS_AN_STANDARD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe79652f80c71ab48e763d55ba1b3d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe79652f80c71ab48e763d55ba1b3d7e">&#9670;&nbsp;</a></span>TreeSingleSoln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeSingleSoln.html">regina::TreeSingleSoln</a>&lt; LPConstraint, BanConstraint, IntType &gt;::<a class="el" href="classregina_1_1TreeSingleSoln.html">TreeSingleSoln</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for running the tree traversal / branching algorithm to locate a non-trivial surface that satisfies the chosen constraints. </p>
<p>This constructor prepares the algorithm; in order to run the algorithm you should call <a class="el" href="group__enumerate.html#gaf6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">find()</a>, which returns <code>true</code> or <code>false</code> according to whether or not such a surface was found.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd>
<dd>
Both the trianglation and the given coordinate system adhere to any preconditions required by the template parameters LPConstraint and BanConstraint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to search for a non-trivial surface. </td></tr>
    <tr><td class="paramname">coords</td><td>the normal or almost normal coordinate system in which to work. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, or NS_AN_STANDARD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1407f91ab30c5445f560506b19157c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1407f91ab30c5445f560506b19157c4">&#9670;&nbsp;</a></span>TreeTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::<a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchesPerQuad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>branchesPerTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enumeration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises a new base object for running the tree traversal algorithm. </p>
<p>This routine may only be called by subclass constructors; for more information on how to create and run a tree traversal, see subclasses such as <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a>, <a class="el" href="classregina_1_1TautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">TautEnumeration</a> or <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to search for normal surfaces or taut angle structures. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system in which wish to search for normal surfaces or taut angle structures. This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, NS_AN_STANDARD, or NS_ANGLE. </td></tr>
    <tr><td class="paramname">branchesPerQuad</td><td>the maximum number of branches we spawn in the search tree for each quadrilateral or angle type (e.g., 4 for a vanilla normal surface tree traversal algorithm, or 3 for enumerating taut angle structures). </td></tr>
    <tr><td class="paramname">branchesPerTri</td><td>the maximum number of branches we spawn in the search tree for each triangle type (e.g., 2 for a vanilla normal surface tree traversal algorithm). If the underlying coordinate system does not support triangles then this argument will be ignored. </td></tr>
    <tr><td class="paramname">enumeration</td><td><code>true</code> if we should optimise the tableaux for a full enumeration of vertex surfaces or taut angle structures, or <code>false</code> if we should optimise the tableaux for an existence test (such as searching for a non-trivial normal disc or sphere). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3c878d36aceccf7a104e7b72b7f9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c878d36aceccf7a104e7b72b7f9a99">&#9670;&nbsp;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::tri</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the underlying 3-manifold triangulation from which the matching equations were derived. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ga2faa804e5db1858dff9ab7a59c4d0725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2faa804e5db1858dff9ab7a59c4d0725">&#9670;&nbsp;</a></span>TypeTrie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises an empty trie. </p>

</div>
</div>
<a id="gac2222c5fe6eaf0a2d35e0ecc27b46d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2222c5fe6eaf0a2d35e0ecc27b46d63">&#9670;&nbsp;</a></span>VecSpec() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::VecSpec </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new clone of the given vector. </p>

</div>
</div>
<a id="ga462ad677eedcb24ba485865675ccbe0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462ad677eedcb24ba485865675ccbe0b">&#9670;&nbsp;</a></span>VecSpec() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec </td>
          <td>(</td>
          <td class="paramtype">const VecSpec&lt; BitmaskType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabca692d0f3531179076044ded1d35ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabca692d0f3531179076044ded1d35ec4">&#9670;&nbsp;</a></span>VecSpec() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::VecSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the zero vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the total dimension of the space (and therefore the toatl length of this vector). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21c10cf7cb826dc6f5867d333a591fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c10cf7cb826dc6f5867d333a591fd4">&#9670;&nbsp;</a></span>VecSpec() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the zero vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the total dimension of the space (and therefore the toatl length of this vector). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga530c40e81f44abdc6e939f6e4ed8aaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530c40e81f44abdc6e939f6e4ed8aaa5">&#9670;&nbsp;</a></span>VecSpec() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HilbertDual::VecSpec&lt; BitmaskType &gt;::VecSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the given unit vector. </p>
<p>The <em>nextHyp_</em> data member will be left uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>indicates which coordinate is set to one in this unit vector. </td></tr>
    <tr><td class="paramname">dim</td><td>the total dimension of the space (and therefore the total length of this vector). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bfeab411c86ea6b91eb7cf1afb655c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bfeab411c86ea6b91eb7cf1afb655c1">&#9670;&nbsp;</a></span>verify() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::LPConstraintBase::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the given angle structure satisfies the extra constraints described by this class. </p>
<p>Ideally this test is not based on explicitly recomputing the linear function(s), but instead runs independent tests; see the related routine <a class="el" href="group__enumerate.html#gad3473818bf1e24235d4b9705cdfccfbf" title="Ensures that the given normal surface satisfies the extra constraints described by this class.">verify(const NormalSurface*)</a> for examples.</p>
<p>If these linear constraints work with normal or almost normal surfaces (not angle structure coordinates), then this routine should return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the angle structure to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given angle structure satisfies these linear constraints, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="ga1b222fac01e81df79115ec9132075448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b222fac01e81df79115ec9132075448">&#9670;&nbsp;</a></span>verify() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td>
          <td class="paramname"><em>angleEqns</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that the given angle structure satisfies the angle equations, as well as any additional constraints from the template parameter LPConstraint. </p>
<p>This routine is for use only with angle structures, not normal (or almost normal) surfaces.</p>
<p>This routine is provided for diagnostic, debugging and verification purposes.</p>
<p>Instead of using the initial tableaux to verify the angle equations, this routine goes back to the original angle equations matrix as constructed by <a class="el" href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a" title="Creates a new set of angle structure equations for the given triangulation.">AngleStructureVector::makeAngleEquations()</a>. This ensures that the test is independent of any potential problems with the tableaux. You are not required to pass your own angle equations (if you don't, they will be temporarily reconstructed for you); however, you may pass your own if you wish to use a non-standard angle equation matrix, and/or reuse the same matrix to avoid the overhead of reconstructing it every time this routine is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was NS_ANGLE.</dd>
<dd>
If <em>angleEqns</em> is non-null, then the number of columns in <em>angleEqns</em> is equal to the number of coordinates in the underlying angle structure coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the angle structure to verify. </td></tr>
    <tr><td class="paramname">angleEqns</td><td>the angle equations to check against the given angle structure; this may be 0, in which case the angle equations will be temporarily reconstructed for you using <a class="el" href="group__angle.html#ga83ce017585b99cfdcdd809ee3c4ed96a" title="Creates a new set of angle structure equations for the given triangulation.">AngleStructureVector::makeAngleEquations()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given angle structure passes all of the tests described above, or <code>false</code> if it fails one or more tests (indicating a problem or error). </dd></dl>

</div>
</div>
<a id="gad3473818bf1e24235d4b9705cdfccfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3473818bf1e24235d4b9705cdfccfbf">&#9670;&nbsp;</a></span>verify() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::LPConstraintBase::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the given normal surface satisfies the extra constraints described by this class. </p>
<p>Ideally this test is not based on explicitly recomputing the linear function(s), but instead runs independent tests. For instance, if this class is used to constraint Euler characteristic, then ideally this routine would call s-&gt;eulerChar() and test the return value of that routine instead.</p>
<p>If these linear constraints work with angle structure coordinates (not normal or almost normal surfaces), then this routine should return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the surface to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given surface satisfies these linear constraints, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="gaa04172f2396e949298a137034c0e608d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04172f2396e949298a137034c0e608d">&#9670;&nbsp;</a></span>verify() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td>
          <td class="paramname"><em>matchingEqns</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that the given normal or almost normal surface satisfies the matching equations, as well as any additional constraints from the template parameter LPConstraint. </p>
<p>This routine is for use only with normal (or almost normal) surfaces, not angle structures.</p>
<p>This routine is provided for diagnostic, debugging and verification purposes.</p>
<p>Instead of using the initial tableaux to verify the matching equations, this routine goes back to the original matching equations matrix as constructed by <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a>. This ensures that the test is independent of any potential problems with the tableaux. You are not required to pass your own matching equations (if you don't, they will be temporarily reconstructed for you); however, you may pass your own if you wish to use a non-standard matching equation matrix, and/or reuse the same matrix to avoid the overhead of reconstructing it every time this routine is called.</p>
<p>If you do not pass your own matching equations and Regina is unable to construct them (which can happen when the underlying triangulation is not supported by the normal coordinate system), then this routine will return <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The normal or almost normal surface <em>s</em> uses the same coordinate system as was passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor. Moreover, this coordinate system is in fact a normal or almost normal coordinate system (i.e., not NS_ANGLE).</dd>
<dd>
If <em>matchingEqns</em> is non-null, then the number of columns in <em>matchingEqns</em> is equal to the number of coordinates in the underlying normal or almost normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the normal surface to verify. </td></tr>
    <tr><td class="paramname">matchingEqns</td><td>the matching equations to check against the given surface; this may be 0, in which case the matching equations will be temporarily reconstructed for you using <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given surface passes all of the tests described above, or <code>false</code> if it fails one or more tests (indicating a problem or error). </dd></dl>

</div>
</div>
<a id="ga1cf5ec27c9170315f1977ee4f47f0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf5ec27c9170315f1977ee4f47f0686">&#9670;&nbsp;</a></span>writeStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the full angle structure coordinates of the taut angle structure at the current point in the given tree traversal search. </p>
<p>You can use this as the callback function <em>useSoln</em> that is passed to <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>.</p>
<p>The angle structure coordinates will be written on a single line, with spaces and punctuation separating them, a prefix indicating which solution we are up to, and a final newline appended. The final scaling coordinate (used to projectivise the angle structure polytope) will also be written. This output format is subject to change in future versions of Regina.</p>
<p>The second (void*) argument is ignored. It is only present for compatibility with <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a taut angle structure. This is always the case any time after <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> calls its callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current taut angle structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (which indicates to <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<a id="ga9c0fbf60b1328751f7cc03c9aa334578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c0fbf60b1328751f7cc03c9aa334578">&#9670;&nbsp;</a></span>writeSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the full triangle-quadrilateral coordinates of the vertex normal or almost normal surface at the current point in the given tree traversal search. </p>
<p>You can use this as the callback function <em>useSoln</em> that is passed to <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<p>The normal surface coordinates will be written on a single line, with spaces and punctuation separating them, a prefix indicating which solution we are up to, and a final newline appended. This output format is subject to change in future versions of Regina.</p>
<p>The second (void*) argument is ignored. It is only present for compatibility with <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a vertex normal or almost normal surface. This is always the case any time after <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> calls its callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current vertex normal or almost normal surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (which indicates to <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<a id="gaf430013a213dbf0ecb2487f389710551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf430013a213dbf0ecb2487f389710551">&#9670;&nbsp;</a></span>writeTypes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TautEnumeration.html">regina::TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TautEnumeration.html">TautEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the type vector at the current point in the given tree traversal search. </p>
<p>You can use this as the callback function <em>useSoln</em> that is passed to <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>.</p>
<p>The type vector will be written on a single line, with no spaces between types, with a prefix indicating which solution we are up to, and with a final newline appended. This output format is subject to change in future versions of Regina.</p>
<p>The second (void*) argument is ignored. It is only present for compatibility with <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a taut angle structure. This is always the case any time after <a class="el" href="group__enumerate.html#gaef628d8527d115ea92798957459bcf06" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">next()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> calls its callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current type vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (which indicates to <a class="el" href="group__enumerate.html#gaf905f788522242ffaf9def76faa42067" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<a id="gaa527c26359b3989cd9ea6fb1ce85efb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa527c26359b3989cd9ea6fb1ce85efb8">&#9670;&nbsp;</a></span>writeTypes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the type vector at the current point in the given tree traversal search. </p>
<p>You can use this as the callback function <em>useSoln</em> that is passed to <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<p>The type vector will be written on a single line, with no spaces between types, with a prefix indicating which solution we are up to, and with a final newline appended. This output format is subject to change in future versions of Regina.</p>
<p>The second (void*) argument is ignored. It is only present for compatibility with <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a vertex normal or almost normal surface. This is always the case any time after <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> returns <code>true</code>, or any time that <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> calls its callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current type vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (which indicates to <a class="el" href="group__enumerate.html#gaf0893b762beded243bd8a3d7445a92d0" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<a id="ga63e53c6bd1b2feebdee47ce63fb4ab21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63e53c6bd1b2feebdee47ce63fb4ab21">&#9670;&nbsp;</a></span>~BanConstraintBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::BanConstraintBase::~BanConstraintBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object and all associated data. </p>

</div>
</div>
<a id="ga294602a33df9186b5ccf57afdeb6c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga294602a33df9186b5ccf57afdeb6c879">&#9670;&nbsp;</a></span>~LPData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">regina::LPData</a>&lt; LPConstraint, IntType &gt;::~<a class="el" href="classregina_1_1LPData.html">LPData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tableaux. </p>
<p>This is safe even if <a class="el" href="group__enumerate.html#gab5120903a7dd47e0e09ce98efd3885bb" title="Reserves enough memory for this tableaux to work with.">reserve()</a> was never called. </p>

</div>
</div>
<a id="ga6d9e1d9717a1363524eb40fd75f81f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9e1d9717a1363524eb40fd75f81f23">&#9670;&nbsp;</a></span>~LPInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::~<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix. </p>

</div>
</div>
<a id="ga7ac4b64820129111953fb8fd76ccbed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac4b64820129111953fb8fd76ccbed2">&#9670;&nbsp;</a></span>~LPMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::~<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix and all of the data it contains. </p>
<p>You can safely destroy a matrix that is uninitialised or only partially initialised (i.e., space has been reserved but the matrix size is not set). </p>

</div>
</div>
<a id="ga2b5682768cd64e18047f7a155e107960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5682768cd64e18047f7a155e107960">&#9670;&nbsp;</a></span>~TreeTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::~<a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object. </p>

</div>
</div>
<a id="ga2b4951053bb78a2c34ecc67fb8fbcc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4951053bb78a2c34ecc67fb8fbcc7b">&#9670;&nbsp;</a></span>~TypeTrie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TypeTrie.html">regina::TypeTrie</a>&lt; nTypes &gt;::~<a class="el" href="classregina_1_1TypeTrie.html">TypeTrie</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this trie. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga04ca0d7c865641b559d540992ef1f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ca0d7c865641b559d540992ef1f022">&#9670;&nbsp;</a></span>banned_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::BanConstraintBase::banned_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which columns of a tableaux correspond to banned coordinates (e.g., banned normal disc types). </p>
<p>The size of this array is the number of normal or angle structure coordinates (so we explicitly exclude extra columns that arise from the template parameter LPConstraint. </p>

</div>
</div>
<a id="gae6a6acd436e0c868617def15827b0dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6a6acd436e0c868617def15827b0dd1">&#9670;&nbsp;</a></span>coords_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::BanConstraintBase::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normal or almost normal coordinate system in which we are working. </p>
<p>This must be one of NS_QUAD, NS_STANDARD, NS_AN_QUAD_OCT, NS_AN_STANDARD, or NS_ANGLE. </p>

</div>
</div>
<a id="ga95fd4b924809b9f74639b855830dee99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95fd4b924809b9f74639b855830dee99">&#9670;&nbsp;</a></span>coords_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coordinate system in which we are enumerating or searching for normal surfaces, almost normal surfaces, or taut angle structures. </p>
<p>This must be one of NS_QUAD or NS_STANDARD if we are only supporting normal surfaces, one of NS_AN_QUAD_OCT or NS_AN_STANDARD if we are allowing octagons in almost normal surfaces, or NS_ANGLE if we are searching for taut angle structures. </p>

</div>
</div>
<a id="ga2c096e6ebafffe44d0e3ba62e6c0b00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c096e6ebafffe44d0e3ba62e6c0b00e">&#9670;&nbsp;</a></span>euler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LPConstraintEuler::Coefficients::euler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The coefficient of the Euler characteristic function for the corresponding column of the matching equation matrix. </p>

</div>
</div>
<a id="gad3269d2da06523312eed52e328c6fe06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3269d2da06523312eed52e328c6fe06">&#9670;&nbsp;</a></span>level_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current level in the search tree. </p>
<p>As the search runs, this holds the index into typeOrder_ corresponding to the last type that we chose. </p>

</div>
</div>
<a id="gaed1fbd8365ea666a28e29d401e3ba808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1fbd8365ea666a28e29d401e3ba808">&#9670;&nbsp;</a></span>longitude</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LPConstraintNonSpun::Coefficients::longitude</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The coefficient of the longitude equation for the corresponding column of the matching equation matrix. </p>

</div>
</div>
<a id="ga399bdd3aa3c2aad75d17b65c3b81715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399bdd3aa3c2aad75d17b65c3b81715c">&#9670;&nbsp;</a></span>lp_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, IntType&gt;* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::lp_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores tableaux for linear programming at various nodes in the search tree. </p>
<p>We only store a limited number of tableaux at any given time, and as the search progresses we overwrite old tableaux with new tableaux.</p>
<p>More precisely, we store a linear number of tableaux, essentially corresponding to the current node in the search tree and all of its ancestores, all the way up to the root node. In addition to these tableaux, we also store other immediate children of these ancestores that we have pre-prepared for future processing. See the documentation within routines such as <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> for details of when and how these tableaux are constructed. </p>

</div>
</div>
<a id="ga16999f1b18c4f3738fc78ab7230c46c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16999f1b18c4f3738fc78ab7230c46c0">&#9670;&nbsp;</a></span>lpSlot_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, IntType&gt;** <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::lpSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors. </p>
<p>This means we have one tableaux for the root node, as well as additional tableaux at each level 0,1,...,<em>level_</em>.</p>
<p>The array lpSlot_ indicates which element of the array <em>lp_</em> holds each of these tableaux. Specifically: lpSlot_[0] points to the tableaux for the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding tableaux is *lpSlot_[i+1]. Again, see the documentation within routines such as <a class="el" href="group__enumerate.html#gae5a02cade5fd5c8db9b5d92e0defb2ab" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> for details of when and how these tableaux are constructed and later overwritten. </p>

</div>
</div>
<a id="ga60e953b2d69f3b5712cb228fb2e3ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e953b2d69f3b5712cb228fb2e3ad9a">&#9670;&nbsp;</a></span>marked_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::BanConstraintBase::marked_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which columns of a tableaux correspond to marked coordinates (e.g., marked normal disc types). </p>
<p>The size of this array is the number of normal or angle structure coordinates (so we explicitly exclude extra columns that arise from the template parameter LPConstraint. </p>

</div>
</div>
<a id="ga98ceee8fc0afeb2fea1ced18fa70f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98ceee8fc0afeb2fea1ced18fa70f506">&#9670;&nbsp;</a></span>mask_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BitmaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BitmaskType regina::HilbertCD::VecSpec&lt; BitmaskType &gt;::mask_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bitmask indicating which coordinates are zero (<code>false</code>) and which are non-zero (<code>true</code>). </p>

</div>
</div>
<a id="ga41bee94672244d2ce13b02cb0c52bef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41bee94672244d2ce13b02cb0c52bef2">&#9670;&nbsp;</a></span>meridian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LPConstraintNonSpun::Coefficients::meridian</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The coefficient of the meridian equation for the corresponding column of the matching equation matrix. </p>

</div>
</div>
<a id="gac0e5e7853637ad4579f4b4783d3f324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e5e7853637ad4579f4b4783d3f324c">&#9670;&nbsp;</a></span>minus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::minus[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rows containing these -1 entries, in any order. </p>
<p>The same row may appear in this list more than once (indicating a -2, -3 or -4 entry in the matrix). </p>

</div>
</div>
<a id="ga63265bf71e0086a5ad1e47657550a521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63265bf71e0086a5ad1e47657550a521">&#9670;&nbsp;</a></span>nextSlot_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, IntType&gt;** <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nextSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points to the next available tableaux in lp_ that is free to use at each level of the search tree. </p>
<p>Specifically: nextSlot_[0] points to the next free tableaux at the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding next free tableaux is *nextSlot_[i+1].</p>
<p>The precise layout of the nextSlot_ array depends on the order in which we process quadrilateral, triangle and/or angle types. </p>

</div>
</div>
<a id="ga1e03d9c29e24a019cb70b5b124ee307a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e03d9c29e24a019cb70b5b124ee307a">&#9670;&nbsp;</a></span>nMinus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::nMinus</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of -1 entries in this column. </p>

</div>
</div>
<a id="gada30f12b826f02258d9916152cd0a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada30f12b826f02258d9916152cd0a5cf">&#9670;&nbsp;</a></span>nPlus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::nPlus</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of +1 entries in this column. </p>

</div>
</div>
<a id="gac51922fd588f4521499e28d3fe399df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51922fd588f4521499e28d3fe399df5">&#9670;&nbsp;</a></span>nTableaux_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search. </p>

</div>
</div>
<a id="gab7d93ed3fb68589d4636512f918808dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d93ed3fb68589d4636512f918808dd">&#9670;&nbsp;</a></span>nTets_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nTets_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of tetrahedra in the underlying triangulation. </p>

</div>
</div>
<a id="gabaa69f409c9c907f44f27d02d765c649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa69f409c9c907f44f27d02d765c649">&#9670;&nbsp;</a></span>nTypes_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nTypes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total length of a type vector. </p>

</div>
</div>
<a id="ga835a117f24c5a359d4f6cd20af50179f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga835a117f24c5a359d4f6cd20af50179f">&#9670;&nbsp;</a></span>nVisited_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::nVisited_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the total number of nodes in the search tree that we have visited thus far. </p>
<p>This may grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree. </p>

</div>
</div>
<a id="gaf7b922a1b3ce46f848c76e5105e80acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b922a1b3ce46f848c76e5105e80acb">&#9670;&nbsp;</a></span>octLevel_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::octLevel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level at which we are enforcing an octagon type (with a strictly positive number of octagons). </p>
<p>If we are working with angle structures or normal surfaces only (and so we do not allow octagons at all), then <em>octLevel_</em> = <em>nTypes_</em>. If we are allowing almost normal surfaces but we have not yet chosen an octagon type, then <em>octLevel_</em> = -1. </p>

</div>
</div>
<a id="ga883cfd719b17e7ddde2093019e8213d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883cfd719b17e7ddde2093019e8213d4">&#9670;&nbsp;</a></span>origTableaux_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt;LPConstraint&gt; <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::origTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins. </p>

</div>
</div>
<a id="ga9f053dc500939bfaa094efb70ee0e550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f053dc500939bfaa094efb70ee0e550">&#9670;&nbsp;</a></span>plus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="structregina_1_1LPCol.html">regina::LPCol</a>&lt; LPConstraint &gt;::plus[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rows containing these +1 entries, in any order. </p>
<p>The same row may appear in this list more than once (indicating a +2, +3 or +4 entry in the matrix). </p>

</div>
</div>
<a id="gae041b264994cb18b5dcae4ebafff7f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae041b264994cb18b5dcae4ebafff7f16">&#9670;&nbsp;</a></span>tmpLP_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;LPConstraint, IntType&gt; <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::tmpLP_[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary tableaux used by the function <a class="el" href="group__enumerate.html#gae46815f41b24319ef2de3a91939bfa37" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree. </p>
<p>Other routines are welcome to use these temporary tableaux also (as "scratch space"); however, be aware that any call to <a class="el" href="group__enumerate.html#gae46815f41b24319ef2de3a91939bfa37" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> will overwrite them. </p>

</div>
</div>
<a id="gad00f1953eebfb29c9398be3be9b20811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad00f1953eebfb29c9398be3be9b20811">&#9670;&nbsp;</a></span>tri_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::BanConstraintBase::tri_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation with which we are working. </p>

</div>
</div>
<a id="ga9f957a2834e470907a883c15694bff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f957a2834e470907a883c15694bff3d">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current working type vector. </p>
<p>As the search runs, we modify this type vector in-place. Any types beyond the current level in the search tree will always be set to zero. </p>

</div>
</div>
<a id="ga85ae7d45353f99075de18edf6bd72291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ae7d45353f99075de18edf6bd72291">&#9670;&nbsp;</a></span>typeOrder_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; LPConstraint, BanConstraint, IntType &gt;::typeOrder_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]]. </p>
<p>This permutation is allowed to change as the algorithm runs (though of course you can only change sections of the permutation that correspond to types not yet selected). </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
